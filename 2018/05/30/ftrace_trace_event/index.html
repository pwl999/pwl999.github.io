<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
































<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.6.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.6.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.6.0" color="#222">









<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.6.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="Linux trace中，最基础的就是：function tracer和trace event。鉴于他们搭建的良好的框架(ringbuffer、tracefs)，各种trace纷纷投奔而来。  tracer发展出了function、function_graph、irqsoff、preemptoff、wakeup等一系列tracer。 而event也发展出tracepoint、kprobe、upro">
<meta name="keywords" content="trace event">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux Ftrace 1.2、trace event">
<meta property="og:url" content="http://yoursite.com/2018/05/30/ftrace_trace_event/index.html">
<meta property="og:site_name" content="pwl999&#39;s blog">
<meta property="og:description" content="Linux trace中，最基础的就是：function tracer和trace event。鉴于他们搭建的良好的框架(ringbuffer、tracefs)，各种trace纷纷投奔而来。  tracer发展出了function、function_graph、irqsoff、preemptoff、wakeup等一系列tracer。 而event也发展出tracepoint、kprobe、upro">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/images/ftrace_trace_event/trace_frame.png">
<meta property="og:image" content="http://yoursite.com/images/ftrace_trace_event/tracepoint_flow.png">
<meta property="og:image" content="http://yoursite.com/images/ftrace_trace_event/entry_format.png">
<meta property="og:image" content="http://yoursite.com/images/ftrace_trace_event/entry_output.png">
<meta property="og:image" content="http://yoursite.com/images/ftrace_trace_event/entry_tracepintk_format.png">
<meta property="og:updated_time" content="2019-01-14T02:17:08.647Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Linux Ftrace 1.2、trace event">
<meta name="twitter:description" content="Linux trace中，最基础的就是：function tracer和trace event。鉴于他们搭建的良好的框架(ringbuffer、tracefs)，各种trace纷纷投奔而来。  tracer发展出了function、function_graph、irqsoff、preemptoff、wakeup等一系列tracer。 而event也发展出tracepoint、kprobe、upro">
<meta name="twitter:image" content="http://yoursite.com/images/ftrace_trace_event/trace_frame.png">






  <link rel="canonical" href="http://yoursite.com/2018/05/30/ftrace_trace_event/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Linux Ftrace 1.2、trace event | pwl999's blog</title>
  












  <noscript>
  <style>
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion .logo-line-before i { left: initial; }
    .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">pwl999's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/30/ftrace_trace_event/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="pwl999">
      <meta itemprop="description" content="RTFSC(Read The Fucking Source Code)">
      <meta itemprop="image" content="/images/touxiang/ycqs.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="pwl999's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Linux Ftrace 1.2、trace event

              
            
          </h1>
        

        <div class="post-meta">

          

        <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-05-30 18:44:14" itemprop="dateCreated datePublished" datetime="2018-05-30T18:44:14+08:00">2018-05-30</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-01-14 10:17:08" itemprop="dateModified" datetime="2019-01-14T10:17:08+08:00">2019-01-14</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/Trace/" itemprop="url" rel="index"><span itemprop="name">Trace</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>Linux trace中，最基础的就是：function tracer和trace event。鉴于他们搭建的良好的框架(ringbuffer、tracefs)，各种trace纷纷投奔而来。</p>
<ul>
<li>tracer发展出了function、function_graph、irqsoff、preemptoff、wakeup等一系列tracer。</li>
<li>而event也发展出tracepoint、kprobe、uprobe等一系列的event。</li>
</ul>
<p><img src="/images/ftrace_trace_event/trace_frame.png" alt="image"></p>
<p>不论是哪种trace，主要的工作都离不开上图的主要流程：</p>
<ul>
<li>函数插桩。使用各种插桩方式把自己的trace函数插入到需要跟踪的probe point上；</li>
<li>input trace数据。在trace的probe函数被命中时，会存储数据到ringbuffer当中；这里还包括filter和trigger功能；</li>
<li>ouput trace数据。用户或者程序需要读出trace数据，根据需要输出ram数据或者是方面用户阅读的数据；对数据的解析，遵循谁存储谁提供解析规则的原则；</li>
</ul>
<h1 id="1、函数插桩"><a href="#1、函数插桩" class="headerlink" title="1、函数插桩"></a>1、函数插桩</h1><p>trace event的插桩使用的是tracepoint机制，tracepoint是一种静态的插桩方法。他需要静态的定义桩函数，并且在插桩位置显式的调用。</p>
<p>这种方法的好处是效率高、可靠，并且可以处于函数中的任何位置、方便的访问各种变量；坏处当然是不太灵活。</p>
<p>kernel在重要节点的固定位置，插入了几百个trace event用于跟踪。</p>
<h2 id="1-1、trace-point"><a href="#1-1、trace-point" class="headerlink" title="1.1、trace point"></a>1.1、trace point</h2><p><img src="/images/ftrace_trace_event/tracepoint_flow.png" alt="image"></p>
<p>关于tracepoint的工作的原理，我们举例说明：</p>
<p>1、我们在“kernel/sched/core.c”中通过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define CREATE_TRACE_POINTS</span><br><span class="line">#include &lt;trace/events/sched.h&gt;</span><br></pre></td></tr></table></figure>
<p>创建了一个tracepoint：__tracepoint_sched_switch (其中##name = sched_switch)。</p>
<p>同时创建了几个操作tracepoint的函数：</p>
<ul>
<li>桩函数trace_##name();</li>
<li>注册回调函数register_trace_##name();</li>
<li>注销回调函数unregister_trace_##name();</li>
</ul>
<p>2、tracepoint的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct tracepoint &#123;</span><br><span class="line">	const char *name;		/* Tracepoint name */</span><br><span class="line">	struct static_key key;</span><br><span class="line">	void (*regfunc)(void);</span><br><span class="line">	void (*unregfunc)(void);</span><br><span class="line">	struct tracepoint_func __rcu *funcs;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>各个字段的含义如下：</p>
<ul>
<li>key。tracepoint是否使能的开关。如果回调函数数组为空则key为disable，如果回调函数数组中有函数指针则key为enable；</li>
<li>*funcs。回调函数数组，tracepoint的作用就是在桩函数被命中时，逐个调用回调函数数组中的函数；</li>
<li><em>regfunc/</em>unregfunc。注册/注销回调函数时的的钩子函数。注意这两个函数只是hook函数，不是用户用来注册/注销回调函数的，注册/注销回调函数的是register_trace_##name()/unregister_trace_##name();</li>
</ul>
<p>3、我们在探测点插入桩函数：</p>
<p>kernel/sched/core.c：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static void __sched notrace __schedule(bool preempt)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    trace_sched_switch(preempt, prev, next);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、桩函数被命中时的执行流程：</p>
<p>可以看到就是逐条的执行回调函数数组中的函数指针。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">trace_sched_switch()</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static inline void trace_##name(proto)				\</span><br><span class="line">&#123;								\</span><br><span class="line">	if (static_key_false(&amp;__tracepoint_##name.key))		\</span><br><span class="line">		__DO_TRACE(&amp;__tracepoint_##name,		\</span><br><span class="line">			TP_PROTO(data_proto),			\</span><br><span class="line">			TP_ARGS(data_args),			\</span><br><span class="line">			TP_CONDITION(cond),,);			\</span><br><span class="line">	if (IS_ENABLED(CONFIG_LOCKDEP) &amp;&amp; (cond)) &#123;		\</span><br><span class="line">		rcu_read_lock_sched_notrace();			\</span><br><span class="line">		rcu_dereference_sched(__tracepoint_##name.funcs);\</span><br><span class="line">		rcu_read_unlock_sched_notrace();		\</span><br><span class="line">	&#125;							\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">#define __DO_TRACE(tp, proto, args, cond, prercu, postrcu)		\</span><br><span class="line">	do &#123;								\</span><br><span class="line">		struct tracepoint_func *it_func_ptr;			\</span><br><span class="line">		void *it_func;						\</span><br><span class="line">		void *__data;						\</span><br><span class="line">									\</span><br><span class="line">		if (!(cond))						\</span><br><span class="line">			return;						\</span><br><span class="line">		prercu;							\</span><br><span class="line">		rcu_read_lock_sched_notrace();				\</span><br><span class="line">		</span><br><span class="line">		/* (1) 逐个调用(tp)-&gt;funcs函数数组中的函数 </span><br><span class="line">		    这些函数可以由trace_event注册，也可以由其他人注册</span><br><span class="line">		*/</span><br><span class="line">		it_func_ptr = rcu_dereference_sched((tp)-&gt;funcs);	\</span><br><span class="line">		if (it_func_ptr) &#123;					\</span><br><span class="line">			do &#123;						\</span><br><span class="line">				it_func = (it_func_ptr)-&gt;func;		\</span><br><span class="line">				__data = (it_func_ptr)-&gt;data;		\</span><br><span class="line">				((void(*)(proto))(it_func))(args);	\</span><br><span class="line">			&#125; while ((++it_func_ptr)-&gt;func);		\</span><br><span class="line">		&#125;							\</span><br><span class="line">		rcu_read_unlock_sched_notrace();			\</span><br><span class="line">		postrcu;						\</span><br><span class="line">	&#125; while (0)</span><br></pre></td></tr></table></figure>
<p>5、注册回调函数：</p>
<p>可以通过register_trace_##name()/unregister_trace_##name()函数向回调函数数组中添加/删除函数指针。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static inline int						\</span><br><span class="line">register_trace_##name(void (*probe)(data_proto), void *data)	\</span><br><span class="line">&#123;								\</span><br><span class="line">	return tracepoint_probe_register(&amp;__tracepoint_##name,	\</span><br><span class="line">					(void *)probe, data);	\</span><br><span class="line">&#125;								\</span><br><span class="line"></span><br><span class="line">static inline int						\</span><br><span class="line">unregister_trace_##name(void (*probe)(data_proto), void *data)	\</span><br><span class="line">&#123;								\</span><br><span class="line">	return tracepoint_probe_unregister(&amp;__tracepoint_##name,\</span><br><span class="line">					(void *)probe, data);	\</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>6、trace event对tracepoint的利用：</p>
<p>以上可以看到，tracepoint只是一种静态插桩方法。trace event可以使用，其他机制也可以使用，只是kernel的绝大部分tracepoint都是trace event在使用。</p>
<p>单纯的定义和使用一个trace point，可以参考：<a href="https://www.kernel.org/doc/Documentation/trace/tracepoints.txt" target="_blank" rel="noopener">Documentation/trace/tracepoints.txt</a></p>
<p>trace event也必须向tracepoint注册自己的回调函数，这些回调函数的作用就是在函数被命中时往ringbuffer中写入trace信息。</p>
<h2 id="1-2、增加一个新的trace-event"><a href="#1-2、增加一个新的trace-event" class="headerlink" title="1.2、增加一个新的trace event"></a>1.2、增加一个新的trace event</h2><p>在现有的代码中添加探测函数，这是让很多内核开发者非常不爽的一件事，因为这可能降低性能或者让代码看起来非常臃肿。为了解决这些问题，内核最终进化出了一个TRACE_EVENT()来实现trace event的定义，这是非常简洁、智能的一个宏定义。</p>
<p>在理解TRACE_EVENT()宏之前，我们先来了解一下怎么样使用TRACE_EVENT()新增加一个trace event。</p>
<p>新增加trace event，我们必须遵循规定的格式。格式可以参考：<a href="https://lwn.net/Articles/379903/" target="_blank" rel="noopener">Using the TRACE_EVENT() macro (Part 1)</a>和<a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/samples/trace_events" target="_blank" rel="noopener">samples/trace_events</a>。</p>
<p>以下以内核中已经存在的event sched_switch为例，说明定义过程。</p>
<ul>
<li>1、首先需要在include/trace/events/文件夹下添加一个自己event的头文件，需要遵循注释的标准格式：</li>
</ul>
<p>include/trace/events/sched.h:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">// (1)TRACE_SYSTEM需要定义的 和头文件名一样，不然后续使用TRACE_SYSTEM多次include头文件的时候会出错</span><br><span class="line">#undef TRACE_SYSTEM</span><br><span class="line">#define TRACE_SYSTEM sched</span><br><span class="line"></span><br><span class="line">// (2)定义一个可以重复include的入口：TRACE_HEADER_MULTI_READ</span><br><span class="line">#if !defined(_TRACE_SCHED_H) || defined(TRACE_HEADER_MULTI_READ)</span><br><span class="line">#define _TRACE_SCHED_H</span><br><span class="line"></span><br><span class="line">// (3)包含进tracepoint.h文件</span><br><span class="line">#include &lt;linux/tracepoint.h&gt;</span><br><span class="line"></span><br><span class="line">// (4)TRACE_EVENT包含5个参数：(name, proto, args, struct, assign, print)</span><br><span class="line">// 前面两个参数：proto, args，是给定义tracepoint使用的。在linux/tracepoint.h中构造tracepoint桩函数、callback regitser/unregister函数，在trace/define_trace.h中定义tracepoint变量。</span><br><span class="line">// 后面三个参数：struct, assign, print，是给trace_event使用的。在trace/trace_events.h，构造trace_event的callback函数，注册到tracepoint。</span><br><span class="line">TRACE_EVENT(sched_switch,</span><br><span class="line"></span><br><span class="line">	TP_PROTO(bool preempt,</span><br><span class="line">		 struct task_struct *prev,</span><br><span class="line">		 struct task_struct *next),</span><br><span class="line"></span><br><span class="line">	TP_ARGS(preempt, prev, next),</span><br><span class="line"></span><br><span class="line">	TP_STRUCT__entry(</span><br><span class="line">		__array(	char,	prev_comm,	TASK_COMM_LEN	)</span><br><span class="line">		__field(	pid_t,	prev_pid			)</span><br><span class="line">		__field(	int,	prev_prio			)</span><br><span class="line">		__field(	long,	prev_state			)</span><br><span class="line">		__array(	char,	next_comm,	TASK_COMM_LEN	)</span><br><span class="line">		__field(	pid_t,	next_pid			)</span><br><span class="line">		__field(	int,	next_prio			)</span><br><span class="line">	),</span><br><span class="line"></span><br><span class="line">	TP_fast_assign(</span><br><span class="line">		memcpy(__entry-&gt;next_comm, next-&gt;comm, TASK_COMM_LEN);</span><br><span class="line">		__entry-&gt;prev_pid	= prev-&gt;pid;</span><br><span class="line">		__entry-&gt;prev_prio	= prev-&gt;prio;</span><br><span class="line">		__entry-&gt;prev_state	= __trace_sched_switch_state(preempt, prev);</span><br><span class="line">		memcpy(__entry-&gt;prev_comm, prev-&gt;comm, TASK_COMM_LEN);</span><br><span class="line">		__entry-&gt;next_pid	= next-&gt;pid;</span><br><span class="line">		__entry-&gt;next_prio	= next-&gt;prio;</span><br><span class="line">	),</span><br><span class="line"></span><br><span class="line">	TP_printk(&quot;prev_comm=%s prev_pid=%d prev_prio=%d prev_state=%s%s ==&gt; next_comm=%s next_pid=%d next_prio=%d&quot;,</span><br><span class="line">		__entry-&gt;prev_comm, __entry-&gt;prev_pid, __entry-&gt;prev_prio,</span><br><span class="line">		__entry-&gt;prev_state &amp; (TASK_STATE_MAX-1) ?</span><br><span class="line">		  __print_flags(__entry-&gt;prev_state &amp; (TASK_STATE_MAX-1), &quot;|&quot;,</span><br><span class="line">				&#123; 1, &quot;S&quot;&#125; , &#123; 2, &quot;D&quot; &#125;, &#123; 4, &quot;T&quot; &#125;, &#123; 8, &quot;t&quot; &#125;,</span><br><span class="line">				&#123; 16, &quot;Z&quot; &#125;, &#123; 32, &quot;X&quot; &#125;, &#123; 64, &quot;x&quot; &#125;,</span><br><span class="line">				&#123; 128, &quot;K&quot; &#125;, &#123; 256, &quot;W&quot; &#125;, &#123; 512, &quot;P&quot; &#125;,</span><br><span class="line">				&#123; 1024, &quot;N&quot; &#125;) : &quot;R&quot;,</span><br><span class="line">		__entry-&gt;prev_state &amp; TASK_STATE_MAX ? &quot;+&quot; : &quot;&quot;,</span><br><span class="line">		__entry-&gt;next_comm, __entry-&gt;next_pid, __entry-&gt;next_prio)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// (5) 为了节约text空间，如果参数都一样只是位置不一样，可以使用DECLARE_EVENT_CLASS() + DEFINE_EVENT()的形式来定义TRACE_EVENT()</span><br><span class="line">// 最新的kernel中，使用TRACE_EVENT()和使用DECLARE_EVENT_CLASS() + DEFINE_EVENT()是等价的</span><br><span class="line">DECLARE_EVENT_CLASS(sched_process_template,</span><br><span class="line"></span><br><span class="line">	TP_PROTO(struct task_struct *p),</span><br><span class="line"></span><br><span class="line">	TP_ARGS(p),</span><br><span class="line"></span><br><span class="line">	TP_STRUCT__entry(</span><br><span class="line">		__array(	char,	comm,	TASK_COMM_LEN	)</span><br><span class="line">		__field(	pid_t,	pid			)</span><br><span class="line">		__field(	int,	prio			)</span><br><span class="line">	),</span><br><span class="line"></span><br><span class="line">	TP_fast_assign(</span><br><span class="line">		memcpy(__entry-&gt;comm, p-&gt;comm, TASK_COMM_LEN);</span><br><span class="line">		__entry-&gt;pid		= p-&gt;pid;</span><br><span class="line">		__entry-&gt;prio		= p-&gt;prio;</span><br><span class="line">	),</span><br><span class="line"></span><br><span class="line">	TP_printk(&quot;comm=%s pid=%d prio=%d&quot;,</span><br><span class="line">		  __entry-&gt;comm, __entry-&gt;pid, __entry-&gt;prio)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Tracepoint for freeing a task:</span><br><span class="line"> */</span><br><span class="line">DEFINE_EVENT(sched_process_template, sched_process_free,</span><br><span class="line">	     TP_PROTO(struct task_struct *p),</span><br><span class="line">	     TP_ARGS(p));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Tracepoint for a task exiting:</span><br><span class="line"> */</span><br><span class="line">DEFINE_EVENT(sched_process_template, sched_process_exit,</span><br><span class="line">	     TP_PROTO(struct task_struct *p),</span><br><span class="line">	     TP_ARGS(p));</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Tracepoint for waiting on task to unschedule:</span><br><span class="line"> */</span><br><span class="line">DEFINE_EVENT(sched_process_template, sched_wait_task,</span><br><span class="line">	TP_PROTO(struct task_struct *p),</span><br><span class="line">	TP_ARGS(p));</span><br><span class="line"></span><br><span class="line">#endif /* _TRACE_SCHED_H */</span><br><span class="line"></span><br><span class="line">// (6) 包含进define_trace.h文件</span><br><span class="line">/* This part must be outside protection */</span><br><span class="line">#include &lt;trace/define_trace.h&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>2、在探测点位置中调用桩函数，需要遵循注释的标准格式：</li>
</ul>
<p>kernel/sched/core.c:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// (1) 定义CREATE_TRACE_POINTS，让define_trace.h能够进入，进行tracepoint和trace_event的创建</span><br><span class="line">#define CREATE_TRACE_POINTS</span><br><span class="line">#include &lt;trace/events/sched.h&gt;</span><br><span class="line"></span><br><span class="line">static void __sched notrace __schedule(bool preempt)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">// (2)trace_point定义的桩函数，在需要插桩的位置进行调用</span><br><span class="line">trace_sched_switch(preempt, prev, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-3、TRACE-EVENT-宏的解析"><a href="#1-3、TRACE-EVENT-宏的解析" class="headerlink" title="1.3、TRACE_EVENT()宏的解析"></a>1.3、TRACE_EVENT()宏的解析</h2><p>从上一节的使用中看，TRACE_EVENT()的使用非常简洁，只是定义了一系列的数据，调用也只是一句话。TRACE_EVENT()帮用户隐藏了所有的复杂细节，函数的定义、数据的写入读出、数据的解析。具体实现了以下功能：</p>
<ul>
<li>创建了一个tracepoint，可以放到kernel代码中；</li>
<li>创建了一个回调函数，可以被上述tracepoint调用</li>
<li>回调函数必须实现以最快的方式将传递给它的数据记录到trace ringbuffer中。</li>
<li>必须创建一个函数能解析从ringbuffer读出的数据，转换成便于用户理解的形式。</li>
</ul>
<p>TRACE_EVENT()为什么这么强大，用一个宏定义出所有的数据和函数？它的主要魔法是使用了一个cpp多次定义的一个技巧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#define DOGS &#123; C(JACK_RUSSELL), C(BULL_TERRIER), C(ITALIAN_GREYHOUND) &#125;</span><br><span class="line">#undef C</span><br><span class="line">#define C(a) ENUM_##a</span><br><span class="line">enum dog_enums DOGS;</span><br><span class="line">#undef C</span><br><span class="line">#define C(a) #a</span><br><span class="line">char *dog_strings[] = DOGS;</span><br><span class="line">char *dog_to_string(enum dog_enums dog)</span><br><span class="line">&#123;</span><br><span class="line">       return dog_strings[dog];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上例中，我们可以看到利用C()这个宏，重复的进行”#undef #define”。第一次我们定义了dog_enums，第二次我们定义了dog_strings[]。内核中也有大量的代码使用了这个技巧，TRACE_EVENT()更是把这个技巧运用到了极致。</p>
<p>我们来分析一下TRACE_EVENT()的扩展过程：</p>
<p>1、在tracepoint.h中，宏TRACE_EVENT()第一次展开，定义了tracepoint需要的一些函数。包括：</p>
<ul>
<li>tracepoint桩函数；桩函数的作用，就是在被调用时，按优先级调用所有的callback函数去执行；</li>
<li>tracepoint callback的register/unregister函数；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">#define TRACE_EVENT(name, proto, args, struct, assign, print)	\</span><br><span class="line">	DECLARE_TRACE(name, PARAMS(proto), PARAMS(args))</span><br><span class="line">↓</span><br><span class="line">#define DECLARE_TRACE(name, proto, args)				\</span><br><span class="line">	__DECLARE_TRACE(name, PARAMS(proto), PARAMS(args),		\</span><br><span class="line">			cpu_online(raw_smp_processor_id()),		\</span><br><span class="line">			PARAMS(void *__data, proto),			\</span><br><span class="line">			PARAMS(__data, args))</span><br><span class="line">↓</span><br><span class="line">#define __DECLARE_TRACE(name, proto, args, cond, data_proto, data_args) \</span><br><span class="line">// (1)tracepoint变量“__tracepoint_##name”本身，并不是本次定义的</span><br><span class="line">	extern struct tracepoint __tracepoint_##name;			\</span><br><span class="line">// (2)tracepoint桩函数“trace_##name”的定义</span><br><span class="line">	static inline void trace_##name(proto)				\</span><br><span class="line">	&#123;								\</span><br><span class="line">		if (static_key_false(&amp;__tracepoint_##name.key))		\</span><br><span class="line">			__DO_TRACE(&amp;__tracepoint_##name,		\</span><br><span class="line">				TP_PROTO(data_proto),			\</span><br><span class="line">				TP_ARGS(data_args),			\</span><br><span class="line">				TP_CONDITION(cond),,);			\</span><br><span class="line">		if (IS_ENABLED(CONFIG_LOCKDEP) &amp;&amp; (cond)) &#123;		\</span><br><span class="line">			rcu_read_lock_sched_notrace();			\</span><br><span class="line">			rcu_dereference_sched(__tracepoint_##name.funcs);\</span><br><span class="line">			rcu_read_unlock_sched_notrace();		\</span><br><span class="line">		&#125;							\</span><br><span class="line">	&#125;								\</span><br><span class="line">	__DECLARE_TRACE_RCU(name, PARAMS(proto), PARAMS(args),		\</span><br><span class="line">		PARAMS(cond), PARAMS(data_proto), PARAMS(data_args))	\</span><br><span class="line">// (3)tracepoint的回调函数注册函数&quot;register_trace_##name&quot;</span><br><span class="line">// 出来trace_event，普通用户也可以调用这个函数来注册自己的回调函数</span><br><span class="line">	static inline int						\</span><br><span class="line">	register_trace_##name(void (*probe)(data_proto), void *data)	\</span><br><span class="line">	&#123;								\</span><br><span class="line">		return tracepoint_probe_register(&amp;__tracepoint_##name,	\</span><br><span class="line">						(void *)probe, data);	\</span><br><span class="line">	&#125;								\</span><br><span class="line">	static inline int						\</span><br><span class="line">	register_trace_prio_##name(void (*probe)(data_proto), void *data,\</span><br><span class="line">				   int prio)				\</span><br><span class="line">	&#123;								\</span><br><span class="line">		return tracepoint_probe_register_prio(&amp;__tracepoint_##name, \</span><br><span class="line">					      (void *)probe, data, prio); \</span><br><span class="line">	&#125;								\</span><br><span class="line">// (4)tracepoint的回调函数反注册函数&quot;unregister_trace_##name&quot;</span><br><span class="line">	static inline int						\</span><br><span class="line">	unregister_trace_##name(void (*probe)(data_proto), void *data)	\</span><br><span class="line">	&#123;								\</span><br><span class="line">		return tracepoint_probe_unregister(&amp;__tracepoint_##name,\</span><br><span class="line">						(void *)probe, data);	\</span><br><span class="line">	&#125;								\</span><br><span class="line">	static inline void						\</span><br><span class="line">	check_trace_callback_type_##name(void (*cb)(data_proto))	\</span><br><span class="line">	&#123;								\</span><br><span class="line">	&#125;								\</span><br><span class="line">	static inline bool						\</span><br><span class="line">	trace_##name##_enabled(void)					\</span><br><span class="line">	&#123;								\</span><br><span class="line">		return static_key_false(&amp;__tracepoint_##name.key);	\</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line">// (2.1) 桩函数中，逐个调用回调函数进行执行</span><br><span class="line">#define __DO_TRACE(tp, proto, args, cond, prercu, postrcu)		\</span><br><span class="line">	do &#123;								\</span><br><span class="line">		struct tracepoint_func *it_func_ptr;			\</span><br><span class="line">		void *it_func;						\</span><br><span class="line">		void *__data;						\</span><br><span class="line">									\</span><br><span class="line">		if (!(cond))						\</span><br><span class="line">			return;						\</span><br><span class="line">		prercu;							\</span><br><span class="line">		rcu_read_lock_sched_notrace();				\</span><br><span class="line">		it_func_ptr = rcu_dereference_sched((tp)-&gt;funcs);	\</span><br><span class="line">		if (it_func_ptr) &#123;					\</span><br><span class="line">			do &#123;						\</span><br><span class="line">				it_func = (it_func_ptr)-&gt;func;		\</span><br><span class="line">				__data = (it_func_ptr)-&gt;data;		\</span><br><span class="line">				((void(*)(proto))(it_func))(args);	\</span><br><span class="line">			&#125; while ((++it_func_ptr)-&gt;func);		\</span><br><span class="line">		&#125;							\</span><br><span class="line">		rcu_read_unlock_sched_notrace();			\</span><br><span class="line">		postrcu;						\</span><br><span class="line">	&#125; while (0)</span><br></pre></td></tr></table></figure>
<p>2、在define_trace.h中，宏TRACE_EVENT()第二次的展开：</p>
<ul>
<li>这一次的目的是定义tracepoint变量“__tracepoint_##name”本身。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">// (1) 只有定义了CREATE_TRACE_POINTS，才准许进入</span><br><span class="line">#ifdef CREATE_TRACE_POINTS</span><br><span class="line"></span><br><span class="line">// (2) 为了避免后面TRACE_INCLUDE(TRACE_INCLUDE_FILE)多次重复包含，undefine掉CREATE_TRACE_POINTS</span><br><span class="line">/* Prevent recursion */</span><br><span class="line">#undef CREATE_TRACE_POINTS</span><br><span class="line"></span><br><span class="line">// (3)定义TRACE_INCLUDE()宏和TRACE_INCLUDE_FILE()宏</span><br><span class="line">// &quot;#include TRACE_INCLUDE(TRACE_INCLUDE_FILE)&quot;的意思就是对用户定义的头文件进行再次包含(例如&quot;include/trace/events/sched.h&quot;)</span><br><span class="line">// 这样会让其中的TRACE_EVENT()宏再次展开</span><br><span class="line">#ifndef TRACE_INCLUDE_FILE</span><br><span class="line"># define TRACE_INCLUDE_FILE TRACE_SYSTEM</span><br><span class="line"># define UNDEF_TRACE_INCLUDE_FILE</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifndef TRACE_INCLUDE_PATH</span><br><span class="line"># define __TRACE_INCLUDE(system) &lt;trace/events/system.h&gt;</span><br><span class="line"># define UNDEF_TRACE_INCLUDE_PATH</span><br><span class="line">#else</span><br><span class="line"># define __TRACE_INCLUDE(system) __stringify(TRACE_INCLUDE_PATH/system.h)</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"># define TRACE_INCLUDE(system) __TRACE_INCLUDE(system)</span><br><span class="line"></span><br><span class="line">// (4.1)重新定义TRACE_EVENT()</span><br><span class="line">#undef TRACE_EVENT</span><br><span class="line">#define TRACE_EVENT(name, proto, args, tstruct, assign, print)	\</span><br><span class="line">	DEFINE_TRACE(name)</span><br><span class="line"></span><br><span class="line">// (4.2)定义TRACE_HEADER_MULTI_READ，让用户定义的头文件能重复进入(例如&quot;include/trace/events/sched.h&quot;)</span><br><span class="line">/* Let the trace headers be reread */</span><br><span class="line">#define TRACE_HEADER_MULTI_READ</span><br><span class="line"></span><br><span class="line">// (4.3)重新包含用户定义的头文件(例如&quot;include/trace/events/sched.h&quot;)，让其中的TRACE_EVENT()定义再次展开</span><br><span class="line">#include TRACE_INCLUDE(TRACE_INCLUDE_FILE)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#ifdef TRACEPOINTS_ENABLED</span><br><span class="line">// (5) 包含trace_events.h</span><br><span class="line">// 在trace_events.h中，继续多次重新定义TRACE_EVENT()，重新包含用户定义的头文件(例如&quot;include/trace/events/sched.h&quot;)</span><br><span class="line">// 目的是实现trace_event对应tracepoint callback函数的定义</span><br><span class="line">#include &lt;trace/trace_events.h&gt;</span><br><span class="line">#include &lt;trace/perf.h&gt;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">// (6) 恢复CREATE_TRACE_POINTS的定义</span><br><span class="line">/* We may be processing more files */</span><br><span class="line">#define CREATE_TRACE_POINTS</span><br><span class="line"></span><br><span class="line">#endif /* CREATE_TRACE_POINTS */</span><br></pre></td></tr></table></figure>
<p>tracepoint.h:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">↓</span><br><span class="line">#define DEFINE_TRACE(name)						\</span><br><span class="line">	DEFINE_TRACE_FN(name, NULL, NULL);</span><br><span class="line">↓</span><br><span class="line">#define DEFINE_TRACE_FN(name, reg, unreg)				 \</span><br><span class="line">	static const char __tpstrtab_##name[]				 \</span><br><span class="line">	__attribute__((section(&quot;__tracepoints_strings&quot;))) = #name;	 \</span><br><span class="line">// (4.1.1)定义tracepoint变量“__tracepoint_##name”本身</span><br><span class="line">	struct tracepoint __tracepoint_##name				 \</span><br><span class="line">	__attribute__((section(&quot;__tracepoints&quot;))) =			 \</span><br><span class="line">		&#123; __tpstrtab_##name, STATIC_KEY_INIT_FALSE, reg, unreg, NULL &#125;;\</span><br><span class="line">// (4.1.2)将tracepoint变量指针&quot;__tracepoint_ptr_##name&quot;存放到section(&quot;__tracepoints_ptrs&quot;)</span><br><span class="line">	static struct tracepoint * const __tracepoint_ptr_##name __used	 \</span><br><span class="line">	__attribute__((section(&quot;__tracepoints_ptrs&quot;))) =		 \</span><br><span class="line">		&amp;__tracepoint_##name;</span><br></pre></td></tr></table></figure></p>
<p>在随后的trace_events.h中，宏TRACE_EVENT()又进行了多次的展开。<br>其中的关键是使用了一个技巧，重复多次定义多次展开。这里是这种技巧的一个最简单的demo：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#define DOGS &#123; C(JACK_RUSSELL), C(BULL_TERRIER), C(ITALIAN_GREYHOUND) &#125;</span><br><span class="line">#undef C</span><br><span class="line">#define C(a) ENUM_##a</span><br><span class="line">enum dog_enums DOGS;</span><br><span class="line">#undef C</span><br><span class="line">#define C(a) #a</span><br><span class="line">char *dog_strings[] = DOGS;</span><br><span class="line">char *dog_to_string(enum dog_enums dog)</span><br><span class="line">&#123;</span><br><span class="line">        return dog_strings[dog];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、trace_events.h中，宏TRACE_EVENT()又进行了多次的展开，定义了trace_event对应tracepoint callback需要的一系列函数。</p>
<p>宏TRACE_EVENT()第3次的展开：</p>
<ul>
<li>定义了一个数据类型”struct trace_event_raw_##name”。用来表示trace_event数据在ringbuffer中的原始存储格式，动态长度成员使用32bit的” __data_loc_##item” 来占位，其中低16bit表示偏移地址，高16bit表示数据长度。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">// (1) 重新定义TRACE_EVENT()</span><br><span class="line">#undef TRACE_EVENT</span><br><span class="line">#define TRACE_EVENT(name, proto, args, tstruct, assign, print) \</span><br><span class="line">	DECLARE_EVENT_CLASS(name,			       \</span><br><span class="line">			     PARAMS(proto),		       \</span><br><span class="line">			     PARAMS(args),		       \</span><br><span class="line">			     PARAMS(tstruct),		       \</span><br><span class="line">			     PARAMS(assign),		       \</span><br><span class="line">			     PARAMS(print));		       \</span><br><span class="line">	DEFINE_EVENT(name, name, PARAMS(proto), PARAMS(args));</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">#undef __field</span><br><span class="line">#define __field(type, item)		type	item;</span><br><span class="line"></span><br><span class="line">#undef __field_ext</span><br><span class="line">#define __field_ext(type, item, filter_type)	type	item;</span><br><span class="line"></span><br><span class="line">#undef __field_struct</span><br><span class="line">#define __field_struct(type, item)	type	item;</span><br><span class="line"></span><br><span class="line">#undef __field_struct_ext</span><br><span class="line">#define __field_struct_ext(type, item, filter_type)	type	item;</span><br><span class="line"></span><br><span class="line">#undef __array</span><br><span class="line">#define __array(type, item, len)	type	item[len];</span><br><span class="line"></span><br><span class="line">// 动态长度成员32bit的占位符“__data_loc_##item”</span><br><span class="line">// 低16bit是动态长度成员在结构体中的偏移量：__get_dynamic_array() = ((void *)__entry + (__entry-&gt;__data_loc_##field &amp; 0xffff))</span><br><span class="line">// 高16bit是动态长度成员的长度：__get_dynamic_array_len() = ((__entry-&gt;__data_loc_##field &gt;&gt; 16) &amp; 0xffff)</span><br><span class="line">#undef __dynamic_array</span><br><span class="line">#define __dynamic_array(type, item, len) u32 __data_loc_##item;</span><br><span class="line"></span><br><span class="line">#undef __string</span><br><span class="line">#define __string(item, src) __dynamic_array(char, item, -1)</span><br><span class="line"></span><br><span class="line">#undef __bitmask</span><br><span class="line">#define __bitmask(item, nr_bits) __dynamic_array(char, item, -1)</span><br><span class="line"></span><br><span class="line">#undef TP_STRUCT__entry</span><br><span class="line">#define TP_STRUCT__entry(args...) args</span><br><span class="line"></span><br><span class="line">// (2) 重新定义DECLARE_EVENT_CLASS()</span><br><span class="line">#undef DECLARE_EVENT_CLASS</span><br><span class="line">#define DECLARE_EVENT_CLASS(name, proto, args, tstruct, assign, print)	\</span><br><span class="line">// (2.1)定义类型&quot;struct trace_event_raw_##name&quot;</span><br><span class="line">	struct trace_event_raw_##name &#123;					\</span><br><span class="line">		struct trace_entry	ent;				\</span><br><span class="line">		tstruct							\</span><br><span class="line">		char			__data[0];			\</span><br><span class="line">	&#125;;								\</span><br><span class="line">									\</span><br><span class="line">	// (2.2) 定义“struct  trace_event_class ”类型的变量&quot;event_class_##name&quot;</span><br><span class="line">// 这里只是定义了一个没有被初始化的变量，后面会被其他赋值变量覆盖</span><br><span class="line">// 这里也有一个C语言的技巧：全局变量如果没有初始化赋值，会被后面有初始化赋值的变量定义所覆盖，而不会出现“变量重定义”的错误</span><br><span class="line">static struct trace_event_class event_class_##name;</span><br><span class="line"></span><br><span class="line">// (3) 重新定义DEFINE_EVENT()</span><br><span class="line">#undef DEFINE_EVENT</span><br><span class="line">#define DEFINE_EVENT(template, name, proto, args)	\</span><br><span class="line">// (3.1) 定义“struct trace_event_call”类型的变量&quot;event_##name&quot;</span><br><span class="line">// 这里只是定义了一个没有被初始化的变量，后面会被其他赋值变量覆盖</span><br><span class="line">	static struct trace_event_call	__used		\</span><br><span class="line">	__attribute__((__aligned__(4))) event_##name</span><br><span class="line"></span><br><span class="line">// (4)重新包含用户定义的头文件(例如&quot;include/trace/events/sched.h&quot;)，让其中的TRACE_EVENT()定义再次展开</span><br><span class="line">#include TRACE_INCLUDE(TRACE_INCLUDE_FILE)</span><br></pre></td></tr></table></figure>
<p>4、宏TRACE_EVENT()第4次的展开：</p>
<ul>
<li>定义了一个数据类型”struct trace_event_data_offsets_##call”。该结构体只包含动态长度成员，每个占位32bit，表示了动态成员之间的相对位置。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">// (1)TRACE_EVENT() = DECLARE_EVENT_CLASS();DEFINE_EVENT();</span><br><span class="line"></span><br><span class="line">#undef __field</span><br><span class="line">#define __field(type, item)</span><br><span class="line"></span><br><span class="line">#undef __field_ext</span><br><span class="line">#define __field_ext(type, item, filter_type)</span><br><span class="line"></span><br><span class="line">#undef __field_struct</span><br><span class="line">#define __field_struct(type, item)</span><br><span class="line"></span><br><span class="line">#undef __field_struct_ext</span><br><span class="line">#define __field_struct_ext(type, item, filter_type)</span><br><span class="line"></span><br><span class="line">#undef __array</span><br><span class="line">#define __array(type, item, len)</span><br><span class="line"></span><br><span class="line">// 只定义动态长度成员，每个长度为32bit；不定义其他常规成员；</span><br><span class="line">// 最终得到的是动态成员间的offset</span><br><span class="line">#undef __dynamic_array</span><br><span class="line">#define __dynamic_array(type, item, len)	u32 item;</span><br><span class="line"></span><br><span class="line">#undef __string</span><br><span class="line">#define __string(item, src) __dynamic_array(char, item, -1)</span><br><span class="line"></span><br><span class="line">#undef __bitmask</span><br><span class="line">#define __bitmask(item, nr_bits) __dynamic_array(unsigned long, item, -1)</span><br><span class="line"></span><br><span class="line">// (2) 重新定义DECLARE_EVENT_CLASS()</span><br><span class="line">#undef DECLARE_EVENT_CLASS</span><br><span class="line">#define DECLARE_EVENT_CLASS(call, proto, args, tstruct, assign, print)	\</span><br><span class="line">// (2.1) 定义类型“struct trace_event_data_offsets_##call”</span><br><span class="line">	struct trace_event_data_offsets_##call &#123;			\</span><br><span class="line">		tstruct;						\</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">// (3) 重新定义DEFINE_EVENT()</span><br><span class="line">#undef DEFINE_EVENT</span><br><span class="line">#define DEFINE_EVENT(template, name, proto, args)</span><br><span class="line"></span><br><span class="line">// (4)重新包含用户定义的头文件(例如&quot;include/trace/events/sched.h&quot;)，让其中的TRACE_EVENT()定义再次展开</span><br><span class="line">#include TRACE_INCLUDE(TRACE_INCLUDE_FILE)</span><br></pre></td></tr></table></figure>
<p>5、宏TRACE_EVENT()第5次的展开：</p>
<ul>
<li>定义了”trace_raw_output_##call()”函数。作用是打印ringbuffer原始数据到output buffer当中；</li>
<li>定义了“struct trace_event_functions”类型的变量“trace_event_type_funcs_##call ”。把”trace_raw_output_##call()”函数赋值给其中的”.trace”成员；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line">// (1)TRACE_EVENT() = DECLARE_EVENT_CLASS();DEFINE_EVENT();</span><br><span class="line"></span><br><span class="line">// 使用&quot;__entry&quot;取代“field”</span><br><span class="line">#undef __entry</span><br><span class="line">#define __entry field</span><br><span class="line"></span><br><span class="line">#undef TP_printk</span><br><span class="line">#define TP_printk(fmt, args...) fmt &quot;\n&quot;, args</span><br><span class="line"></span><br><span class="line">// “__data_loc_##field”的低16bit为动态长度成员的地址偏移</span><br><span class="line">#undef __get_dynamic_array</span><br><span class="line">#define __get_dynamic_array(field)	\</span><br><span class="line">		((void *)__entry + (__entry-&gt;__data_loc_##field &amp; 0xffff))</span><br><span class="line"></span><br><span class="line">// “__data_loc_##field”的高16bit为动态长度成员的长度</span><br><span class="line">#undef __get_dynamic_array_len</span><br><span class="line">#define __get_dynamic_array_len(field)	\</span><br><span class="line">		((__entry-&gt;__data_loc_##field &gt;&gt; 16) &amp; 0xffff)</span><br><span class="line"></span><br><span class="line">// str成员为dynamic_array的一种</span><br><span class="line">#undef __get_str</span><br><span class="line">#define __get_str(field) (char *)__get_dynamic_array(field)</span><br><span class="line"></span><br><span class="line">// 获取到bitmask的值，并且打印到output buffer</span><br><span class="line">// p为下面函数中定义的临时buffer</span><br><span class="line">#undef __get_bitmask</span><br><span class="line">#define __get_bitmask(field)						\</span><br><span class="line">	(&#123;								\</span><br><span class="line">		void *__bitmask = __get_dynamic_array(field);		\</span><br><span class="line">		unsigned int __bitmask_size;				\</span><br><span class="line">		__bitmask_size = __get_dynamic_array_len(field);	\</span><br><span class="line">		trace_print_bitmask_seq(p, __bitmask, __bitmask_size);	\</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">// 根据flag_array[]解析出flag的含义，并且打印到output buffer</span><br><span class="line">// p为下面函数中定义的临时buffer</span><br><span class="line">#undef __print_flags</span><br><span class="line">#define __print_flags(flag, delim, flag_array...)			\</span><br><span class="line">	(&#123;								\</span><br><span class="line">		static const struct trace_print_flags __flags[] =	\</span><br><span class="line">			&#123; flag_array, &#123; -1, NULL &#125;&#125;;			\</span><br><span class="line">		trace_print_flags_seq(p, delim, flag, __flags);	\</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">#undef __print_symbolic</span><br><span class="line">#define __print_symbolic(value, symbol_array...)			\</span><br><span class="line">	(&#123;								\</span><br><span class="line">		static const struct trace_print_flags symbols[] =	\</span><br><span class="line">			&#123; symbol_array, &#123; -1, NULL &#125;&#125;;			\</span><br><span class="line">		trace_print_symbols_seq(p, value, symbols);		\</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">#undef __print_symbolic_u64</span><br><span class="line">#if BITS_PER_LONG == 32</span><br><span class="line">#define __print_symbolic_u64(value, symbol_array...)			\</span><br><span class="line">	(&#123;								\</span><br><span class="line">		static const struct trace_print_flags_u64 symbols[] =	\</span><br><span class="line">			&#123; symbol_array, &#123; -1, NULL &#125; &#125;;			\</span><br><span class="line">		trace_print_symbols_seq_u64(p, value, symbols);	\</span><br><span class="line">	&#125;)</span><br><span class="line">#else</span><br><span class="line">#define __print_symbolic_u64(value, symbol_array...)			\</span><br><span class="line">			__print_symbolic(value, symbol_array)</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#undef __print_hex</span><br><span class="line">#define __print_hex(buf, buf_len) trace_print_hex_seq(p, buf, buf_len)</span><br><span class="line"></span><br><span class="line">#undef __print_array</span><br><span class="line">#define __print_array(array, count, el_size)				\</span><br><span class="line">	(&#123;								\</span><br><span class="line">		BUILD_BUG_ON(el_size != 1 &amp;&amp; el_size != 2 &amp;&amp;		\</span><br><span class="line">			     el_size != 4 &amp;&amp; el_size != 8);		\</span><br><span class="line">		trace_print_array_seq(p, array, count, el_size);	\</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">// (2) 重新定义DECLARE_EVENT_CLASS()</span><br><span class="line">#undef DECLARE_EVENT_CLASS</span><br><span class="line">#define DECLARE_EVENT_CLASS(call, proto, args, tstruct, assign, print)	\</span><br><span class="line">// (2.1) 定义output format函数&quot;trace_raw_output_##call()&quot;</span><br><span class="line">// 把ringbuffer中的原始数据打印解析到output buffer中</span><br><span class="line">static notrace enum print_line_t					\</span><br><span class="line">trace_raw_output_##call(struct trace_iterator *iter, int flags,		\</span><br><span class="line">			struct trace_event *trace_event)		\</span><br><span class="line">&#123;									\</span><br><span class="line">// (2.1.1) iter-&gt;seq：为output buffer</span><br><span class="line">	struct trace_seq *s = &amp;iter-&gt;seq;				\</span><br><span class="line">// (2.1.2) iter-&gt;tmp_seq：为临时buffer，供__get_bitmask()、__print_flags()、__print_symbolic()等一系列函数先把值转换成字符串</span><br><span class="line">	struct trace_seq __maybe_unused *p = &amp;iter-&gt;tmp_seq;		\</span><br><span class="line">//  (2.1.3) iter-&gt;ent：为ringbuffer原始数据的存放buffer，</span><br><span class="line">// 使用上面定义的结构&quot;struct trace_event_raw_##call&quot;指向这片区域，来进行引用</span><br><span class="line">	struct trace_event_raw_##call *field;				\</span><br><span class="line">	int ret;							\</span><br><span class="line">									\</span><br><span class="line">	field = (typeof(field))iter-&gt;ent;				\</span><br><span class="line">									\</span><br><span class="line">// (2.1.4)在output buffer的最前头，打印出trace_event的name</span><br><span class="line">	ret = trace_raw_output_prep(iter, trace_event);			\</span><br><span class="line">	if (ret != TRACE_TYPE_HANDLED)					\</span><br><span class="line">		return ret;						\</span><br><span class="line">									\</span><br><span class="line">// (2.1.5)把ringbuffer中的原始数据根据格式打印到output buffer当中</span><br><span class="line">	trace_seq_printf(s, print);					\</span><br><span class="line">									\</span><br><span class="line">	return trace_handle_return(s);					\</span><br><span class="line">&#125;									\</span><br><span class="line">//  (2.2) 定义“struct trace_event_functions”类型的变量“trace_event_type_funcs_##call ”</span><br><span class="line">// 把&quot;trace_raw_output_##call()&quot;函数赋值给其中的&quot;.trace&quot;成员</span><br><span class="line">static struct trace_event_functions trace_event_type_funcs_##call = &#123;	\</span><br><span class="line">	.trace			= trace_raw_output_##call,		\</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// (3) 重新定义DEFINE_EVENT_PRINT()</span><br><span class="line">#undef DEFINE_EVENT_PRINT</span><br><span class="line">#define DEFINE_EVENT_PRINT(template, call, proto, args, print)		\</span><br><span class="line">static notrace enum print_line_t					\</span><br><span class="line">trace_raw_output_##call(struct trace_iterator *iter, int flags,		\</span><br><span class="line">			 struct trace_event *event)			\</span><br><span class="line">&#123;									\</span><br><span class="line">	struct trace_event_raw_##template *field;			\</span><br><span class="line">	struct trace_entry *entry;					\</span><br><span class="line">	struct trace_seq *p = &amp;iter-&gt;tmp_seq;				\</span><br><span class="line">									\</span><br><span class="line">	entry = iter-&gt;ent;						\</span><br><span class="line">									\</span><br><span class="line">	if (entry-&gt;type != event_##call.event.type) &#123;			\</span><br><span class="line">		WARN_ON_ONCE(1);					\</span><br><span class="line">		return TRACE_TYPE_UNHANDLED;				\</span><br><span class="line">	&#125;								\</span><br><span class="line">									\</span><br><span class="line">	field = (typeof(field))entry;					\</span><br><span class="line">									\</span><br><span class="line">	trace_seq_init(p);						\</span><br><span class="line">	return trace_output_call(iter, #call, print);			\</span><br><span class="line">&#125;									\</span><br><span class="line">static struct trace_event_functions trace_event_type_funcs_##call = &#123;	\</span><br><span class="line">	.trace			= trace_raw_output_##call,		\</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// (4)重新包含用户定义的头文件(例如&quot;include/trace/events/sched.h&quot;)，让其中的TRACE_EVENT()定义再次展开</span><br><span class="line">#include TRACE_INCLUDE(TRACE_INCLUDE_FILE)</span><br></pre></td></tr></table></figure>
<p>6、宏TRACE_EVENT()第6次的展开：</p>
<ul>
<li>定义了函数”trace_event_define_fields_##call()”，把TP_STRUCT__entry()结构体中各成员，转换成ftrace_event_field链表，供后面trace_event filter功能来使用。在events对应的”format”文件中，可以看到这些field的定义。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">// (1)TRACE_EVENT() = DECLARE_EVENT_CLASS();DEFINE_EVENT();</span><br><span class="line"></span><br><span class="line">// 把一个__field_ext成员转换成ftrace_event_field，并且挂载到trace_event_call-&gt;class-&gt;fields链表当中</span><br><span class="line">// ftrace_event_field包含以下成员：(const char *type,  const char *name, int offset, int size, int is_signed, int filter_type)</span><br><span class="line">#undef __field_ext</span><br><span class="line">#define __field_ext(type, item, filter_type)				\</span><br><span class="line">	ret = trace_define_field(event_call, #type, #item,		\</span><br><span class="line">				 offsetof(typeof(field), item),		\</span><br><span class="line">				 sizeof(field.item),			\</span><br><span class="line">				 is_signed_type(type), filter_type);	\</span><br><span class="line">	if (ret)							\</span><br><span class="line">		return ret;</span><br><span class="line"></span><br><span class="line">#undef __field_struct_ext</span><br><span class="line">#define __field_struct_ext(type, item, filter_type)			\</span><br><span class="line">	ret = trace_define_field(event_call, #type, #item,		\</span><br><span class="line">				 offsetof(typeof(field), item),		\</span><br><span class="line">				 sizeof(field.item),			\</span><br><span class="line">				 0, filter_type);			\</span><br><span class="line">	if (ret)							\</span><br><span class="line">		return ret;</span><br><span class="line"></span><br><span class="line">// 把一个__field成员转换成ftrace_event_field，并且挂载到trace_event_call-&gt;class-&gt;fields链表当中</span><br><span class="line">// filter type = FILTER_OTHER</span><br><span class="line">#undef __field</span><br><span class="line">#define __field(type, item)	__field_ext(type, item, FILTER_OTHER)</span><br><span class="line"></span><br><span class="line">#undef __field_struct</span><br><span class="line">#define __field_struct(type, item) __field_struct_ext(type, item, FILTER_OTHER)</span><br><span class="line"></span><br><span class="line">// 把一个__array成员转换成ftrace_event_field，并且挂载到trace_event_call-&gt;class-&gt;fields链表当中</span><br><span class="line">// filter type = FILTER_OTHER</span><br><span class="line">// 如果type = char， filter type = FILTER_STATIC_STRING</span><br><span class="line">#undef __array</span><br><span class="line">#define __array(type, item, len)					\</span><br><span class="line">	do &#123;								\</span><br><span class="line">		char *type_str = #type&quot;[&quot;__stringify(len)&quot;]&quot;;		\</span><br><span class="line">		BUILD_BUG_ON(len &gt; MAX_FILTER_STR_VAL);			\</span><br><span class="line">		ret = trace_define_field(event_call, type_str, #item,	\</span><br><span class="line">				 offsetof(typeof(field), item),		\</span><br><span class="line">				 sizeof(field.item),			\</span><br><span class="line">				 is_signed_type(type), FILTER_OTHER);	\</span><br><span class="line">		if (ret)						\</span><br><span class="line">			return ret;					\</span><br><span class="line">	&#125; while (0);</span><br><span class="line"></span><br><span class="line">// 把一个__dynamic_array成员转换成ftrace_event_field，并且挂载到trace_event_call-&gt;class-&gt;fields链表当中</span><br><span class="line">// 其中的数据是动态长度成员的占位符&quot;__data_loc_##item&quot;</span><br><span class="line">// filter type = FILTER_OTHER</span><br><span class="line">// 如果type = char， filter type = FILTER_DYN_STRING</span><br><span class="line">#undef __dynamic_array</span><br><span class="line">#define __dynamic_array(type, item, len)				       \</span><br><span class="line">	ret = trace_define_field(event_call, &quot;__data_loc &quot; #type &quot;[]&quot;, #item,  \</span><br><span class="line">				 offsetof(typeof(field), __data_loc_##item),   \</span><br><span class="line">				 sizeof(field.__data_loc_##item),	       \</span><br><span class="line">				 is_signed_type(type), FILTER_OTHER);</span><br><span class="line"></span><br><span class="line">#undef __string</span><br><span class="line">#define __string(item, src) __dynamic_array(char, item, -1)</span><br><span class="line"></span><br><span class="line">#undef __bitmask</span><br><span class="line">#define __bitmask(item, nr_bits) __dynamic_array(unsigned long, item, -1)</span><br><span class="line"></span><br><span class="line">// (2) 重新定义DECLARE_EVENT_CLASS()</span><br><span class="line">#undef DECLARE_EVENT_CLASS</span><br><span class="line">#define DECLARE_EVENT_CLASS(call, proto, args, tstruct, func, print)	\</span><br><span class="line">// (2.1)创建函数&quot;trace_event_define_fields_##call()&quot;</span><br><span class="line">// 把TP_STRUCT__entry()结构体中各成员，转换成ftrace_event_field链表</span><br><span class="line">// 供后面trace_event filter功能来使用.</span><br><span class="line">// 在events对应的&quot;format&quot;文件中，可以看到这些field的定义。</span><br><span class="line">static int notrace __init						\</span><br><span class="line">trace_event_define_fields_##call(struct trace_event_call *event_call)	\</span><br><span class="line">&#123;									\</span><br><span class="line">	struct trace_event_raw_##call field;				\</span><br><span class="line">	int ret;							\</span><br><span class="line">									\</span><br><span class="line">	tstruct;							\</span><br><span class="line">									\</span><br><span class="line">	return ret;							\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// (3) 重新定义DEFINE_EVENT()</span><br><span class="line">#undef DEFINE_EVENT</span><br><span class="line">#define DEFINE_EVENT(template, name, proto, args)</span><br><span class="line"></span><br><span class="line">// (4)重新包含用户定义的头文件(例如&quot;include/trace/events/sched.h&quot;)，让其中的TRACE_EVENT()定义再次展开</span><br><span class="line">#include TRACE_INCLUDE(TRACE_INCLUDE_FILE)</span><br></pre></td></tr></table></figure>
<p>7、宏TRACE_EVENT()第7次的展开：</p>
<ul>
<li>定义了函数”trace_event_get_offsets_##call()”。计算了每个动态成员的偏移和长度，存放到“struct trace_event_data_offsets_##call”变量中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">// (1)TRACE_EVENT() = DECLARE_EVENT_CLASS();DEFINE_EVENT();</span><br><span class="line"></span><br><span class="line">#undef __entry</span><br><span class="line">#define __entry entry</span><br><span class="line"></span><br><span class="line">#undef __field</span><br><span class="line">#define __field(type, item)</span><br><span class="line"></span><br><span class="line">#undef __field_ext</span><br><span class="line">#define __field_ext(type, item, filter_type)</span><br><span class="line"></span><br><span class="line">#undef __field_struct</span><br><span class="line">#define __field_struct(type, item)</span><br><span class="line"></span><br><span class="line">#undef __field_struct_ext</span><br><span class="line">#define __field_struct_ext(type, item, filter_type)</span><br><span class="line"></span><br><span class="line">#undef __array</span><br><span class="line">#define __array(type, item, len)</span><br><span class="line"></span><br><span class="line">// 计算动态长度成员，在entry结构体中的偏移和长度</span><br><span class="line">// entry-&gt;__data[0]开始，是给动态长度成员存储实际数据的</span><br><span class="line">// 把数据的偏移和长度，存储到前面定义的结构体&quot;struct trace_event_data_offsets_##call&quot;中</span><br><span class="line">#undef __dynamic_array</span><br><span class="line">#define __dynamic_array(type, item, len)				\</span><br><span class="line">	__item_length = (len) * sizeof(type);				\</span><br><span class="line">	__data_offsets-&gt;item = __data_size +				\</span><br><span class="line">			       offsetof(typeof(*entry), __data);	\</span><br><span class="line">	__data_offsets-&gt;item |= __item_length &lt;&lt; 16;			\</span><br><span class="line">	__data_size += __item_length;</span><br><span class="line"></span><br><span class="line">// 用strlen()来计算确定string的长度</span><br><span class="line">#undef __string</span><br><span class="line">#define __string(item, src) __dynamic_array(char, item,			\</span><br><span class="line">		    strlen((src) ? (const char *)(src) : &quot;(null)&quot;) + 1)</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * __bitmask_size_in_bytes_raw is the number of bytes needed to hold</span><br><span class="line"> * num_possible_cpus().</span><br><span class="line"> */</span><br><span class="line">#define __bitmask_size_in_bytes_raw(nr_bits)	\</span><br><span class="line">	(((nr_bits) + 7) / 8)</span><br><span class="line"></span><br><span class="line">#define __bitmask_size_in_longs(nr_bits)			\</span><br><span class="line">	((__bitmask_size_in_bytes_raw(nr_bits) +		\</span><br><span class="line">	  ((BITS_PER_LONG / 8) - 1)) / (BITS_PER_LONG / 8))</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * __bitmask_size_in_bytes is the number of bytes needed to hold</span><br><span class="line"> * num_possible_cpus() padded out to the nearest long. This is what</span><br><span class="line"> * is saved in the buffer, just to be consistent.</span><br><span class="line"> */</span><br><span class="line">#define __bitmask_size_in_bytes(nr_bits)				\</span><br><span class="line">	(__bitmask_size_in_longs(nr_bits) * (BITS_PER_LONG / 8))</span><br><span class="line"></span><br><span class="line">#undef __bitmask</span><br><span class="line">#define __bitmask(item, nr_bits) __dynamic_array(unsigned long, item,	\</span><br><span class="line">					 __bitmask_size_in_longs(nr_bits))</span><br><span class="line"></span><br><span class="line">// (2) 重新定义DECLARE_EVENT_CLASS()</span><br><span class="line">#undef DECLARE_EVENT_CLASS</span><br><span class="line">#define DECLARE_EVENT_CLASS(call, proto, args, tstruct, assign, print)	\</span><br><span class="line">// (2.1)创建了函数&quot;trace_event_get_offsets_##call()&quot;</span><br><span class="line">// 计算了每个动态成员的偏移和长度，存放到“struct trace_event_data_offsets_##call”变量中</span><br><span class="line">static inline notrace int trace_event_get_offsets_##call(		\</span><br><span class="line">	struct trace_event_data_offsets_##call *__data_offsets, proto)	\</span><br><span class="line">&#123;									\</span><br><span class="line">	int __data_size = 0;						\</span><br><span class="line">	int __maybe_unused __item_length;				\</span><br><span class="line">	struct trace_event_raw_##call __maybe_unused *entry;		\</span><br><span class="line">									\</span><br><span class="line">	tstruct;							\</span><br><span class="line">									\</span><br><span class="line">	return __data_size;						\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// (3) 重新定义DEFINE_EVENT()</span><br><span class="line">#undef DEFINE_EVENT</span><br><span class="line">#define DEFINE_EVENT(template, name, proto, args)</span><br><span class="line"></span><br><span class="line">// (4)重新包含用户定义的头文件(例如&quot;include/trace/events/sched.h&quot;)，让其中的TRACE_EVENT()定义再次展开</span><br><span class="line">#include TRACE_INCLUDE(TRACE_INCLUDE_FILE)</span><br></pre></td></tr></table></figure>
<p>8、宏TRACE_EVENT()第8次的展开：</p>
<ul>
<li>定义最核心的函数”trace_event_raw_event_##call()”，这个函数实现trace_event的3个重要功能： 1、判断是否需要filter。 2、判断是否trigger。 3、记录数据到ringbuffer。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">// (1)TRACE_EVENT() = DECLARE_EVENT_CLASS();DEFINE_EVENT();</span><br><span class="line"></span><br><span class="line">#undef __entry</span><br><span class="line">#define __entry entry</span><br><span class="line"></span><br><span class="line">#undef __field</span><br><span class="line">#define __field(type, item)</span><br><span class="line"></span><br><span class="line">#undef __field_struct</span><br><span class="line">#define __field_struct(type, item)</span><br><span class="line"></span><br><span class="line">#undef __array</span><br><span class="line">#define __array(type, item, len)</span><br><span class="line"></span><br><span class="line">// 根据trace_event_get_offsets_##call()计算的动态长度成员的偏移和长度，</span><br><span class="line">// 给entry中的动态成员占位符&quot;__entry-&gt;__data_loc_##item&quot;赋值</span><br><span class="line">#undef __dynamic_array</span><br><span class="line">#define __dynamic_array(type, item, len)				\</span><br><span class="line">	__entry-&gt;__data_loc_##item = __data_offsets.item;</span><br><span class="line"></span><br><span class="line">#undef __string</span><br><span class="line">#define __string(item, src) __dynamic_array(char, item, -1)</span><br><span class="line"></span><br><span class="line">#undef __assign_str</span><br><span class="line">#define __assign_str(dst, src)						\</span><br><span class="line">	strcpy(__get_str(dst), (src) ? (const char *)(src) : &quot;(null)&quot;);</span><br><span class="line"></span><br><span class="line">#undef __bitmask</span><br><span class="line">#define __bitmask(item, nr_bits) __dynamic_array(unsigned long, item, -1)</span><br><span class="line"></span><br><span class="line">#undef __get_bitmask</span><br><span class="line">#define __get_bitmask(field) (char *)__get_dynamic_array(field)</span><br><span class="line"></span><br><span class="line">#undef __assign_bitmask</span><br><span class="line">#define __assign_bitmask(dst, src, nr_bits)					\</span><br><span class="line">	memcpy(__get_bitmask(dst), (src), __bitmask_size_in_bytes(nr_bits))</span><br><span class="line"></span><br><span class="line">#undef TP_fast_assign</span><br><span class="line">#define TP_fast_assign(args...) args</span><br><span class="line"></span><br><span class="line">#undef __perf_addr</span><br><span class="line">#define __perf_addr(a)	(a)</span><br><span class="line"></span><br><span class="line">#undef __perf_count</span><br><span class="line">#define __perf_count(c)	(c)</span><br><span class="line"></span><br><span class="line">#undef __perf_task</span><br><span class="line">#define __perf_task(t)	(t)</span><br><span class="line"></span><br><span class="line">// (2) 重新定义DECLARE_EVENT_CLASS()</span><br><span class="line">#undef DECLARE_EVENT_CLASS</span><br><span class="line">#define DECLARE_EVENT_CLASS(call, proto, args, tstruct, assign, print)	\</span><br><span class="line">									\</span><br><span class="line">// (2.1)创建函数&quot;trace_event_raw_event_##call()&quot;，这个函数实现trace_event的3个重要功能：</span><br><span class="line">// 1、判断是否需要filter</span><br><span class="line">// 2、判断是否trigger</span><br><span class="line">// 3、记录数据到ringbuffer</span><br><span class="line">static notrace void							\</span><br><span class="line">trace_event_raw_event_##call(void *__data, proto)			\</span><br><span class="line">&#123;									\</span><br><span class="line">	struct trace_event_file *trace_file = __data;			\</span><br><span class="line">	struct trace_event_data_offsets_##call __maybe_unused __data_offsets;\</span><br><span class="line">	struct trace_event_buffer fbuffer;				\</span><br><span class="line">	struct trace_event_raw_##call *entry;				\</span><br><span class="line">	int __data_size;						\</span><br><span class="line">									\</span><br><span class="line">// (2.1.1)在本event被&quot;soft disable&quot;的情况下：</span><br><span class="line">// 如果绑定的trigger，没有设置filter，在&quot;soft disable&quot;的情况下，trigger任然可以被执行</span><br><span class="line">	if (trace_trigger_soft_disabled(trace_file))			\</span><br><span class="line">		return;							\</span><br><span class="line">									\</span><br><span class="line">// (2.1.2)计算每个动态长度成员的偏移和长度，并且返回总的长度</span><br><span class="line">// 动态成员的存储位置在最后面&quot;enrey-&gt;__data[0]&quot;开始的位置</span><br><span class="line">	__data_size = trace_event_get_offsets_##call(&amp;__data_offsets, args); \</span><br><span class="line">									\</span><br><span class="line">// (2.1.3)根据&quot;entery的固定长度+动态数据长度&quot;，向ringbuffer中申请空间</span><br><span class="line">	entry = trace_event_buffer_reserve(&amp;fbuffer, trace_file,	\</span><br><span class="line">				 sizeof(*entry) + __data_size);		\</span><br><span class="line">									\</span><br><span class="line">	if (!entry)							\</span><br><span class="line">		return;							\</span><br><span class="line">									\</span><br><span class="line">// (2.1.4)根据trace_event_get_offsets_##call()计算的动态长度成员的偏移和长度，</span><br><span class="line">// 给entry中的动态成员占位符&quot;__entry-&gt;__data_loc_##item&quot;赋值</span><br><span class="line">	tstruct								\</span><br><span class="line">									\</span><br><span class="line">// (2.1.5)记录数据到ringbuffer</span><br><span class="line">	&#123; assign; &#125;							\</span><br><span class="line">									\</span><br><span class="line">// (2.1.6)确认ringbuffer提交</span><br><span class="line">// 1、判断是否需要filter</span><br><span class="line">// 2、判断是否trigger</span><br><span class="line">	trace_event_buffer_commit(&amp;fbuffer,				\</span><br><span class="line">				  sizeof(*entry) + __data_size);	\</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line"> * The ftrace_test_probe is compiled out, it is only here as a build time check</span><br><span class="line"> * to make sure that if the tracepoint handling changes, the ftrace probe will</span><br><span class="line"> * fail to compile unless it too is updated.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">// (3) 重新定义DEFINE_EVENT()</span><br><span class="line">#undef DEFINE_EVENT</span><br><span class="line">#define DEFINE_EVENT(template, call, proto, args)			\</span><br><span class="line">static inline void ftrace_test_probe_##call(void)			\</span><br><span class="line">&#123;									\</span><br><span class="line">	check_trace_callback_type_##call(trace_event_raw_event_##template); \</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// (4)重新包含用户定义的头文件(例如&quot;include/trace/events/sched.h&quot;)，让其中的TRACE_EVENT()定义再次展开</span><br><span class="line">#include TRACE_INCLUDE(TRACE_INCLUDE_FILE)</span><br></pre></td></tr></table></figure>
<p>↓</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">trace_event_buffer_commit()</span><br><span class="line">↓</span><br><span class="line">static inline void</span><br><span class="line">event_trigger_unlock_commit(struct trace_event_file *file,</span><br><span class="line">			    struct ring_buffer *buffer,</span><br><span class="line">			    struct ring_buffer_event *event,</span><br><span class="line">			    void *entry, unsigned long irq_flags, int pc,</span><br><span class="line">			    unsigned long len)</span><br><span class="line">&#123;</span><br><span class="line">	enum event_trigger_type tt = ETT_NONE;</span><br><span class="line"></span><br><span class="line">// (2.1.6.1) 判断filter和trigger filter的条件是否成立</span><br><span class="line">	if (!__event_trigger_test_discard(file, buffer, event, entry, &amp;tt)) &#123;</span><br><span class="line">		if (len)</span><br><span class="line">			stm_log(OST_ENTITY_FTRACE_EVENTS, entry, len);</span><br><span class="line">// (2.1.6.2) 正式提交commit到ringbuffer</span><br><span class="line">		trace_buffer_unlock_commit(file-&gt;tr, buffer, event, irq_flags, pc);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">// (2.1.6.3) 执行post类型的trigger</span><br><span class="line">	if (tt)</span><br><span class="line">		event_triggers_post_call(file, tt);</span><br><span class="line">&#125;</span><br><span class="line">↓</span><br><span class="line">static inline bool</span><br><span class="line">__event_trigger_test_discard(struct trace_event_file *file,</span><br><span class="line">			     struct ring_buffer *buffer,</span><br><span class="line">			     struct ring_buffer_event *event,</span><br><span class="line">			     void *entry,</span><br><span class="line">			     enum event_trigger_type *tt)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned long eflags = file-&gt;flags;</span><br><span class="line"></span><br><span class="line">// (2.1.6.1.1)根据trigger的filter条件，执行trigger</span><br><span class="line">	if (eflags &amp; EVENT_FILE_FL_TRIGGER_COND)</span><br><span class="line">		*tt = event_triggers_call(file, entry);</span><br><span class="line"></span><br><span class="line">// (2.1.6.1.2)如果当前event处在&quot;soft disable&quot;模式，丢弃掉ringbuffer的commit数据提交</span><br><span class="line">	if (test_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &amp;file-&gt;flags))</span><br><span class="line">		ring_buffer_discard_commit(buffer, event);</span><br><span class="line">// (2.1.6.1.3)检查event的filter条件是否成立</span><br><span class="line">	else if (!filter_check_discard(file, entry, buffer, event))</span><br><span class="line">		return false;</span><br><span class="line"></span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>9、宏TRACE_EVENT()第9次的展开：</p>
<ul>
<li>定义重要” struct trace_event_class”类型的变量“event_class_##call”</li>
<li>定义重要”struct trace_event_call”类型的变量“event_##call”</li>
<li>把”struct trace_event_call”类型变量的指针”__event_##call”存放到”section(“_ftrace_events”)”区域。在trace_events初始化时会逐个遍历section(“_ftrace_events”)中的指针来添加静态的events。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">// (1)TRACE_EVENT() = DECLARE_EVENT_CLASS();DEFINE_EVENT();</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_PERF_EVENTS</span><br><span class="line"></span><br><span class="line">// perf_event的probe函数&quot;perf_trace_##call&quot;的声明</span><br><span class="line">#define _TRACE_PERF_PROTO(call, proto)					\</span><br><span class="line">	static notrace void						\</span><br><span class="line">	perf_trace_##call(void *__data, proto);</span><br><span class="line">#define _TRACE_PERF_INIT(call)						\</span><br><span class="line">	.perf_probe		= perf_trace_##call,</span><br><span class="line">#else</span><br><span class="line">#define _TRACE_PERF_PROTO(call, proto)</span><br><span class="line">#define _TRACE_PERF_INIT(call)</span><br><span class="line">#endif /* CONFIG_PERF_EVENTS */</span><br><span class="line"></span><br><span class="line">#undef __entry</span><br><span class="line">#define __entry REC</span><br><span class="line"></span><br><span class="line">#undef __print_flags</span><br><span class="line">#undef __print_symbolic</span><br><span class="line">#undef __print_hex</span><br><span class="line">#undef __get_dynamic_array</span><br><span class="line">#undef __get_dynamic_array_len</span><br><span class="line">#undef __get_str</span><br><span class="line">#undef __get_bitmask</span><br><span class="line">#undef __print_array</span><br><span class="line"></span><br><span class="line">#undef TP_printk</span><br><span class="line">#define TP_printk(fmt, args...) &quot;\&quot;&quot; fmt &quot;\&quot;, &quot;  __stringify(args)</span><br><span class="line"></span><br><span class="line">// (2) 重新定义DECLARE_EVENT_CLASS()</span><br><span class="line">#undef DECLARE_EVENT_CLASS</span><br><span class="line">#define DECLARE_EVENT_CLASS(call, proto, args, tstruct, assign, print)	\</span><br><span class="line">_TRACE_PERF_PROTO(call, PARAMS(proto));					\</span><br><span class="line">static char print_fmt_##call[] = print;					\</span><br><span class="line">// (2.1)定义&quot;struct trace_event_class&quot;类型的变量&quot;event_class_##call&quot;</span><br><span class="line">static struct trace_event_class __used __refdata event_class_##call = &#123; \</span><br><span class="line">	.system			= TRACE_SYSTEM_STRING,			\</span><br><span class="line">// 前面定义的函数，把成员转成ftrace_event_field，并且挂载到trace_event_call-&gt;class-&gt;fields链表当中</span><br><span class="line">	.define_fields		= trace_event_define_fields_##call,	\	</span><br><span class="line">	.fields			= LIST_HEAD_INIT(event_class_##call.fields),\</span><br><span class="line">// trace_event_call初始化</span><br><span class="line">	.raw_init		= trace_event_raw_init,			\</span><br><span class="line">// 前面定义的函数，trace_event的probe函数，记录数据到ringbuffer</span><br><span class="line">	.probe			= trace_event_raw_event_##call,		\	</span><br><span class="line">// 注册trace_event/perf_event的probe函数到tracepoint中</span><br><span class="line">	.reg			= trace_event_reg,			\</span><br><span class="line">// perf_event的probe函数&quot;perf_trace_##call&quot;</span><br><span class="line">	_TRACE_PERF_INIT(call)						\</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// (3) 重新定义DEFINE_EVENT()</span><br><span class="line">#undef DEFINE_EVENT</span><br><span class="line">#define DEFINE_EVENT(template, call, proto, args)			\</span><br><span class="line">									\</span><br><span class="line">// (3.1)定义&quot; struct trace_event_call&quot;类型的变量&quot;event_##call&quot;</span><br><span class="line">static struct trace_event_call __used event_##call = &#123;			\</span><br><span class="line">// 上一步定义的“struct trace_event_class”类型的变量</span><br><span class="line">	.class			= &amp;event_class_##template,		\</span><br><span class="line">	&#123;								\</span><br><span class="line">// 前面定义tracepoint变量</span><br><span class="line">		.tp			= &amp;__tracepoint_##call,		\</span><br><span class="line">	&#125;,								\</span><br><span class="line">// 前面定义的变量，其中的.trace = trace_raw_output_##call，把ringbuffer数据format output</span><br><span class="line">	.event.funcs		= &amp;trace_event_type_funcs_##template,	\</span><br><span class="line">	.print_fmt		= print_fmt_##template,			\</span><br><span class="line">	.flags			= TRACE_EVENT_FL_TRACEPOINT,		\</span><br><span class="line">&#125;;									\</span><br><span class="line">// (3.2) 把trace_event_call的指针存放到section(&quot;_ftrace_events&quot;)区域中</span><br><span class="line">// 在trace_events初始化时会逐个遍历section(&quot;_ftrace_events&quot;)中的指针来添加静态的events</span><br><span class="line">static struct trace_event_call __used					\</span><br><span class="line">__attribute__((section(&quot;_ftrace_events&quot;))) *__event_##call = &amp;event_##call</span><br><span class="line"></span><br><span class="line">#undef DEFINE_EVENT_PRINT</span><br><span class="line">#define DEFINE_EVENT_PRINT(template, call, proto, args, print)		\</span><br><span class="line">									\</span><br><span class="line">static char print_fmt_##call[] = print;					\</span><br><span class="line">									\</span><br><span class="line">static struct trace_event_call __used event_##call = &#123;			\</span><br><span class="line">	.class			= &amp;event_class_##template,		\</span><br><span class="line">	&#123;								\</span><br><span class="line">		.tp			= &amp;__tracepoint_##call,		\</span><br><span class="line">	&#125;,								\</span><br><span class="line">	.event.funcs		= &amp;trace_event_type_funcs_##call,	\</span><br><span class="line">	.print_fmt		= print_fmt_##call,			\</span><br><span class="line">	.flags			= TRACE_EVENT_FL_TRACEPOINT,		\</span><br><span class="line">&#125;;									\</span><br><span class="line">static struct trace_event_call __used					\</span><br><span class="line">__attribute__((section(&quot;_ftrace_events&quot;))) *__event_##call = &amp;event_##call</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// (4)重新包含用户定义的头文件(例如&quot;include/trace/events/sched.h&quot;)，让其中的TRACE_EVENT()定义再次展开</span><br><span class="line">#include TRACE_INCLUDE(TRACE_INCLUDE_FILE)</span><br></pre></td></tr></table></figure>
<p>10、如果定义了CONFIG_PERF_EVENTS，TRACE_EVENT()会在”include\trace\perf.h”中再一次展开。</p>
<p>define_trace.h：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#ifdef TRACEPOINTS_ENABLED</span><br><span class="line">#include &lt;trace/trace_events.h&gt;</span><br><span class="line">#include &lt;trace/perf.h&gt;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>↓</p>
<p>“include\trace\perf.h”，宏TRACE_EVENT()第10次的展开：</p>
<ul>
<li>定义了函数perf_trace_##call()，是perf_event的probe函数，和trace_event的功能类似都是把数据记录到buffer当中，不过这里不是trace_event的ringbuffer，而是perf_event自己的buffer。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">// (1)TRACE_EVENT() = DECLARE_EVENT_CLASS();DEFINE_EVENT();</span><br><span class="line">#ifdef CONFIG_PERF_EVENTS</span><br><span class="line"></span><br><span class="line">#undef __entry</span><br><span class="line">#define __entry entry</span><br><span class="line"></span><br><span class="line">#undef __get_dynamic_array</span><br><span class="line">#define __get_dynamic_array(field)	\</span><br><span class="line">		((void *)__entry + (__entry-&gt;__data_loc_##field &amp; 0xffff))</span><br><span class="line"></span><br><span class="line">#undef __get_dynamic_array_len</span><br><span class="line">#define __get_dynamic_array_len(field)	\</span><br><span class="line">		((__entry-&gt;__data_loc_##field &gt;&gt; 16) &amp; 0xffff)</span><br><span class="line"></span><br><span class="line">#undef __get_str</span><br><span class="line">#define __get_str(field) (char *)__get_dynamic_array(field)</span><br><span class="line"></span><br><span class="line">#undef __get_bitmask</span><br><span class="line">#define __get_bitmask(field) (char *)__get_dynamic_array(field)</span><br><span class="line"></span><br><span class="line">#undef __perf_addr</span><br><span class="line">#define __perf_addr(a)	(__addr = (a))</span><br><span class="line"></span><br><span class="line">#undef __perf_count</span><br><span class="line">#define __perf_count(c)	(__count = (c))</span><br><span class="line"></span><br><span class="line">#undef __perf_task</span><br><span class="line">#define __perf_task(t)	(__task = (t))</span><br><span class="line"></span><br><span class="line">// (2) 重新定义DECLARE_EVENT_CLASS()</span><br><span class="line">#undef DECLARE_EVENT_CLASS</span><br><span class="line">#define DECLARE_EVENT_CLASS(call, proto, args, tstruct, assign, print)	\</span><br><span class="line">// (2.1)定义了函数perf_trace_##call()，是perf_event的probe函数，</span><br><span class="line">// 和trace_event的功能类似都是把数据记录到buffer当中，不过这里不是trace_event的ringbuffer，而是perf_event自己的buffer。</span><br><span class="line">static notrace void							\</span><br><span class="line">perf_trace_##call(void *__data, proto)					\</span><br><span class="line">&#123;									\</span><br><span class="line">	struct trace_event_call *event_call = __data;			\</span><br><span class="line">	struct trace_event_data_offsets_##call __maybe_unused __data_offsets;\</span><br><span class="line">	struct trace_event_raw_##call *entry;				\</span><br><span class="line">	struct pt_regs *__regs;						\</span><br><span class="line">	u64 __addr = 0, __count = 1;					\</span><br><span class="line">	struct task_struct *__task = NULL;				\</span><br><span class="line">	struct hlist_head *head;					\</span><br><span class="line">	int __entry_size;						\</span><br><span class="line">	int __data_size;						\</span><br><span class="line">	int rctx;							\</span><br><span class="line">									\</span><br><span class="line">// (2.1.1)计算动态数据的长度</span><br><span class="line">	__data_size = trace_event_get_offsets_##call(&amp;__data_offsets, args); \</span><br><span class="line">									\</span><br><span class="line">	head = this_cpu_ptr(event_call-&gt;perf_events);			\</span><br><span class="line">	if (__builtin_constant_p(!__task) &amp;&amp; !__task &amp;&amp;			\</span><br><span class="line">				hlist_empty(head))			\</span><br><span class="line">		return;							\</span><br><span class="line">									\</span><br><span class="line">// (2.1.2)计算需要存储数据的总长度</span><br><span class="line">	__entry_size = ALIGN(__data_size + sizeof(*entry) + sizeof(u32),\</span><br><span class="line">			     sizeof(u64));				\</span><br><span class="line">	__entry_size -= sizeof(u32);					\</span><br><span class="line">									\</span><br><span class="line">// (2.1.3)分配perf_event的buffer空间</span><br><span class="line">	entry = perf_trace_buf_prepare(__entry_size,			\</span><br><span class="line">			event_call-&gt;event.type, &amp;__regs, &amp;rctx);	\</span><br><span class="line">	if (!entry)							\</span><br><span class="line">		return;							\</span><br><span class="line">									\</span><br><span class="line">	perf_fetch_caller_regs(__regs);					\</span><br><span class="line">									\</span><br><span class="line">// (2.1.4)根据trace_event_get_offsets_##call()计算的动态长度成员的偏移和长度，</span><br><span class="line">// 给entry中的动态成员占位符&quot;__entry-&gt;__data_loc_##item&quot;赋值</span><br><span class="line">	tstruct								\</span><br><span class="line">									\</span><br><span class="line">// (2.1.5)存储数据到perf_event的buffer当中</span><br><span class="line">	&#123; assign; &#125;							\</span><br><span class="line">									\</span><br><span class="line">// (2.1.6)确认数据的提交</span><br><span class="line">	perf_trace_buf_submit(entry, __entry_size, rctx, __addr,	\</span><br><span class="line">		__count, __regs, head, __task);				\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * This part is compiled out, it is only here as a build time check</span><br><span class="line"> * to make sure that if the tracepoint handling changes, the</span><br><span class="line"> * perf probe will fail to compile unless it too is updated.</span><br><span class="line"> */</span><br><span class="line">// (3) 重新定义DEFINE_EVENT()</span><br><span class="line">#undef DEFINE_EVENT</span><br><span class="line">#define DEFINE_EVENT(template, call, proto, args)			\</span><br><span class="line">static inline void perf_test_probe_##call(void)				\</span><br><span class="line">&#123;									\</span><br><span class="line">	check_trace_callback_type_##call(perf_trace_##template);	\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#undef DEFINE_EVENT_PRINT</span><br><span class="line">#define DEFINE_EVENT_PRINT(template, name, proto, args, print)	\</span><br><span class="line">	DEFINE_EVENT(template, name, PARAMS(proto), PARAMS(args))</span><br><span class="line"></span><br><span class="line">// (4)重新包含用户定义的头文件(例如&quot;include/trace/events/sched.h&quot;)，让其中的TRACE_EVENT()定义再次展开</span><br><span class="line">#include TRACE_INCLUDE(TRACE_INCLUDE_FILE)</span><br><span class="line">#endif /* CONFIG_PERF_EVENTS */</span><br></pre></td></tr></table></figure>
<h2 id="1-4、trace初始化"><a href="#1-4、trace初始化" class="headerlink" title="1.4、trace初始化"></a>1.4、trace初始化</h2><p>参考上一节第9次展开的结论，TRACE_EVENT()多次展开定义了各种实现函数以后，最终把本event的所有的函数和数据存放在顶级数据结构trace_event_call中，而所有的event都会把自己的trace_event_call指针存放到section(“_ftrace_events”)中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">9、宏TRACE_EVENT()第9次的展开：</span><br><span class="line"></span><br><span class="line">- 定义重要&quot; struct trace_event_class&quot;类型的变量“event_class_##call”</span><br><span class="line">- 定义重要&quot;struct trace_event_call&quot;类型的变量“event_##call”</span><br><span class="line">- 把&quot;struct trace_event_call&quot;类型变量的指针&quot;__event_##call&quot;存放到&quot;section(&quot;_ftrace_events&quot;)&quot;区域。在trace_events初始化时会逐个遍历section(&quot;_ftrace_events&quot;)中的指针来添加静态的events。</span><br></pre></td></tr></table></figure>
<p>在trace初始化或者是Instances化时，系统会新建ringbuffer空间，并且建立ringbuffer和trace_event_call之间的关联。我们通过分析trace的初始化过程，来理清他们相互之间的联系。</p>
<p>最关键的是：创建trace_event_file结构，并将trace_array、trace_event_call结合在一起。</p>
<p>start_kernel() -&gt; trace_init()：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">void __init trace_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	if (tracepoint_printk) &#123;</span><br><span class="line">		tracepoint_print_iter =</span><br><span class="line">			kmalloc(sizeof(*tracepoint_print_iter), GFP_KERNEL);</span><br><span class="line">		if (WARN_ON(!tracepoint_print_iter))</span><br><span class="line">			tracepoint_printk = 0;</span><br><span class="line">	&#125;</span><br><span class="line">	/* 1、初始化struct trace_array的global_trace：</span><br><span class="line">	    -&gt;trace_buffe，分配主要的trace ringbuffer空间</span><br><span class="line">	    -&gt;max_buffer，分配snapshot空间，大小和trace_buffer一样</span><br><span class="line">	    -&gt;ops，初始化为global_ops</span><br><span class="line">	    -&gt;current_trace，默认tracer为nop_trace</span><br><span class="line">	    最后将global_trace加入到ftrace_trace_arrays链表</span><br><span class="line">	   2、初始化trace_printk()用到的trace_buffer_struct：</span><br><span class="line">	    trace_percpu_buffer、trace_percpu_sirq_buffer、trace_percpu_irq_buffer、trace_percpu_nmi_buffer</span><br><span class="line">	   3、初始化temp_buffer，</span><br><span class="line">	    在主buffer disable的时候给trigger使用</span><br><span class="line">	 */</span><br><span class="line">	tracer_alloc_buffers();</span><br><span class="line">	</span><br><span class="line">	/* trace event 初始化*/</span><br><span class="line">	trace_event_init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">void __init trace_event_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    /* 创建field_cachep、file_cachep对应的slub内存池 */</span><br><span class="line">	event_trace_memsetup();</span><br><span class="line">	/* syscall对应初始化 */</span><br><span class="line">	init_ftrace_syscalls();</span><br><span class="line">	/* 使能event */</span><br><span class="line">	event_trace_enable();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">||→</span><br><span class="line"></span><br><span class="line">static __init int event_trace_enable(void)</span><br><span class="line">&#123;</span><br><span class="line">    /* (1) get top trace_arrary，这是应该获得的是global_trace */</span><br><span class="line">	struct trace_array *tr = top_trace_array();</span><br><span class="line">	struct trace_event_call **iter, *call;</span><br><span class="line">	int ret;</span><br><span class="line"></span><br><span class="line">	if (!tr)</span><br><span class="line">		return -ENODEV;</span><br><span class="line"></span><br><span class="line">    /* (2) 从section(&quot;_ftrace_events&quot;)逐个拿出，使用TRACE_EVENT()宏定义的trace_event_call指针，</span><br><span class="line">        并进行初始化</span><br><span class="line">     */</span><br><span class="line">	for_each_event(iter, __start_ftrace_events, __stop_ftrace_events) &#123;</span><br><span class="line"></span><br><span class="line">		call = *iter;</span><br><span class="line">		/* (2.1) 初始化trace_event_call */</span><br><span class="line">		ret = event_init(call);</span><br><span class="line">		if (!ret)</span><br><span class="line">		    /* (2.2) 将trace_event_call加入ftrace_events链表 */</span><br><span class="line">			list_add(&amp;call-&gt;list, &amp;ftrace_events);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * We need the top trace array to have a working set of trace</span><br><span class="line">	 * points at early init, before the debug files and directories</span><br><span class="line">	 * are created. Create the file entries now, and attach them</span><br><span class="line">	 * to the actual file dentries later.</span><br><span class="line">	 */</span><br><span class="line">	/* (3) 创建trace_event_file结构，并将trace_array、trace_event_call结合在一起：</span><br><span class="line">	    file-&gt;event_call = trace_event_call，event相关操作函数</span><br><span class="line">	    file-&gt;tr = trace_array，ringbuffer</span><br><span class="line">	    </span><br><span class="line">	    list_add(&amp;file-&gt;list, &amp;tr-&gt;events)，将file加入到tr-&gt;events链表中</span><br><span class="line">	    这个时候虽然trace_event_file结构已经创建，但是因为debugfs并没有准备好，所以不会有对应的文件创建，只是给那些early trace使用</span><br><span class="line">	 */</span><br><span class="line">	__trace_early_add_events(tr);</span><br><span class="line"></span><br><span class="line">    /* (4) 根据bootcmd enable一些early trace event */</span><br><span class="line">	early_enable_events(tr, false);</span><br><span class="line"></span><br><span class="line">    /* (5) 如果trace_printk已经使能，开始cmdline cache的记录 */</span><br><span class="line">	trace_printk_start_comm();</span><br><span class="line"></span><br><span class="line">    /* (6) 注册event的command */</span><br><span class="line">	register_event_cmds();</span><br><span class="line"></span><br><span class="line">    /* (7) 注册trigger的command */</span><br><span class="line">	register_trigger_cmds();</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|||→</span><br><span class="line"></span><br><span class="line">static int event_init(struct trace_event_call *call)</span><br><span class="line">&#123;</span><br><span class="line">	int ret = 0;</span><br><span class="line">	const char *name;</span><br><span class="line"></span><br><span class="line">	name = trace_event_name(call);</span><br><span class="line">	if (WARN_ON(!name))</span><br><span class="line">		return -EINVAL;</span><br><span class="line"></span><br><span class="line">	if (call-&gt;class-&gt;raw_init) &#123;</span><br><span class="line">	    /* (2.1.1) 调用trace_event_class的raw_init函数 */</span><br><span class="line">		ret = call-&gt;class-&gt;raw_init(call);</span><br><span class="line">		if (ret &lt; 0 &amp;&amp; ret != -ENOSYS)</span><br><span class="line">			pr_warn(&quot;Could not initialize trace events/%s\n&quot;, name);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据“include/trace/trace_event.h”中event_class_##call的定义，raw_init()最后调用到trace_event_raw_init()：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">int trace_event_raw_init(struct trace_event_call *call)</span><br><span class="line">&#123;</span><br><span class="line">	int id;</span><br><span class="line"></span><br><span class="line">    /* (2.1.1.1) 注册trace_event_call结构中的trace_event成员 */</span><br><span class="line">	id = register_trace_event(&amp;call-&gt;event);</span><br><span class="line">	if (!id)</span><br><span class="line">		return -ENODEV;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">int register_trace_event(struct trace_event *event)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned key;</span><br><span class="line">	int ret = 0;</span><br><span class="line"></span><br><span class="line">	down_write(&amp;trace_event_sem);</span><br><span class="line"></span><br><span class="line">	if (WARN_ON(!event))</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">	if (WARN_ON(!event-&gt;funcs))</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">	INIT_LIST_HEAD(&amp;event-&gt;list);</span><br><span class="line"></span><br><span class="line">    /* (2.1.1.1.1) 给event-&gt;type分配一个id，这个id非常重要：</span><br><span class="line">        在存入数据到ringbuffer中的时候，ent-&gt;type记录这个数据是谁存储的</span><br><span class="line">        在读出数据时，根据ent-&gt;type找到对应的trace_event和trace_event_call，由具体的trace_event来格式化输出数据到用户可读格式</span><br><span class="line">     */</span><br><span class="line">	if (!event-&gt;type) &#123;</span><br><span class="line">		struct list_head *list = NULL;</span><br><span class="line"></span><br><span class="line">		if (next_event_type &gt; TRACE_EVENT_TYPE_MAX) &#123;</span><br><span class="line"></span><br><span class="line">			event-&gt;type = trace_search_list(&amp;list);</span><br><span class="line">			if (!event-&gt;type)</span><br><span class="line">				goto out;</span><br><span class="line"></span><br><span class="line">		&#125; else &#123;</span><br><span class="line"></span><br><span class="line">			event-&gt;type = next_event_type++;</span><br><span class="line">			list = &amp;ftrace_event_list;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (WARN_ON(ftrace_find_event(event-&gt;type)))</span><br><span class="line">			goto out;</span><br><span class="line"></span><br><span class="line">		list_add_tail(&amp;event-&gt;list, list);</span><br><span class="line"></span><br><span class="line">	&#125; else if (event-&gt;type &gt; __TRACE_LAST_TYPE) &#123;</span><br><span class="line">		printk(KERN_WARNING &quot;Need to add type to trace.h\n&quot;);</span><br><span class="line">		WARN_ON(1);</span><br><span class="line">		goto out;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		/* Is this event already used */</span><br><span class="line">		if (ftrace_find_event(event-&gt;type))</span><br><span class="line">			goto out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (2.1.1.1.2) 初始化event默认的各种输出函数 */</span><br><span class="line">	if (event-&gt;funcs-&gt;trace == NULL)</span><br><span class="line">		event-&gt;funcs-&gt;trace = trace_nop_print;</span><br><span class="line">	if (event-&gt;funcs-&gt;raw == NULL)</span><br><span class="line">		event-&gt;funcs-&gt;raw = trace_nop_print;</span><br><span class="line">	if (event-&gt;funcs-&gt;hex == NULL)</span><br><span class="line">		event-&gt;funcs-&gt;hex = trace_nop_print;</span><br><span class="line">	if (event-&gt;funcs-&gt;binary == NULL)</span><br><span class="line">		event-&gt;funcs-&gt;binary = trace_nop_print;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /* (2.1.1.1.3) 将event安装type的数值加入到hash数组，方便读出数据时快速根据type找到event结构</span><br><span class="line">     */</span><br><span class="line">	key = event-&gt;type &amp; (EVENT_HASHSIZE - 1);</span><br><span class="line"></span><br><span class="line">	hlist_add_head(&amp;event-&gt;node, &amp;event_hash[key]);</span><br><span class="line"></span><br><span class="line">	ret = event-&gt;type;</span><br><span class="line"> out:</span><br><span class="line">	up_write(&amp;trace_event_sem);</span><br><span class="line"></span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在event_trace_enable()中创建的trace_event_file，直到event_trace_init()中才会真正创建成各种文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">fs_initcall(event_trace_init);</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static __init int event_trace_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	struct trace_array *tr;</span><br><span class="line">	struct dentry *d_tracer;</span><br><span class="line">	struct dentry *entry;</span><br><span class="line">	int ret;</span><br><span class="line"></span><br><span class="line">	tr = top_trace_array();</span><br><span class="line">	if (!tr)</span><br><span class="line">		return -ENODEV;</span><br><span class="line"></span><br><span class="line">    /* (1) 创建顶级文件夹：tracing */</span><br><span class="line">	d_tracer = tracing_init_dentry();</span><br><span class="line">	if (IS_ERR(d_tracer))</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">    /* (2) 创建&quot;tracing/available_events&quot;文件 */</span><br><span class="line">	entry = tracefs_create_file(&quot;available_events&quot;, 0444, d_tracer,</span><br><span class="line">				    tr, &amp;ftrace_avail_fops);</span><br><span class="line">	if (!entry)</span><br><span class="line">		pr_warn(&quot;Could not create tracefs &apos;available_events&apos; entry\n&quot;);</span><br><span class="line"></span><br><span class="line">    /* (3) 创建generic字段：</span><br><span class="line">        CPU/cpu/COMM/comm，并加入到ftrace_generic_fields链表</span><br><span class="line">     */</span><br><span class="line">	if (trace_define_generic_fields())</span><br><span class="line">		pr_warn(&quot;tracing: Failed to allocated generic fields&quot;);</span><br><span class="line"></span><br><span class="line">    /* (4) 创建common字段：</span><br><span class="line">        type/flags/preempt_count/pid，并加入到ftrace_common_fields链表</span><br><span class="line">     */</span><br><span class="line">	if (trace_define_common_fields())</span><br><span class="line">		pr_warn(&quot;tracing: Failed to allocate common fields&quot;);</span><br><span class="line"></span><br><span class="line">    /* (5) 使用early创建的trace_event_file，继续创建相关文件 */</span><br><span class="line">	ret = early_event_add_tracer(d_tracer, tr);</span><br><span class="line">	if (ret)</span><br><span class="line">		return ret;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_MODULES</span><br><span class="line">	ret = register_module_notifier(&amp;trace_module_nb);</span><br><span class="line">	if (ret)</span><br><span class="line">		pr_warn(&quot;Failed to register trace events module notifier\n&quot;);</span><br><span class="line">#endif</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">static __init int</span><br><span class="line">early_event_add_tracer(struct dentry *parent, struct trace_array *tr)</span><br><span class="line">&#123;</span><br><span class="line">	int ret;</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;event_mutex);</span><br><span class="line"></span><br><span class="line">    /* (5.1) 创建相关文件：</span><br><span class="line">        &quot;set_event&quot;、&quot;set_event_pid&quot;、&quot;events/&quot;、&quot;events/header_page&quot;、&quot;events/header_event&quot;、&quot;events/enable&quot;</span><br><span class="line">     */</span><br><span class="line">	ret = create_event_toplevel_files(parent, tr);</span><br><span class="line">	if (ret)</span><br><span class="line">		goto out_unlock;</span><br><span class="line"></span><br><span class="line">    down_write(&amp;trace_event_sem);</span><br><span class="line">    /* (5.2) 根据early创建的trace_event_file，</span><br><span class="line">        逐个在&quot;events/&quot;文件夹中创建对应的&quot;subsystem&quot;和&quot;event&quot;文件夹 </span><br><span class="line">     */</span><br><span class="line">	__trace_early_add_event_dirs(tr);</span><br><span class="line">	up_write(&amp;trace_event_sem);</span><br><span class="line"></span><br><span class="line"> out_unlock:</span><br><span class="line">	mutex_unlock(&amp;event_mutex);</span><br><span class="line"></span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">||→</span><br><span class="line"></span><br><span class="line">static __init void</span><br><span class="line">__trace_early_add_event_dirs(struct trace_array *tr)</span><br><span class="line">&#123;</span><br><span class="line">	struct trace_event_file *file;</span><br><span class="line">	int ret;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	list_for_each_entry(file, &amp;tr-&gt;events, list) &#123;</span><br><span class="line">		ret = event_create_dir(tr-&gt;event_dir, file);</span><br><span class="line">		if (ret &lt; 0)</span><br><span class="line">			pr_warn(&quot;Could not create directory for event %s\n&quot;,</span><br><span class="line">				trace_event_name(file-&gt;event_call));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-5、event-enable"><a href="#1-5、event-enable" class="headerlink" title="1.5、event enable"></a>1.5、event enable</h2><p>在trace初始化以后，tracepoint的桩函数和trace_event_call之间并没有建立起联系。只有在event被enable的时候，call-&gt;class-&gt;probe才会被注册成tracepoint的回调函数；同理event被disable时，call-&gt;class-&gt;probe会被从tracepoint的回调函数组中注销。</p>
<p>我们来看看enable的具体过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line">trace_create_file(&quot;enable&quot;, 0644, file-&gt;dir, file,</span><br><span class="line">	 &amp;ftrace_enable_fops);</span><br><span class="line">	 </span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static const struct file_operations ftrace_enable_fops = &#123;</span><br><span class="line">	.open = tracing_open_generic,</span><br><span class="line">	.read = event_enable_read,</span><br><span class="line">	.write = event_enable_write,</span><br><span class="line">	.llseek = default_llseek,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static ssize_t</span><br><span class="line">event_enable_write(struct file *filp, const char __user *ubuf, size_t cnt,</span><br><span class="line">		   loff_t *ppos)</span><br><span class="line">&#123;</span><br><span class="line">	struct trace_event_file *file;</span><br><span class="line">	unsigned long val;</span><br><span class="line">	int ret;</span><br><span class="line"></span><br><span class="line">	ret = kstrtoul_from_user(ubuf, cnt, 10, &amp;val);</span><br><span class="line">	if (ret)</span><br><span class="line">		return ret;</span><br><span class="line"></span><br><span class="line">	ret = tracing_update_buffers();</span><br><span class="line">	if (ret &lt; 0)</span><br><span class="line">		return ret;</span><br><span class="line"></span><br><span class="line">	switch (val) &#123;</span><br><span class="line">	case 0:</span><br><span class="line">	case 1:</span><br><span class="line">		ret = -ENODEV;</span><br><span class="line">		mutex_lock(&amp;event_mutex);</span><br><span class="line">		/* (1) 获得event对应的trace_event_file结构 */</span><br><span class="line">		file = event_file_data(filp);</span><br><span class="line">		if (likely(file))</span><br><span class="line">		    /* (2) 配置enable/disable */</span><br><span class="line">			ret = ftrace_event_enable_disable(file, val);</span><br><span class="line">		mutex_unlock(&amp;event_mutex);</span><br><span class="line">		break;</span><br><span class="line"></span><br><span class="line">	default:</span><br><span class="line">		return -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	*ppos += cnt;</span><br><span class="line"></span><br><span class="line">	return ret ? ret : cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">static int ftrace_event_enable_disable(struct trace_event_file *file,</span><br><span class="line">				       int enable)</span><br><span class="line">&#123;</span><br><span class="line">	return __ftrace_event_enable_disable(file, enable, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">||→</span><br><span class="line"></span><br><span class="line">static int __ftrace_event_enable_disable(struct trace_event_file *file,</span><br><span class="line">					 int enable, int soft_disable)</span><br><span class="line">&#123;</span><br><span class="line">	struct trace_event_call *call = file-&gt;event_call;</span><br><span class="line">	struct trace_array *tr = file-&gt;tr;</span><br><span class="line">	int ret = 0;</span><br><span class="line">	int disable;</span><br><span class="line"></span><br><span class="line">	switch (enable) &#123;</span><br><span class="line">	case 0:</span><br><span class="line">		/*</span><br><span class="line">		 * When soft_disable is set and enable is cleared, the sm_ref</span><br><span class="line">		 * reference counter is decremented. If it reaches 0, we want</span><br><span class="line">		 * to clear the SOFT_DISABLED flag but leave the event in the</span><br><span class="line">		 * state that it was. That is, if the event was enabled and</span><br><span class="line">		 * SOFT_DISABLED isn&apos;t set, then do nothing. But if SOFT_DISABLED</span><br><span class="line">		 * is set we do not want the event to be enabled before we</span><br><span class="line">		 * clear the bit.</span><br><span class="line">		 *</span><br><span class="line">		 * When soft_disable is not set but the SOFT_MODE flag is,</span><br><span class="line">		 * we do nothing. Do not disable the tracepoint, otherwise</span><br><span class="line">		 * &quot;soft enable&quot;s (clearing the SOFT_DISABLED bit) wont work.</span><br><span class="line">		 */</span><br><span class="line">		if (soft_disable) &#123;</span><br><span class="line">			if (atomic_dec_return(&amp;file-&gt;sm_ref) &gt; 0)</span><br><span class="line">				break;</span><br><span class="line">			disable = file-&gt;flags &amp; EVENT_FILE_FL_SOFT_DISABLED;</span><br><span class="line">			clear_bit(EVENT_FILE_FL_SOFT_MODE_BIT, &amp;file-&gt;flags);</span><br><span class="line">		&#125; else</span><br><span class="line">			disable = !(file-&gt;flags &amp; EVENT_FILE_FL_SOFT_MODE);</span><br><span class="line"></span><br><span class="line">		if (disable &amp;&amp; (file-&gt;flags &amp; EVENT_FILE_FL_ENABLED)) &#123;</span><br><span class="line">			clear_bit(EVENT_FILE_FL_ENABLED_BIT, &amp;file-&gt;flags);</span><br><span class="line">			if (file-&gt;flags &amp; EVENT_FILE_FL_RECORDED_CMD) &#123;</span><br><span class="line">				tracing_stop_cmdline_record();</span><br><span class="line">				clear_bit(EVENT_FILE_FL_RECORDED_CMD_BIT, &amp;file-&gt;flags);</span><br><span class="line">			&#125;</span><br><span class="line">			/* (2.1) 在disable时，调用call-&gt;class-&gt;reg()的UNREGISTER动作 */</span><br><span class="line">			call-&gt;class-&gt;reg(call, TRACE_REG_UNREGISTER, file);</span><br><span class="line">		&#125;</span><br><span class="line">		/* If in SOFT_MODE, just set the SOFT_DISABLE_BIT, else clear it */</span><br><span class="line">		if (file-&gt;flags &amp; EVENT_FILE_FL_SOFT_MODE)</span><br><span class="line">			set_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &amp;file-&gt;flags);</span><br><span class="line">		else</span><br><span class="line">			clear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &amp;file-&gt;flags);</span><br><span class="line">		break;</span><br><span class="line">	case 1:</span><br><span class="line">		/*</span><br><span class="line">		 * When soft_disable is set and enable is set, we want to</span><br><span class="line">		 * register the tracepoint for the event, but leave the event</span><br><span class="line">		 * as is. That means, if the event was already enabled, we do</span><br><span class="line">		 * nothing (but set SOFT_MODE). If the event is disabled, we</span><br><span class="line">		 * set SOFT_DISABLED before enabling the event tracepoint, so</span><br><span class="line">		 * it still seems to be disabled.</span><br><span class="line">		 */</span><br><span class="line">		if (!soft_disable)</span><br><span class="line">			clear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &amp;file-&gt;flags);</span><br><span class="line">		else &#123;</span><br><span class="line">			if (atomic_inc_return(&amp;file-&gt;sm_ref) &gt; 1)</span><br><span class="line">				break;</span><br><span class="line">			set_bit(EVENT_FILE_FL_SOFT_MODE_BIT, &amp;file-&gt;flags);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (!(file-&gt;flags &amp; EVENT_FILE_FL_ENABLED)) &#123;</span><br><span class="line"></span><br><span class="line">			/* Keep the event disabled, when going to SOFT_MODE. */</span><br><span class="line">			if (soft_disable)</span><br><span class="line">				set_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &amp;file-&gt;flags);</span><br><span class="line"></span><br><span class="line">			if (tr-&gt;trace_flags &amp; TRACE_ITER_RECORD_CMD) &#123;</span><br><span class="line">				tracing_start_cmdline_record();</span><br><span class="line">				set_bit(EVENT_FILE_FL_RECORDED_CMD_BIT, &amp;file-&gt;flags);</span><br><span class="line">			&#125;</span><br><span class="line">			/* (2.2) 在enable时，调用call-&gt;class-&gt;reg()的REGISTER动作 */</span><br><span class="line">			ret = call-&gt;class-&gt;reg(call, TRACE_REG_REGISTER, file);</span><br><span class="line">			if (ret) &#123;</span><br><span class="line">				tracing_stop_cmdline_record();</span><br><span class="line">				pr_info(&quot;event trace: Could not enable event &quot;</span><br><span class="line">					&quot;%s\n&quot;, trace_event_name(call));</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			set_bit(EVENT_FILE_FL_ENABLED_BIT, &amp;file-&gt;flags);</span><br><span class="line"></span><br><span class="line">			/* WAS_ENABLED gets set but never cleared. */</span><br><span class="line">			call-&gt;flags |= TRACE_EVENT_FL_WAS_ENABLED;</span><br><span class="line">		&#125;</span><br><span class="line">		break;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据“include/trace/trace_event.h”中event_class_##call的定义，call-&gt;class-&gt;reg()最后调用到trace_event_reg()：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">int trace_event_reg(struct trace_event_call *call,</span><br><span class="line">		    enum trace_reg type, void *data)</span><br><span class="line">&#123;</span><br><span class="line">	struct trace_event_file *file = data;</span><br><span class="line"></span><br><span class="line">	WARN_ON(!(call-&gt;flags &amp; TRACE_EVENT_FL_TRACEPOINT));</span><br><span class="line">	switch (type) &#123;</span><br><span class="line">	</span><br><span class="line">	/* (2.2.1) 把call-&gt;class-&gt;probe()注册成call-&gt;tp的回调函数 */</span><br><span class="line">	case TRACE_REG_REGISTER:</span><br><span class="line">		return tracepoint_probe_register(call-&gt;tp,</span><br><span class="line">						 call-&gt;class-&gt;probe,</span><br><span class="line">						 file)</span><br><span class="line">	</span><br><span class="line">	/* (2.1.1) 把call-&gt;class-&gt;probe()从call-&gt;tp的回调函数组中注销 */</span><br><span class="line">	case TRACE_REG_UNREGISTER:</span><br><span class="line">		tracepoint_probe_unregister(call-&gt;tp,</span><br><span class="line">					    call-&gt;class-&gt;probe,</span><br><span class="line">					    file);</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_PERF_EVENTS</span><br><span class="line">	case TRACE_REG_PERF_REGISTER:</span><br><span class="line">		return tracepoint_probe_register(call-&gt;tp,</span><br><span class="line">						 call-&gt;class-&gt;perf_probe,</span><br><span class="line">						 call);</span><br><span class="line">	case TRACE_REG_PERF_UNREGISTER:</span><br><span class="line">		tracepoint_probe_unregister(call-&gt;tp,</span><br><span class="line">					    call-&gt;class-&gt;perf_probe,</span><br><span class="line">					    call);</span><br><span class="line">		return 0;</span><br><span class="line">	case TRACE_REG_PERF_OPEN:</span><br><span class="line">	case TRACE_REG_PERF_CLOSE:</span><br><span class="line">	case TRACE_REG_PERF_ADD:</span><br><span class="line">	case TRACE_REG_PERF_DEL:</span><br><span class="line">		return 0;</span><br><span class="line">#endif</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-6、”soft-disable”模式"><a href="#1-6、”soft-disable”模式" class="headerlink" title="1.6、”soft disable”模式"></a>1.6、”soft disable”模式</h2><p>在enable/disable trace event的时候，常规模式enable/disable会注册/注销tracepoint回调函数，除此之外还有一种”soft disable”模式。在这种模式下，tracepoint的回调函数被注册，回调函数在event被命中的时候会被调用；但是因为处于”soft disable”模式，会做以下处理：</p>
<ul>
<li>只会处理trigger/condition trigger命令；</li>
<li>不会记录trace数据；</li>
<li>同时也不会判断filter；</li>
</ul>
<p>这种模式就是专门给trigger设计的，应用场景有两处：</p>
<ul>
<li>如果本event配置了trigger命令，把本event配置成”soft disable”模式。这样不管本event有没有enable，trigger命令都会被触发；</li>
<li>如果配置了”enable_event”/“disable_event” trigger命令，在trigger的时候enable/disable目标event，在trigger注册的时候就把目标event设置成”soft”模式，trigger的时候设置目标event在”soft”模式下enable/disable。这样做的目的应该还是因为这样做开销比较小，因为常规完整模式的enable/disable event路径太长。</li>
</ul>
<p>判断是否处于”soft disable”模式只看trace_event_file-&gt;flags中的EVENT_FILE_FL_SOFT_DISABLED_BIT，EVENT_FILE_FL_SOFT_MODE_BIT起辅助作用。”soft disable”模式和普通模式可以共存。</p>
<p>关键函数是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static int __ftrace_event_enable_disable(struct trace_event_file *file,</span><br><span class="line">					 int enable, int soft_disable)</span><br></pre></td></tr></table></figure>
<table border="1"><br><caption> “soft disable” mode </caption><br><br><tr><br><th style="width: 200px;">Mode</th><br><th style="width: 200px;">Action</th><br><th style="width: 600px;">Description</th><br></tr><br><br><br><tr><br><td rowspan="2"> soft disable </td><br><td> enable </td><br><td><br><pre><br><strong>ftrace_event_enable_disable(file,1,1)<br>{<br>    第一次设置：<br>        EVENT_FILE_FL_SOFT_MODE_BIT=1<br>        EVENT_FILE_FL_SOFT_DISABLED_BIT=1<br>        file-&gt;sm_ref++<br><br>    第2-n次设置：<br>        file-&gt;sm_ref++<br><br>    if not reg:<br>        call-&gt;class-&gt;reg()<br>}<br></strong></pre><br></td><br></tr><br><br><tr><br><td> disable </td><br><td><br><pre>
ftrace_event_enable_disable(file,0,1)<br>{<br>    if file-&gt;sm_ref– &gt; 0：<br>        return<br>    else // file-&gt;sm_ref == 0<br>        EVENT_FILE_FL_SOFT_MODE_BIT=0<br>        EVENT_FILE_FL_SOFT_DISABLED_BIT=0<br><br>        if reg:<br>            call-&gt;class-&gt;unreg()<br>}<br></pre><br></td><br></tr><br><br><tr><br><td rowspan="2"> normal </td><br><td> enable </td><br><td><br><pre><br><strong>ftrace_event_enable_disable(file,1,0)<br>{<br>    if not reg:<br>        call-&gt;class-&gt;reg()<br>}<br></strong></pre><br></td><br></tr><br><br><tr><br><td> disable </td><br><td><br><pre>
ftrace_event_enable_disable(file,0,0)<br>{<br>    if reg:<br>        call-&gt;class-&gt;unreg()<br>}<br></pre><br></td><br></tr><br><br></table>

<p>z注意：以上只是”soft disable”模式和”normal”模式单独使用时的场景。如果交错使用还有相互恢复、覆盖的逻辑，大家可以查看__ftrace_event_enable_disable()内部具体代码实现。</p>
<h1 id="2、数据存入"><a href="#2、数据存入" class="headerlink" title="2、数据存入"></a>2、数据存入</h1><p>从event enable一节可以看到，系统会把把call-&gt;class-&gt;probe()注册成tracepoint的回调函数，所以当tracepoint被命中call-&gt;class-&gt;probe()就会被调用。call-&gt;class-&gt;probe()负责了把trace数据存入ringbuffer的工作。</p>
<p>根据“include/trace/trace_event.h”中event_class_##call的定义，call-&gt;class-&gt;probe()最后调用到trace_event_raw_event_##call()：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">static notrace void							\</span><br><span class="line">trace_event_raw_event_##call(void *__data, proto)			\</span><br><span class="line">&#123;									\</span><br><span class="line">	struct trace_event_file *trace_file = __data;			\</span><br><span class="line">	struct trace_event_data_offsets_##call __maybe_unused __data_offsets;\</span><br><span class="line">	struct trace_event_buffer fbuffer;				\</span><br><span class="line">	struct trace_event_raw_##call *entry;				\</span><br><span class="line">	int __data_size;						\</span><br><span class="line">									\</span><br><span class="line">    /* (1) 如果没有condition trigger，执行以下事务：</span><br><span class="line">        1、执行无条件调用的trigger</span><br><span class="line">        2、如果处在SOFT_DISABLE模式，直接返回</span><br><span class="line">        3、查看PID_Filter情况，如果被过滤直接返回</span><br><span class="line">     */</span><br><span class="line">	if (trace_trigger_soft_disabled(trace_file))			\</span><br><span class="line">		return;							\</span><br><span class="line">									\</span><br><span class="line">    </span><br><span class="line">    /* (2) 计算entry中动态数据的长度 */</span><br><span class="line">	__data_size = trace_event_get_offsets_##call(&amp;__data_offsets, args); \</span><br><span class="line">									\</span><br><span class="line">    /* (3) 从ringbuffer中分配整个entry的空间，</span><br><span class="line">        并且给entry中的comm字段赋值：</span><br><span class="line">        entry-&gt;type = event_call-&gt;event.type; // event的id</span><br><span class="line">        entry-&gt;preempt_count = pc &amp; 0xff; // 抢占计数</span><br><span class="line">        entry-&gt;pid= (tsk) ? tsk-&gt;pid : 0; //当前进程pid</span><br><span class="line">        entry-&gt;flags =      // 中断是否disable、是否在HARDIRQ、是否在SOFTIRQ、need_resched、preempt_need_resched</span><br><span class="line">        #ifdef CONFIG_TRACE_IRQFLAGS_SUPPORT</span><br><span class="line">        		(irqs_disabled_flags(flags) ? TRACE_FLAG_IRQS_OFF : 0) |</span><br><span class="line">        #else</span><br><span class="line">        		TRACE_FLAG_IRQS_NOSUPPORT |</span><br><span class="line">        #endif</span><br><span class="line">        		((pc &amp; HARDIRQ_MASK) ? TRACE_FLAG_HARDIRQ : 0) |</span><br><span class="line">        		((pc &amp; SOFTIRQ_OFFSET) ? TRACE_FLAG_SOFTIRQ : 0) |</span><br><span class="line">        		(tif_need_resched() ? TRACE_FLAG_NEED_RESCHED : 0) |</span><br><span class="line">        		(test_preempt_need_resched() ? TRACE_FLAG_PREEMPT_RESCHED : 0);</span><br><span class="line">     */</span><br><span class="line">	entry = trace_event_buffer_reserve(&amp;fbuffer, trace_file,	\</span><br><span class="line">				 sizeof(*entry) + __data_size);		\</span><br><span class="line">									\</span><br><span class="line">	if (!entry)							\</span><br><span class="line">		return;							\</span><br><span class="line">									\</span><br><span class="line">	tstruct								\</span><br><span class="line">									\</span><br><span class="line">    /* (4) 写入用户的trace数据</span><br><span class="line">        给entry中自定义的字段赋值 </span><br><span class="line">     */</span><br><span class="line">	&#123; assign; &#125;							\</span><br><span class="line">									\</span><br><span class="line">    /* (5) 向ringbuffer中提交entry </span><br><span class="line">        或者根据filter丢弃entry</span><br><span class="line">        无论提交还是丢弃，判断执行condition trigger</span><br><span class="line">     */</span><br><span class="line">	trace_event_buffer_commit(&amp;fbuffer,				\</span><br><span class="line">				  sizeof(*entry) + __data_size);	\</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-1、数据格式"><a href="#2-1、数据格式" class="headerlink" title="2.1、数据格式"></a>2.1、数据格式</h2><p><img src="/images/ftrace_trace_event/entry_format.png" alt="image"></p>
<p>我们可以看到，我们从ringbuffer从分配一段空间给event使用以后，除了保留给用户保存自己trace信息的空间，已经包含如下公共信息：</p>
<table border="1"><br><caption> entry format </caption><br><br><tr><br><th style="width: 200px;">Field</th><br><th style="width: 600px;">Description</th><br></tr><br><br><br><tr><br><td> time_stamp </td><br><td><br>entry分配时候的时间戳。<br></td><br></tr><br><br><tr><br><td> type </td><br><td><br>trace_event对应的id，在读取数据时，会根据type字段反向查找到对应的trace_event数据结构。<br></td><br></tr><br><br><tr><br><td> flags </td><br><td><br><pre><br> =<br>#ifdef CONFIG_TRACE_IRQFLAGS_SUPPORT<br>        (irqs_disabled_flags(flags) ? TRACE_FLAG_IRQS_OFF : 0) |<br>#else<br>        TRACE_FLAG_IRQS_NOSUPPORT |<br>#endif<br>        ((pc &amp; HARDIRQ_MASK) ? TRACE_FLAG_HARDIRQ : 0) |<br>        ((pc &amp; SOFTIRQ_OFFSET) ? TRACE_FLAG_SOFTIRQ : 0) |<br>        (tif_need_resched() ? TRACE_FLAG_NEED_RESCHED : 0) |<br>        (test_preempt_need_resched() ? TRACE_FLAG_PREEMPT_RESCHED : 0);<br></pre><br>中断是否disable、是否在HARDIRQ、是否在SOFTIRQ、need_resched、preempt_need_resched<br></td><br></tr><br><br><tr><br><td> preempt_count </td><br><td><br><pre><br>= pc &amp; 0xff;<br></pre><br>抢占计数<br></td><br></tr><br><br><tr><br><td> pid </td><br><td><br><pre><br>= (tsk) ? tsk-&gt;pid : 0;<br></pre><br>当前的进程pid<br></td><br></tr><br><br></table>

<h2 id="2-2、trigger-command"><a href="#2-2、trigger-command" class="headerlink" title="2.2、trigger command"></a>2.2、trigger command</h2><p>1、初始化时，注册trigger command：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">start_kernel() -&gt; trace_init() -&gt; trace_event_init() -&gt; event_trace_enable() -&gt; register_trigger_cmds()</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">__init int register_trigger_cmds(void)</span><br><span class="line">&#123;</span><br><span class="line">	register_trigger_traceon_traceoff_cmds();</span><br><span class="line">	register_trigger_snapshot_cmd();</span><br><span class="line">	register_trigger_stacktrace_cmd();</span><br><span class="line">	register_trigger_enable_disable_cmds();</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static __init int register_trigger_traceon_traceoff_cmds(void)</span><br><span class="line">&#123;</span><br><span class="line">	int ret;</span><br><span class="line"></span><br><span class="line">	ret = register_event_command(&amp;trigger_traceon_cmd);</span><br><span class="line">	if (WARN_ON(ret &lt; 0))</span><br><span class="line">		return ret;</span><br><span class="line">	ret = register_event_command(&amp;trigger_traceoff_cmd);</span><br><span class="line">	if (WARN_ON(ret &lt; 0))</span><br><span class="line">		unregister_trigger_traceon_traceoff_cmds();</span><br><span class="line"></span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static __init int register_event_command(struct event_command *cmd)</span><br><span class="line">&#123;</span><br><span class="line">	struct event_command *p;</span><br><span class="line">	int ret = 0;</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;trigger_cmd_mutex);</span><br><span class="line">	/* 注册只是简单的将command加入到trigger_commands链表当中 */</span><br><span class="line">	list_for_each_entry(p, &amp;trigger_commands, list) &#123;</span><br><span class="line">		if (strcmp(cmd-&gt;name, p-&gt;name) == 0) &#123;</span><br><span class="line">			ret = -EBUSY;</span><br><span class="line">			goto out_unlock;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	list_add(&amp;cmd-&gt;list, &amp;trigger_commands);</span><br><span class="line"> out_unlock:</span><br><span class="line">	mutex_unlock(&amp;trigger_cmd_mutex);</span><br><span class="line"></span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以trigger_enable_cmd、trigger_disable_cmd为例，对应重要的数据结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">static struct event_command trigger_enable_cmd = &#123;</span><br><span class="line">	.name			= ENABLE_EVENT_STR,</span><br><span class="line">	.trigger_type		= ETT_EVENT_ENABLE,</span><br><span class="line">	.func			= event_enable_trigger_func,</span><br><span class="line">	.reg			= event_enable_register_trigger,</span><br><span class="line">	.unreg			= event_enable_unregister_trigger,</span><br><span class="line">	.get_trigger_ops	= event_enable_get_trigger_ops,</span><br><span class="line">	.set_filter		= set_trigger_filter,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct event_command trigger_disable_cmd = &#123;</span><br><span class="line">	.name			= DISABLE_EVENT_STR,</span><br><span class="line">	.trigger_type		= ETT_EVENT_ENABLE,</span><br><span class="line">	.func			= event_enable_trigger_func,</span><br><span class="line">	.reg			= event_enable_register_trigger,</span><br><span class="line">	.unreg			= event_enable_unregister_trigger,</span><br><span class="line">	.get_trigger_ops	= event_enable_get_trigger_ops,</span><br><span class="line">	.set_filter		= set_trigger_filter,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct event_trigger_ops *</span><br><span class="line">event_enable_get_trigger_ops(char *cmd, char *param)</span><br><span class="line">&#123;</span><br><span class="line">	struct event_trigger_ops *ops;</span><br><span class="line">	bool enable;</span><br><span class="line"></span><br><span class="line">	enable = strcmp(cmd, ENABLE_EVENT_STR) == 0;</span><br><span class="line"></span><br><span class="line">	if (enable)</span><br><span class="line">		ops = param ? &amp;event_enable_count_trigger_ops :</span><br><span class="line">			&amp;event_enable_trigger_ops;</span><br><span class="line">	else</span><br><span class="line">		ops = param ? &amp;event_disable_count_trigger_ops :</span><br><span class="line">			&amp;event_disable_trigger_ops;</span><br><span class="line"></span><br><span class="line">	return ops;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static struct event_trigger_ops event_enable_trigger_ops = &#123;</span><br><span class="line">	.func			= event_enable_trigger,</span><br><span class="line">	.print			= event_enable_trigger_print,</span><br><span class="line">	.init			= event_trigger_init,</span><br><span class="line">	.free			= event_enable_trigger_free,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct event_trigger_ops event_enable_count_trigger_ops = &#123;</span><br><span class="line">	.func			= event_enable_count_trigger,</span><br><span class="line">	.print			= event_enable_trigger_print,</span><br><span class="line">	.init			= event_trigger_init,</span><br><span class="line">	.free			= event_enable_trigger_free,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct event_trigger_ops event_disable_trigger_ops = &#123;</span><br><span class="line">	.func			= event_enable_trigger,</span><br><span class="line">	.print			= event_enable_trigger_print,</span><br><span class="line">	.init			= event_trigger_init,</span><br><span class="line">	.free			= event_enable_trigger_free,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct event_trigger_ops event_disable_count_trigger_ops = &#123;</span><br><span class="line">	.func			= event_enable_count_trigger,</span><br><span class="line">	.print			= event_enable_trigger_print,</span><br><span class="line">	.init			= event_trigger_init,</span><br><span class="line">	.free			= event_enable_trigger_free,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>2、通过“tracing/events/xxxsubsystem/xxxevent/trigger”文件来配置trigger：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">trace_create_file(&quot;trigger&quot;, 0644, file-&gt;dir, file,</span><br><span class="line">	  &amp;event_trigger_fops);</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">const struct file_operations event_trigger_fops = &#123;</span><br><span class="line">	.open = event_trigger_open,</span><br><span class="line">	.read = seq_read,</span><br><span class="line">	.write = event_trigger_write,</span><br><span class="line">	.llseek = tracing_lseek,</span><br><span class="line">	.release = event_trigger_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static ssize_t</span><br><span class="line">event_trigger_write(struct file *filp, const char __user *ubuf,</span><br><span class="line">		    size_t cnt, loff_t *ppos)</span><br><span class="line">&#123;</span><br><span class="line">	return event_trigger_regex_write(filp, ubuf, cnt, ppos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static ssize_t event_trigger_regex_write(struct file *file,</span><br><span class="line">					 const char __user *ubuf,</span><br><span class="line">					 size_t cnt, loff_t *ppos)</span><br><span class="line">&#123;</span><br><span class="line">	struct trace_event_file *event_file;</span><br><span class="line">	ssize_t ret;</span><br><span class="line">	char *buf;</span><br><span class="line"></span><br><span class="line">	if (!cnt)</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">	if (cnt &gt;= PAGE_SIZE)</span><br><span class="line">		return -EINVAL;</span><br><span class="line"></span><br><span class="line">	buf = (char *)__get_free_page(GFP_TEMPORARY);</span><br><span class="line">	if (!buf)</span><br><span class="line">		return -ENOMEM;</span><br><span class="line"></span><br><span class="line">	if (copy_from_user(buf, ubuf, cnt)) &#123;</span><br><span class="line">		free_page((unsigned long)buf);</span><br><span class="line">		return -EFAULT;</span><br><span class="line">	&#125;</span><br><span class="line">	buf[cnt] = &apos;\0&apos;;</span><br><span class="line">	strim(buf);</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;event_mutex);</span><br><span class="line">	/* event对应的trace_event_file */</span><br><span class="line">	event_file = event_file_data(file);</span><br><span class="line">	if (unlikely(!event_file)) &#123;</span><br><span class="line">		mutex_unlock(&amp;event_mutex);</span><br><span class="line">		free_page((unsigned long)buf);</span><br><span class="line">		return -ENODEV;</span><br><span class="line">	&#125;</span><br><span class="line">	/* 解析trigger文件配置的规则 */</span><br><span class="line">	ret = trigger_process_regex(event_file, buf);</span><br><span class="line">	mutex_unlock(&amp;event_mutex);</span><br><span class="line"></span><br><span class="line">	free_page((unsigned long)buf);</span><br><span class="line">	if (ret &lt; 0)</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">	*ppos += cnt;</span><br><span class="line">	ret = cnt;</span><br><span class="line"> out:</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static int trigger_process_regex(struct trace_event_file *file, char *buff)</span><br><span class="line">&#123;</span><br><span class="line">	char *command, *next = buff;</span><br><span class="line">	struct event_command *p;</span><br><span class="line">	int ret = -EINVAL;</span><br><span class="line"></span><br><span class="line">	command = strsep(&amp;next, &quot;: \t&quot;);</span><br><span class="line">	command = (command[0] != &apos;!&apos;) ? command : command + 1;</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;trigger_cmd_mutex);</span><br><span class="line">	/* 根据command name，在trigger_commands链表中查找初始化时注册的event_command */</span><br><span class="line">	list_for_each_entry(p, &amp;trigger_commands, list) &#123;</span><br><span class="line">		if (strcmp(p-&gt;name, command) == 0) &#123;</span><br><span class="line">		    /* 调用event_command的func()函数来处理配置字符串 */</span><br><span class="line">			ret = p-&gt;func(p, file, buff, command, next);</span><br><span class="line">			goto out_unlock;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> out_unlock:</span><br><span class="line">	mutex_unlock(&amp;trigger_cmd_mutex);</span><br><span class="line"></span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以”enable_event”命令为例，我们继续分析p-&gt;func()的调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line">static struct event_command trigger_enable_cmd = &#123;</span><br><span class="line">	.name			= ENABLE_EVENT_STR,</span><br><span class="line">	.trigger_type		= ETT_EVENT_ENABLE,</span><br><span class="line">	.func			= event_enable_trigger_func,</span><br><span class="line">	.reg			= event_enable_register_trigger,</span><br><span class="line">	.unreg			= event_enable_unregister_trigger,</span><br><span class="line">	.get_trigger_ops	= event_enable_get_trigger_ops,</span><br><span class="line">	.set_filter		= set_trigger_filter,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static int</span><br><span class="line">event_enable_trigger_func(struct event_command *cmd_ops,</span><br><span class="line">			  struct trace_event_file *file,</span><br><span class="line">			  char *glob, char *cmd, char *param)</span><br><span class="line">&#123;</span><br><span class="line">	struct trace_event_file *event_enable_file;</span><br><span class="line">	struct enable_trigger_data *enable_data;</span><br><span class="line">	struct event_trigger_data *trigger_data;</span><br><span class="line">	struct event_trigger_ops *trigger_ops;</span><br><span class="line">	struct trace_array *tr = file-&gt;tr;</span><br><span class="line">	const char *system;</span><br><span class="line">	const char *event;</span><br><span class="line">	char *trigger;</span><br><span class="line">	char *number;</span><br><span class="line">	bool enable;</span><br><span class="line">	int ret;</span><br><span class="line"></span><br><span class="line">	if (!param)</span><br><span class="line">		return -EINVAL;</span><br><span class="line"></span><br><span class="line">	/* separate the trigger from the filter (s:e:n [if filter]) */</span><br><span class="line">	/* (1) 从&quot;&lt;system&gt;:&lt;event&gt;[:count] [if filter]&quot;中分离出&quot;&lt;system&gt;:&lt;event&gt;[:count]&quot; */</span><br><span class="line">	trigger = strsep(&amp;param, &quot; \t&quot;);</span><br><span class="line">	if (!trigger)</span><br><span class="line">		return -EINVAL;</span><br><span class="line"></span><br><span class="line">    /* (1.1) 分离出&quot;&lt;system&gt;&quot; */</span><br><span class="line">	system = strsep(&amp;trigger, &quot;:&quot;);</span><br><span class="line">	if (!trigger)</span><br><span class="line">		return -EINVAL;</span><br><span class="line"></span><br><span class="line">    /* (1.2) 分离出&quot;&lt;event&gt;&quot; */</span><br><span class="line">	event = strsep(&amp;trigger, &quot;:&quot;);</span><br><span class="line"></span><br><span class="line">	ret = -EINVAL;</span><br><span class="line">	/* (1.3) 根据目标system、event的name，找到对应的trace_event_file */</span><br><span class="line">	event_enable_file = find_event_file(tr, system, event);</span><br><span class="line">	if (!event_enable_file)</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">    /* (1.4) &quot;enable_event&quot; or &quot;disable_event&quot; ? */</span><br><span class="line">	enable = strcmp(cmd, ENABLE_EVENT_STR) == 0;</span><br><span class="line"></span><br><span class="line">    /* (2) 根据是否包含&quot;[:count]&quot;字段来给trigger_ops赋值：</span><br><span class="line">        = event_enable_count_trigger_ops //有count</span><br><span class="line">        = event_enable_trigger_ops // 无count</span><br><span class="line">     */</span><br><span class="line">	trigger_ops = cmd_ops-&gt;get_trigger_ops(cmd, trigger);</span><br><span class="line"></span><br><span class="line">	ret = -ENOMEM;</span><br><span class="line">	trigger_data = kzalloc(sizeof(*trigger_data), GFP_KERNEL);</span><br><span class="line">	if (!trigger_data)</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">	enable_data = kzalloc(sizeof(*enable_data), GFP_KERNEL);</span><br><span class="line">	if (!enable_data) &#123;</span><br><span class="line">		kfree(trigger_data);</span><br><span class="line">		goto out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (3) 准备本event的data */</span><br><span class="line">	trigger_data-&gt;count = -1;</span><br><span class="line">	trigger_data-&gt;ops = trigger_ops;</span><br><span class="line">	trigger_data-&gt;cmd_ops = cmd_ops;</span><br><span class="line">	INIT_LIST_HEAD(&amp;trigger_data-&gt;list);</span><br><span class="line">	RCU_INIT_POINTER(trigger_data-&gt;filter, NULL);</span><br><span class="line"></span><br><span class="line">    /* (3.1) 准备目标event的data */</span><br><span class="line">	enable_data-&gt;enable = enable;</span><br><span class="line">	enable_data-&gt;file = event_enable_file;</span><br><span class="line">	trigger_data-&gt;private_data = enable_data;</span><br><span class="line"></span><br><span class="line">    /* (4) 如果命令字符串首字符是&apos;!&apos;，说明是unregister trigger */</span><br><span class="line">	if (glob[0] == &apos;!&apos;) &#123;</span><br><span class="line">	    /* (4.1) 注销trigger */</span><br><span class="line">		cmd_ops-&gt;unreg(glob+1, trigger_ops, trigger_data, file);</span><br><span class="line">		kfree(trigger_data);</span><br><span class="line">		kfree(enable_data);</span><br><span class="line">		ret = 0;</span><br><span class="line">		goto out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (3.2) 如果有&quot;[:count]&quot;字段，赋值给trigger_data-&gt;count */</span><br><span class="line">	if (trigger) &#123;</span><br><span class="line">		number = strsep(&amp;trigger, &quot;:&quot;);</span><br><span class="line"></span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">		if (!strlen(number))</span><br><span class="line">			goto out_free;</span><br><span class="line"></span><br><span class="line">		/*</span><br><span class="line">		 * We use the callback data field (which is a pointer)</span><br><span class="line">		 * as our counter.</span><br><span class="line">		 */</span><br><span class="line">		ret = kstrtoul(number, 0, &amp;trigger_data-&gt;count);</span><br><span class="line">		if (ret)</span><br><span class="line">			goto out_free;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (!param) /* if param is non-empty, it&apos;s supposed to be a filter */</span><br><span class="line">		goto out_reg;</span><br><span class="line"></span><br><span class="line">	if (!cmd_ops-&gt;set_filter)</span><br><span class="line">		goto out_reg;</span><br><span class="line"></span><br><span class="line">    /* (5) 如果有“[if filter]”字段，配置filter */</span><br><span class="line">	ret = cmd_ops-&gt;set_filter(param, trigger_data, file);</span><br><span class="line">	if (ret &lt; 0)</span><br><span class="line">		goto out_free;</span><br><span class="line"></span><br><span class="line"> out_reg:</span><br><span class="line">	/* Don&apos;t let event modules unload while probe registered */</span><br><span class="line">	ret = try_module_get(event_enable_file-&gt;event_call-&gt;mod);</span><br><span class="line">	if (!ret) &#123;</span><br><span class="line">		ret = -EBUSY;</span><br><span class="line">		goto out_free;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (6) 首先把目标event设置为“soft”+“disable”模式 */</span><br><span class="line">	ret = trace_event_enable_disable(event_enable_file, 1, 1);</span><br><span class="line">	if (ret &lt; 0)</span><br><span class="line">		goto out_put;</span><br><span class="line">	/* (7) 注册trigger */</span><br><span class="line">	ret = cmd_ops-&gt;reg(glob, trigger_ops, trigger_data, file);</span><br><span class="line">	/*</span><br><span class="line">	 * The above returns on success the # of functions enabled,</span><br><span class="line">	 * but if it didn&apos;t find any functions it returns zero.</span><br><span class="line">	 * Consider no functions a failure too.</span><br><span class="line">	 */</span><br><span class="line">	if (!ret) &#123;</span><br><span class="line">		ret = -ENOENT;</span><br><span class="line">		goto out_disable;</span><br><span class="line">	&#125; else if (ret &lt; 0)</span><br><span class="line">		goto out_disable;</span><br><span class="line">	/* Just return zero, not the number of enabled functions */</span><br><span class="line">	ret = 0;</span><br><span class="line"> out:</span><br><span class="line">	return ret;</span><br><span class="line"></span><br><span class="line"> out_disable:</span><br><span class="line">	trace_event_enable_disable(event_enable_file, 0, 1);</span><br><span class="line"> out_put:</span><br><span class="line">	module_put(event_enable_file-&gt;event_call-&gt;mod);</span><br><span class="line"> out_free:</span><br><span class="line">	if (cmd_ops-&gt;set_filter)</span><br><span class="line">		cmd_ops-&gt;set_filter(NULL, trigger_data, NULL);</span><br><span class="line">	kfree(trigger_data);</span><br><span class="line">	kfree(enable_data);</span><br><span class="line">	goto out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，设置filter的具体操作如下(trigger_data把condition trigger的filter条件和trigger操作联结在了一起)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">static int set_trigger_filter(char *filter_str,</span><br><span class="line">			      struct event_trigger_data *trigger_data,</span><br><span class="line">			      struct trace_event_file *file)</span><br><span class="line">&#123;</span><br><span class="line">	struct event_trigger_data *data = trigger_data;</span><br><span class="line">	struct event_filter *filter = NULL, *tmp;</span><br><span class="line">	int ret = -EINVAL;</span><br><span class="line">	char *s;</span><br><span class="line"></span><br><span class="line">	if (!filter_str) /* clear the current filter */</span><br><span class="line">		goto assign;</span><br><span class="line"></span><br><span class="line">	s = strsep(&amp;filter_str, &quot; \t&quot;);</span><br><span class="line"></span><br><span class="line">	if (!strlen(s) || strcmp(s, &quot;if&quot;) != 0)</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">	if (!filter_str)</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">	/* The filter is for the &apos;trigger&apos; event, not the triggered event */</span><br><span class="line">	/* (5.1) 对本event创建filter */</span><br><span class="line">	ret = create_event_filter(file-&gt;event_call, filter_str, false, &amp;filter);</span><br><span class="line">	if (ret)</span><br><span class="line">		goto out;</span><br><span class="line"> assign:</span><br><span class="line">	tmp = rcu_access_pointer(data-&gt;filter);</span><br><span class="line"></span><br><span class="line">    /* (5.2) 创建好的filter赋值给trigger_data-&gt;filter */</span><br><span class="line">	rcu_assign_pointer(data-&gt;filter, filter);</span><br><span class="line"></span><br><span class="line">	if (tmp) &#123;</span><br><span class="line">		/* Make sure the call is done with the filter */</span><br><span class="line">		synchronize_sched();</span><br><span class="line">		free_event_filter(tmp);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	kfree(data-&gt;filter_str);</span><br><span class="line">	data-&gt;filter_str = NULL;</span><br><span class="line"></span><br><span class="line">    /* (5.3) 使用trigger_data-&gt;filter_str保存原有的filter字符串 */</span><br><span class="line">	if (filter_str) &#123;</span><br><span class="line">		data-&gt;filter_str = kstrdup(filter_str, GFP_KERNEL);</span><br><span class="line">		if (!data-&gt;filter_str) &#123;</span><br><span class="line">			free_event_filter(rcu_access_pointer(data-&gt;filter));</span><br><span class="line">			data-&gt;filter = NULL;</span><br><span class="line">			ret = -ENOMEM;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> out:</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">int create_event_filter(struct trace_event_call *call,</span><br><span class="line">			char *filter_str, bool set_str,</span><br><span class="line">			struct event_filter **filterp)</span><br><span class="line">&#123;</span><br><span class="line">    /* 具体的filter的创建我也没看懂，反正就是根据表达式对field和条件进行一系列判断 */</span><br><span class="line">	return create_filter(call, filter_str, set_str, filterp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把目标event设置为“soft disable”模式的具体操作如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ret = trace_event_enable_disable(event_enable_file, 1, 1);</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">int trace_event_enable_disable(struct trace_event_file *file,</span><br><span class="line">			       int enable, int soft_disable)</span><br><span class="line">&#123;</span><br><span class="line">	return __ftrace_event_enable_disable(file, enable, soft_disable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注册trigger的具体操作如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">static int event_enable_register_trigger(char *glob,</span><br><span class="line">					 struct event_trigger_ops *ops,</span><br><span class="line">					 struct event_trigger_data *data,</span><br><span class="line">					 struct trace_event_file *file)</span><br><span class="line">&#123;</span><br><span class="line">	struct enable_trigger_data *enable_data = data-&gt;private_data;</span><br><span class="line">	struct enable_trigger_data *test_enable_data;</span><br><span class="line">	struct event_trigger_data *test;</span><br><span class="line">	int ret = 0;</span><br><span class="line"></span><br><span class="line">    /* (7.1) 判断目标event是否已经有trigger已经注册 */</span><br><span class="line">	list_for_each_entry_rcu(test, &amp;file-&gt;triggers, list) &#123;</span><br><span class="line">		test_enable_data = test-&gt;private_data;</span><br><span class="line">		if (test_enable_data &amp;&amp;</span><br><span class="line">		    (test_enable_data-&gt;file == enable_data-&gt;file)) &#123;</span><br><span class="line">			ret = -EEXIST;</span><br><span class="line">			goto out;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (7.2) init */</span><br><span class="line">	if (data-&gt;ops-&gt;init) &#123;</span><br><span class="line">		ret = data-&gt;ops-&gt;init(data-&gt;ops, data);</span><br><span class="line">		if (ret &lt; 0)</span><br><span class="line">			goto out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (7.3) 将event_trigger_data加入到file-&gt;triggers链表中 */</span><br><span class="line">	list_add_rcu(&amp;data-&gt;list, &amp;file-&gt;triggers);</span><br><span class="line">	ret++;</span><br><span class="line"></span><br><span class="line">    /* (7.4) 设置本event的EVENT_FILE_FL_TRIGGER_MODE_BIT标志位</span><br><span class="line">        将本event设置成“soft disable”模式</span><br><span class="line">     */</span><br><span class="line">	if (trace_event_trigger_enable_disable(file, 1) &lt; 0) &#123;</span><br><span class="line">		list_del_rcu(&amp;data-&gt;list);</span><br><span class="line">		ret--;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	/* (7.5) 如果有filter trigger，设置EVENT_FILE_FL_TRIGGER_COND_BIT标志位 */</span><br><span class="line">	update_cond_flag(file);</span><br><span class="line">out:</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static int trace_event_trigger_enable_disable(struct trace_event_file *file,</span><br><span class="line">					      int trigger_enable)</span><br><span class="line">&#123;</span><br><span class="line">	int ret = 0;</span><br><span class="line"></span><br><span class="line">	if (trigger_enable) &#123;</span><br><span class="line">		if (atomic_inc_return(&amp;file-&gt;tm_ref) &gt; 1)</span><br><span class="line">			return ret;</span><br><span class="line">		set_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &amp;file-&gt;flags);</span><br><span class="line">		ret = trace_event_enable_disable(file, 1, 1);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		if (atomic_dec_return(&amp;file-&gt;tm_ref) &gt; 0)</span><br><span class="line">			return ret;</span><br><span class="line">		clear_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &amp;file-&gt;flags);</span><br><span class="line">		ret = trace_event_enable_disable(file, 0, 1);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、在trace event被命中时，trigger的工作流程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><span class="line">static notrace void							\</span><br><span class="line">trace_event_raw_event_##call(void *__data, proto)			\</span><br><span class="line">&#123;									\</span><br><span class="line">	struct trace_event_file *trace_file = __data;			\</span><br><span class="line">	struct trace_event_data_offsets_##call __maybe_unused __data_offsets;\</span><br><span class="line">	struct trace_event_buffer fbuffer;				\</span><br><span class="line">	struct trace_event_raw_##call *entry;				\</span><br><span class="line">	int __data_size;						\</span><br><span class="line">									\</span><br><span class="line">    /* (1) 如果没有condition trigger，执行以下事务：</span><br><span class="line">        1、执行无条件调用的trigger</span><br><span class="line">        2、如果处在SOFT_DISABLE模式，直接返回</span><br><span class="line">        3、查看PID_Filter情况，如果被过滤直接返回</span><br><span class="line">     */</span><br><span class="line">	if (trace_trigger_soft_disabled(trace_file))			\</span><br><span class="line">		return;							\</span><br><span class="line">									\</span><br><span class="line">    </span><br><span class="line">    /* (2) 计算entry中动态数据的长度 */</span><br><span class="line">	__data_size = trace_event_get_offsets_##call(&amp;__data_offsets, args); \</span><br><span class="line">									\</span><br><span class="line">    /* (3) 从ringbuffer中分配整个entry的空间，</span><br><span class="line">        并且给entry中的comm字段赋值：</span><br><span class="line">        entry-&gt;type = event_call-&gt;event.type; // event的id</span><br><span class="line">        entry-&gt;preempt_count = pc &amp; 0xff; // 抢占计数</span><br><span class="line">        entry-&gt;pid= (tsk) ? tsk-&gt;pid : 0; //当前进程pid</span><br><span class="line">        entry-&gt;flags =      // 中断是否disable、是否在HARDIRQ、是否在SOFTIRQ、need_resched、preempt_need_resched</span><br><span class="line">        #ifdef CONFIG_TRACE_IRQFLAGS_SUPPORT</span><br><span class="line">        		(irqs_disabled_flags(flags) ? TRACE_FLAG_IRQS_OFF : 0) |</span><br><span class="line">        #else</span><br><span class="line">        		TRACE_FLAG_IRQS_NOSUPPORT |</span><br><span class="line">        #endif</span><br><span class="line">        		((pc &amp; HARDIRQ_MASK) ? TRACE_FLAG_HARDIRQ : 0) |</span><br><span class="line">        		((pc &amp; SOFTIRQ_OFFSET) ? TRACE_FLAG_SOFTIRQ : 0) |</span><br><span class="line">        		(tif_need_resched() ? TRACE_FLAG_NEED_RESCHED : 0) |</span><br><span class="line">        		(test_preempt_need_resched() ? TRACE_FLAG_PREEMPT_RESCHED : 0);</span><br><span class="line">     */</span><br><span class="line">	entry = trace_event_buffer_reserve(&amp;fbuffer, trace_file,	\</span><br><span class="line">				 sizeof(*entry) + __data_size);		\</span><br><span class="line">									\</span><br><span class="line">	if (!entry)							\</span><br><span class="line">		return;							\</span><br><span class="line">									\</span><br><span class="line">	tstruct								\</span><br><span class="line">									\</span><br><span class="line">    /* (4) 写入用户的trace数据</span><br><span class="line">        给entry中自定义的字段赋值 </span><br><span class="line">     */</span><br><span class="line">	&#123; assign; &#125;							\</span><br><span class="line">									\</span><br><span class="line">    /* (5) 向ringbuffer中提交entry </span><br><span class="line">        或者根据filter丢弃entry</span><br><span class="line">        无论提交还是丢弃，判断执行condition trigger</span><br><span class="line">     */</span><br><span class="line">	trace_event_buffer_commit(&amp;fbuffer,				\</span><br><span class="line">				  sizeof(*entry) + __data_size);	\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">static inline bool</span><br><span class="line">trace_trigger_soft_disabled(struct trace_event_file *file)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned long eflags = file-&gt;flags;</span><br><span class="line"></span><br><span class="line">    /* (1.1) 只有没有condition trigger时，做进一步的判断 */</span><br><span class="line">	if (!(eflags &amp; EVENT_FILE_FL_TRIGGER_COND)) &#123;</span><br><span class="line">	    </span><br><span class="line">	    /* (1.1.1) 执行无条件trigger */</span><br><span class="line">		if (eflags &amp; EVENT_FILE_FL_TRIGGER_MODE)</span><br><span class="line">			event_triggers_call(file, NULL);</span><br><span class="line">		</span><br><span class="line">		/* (1.1.2) 如果处在“soft disable”模式， </span><br><span class="line">		    执行完无条件trigger就可以返回了</span><br><span class="line">		 */</span><br><span class="line">		if (eflags &amp; EVENT_FILE_FL_SOFT_DISABLED)</span><br><span class="line">			return true;</span><br><span class="line">			</span><br><span class="line">		/* (1.1.3) 判断当前pid是否被过滤 */</span><br><span class="line">		if (eflags &amp; EVENT_FILE_FL_PID_FILTER)</span><br><span class="line">			return trace_event_ignore_this_pid(file);</span><br><span class="line">	&#125;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">void *trace_event_buffer_reserve(struct trace_event_buffer *fbuffer,</span><br><span class="line">				 struct trace_event_file *trace_file,</span><br><span class="line">				 unsigned long len)</span><br><span class="line">&#123;</span><br><span class="line">	struct trace_event_call *event_call = trace_file-&gt;event_call;</span><br><span class="line"></span><br><span class="line">    /* (3.1) 判断当前pid是否被过滤 */</span><br><span class="line">	if ((trace_file-&gt;flags &amp; EVENT_FILE_FL_PID_FILTER) &amp;&amp;</span><br><span class="line">	    trace_event_ignore_this_pid(trace_file))</span><br><span class="line">		return NULL;</span><br><span class="line"></span><br><span class="line">	local_save_flags(fbuffer-&gt;flags);</span><br><span class="line">	fbuffer-&gt;pc = preempt_count();</span><br><span class="line">	fbuffer-&gt;trace_file = trace_file;</span><br><span class="line"></span><br><span class="line">	fbuffer-&gt;event =</span><br><span class="line">		trace_event_buffer_lock_reserve(&amp;fbuffer-&gt;buffer, trace_file,</span><br><span class="line">						event_call-&gt;event.type, len,</span><br><span class="line">						fbuffer-&gt;flags, fbuffer-&gt;pc);</span><br><span class="line">	if (!fbuffer-&gt;event)</span><br><span class="line">		return NULL;</span><br><span class="line"></span><br><span class="line">	fbuffer-&gt;entry = ring_buffer_event_data(fbuffer-&gt;event);</span><br><span class="line">	return fbuffer-&gt;entry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">void trace_event_buffer_commit(struct trace_event_buffer *fbuffer,</span><br><span class="line">			       unsigned long len)</span><br><span class="line">&#123;</span><br><span class="line">	if (tracepoint_printk)</span><br><span class="line">		output_printk(fbuffer);</span><br><span class="line"></span><br><span class="line">    /* (5.1) */</span><br><span class="line">	event_trigger_unlock_commit(fbuffer-&gt;trace_file, fbuffer-&gt;buffer,</span><br><span class="line">				    fbuffer-&gt;event, fbuffer-&gt;entry,</span><br><span class="line">				    fbuffer-&gt;flags, fbuffer-&gt;pc, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">||→</span><br><span class="line"></span><br><span class="line">static inline void</span><br><span class="line">event_trigger_unlock_commit(struct trace_event_file *file,</span><br><span class="line">			    struct ring_buffer *buffer,</span><br><span class="line">			    struct ring_buffer_event *event,</span><br><span class="line">			    void *entry, unsigned long irq_flags, int pc,</span><br><span class="line">			    unsigned long len)</span><br><span class="line">&#123;</span><br><span class="line">	enum event_trigger_type tt = ETT_NONE;</span><br><span class="line"></span><br><span class="line">    /* (5.1.1) 判断condition trigger是否要被触发和filter是否需要丢弃数据 */</span><br><span class="line">	if (!__event_trigger_test_discard(file, buffer, event, entry, &amp;tt)) &#123;</span><br><span class="line">		if (len)</span><br><span class="line">			stm_log(OST_ENTITY_FTRACE_EVENTS, entry, len);</span><br><span class="line">		</span><br><span class="line">		/* (5.1.2) 如果数据不丢弃，则正常commit */</span><br><span class="line">		trace_buffer_unlock_commit(file-&gt;tr, buffer, event, irq_flags, pc);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (tt)</span><br><span class="line">		event_triggers_post_call(file, tt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|||→</span><br><span class="line"></span><br><span class="line">static inline bool</span><br><span class="line">__event_trigger_test_discard(struct trace_event_file *file,</span><br><span class="line">			     struct ring_buffer *buffer,</span><br><span class="line">			     struct ring_buffer_event *event,</span><br><span class="line">			     void *entry,</span><br><span class="line">			     enum event_trigger_type *tt)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned long eflags = file-&gt;flags;</span><br><span class="line"></span><br><span class="line">    /* (5.1.1.1) 判断condition trigger是否要被触发 */</span><br><span class="line">	if (eflags &amp; EVENT_FILE_FL_TRIGGER_COND)</span><br><span class="line">		*tt = event_triggers_call(file, entry);</span><br><span class="line"></span><br><span class="line">    /* (5.1.1.2) 如果处在“soft disable”模式， </span><br><span class="line">	    执行完condition trigger就可以返回了</span><br><span class="line">	 */</span><br><span class="line">	if (test_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &amp;file-&gt;flags))</span><br><span class="line">		ring_buffer_discard_commit(buffer, event);</span><br><span class="line">	</span><br><span class="line">	/* (5.1.1.3) 判断filter是否需要丢弃数据 */</span><br><span class="line">	else if (!filter_check_discard(file, entry, buffer, event))</span><br><span class="line">		return false;</span><br><span class="line"></span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">||||→</span><br><span class="line"></span><br><span class="line">enum event_trigger_type</span><br><span class="line">event_triggers_call(struct trace_event_file *file, void *rec)</span><br><span class="line">&#123;</span><br><span class="line">	struct event_trigger_data *data;</span><br><span class="line">	enum event_trigger_type tt = ETT_NONE;</span><br><span class="line">	struct event_filter *filter;</span><br><span class="line"></span><br><span class="line">	if (list_empty(&amp;file-&gt;triggers))</span><br><span class="line">		return tt;</span><br><span class="line"></span><br><span class="line">    /* (5.1.1.1.1) 逐个判断event的trigger链表中的trigger是否需要执行 */</span><br><span class="line">	list_for_each_entry_rcu(data, &amp;file-&gt;triggers, list) &#123;</span><br><span class="line">	</span><br><span class="line">	    /* (5.1.1.1.2) 数据为空，执行无条件trigger */</span><br><span class="line">		if (!rec) &#123;</span><br><span class="line">			data-&gt;ops-&gt;func(data);</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		/* (5.1.1.1.3) 判断condition trigger中的condition是否成立 */</span><br><span class="line">		filter = rcu_dereference_sched(data-&gt;filter);</span><br><span class="line">		if (filter &amp;&amp; !filter_match_preds(filter, rec))</span><br><span class="line">			continue;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		if (data-&gt;cmd_ops-&gt;post_trigger) &#123;</span><br><span class="line">			tt |= data-&gt;cmd_ops-&gt;trigger_type;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		/* (5.1.1.1.4) condition成立，执行condition trigger */</span><br><span class="line">		data-&gt;ops-&gt;func(data);</span><br><span class="line">	&#125;</span><br><span class="line">	return tt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以”enable_event”命令为例，我们继续分析data-&gt;ops-&gt;func()的调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">static void</span><br><span class="line">event_enable_trigger(struct event_trigger_data *data)</span><br><span class="line">&#123;</span><br><span class="line">	struct enable_trigger_data *enable_data = data-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    /* 因为目标event已经被设置成“soft”模式，在此模式下：</span><br><span class="line">        EVENT_FILE_FL_SOFT_DISABLED_BIT = 1，disable模式</span><br><span class="line">        EVENT_FILE_FL_SOFT_DISABLED_BIT = 0，enable模式</span><br><span class="line">     */</span><br><span class="line">	if (enable_data-&gt;enable)</span><br><span class="line">		clear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &amp;enable_data-&gt;file-&gt;flags);</span><br><span class="line">	else</span><br><span class="line">		set_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &amp;enable_data-&gt;file-&gt;flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">event_enable_count_trigger(struct event_trigger_data *data)</span><br><span class="line">&#123;</span><br><span class="line">	struct enable_trigger_data *enable_data = data-&gt;private_data;</span><br><span class="line"></span><br><span class="line">	if (!data-&gt;count)</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	/* Skip if the event is in a state we want to switch to */</span><br><span class="line">	/* 如果trigger命令中的“[:count]”被设置，计数event的触发次数</span><br><span class="line">	    到达门限后再调用trigger命令</span><br><span class="line">	 */</span><br><span class="line">	if (enable_data-&gt;enable == !(enable_data-&gt;file-&gt;flags &amp; EVENT_FILE_FL_SOFT_DISABLED))</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	if (data-&gt;count != -1)</span><br><span class="line">		(data-&gt;count)--;</span><br><span class="line"></span><br><span class="line">	event_enable_trigger(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-3、filter"><a href="#2-3、filter" class="headerlink" title="2.3、filter"></a>2.3、filter</h2><p>1、通过“tracing/events/xxxsubsystem/xxxevent/filter”文件来配置filter：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">trace_create_file(&quot;filter&quot;, 0644, file-&gt;dir, file,</span><br><span class="line">		  &amp;ftrace_event_filter_fops);</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static const struct file_operations ftrace_event_filter_fops = &#123;</span><br><span class="line">	.open = tracing_open_generic,</span><br><span class="line">	.read = event_filter_read,</span><br><span class="line">	.write = event_filter_write,</span><br><span class="line">	.llseek = default_llseek,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static ssize_t</span><br><span class="line">event_filter_write(struct file *filp, const char __user *ubuf, size_t cnt,</span><br><span class="line">		   loff_t *ppos)</span><br><span class="line">&#123;</span><br><span class="line">	struct trace_event_file *file;</span><br><span class="line">	char *buf;</span><br><span class="line">	int err = -ENODEV;</span><br><span class="line"></span><br><span class="line">	if (cnt &gt;= PAGE_SIZE)</span><br><span class="line">		return -EINVAL;</span><br><span class="line"></span><br><span class="line">	buf = (char *)__get_free_page(GFP_TEMPORARY);</span><br><span class="line">	if (!buf)</span><br><span class="line">		return -ENOMEM;</span><br><span class="line"></span><br><span class="line">	if (copy_from_user(buf, ubuf, cnt)) &#123;</span><br><span class="line">		free_page((unsigned long) buf);</span><br><span class="line">		return -EFAULT;</span><br><span class="line">	&#125;</span><br><span class="line">	buf[cnt] = &apos;\0&apos;;</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;event_mutex);</span><br><span class="line">	file = event_file_data(filp);</span><br><span class="line">	if (file)</span><br><span class="line">		err = apply_event_filter(file, buf);</span><br><span class="line">	mutex_unlock(&amp;event_mutex);</span><br><span class="line"></span><br><span class="line">	free_page((unsigned long) buf);</span><br><span class="line">	if (err &lt; 0)</span><br><span class="line">		return err;</span><br><span class="line"></span><br><span class="line">	*ppos += cnt;</span><br><span class="line"></span><br><span class="line">	return cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">int apply_event_filter(struct trace_event_file *file, char *filter_string)</span><br><span class="line">&#123;</span><br><span class="line">	struct trace_event_call *call = file-&gt;event_call;</span><br><span class="line">	struct event_filter *filter;</span><br><span class="line">	int err;</span><br><span class="line"></span><br><span class="line">	if (!strcmp(strstrip(filter_string), &quot;0&quot;)) &#123;</span><br><span class="line">		filter_disable(file);</span><br><span class="line">		filter = event_filter(file);</span><br><span class="line"></span><br><span class="line">		if (!filter)</span><br><span class="line">			return 0;</span><br><span class="line"></span><br><span class="line">		event_clear_filter(file);</span><br><span class="line"></span><br><span class="line">		/* Make sure the filter is not being used */</span><br><span class="line">		synchronize_sched();</span><br><span class="line">		__free_filter(filter);</span><br><span class="line"></span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = create_filter(call, filter_string, true, &amp;filter);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Always swap the call filter with the new filter</span><br><span class="line">	 * even if there was an error. If there was an error</span><br><span class="line">	 * in the filter, we disable the filter and show the error</span><br><span class="line">	 * string</span><br><span class="line">	 */</span><br><span class="line">	if (filter) &#123;</span><br><span class="line">		struct event_filter *tmp;</span><br><span class="line"></span><br><span class="line">		tmp = event_filter(file);</span><br><span class="line">		if (!err)</span><br><span class="line">			event_set_filtered_flag(file);</span><br><span class="line">		else</span><br><span class="line">			filter_disable(file);</span><br><span class="line"></span><br><span class="line">		event_set_filter(file, filter);</span><br><span class="line"></span><br><span class="line">		if (tmp) &#123;</span><br><span class="line">			/* Make sure the call is done with the filter */</span><br><span class="line">			synchronize_sched();</span><br><span class="line">			__free_filter(tmp);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、在trace event被命中时，filter的工作流程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">trace_event_raw_event_##call() -&gt; trace_event_buffer_commit() -&gt; event_trigger_unlock_commit() -&gt; __event_trigger_test_discard() -&gt; filter_check_discard()</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">int filter_check_discard(struct trace_event_file *file, void *rec,</span><br><span class="line">			 struct ring_buffer *buffer,</span><br><span class="line">			 struct ring_buffer_event *event)</span><br><span class="line">&#123;</span><br><span class="line">	if (unlikely(file-&gt;flags &amp; EVENT_FILE_FL_FILTERED) &amp;&amp;</span><br><span class="line">	    !filter_match_preds(file-&gt;filter, rec)) &#123;</span><br><span class="line">		ring_buffer_discard_commit(buffer, event);</span><br><span class="line">		return 1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3、数据取出"><a href="#3、数据取出" class="headerlink" title="3、数据取出"></a>3、数据取出</h1><p>trace数据被存入ringbuffer以后，可以通过不同的形式来查看：</p>
<ul>
<li>可以在trace结束后，通过“trace”文件来读取用户可读的数据。这种使用iterator读，数据不会丢失，可重复读取；</li>
<li>也可以在trace的过程中，使用“trace_pipe”接口同步读取数据，不会阻塞trace数据的写入。这种使用reader_page swap读，读完数据会丢失，只能读一次；</li>
<li>也可以使用“per_cpu/cpu0/trace_pipe_raw”接口，读取raw数据，在用户态工具侧再来解析；</li>
</ul>
<h2 id="3-1、“trace”文件的读取"><a href="#3-1、“trace”文件的读取" class="headerlink" title="3.1、“trace”文件的读取"></a>3.1、“trace”文件的读取</h2><p><img src="/images/ftrace_trace_event/entry_output.png" alt="image"></p>
<p>上图展示了从trace文件中读取trace数据时的情况，把raw trace数据格式化成用户可读的形式。trace数据分成两部分：一部分是comm信息，一部分是用户自定义的trace信息。这两部分分开格式化</p>
<ul>
<li>comm信息。这部分有系统根据当前是“Normal format”还是“Latency trace format”，选择使用trace_print_context()或者是trace_print_lat_context()函数来进行格式化。</li>
<li>用户trace信息。这部分根据type字段找到对应的trace_event结构，有其event-&gt;funcs-&gt;trace()函数来进行格式化。遵循谁存储谁解析的原则，其他人也不清楚raw数据的解析规则。</li>
</ul>
<p>我们看看具体的代码分析：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line">trace_create_file(&quot;trace&quot;, 0644, d_tracer,</span><br><span class="line">		  tr, &amp;tracing_fops);</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static const struct file_operations tracing_fops = &#123;</span><br><span class="line">	.open		= tracing_open,</span><br><span class="line">	.read		= seq_read,</span><br><span class="line">	.write		= tracing_write_stub,</span><br><span class="line">	.llseek		= tracing_lseek,</span><br><span class="line">	.release	= tracing_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">ssize_t seq_read(struct file *file, char __user *buf, size_t size, loff_t *ppos)</span><br><span class="line">&#123;</span><br><span class="line">	struct seq_file *m = file-&gt;private_data;</span><br><span class="line">	size_t copied = 0;</span><br><span class="line">	loff_t pos;</span><br><span class="line">	size_t n;</span><br><span class="line">	void *p;</span><br><span class="line">	int err = 0;</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;m-&gt;lock);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * seq_file-&gt;op-&gt;..m_start/m_stop/m_next may do special actions</span><br><span class="line">	 * or optimisations based on the file-&gt;f_version, so we want to</span><br><span class="line">	 * pass the file-&gt;f_version to those methods.</span><br><span class="line">	 *</span><br><span class="line">	 * seq_file-&gt;version is just copy of f_version, and seq_file</span><br><span class="line">	 * methods can treat it simply as file version.</span><br><span class="line">	 * It is copied in first and copied out after all operations.</span><br><span class="line">	 * It is convenient to have it as  part of structure to avoid the</span><br><span class="line">	 * need of passing another argument to all the seq_file methods.</span><br><span class="line">	 */</span><br><span class="line">	m-&gt;version = file-&gt;f_version;</span><br><span class="line"></span><br><span class="line">	/* Don&apos;t assume *ppos is where we left it */</span><br><span class="line">	if (unlikely(*ppos != m-&gt;read_pos)) &#123;</span><br><span class="line">		while ((err = traverse(m, *ppos)) == -EAGAIN)</span><br><span class="line">			;</span><br><span class="line">		if (err) &#123;</span><br><span class="line">			/* With prejudice... */</span><br><span class="line">			m-&gt;read_pos = 0;</span><br><span class="line">			m-&gt;version = 0;</span><br><span class="line">			m-&gt;index = 0;</span><br><span class="line">			m-&gt;count = 0;</span><br><span class="line">			goto Done;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			m-&gt;read_pos = *ppos;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* grab buffer if we didn&apos;t have one */</span><br><span class="line">	if (!m-&gt;buf) &#123;</span><br><span class="line">		m-&gt;buf = seq_buf_alloc(m-&gt;size = PAGE_SIZE);</span><br><span class="line">		if (!m-&gt;buf)</span><br><span class="line">			goto Enomem;</span><br><span class="line">	&#125;</span><br><span class="line">	/* if not empty - flush it first */</span><br><span class="line">	if (m-&gt;count) &#123;</span><br><span class="line">		n = min(m-&gt;count, size);</span><br><span class="line">		err = copy_to_user(buf, m-&gt;buf + m-&gt;from, n);</span><br><span class="line">		if (err)</span><br><span class="line">			goto Efault;</span><br><span class="line">		m-&gt;count -= n;</span><br><span class="line">		m-&gt;from += n;</span><br><span class="line">		size -= n;</span><br><span class="line">		buf += n;</span><br><span class="line">		copied += n;</span><br><span class="line">		if (!m-&gt;count) &#123;</span><br><span class="line">			m-&gt;from = 0;</span><br><span class="line">			m-&gt;index++;</span><br><span class="line">		&#125;</span><br><span class="line">		if (!size)</span><br><span class="line">			goto Done;</span><br><span class="line">	&#125;</span><br><span class="line">	/* we need at least one record in buffer */</span><br><span class="line">	pos = m-&gt;index;</span><br><span class="line">	p = m-&gt;op-&gt;start(m, &amp;pos);</span><br><span class="line">	while (1) &#123;</span><br><span class="line">		err = PTR_ERR(p);</span><br><span class="line">		if (!p || IS_ERR(p))</span><br><span class="line">			break;</span><br><span class="line">		err = m-&gt;op-&gt;show(m, p);</span><br><span class="line">		if (err &lt; 0)</span><br><span class="line">			break;</span><br><span class="line">		if (unlikely(err))</span><br><span class="line">			m-&gt;count = 0;</span><br><span class="line">		if (unlikely(!m-&gt;count)) &#123;</span><br><span class="line">			p = m-&gt;op-&gt;next(m, p, &amp;pos);</span><br><span class="line">			m-&gt;index = pos;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		if (m-&gt;count &lt; m-&gt;size)</span><br><span class="line">			goto Fill;</span><br><span class="line">		m-&gt;op-&gt;stop(m, p);</span><br><span class="line">		kvfree(m-&gt;buf);</span><br><span class="line">		m-&gt;count = 0;</span><br><span class="line">		m-&gt;buf = seq_buf_alloc(m-&gt;size &lt;&lt;= 1);</span><br><span class="line">		if (!m-&gt;buf)</span><br><span class="line">			goto Enomem;</span><br><span class="line">		m-&gt;version = 0;</span><br><span class="line">		pos = m-&gt;index;</span><br><span class="line">		p = m-&gt;op-&gt;start(m, &amp;pos);</span><br><span class="line">	&#125;</span><br><span class="line">	m-&gt;op-&gt;stop(m, p);</span><br><span class="line">	m-&gt;count = 0;</span><br><span class="line">	goto Done;</span><br><span class="line">Fill:</span><br><span class="line">	/* they want more? let&apos;s try to get some more */</span><br><span class="line">	while (m-&gt;count &lt; size) &#123;</span><br><span class="line">		size_t offs = m-&gt;count;</span><br><span class="line">		loff_t next = pos;</span><br><span class="line">		p = m-&gt;op-&gt;next(m, p, &amp;next);</span><br><span class="line">		if (!p || IS_ERR(p)) &#123;</span><br><span class="line">			err = PTR_ERR(p);</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		err = m-&gt;op-&gt;show(m, p);</span><br><span class="line">		if (seq_has_overflowed(m) || err) &#123;</span><br><span class="line">			m-&gt;count = offs;</span><br><span class="line">			if (likely(err &lt;= 0))</span><br><span class="line">				break;</span><br><span class="line">		&#125;</span><br><span class="line">		pos = next;</span><br><span class="line">	&#125;</span><br><span class="line">	m-&gt;op-&gt;stop(m, p);</span><br><span class="line">	n = min(m-&gt;count, size);</span><br><span class="line">	err = copy_to_user(buf, m-&gt;buf, n);</span><br><span class="line">	if (err)</span><br><span class="line">		goto Efault;</span><br><span class="line">	copied += n;</span><br><span class="line">	m-&gt;count -= n;</span><br><span class="line">	if (m-&gt;count)</span><br><span class="line">		m-&gt;from = n;</span><br><span class="line">	else</span><br><span class="line">		pos++;</span><br><span class="line">	m-&gt;index = pos;</span><br><span class="line">Done:</span><br><span class="line">	if (!copied)</span><br><span class="line">		copied = err;</span><br><span class="line">	else &#123;</span><br><span class="line">		*ppos += copied;</span><br><span class="line">		m-&gt;read_pos += copied;</span><br><span class="line">	&#125;</span><br><span class="line">	file-&gt;f_version = m-&gt;version;</span><br><span class="line">	mutex_unlock(&amp;m-&gt;lock);</span><br><span class="line">	return copied;</span><br><span class="line">Enomem:</span><br><span class="line">	err = -ENOMEM;</span><br><span class="line">	goto Done;</span><br><span class="line">Efault:</span><br><span class="line">	err = -EFAULT;</span><br><span class="line">	goto Done;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读操作实际最后落在tracer_seq_ops的s_next()和s_show()上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line">static const struct seq_operations tracer_seq_ops = &#123;</span><br><span class="line">	.start		= s_start,</span><br><span class="line">	.next		= s_next,</span><br><span class="line">	.stop		= s_stop,</span><br><span class="line">	.show		= s_show,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static void *s_next(struct seq_file *m, void *v, loff_t *pos)</span><br><span class="line">&#123;</span><br><span class="line">	struct trace_iterator *iter = m-&gt;private;</span><br><span class="line">	int i = (int)*pos;</span><br><span class="line">	void *ent;</span><br><span class="line"></span><br><span class="line">	WARN_ON_ONCE(iter-&gt;leftover);</span><br><span class="line"></span><br><span class="line">	(*pos)++;</span><br><span class="line"></span><br><span class="line">	/* can&apos;t go backwards */</span><br><span class="line">	if (iter-&gt;idx &gt; i)</span><br><span class="line">		return NULL;</span><br><span class="line"></span><br><span class="line">	if (iter-&gt;idx &lt; 0)</span><br><span class="line">		ent = trace_find_next_entry_inc(iter);</span><br><span class="line">	else</span><br><span class="line">		ent = iter;</span><br><span class="line"></span><br><span class="line">    /* (1) 从ringbuffer中取出下一个entry */</span><br><span class="line">	while (ent &amp;&amp; iter-&gt;idx &lt; i)</span><br><span class="line">		ent = trace_find_next_entry_inc(iter);</span><br><span class="line"></span><br><span class="line">	iter-&gt;pos = *pos;</span><br><span class="line"></span><br><span class="line">	return ent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">void *trace_find_next_entry_inc(struct trace_iterator *iter)</span><br><span class="line">&#123;</span><br><span class="line">    /* (1.1) 取出下一个entry */</span><br><span class="line">	iter-&gt;ent = __find_next_entry(iter, &amp;iter-&gt;cpu,</span><br><span class="line">				      &amp;iter-&gt;lost_events, &amp;iter-&gt;ts);</span><br><span class="line"></span><br><span class="line">    /* (1.2) 增加iter中的读指针 */</span><br><span class="line">	if (iter-&gt;ent)</span><br><span class="line">		trace_iterator_increment(iter);</span><br><span class="line"></span><br><span class="line">	return iter-&gt;ent ? iter : NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static int s_show(struct seq_file *m, void *v)</span><br><span class="line">&#123;</span><br><span class="line">	struct trace_iterator *iter = v;</span><br><span class="line">	int ret;</span><br><span class="line"></span><br><span class="line">	if (iter-&gt;ent == NULL) &#123;</span><br><span class="line">		if (iter-&gt;tr) &#123;</span><br><span class="line">			seq_printf(m, &quot;# tracer: %s\n&quot;, iter-&gt;trace-&gt;name);</span><br><span class="line">			seq_puts(m, &quot;#\n&quot;);</span><br><span class="line">			test_ftrace_alive(m);</span><br><span class="line">		&#125;</span><br><span class="line">		if (iter-&gt;snapshot &amp;&amp; trace_empty(iter))</span><br><span class="line">			print_snapshot_help(m, iter);</span><br><span class="line">		else if (iter-&gt;trace &amp;&amp; iter-&gt;trace-&gt;print_header)</span><br><span class="line">			iter-&gt;trace-&gt;print_header(m);</span><br><span class="line">		else</span><br><span class="line">			trace_default_header(m);</span><br><span class="line"></span><br><span class="line">	&#125; else if (iter-&gt;leftover) &#123;</span><br><span class="line">		/*</span><br><span class="line">		 * If we filled the seq_file buffer earlier, we</span><br><span class="line">		 * want to just show it now.</span><br><span class="line">		 */</span><br><span class="line">		ret = trace_print_seq(m, &amp;iter-&gt;seq);</span><br><span class="line"></span><br><span class="line">		/* ret should this time be zero, but you never know */</span><br><span class="line">		iter-&gt;leftover = ret;</span><br><span class="line"></span><br><span class="line">	&#125; else &#123;</span><br><span class="line">	    /* (2) 把entry格式化成用户可读字符串 */</span><br><span class="line">		print_trace_line(iter);</span><br><span class="line">		/* 将iter中的内容拷贝到文件中 */</span><br><span class="line">		ret = trace_print_seq(m, &amp;iter-&gt;seq);</span><br><span class="line">		/*</span><br><span class="line">		 * If we overflow the seq_file buffer, then it will</span><br><span class="line">		 * ask us for this data again at start up.</span><br><span class="line">		 * Use that instead.</span><br><span class="line">		 *  ret is 0 if seq_file write succeeded.</span><br><span class="line">		 *        -1 otherwise.</span><br><span class="line">		 */</span><br><span class="line">		iter-&gt;leftover = ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">enum print_line_t print_trace_line(struct trace_iterator *iter)</span><br><span class="line">&#123;</span><br><span class="line">	struct trace_array *tr = iter-&gt;tr;</span><br><span class="line">	unsigned long trace_flags = tr-&gt;trace_flags;</span><br><span class="line">	enum print_line_t ret;</span><br><span class="line"></span><br><span class="line">	if (iter-&gt;lost_events) &#123;</span><br><span class="line">		trace_seq_printf(&amp;iter-&gt;seq, &quot;CPU:%d [LOST %lu EVENTS]\n&quot;,</span><br><span class="line">				 iter-&gt;cpu, iter-&gt;lost_events);</span><br><span class="line">		if (trace_seq_has_overflowed(&amp;iter-&gt;seq))</span><br><span class="line">			return TRACE_TYPE_PARTIAL_LINE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (iter-&gt;trace &amp;&amp; iter-&gt;trace-&gt;print_line) &#123;</span><br><span class="line">		ret = iter-&gt;trace-&gt;print_line(iter);</span><br><span class="line">		if (ret != TRACE_TYPE_UNHANDLED)</span><br><span class="line">			return ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (2.1) 几种特殊type的格式化方式 */</span><br><span class="line">	if (iter-&gt;ent-&gt;type == TRACE_BPUTS &amp;&amp;</span><br><span class="line">			trace_flags &amp; TRACE_ITER_PRINTK &amp;&amp;</span><br><span class="line">			trace_flags &amp; TRACE_ITER_PRINTK_MSGONLY)</span><br><span class="line">		return trace_print_bputs_msg_only(iter);</span><br><span class="line"></span><br><span class="line">	if (iter-&gt;ent-&gt;type == TRACE_BPRINT &amp;&amp;</span><br><span class="line">			trace_flags &amp; TRACE_ITER_PRINTK &amp;&amp;</span><br><span class="line">			trace_flags &amp; TRACE_ITER_PRINTK_MSGONLY)</span><br><span class="line">		return trace_print_bprintk_msg_only(iter);</span><br><span class="line"></span><br><span class="line">	if (iter-&gt;ent-&gt;type == TRACE_PRINT &amp;&amp;</span><br><span class="line">			trace_flags &amp; TRACE_ITER_PRINTK &amp;&amp;</span><br><span class="line">			trace_flags &amp; TRACE_ITER_PRINTK_MSGONLY)</span><br><span class="line">		return trace_print_printk_msg_only(iter);</span><br><span class="line"></span><br><span class="line">    /* (2.2) raw数据的打印方式 */</span><br><span class="line">	if (trace_flags &amp; TRACE_ITER_BIN)</span><br><span class="line">		return print_bin_fmt(iter);</span><br><span class="line"></span><br><span class="line">	if (trace_flags &amp; TRACE_ITER_HEX)</span><br><span class="line">		return print_hex_fmt(iter);</span><br><span class="line"></span><br><span class="line">	if (trace_flags &amp; TRACE_ITER_RAW)</span><br><span class="line">		return print_raw_fmt(iter);</span><br><span class="line"></span><br><span class="line">    /* (2.3) 普通trace信息的打印方式 */</span><br><span class="line">	return print_trace_fmt(iter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">||→</span><br><span class="line"></span><br><span class="line">static enum print_line_t print_trace_fmt(struct trace_iterator *iter)</span><br><span class="line">&#123;</span><br><span class="line">	struct trace_array *tr = iter-&gt;tr;</span><br><span class="line">	struct trace_seq *s = &amp;iter-&gt;seq;</span><br><span class="line">	unsigned long sym_flags = (tr-&gt;trace_flags &amp; TRACE_ITER_SYM_MASK);</span><br><span class="line">	struct trace_entry *entry;</span><br><span class="line">	struct trace_event *event;</span><br><span class="line"></span><br><span class="line">	entry = iter-&gt;ent;</span><br><span class="line"></span><br><span class="line">	test_cpu_buff_start(iter);</span><br><span class="line"></span><br><span class="line">	event = ftrace_find_event(entry-&gt;type);</span><br><span class="line"></span><br><span class="line">    /* (2.3.1) 打印头部comm信息 */</span><br><span class="line">	if (tr-&gt;trace_flags &amp; TRACE_ITER_CONTEXT_INFO) &#123;</span><br><span class="line">		if (iter-&gt;iter_flags &amp; TRACE_FILE_LAT_FMT)</span><br><span class="line">		    /* Latency trace format */</span><br><span class="line">			trace_print_lat_context(iter);</span><br><span class="line">		else</span><br><span class="line">		    /* Normal format */</span><br><span class="line">			trace_print_context(iter);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (trace_seq_has_overflowed(s))</span><br><span class="line">		return TRACE_TYPE_PARTIAL_LINE;</span><br><span class="line"></span><br><span class="line">    /* (2.3.2) 打印用户trace信息 */</span><br><span class="line">	if (event)</span><br><span class="line">		return event-&gt;funcs-&gt;trace(iter, sym_flags, event);</span><br><span class="line"></span><br><span class="line">	trace_seq_printf(s, &quot;Unknown type %d\n&quot;, entry-&gt;type);</span><br><span class="line"></span><br><span class="line">	return trace_handle_return(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以trace event为例，我们继续分析event-&gt;funcs-&gt;trace()。最后调用到“include/trace/trace_event.h”中的trace_raw_output_##call()函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">static notrace enum print_line_t					\</span><br><span class="line">trace_raw_output_##call(struct trace_iterator *iter, int flags,		\</span><br><span class="line">			struct trace_event *trace_event)		\</span><br><span class="line">&#123;									\</span><br><span class="line">    // (2.3.2.1) iter-&gt;seq：为output buffer</span><br><span class="line">	struct trace_seq *s = &amp;iter-&gt;seq;				\</span><br><span class="line">	</span><br><span class="line">    // (2.3.2.2) iter-&gt;tmp_seq：为临时buffer，供__get_bitmask()、__print_flags()、__print_symbolic()等一系列函数先把值转换成字符串</span><br><span class="line">	struct trace_seq __maybe_unused *p = &amp;iter-&gt;tmp_seq;		\</span><br><span class="line">	</span><br><span class="line">    //  (2.3.2.3) iter-&gt;ent：为ringbuffer原始数据的存放buffer，</span><br><span class="line">    // 使用上面定义的结构&quot;struct trace_event_raw_##call&quot;指向这片区域，来进行引用</span><br><span class="line">	struct trace_event_raw_##call *field;				\</span><br><span class="line">	</span><br><span class="line">	int ret;							\</span><br><span class="line">									\</span><br><span class="line">	field = (typeof(field))iter-&gt;ent;				\</span><br><span class="line">									\</span><br><span class="line">    // (2.3.2.4)在output buffer的最前头，打印出trace_event的name</span><br><span class="line">	ret = trace_raw_output_prep(iter, trace_event);			\</span><br><span class="line">	if (ret != TRACE_TYPE_HANDLED)					\</span><br><span class="line">		return ret;						\</span><br><span class="line">									\</span><br><span class="line">    // (2.3.2.5)把ringbuffer中的原始数据根据格式打印到output buffer当中</span><br><span class="line">	trace_seq_printf(s, print);					\</span><br><span class="line">									\</span><br><span class="line">	return trace_handle_return(s);					\</span><br><span class="line">&#125;									\</span><br></pre></td></tr></table></figure>
<p>trace_iterator只是一个中间临时变量，主要是利用iter-&gt;seq、iter-&gt;tmp_seq把iter-&gt;ent指向的ringbuffer数据按照format转换成用户可读的数据。</p>
<h1 id="4、trace-printk"><a href="#4、trace-printk" class="headerlink" title="4、trace_printk()"></a>4、trace_printk()</h1><p>trace_printk()是利用printk的形式，把调试信息存入到trace ringbuffer中去。从前面的trace event分析中可以看到，在trace框架中存储trace数据需要几大要素：</p>
<ul>
<li>插桩点。因为trace_printk()是在代码中显式的调用，所以这个不是问题；</li>
<li>trace框架数据结构，操作函数合集。这个的顶级数据结构是trace_event_call，我们通过TRACE_EVENT()宏创建一个trace event的时候会自动创建一个trace_event_call。针对trace_printk()，系统也创建了一些默认trace_event_call供其使用。</li>
<li>使用哪块ringbuffer。trace_printk()默认使用global_trace。</li>
</ul>
<h2 id="4-1、trace-printk-定义"><a href="#4-1、trace-printk-定义" class="headerlink" title="4.1、trace_printk()定义"></a>4.1、trace_printk()定义</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#define trace_printk(fmt, ...)				\</span><br><span class="line">do &#123;							\</span><br><span class="line">	char _______STR[] = __stringify((__VA_ARGS__));	\</span><br><span class="line">	/* (1) 如果##__VA_ARGS__不为空，trace_printk()的调用为可变参数 */</span><br><span class="line">	if (sizeof(_______STR) &gt; 3)			\</span><br><span class="line">		do_trace_printk(fmt, ##__VA_ARGS__);	\</span><br><span class="line">	</span><br><span class="line">	/* (2) 如果##__VA_ARGS__为空，trace_printk()的调用为只有一个参数“fmt” */</span><br><span class="line">	else						\</span><br><span class="line">		trace_puts(fmt);			\</span><br><span class="line">&#125; while (0)</span><br></pre></td></tr></table></figure>
<p>1、do_trace_printk()的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line">#define do_trace_printk(fmt, args...)					\</span><br><span class="line">do &#123;									\</span><br><span class="line">	static const char *trace_printk_fmt __used			\</span><br><span class="line">		__attribute__((section(&quot;__trace_printk_fmt&quot;))) =	\</span><br><span class="line">		__builtin_constant_p(fmt) ? fmt : NULL;			\</span><br><span class="line">									\</span><br><span class="line">	__trace_printk_check_format(fmt, ##args);			\</span><br><span class="line">									\</span><br><span class="line">    /* (1.1) 如果格式字符串“fmt”是一个常量，在编译的时候就能确定 </span><br><span class="line">        将“fmt”存入到section(&quot;__trace_printk_fmt&quot;)，可以在“printk_formats”文件中查看</span><br><span class="line">        在保存trace的时候就不需要保存“fmt”到ringbuffer，只需保存“fmt”指针和“##args”到ringbuffer</span><br><span class="line">        可以节约宝贵的ringbuffer空间</span><br><span class="line">        在数据读出的时候，再根据“fmt”的format，格式化打印“##args”数据</span><br><span class="line">        使用TRACE_BPRINT type的trace_event_call来处理数据</span><br><span class="line">     */</span><br><span class="line">	if (__builtin_constant_p(fmt))					\</span><br><span class="line">		__trace_bprintk(_THIS_IP_, trace_printk_fmt, ##args);	\</span><br><span class="line">	</span><br><span class="line">	/* (1.2) 如果格式字符串“fmt”是一个变量，比如引用的是一个字符串变量，在运行的时候才能确认 </span><br><span class="line">	    因为“fmt”是一个变量，所以不能事先保存</span><br><span class="line">	    在保存trace的时候就需要根据“fmt”的format格式化打印“##args”数据，保存“fmt”内容和“##args”到ringbuffer</span><br><span class="line">	    比较浪费ringbuffer空间，但是没有办法</span><br><span class="line">	    在数据读出的时候，因为ringbuffer中存储的已经是格式化好的字符串，只需读出即可</span><br><span class="line">        使用TRACE_PRINT type的trace_event_call来处理数据</span><br><span class="line">	 */</span><br><span class="line">	else								\</span><br><span class="line">		__trace_printk(_THIS_IP_, fmt, ##args);			\</span><br><span class="line">&#125; while (0)</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">__trace_bprintk() -&gt; trace_vbprintk():</span><br><span class="line"></span><br><span class="line">int trace_vbprintk(unsigned long ip, const char *fmt, va_list args)</span><br><span class="line">&#123;</span><br><span class="line">	struct trace_event_call *call = &amp;event_bprint;</span><br><span class="line">	struct ring_buffer_event *event;</span><br><span class="line">	struct ring_buffer *buffer;</span><br><span class="line">	struct trace_array *tr = &amp;global_trace;</span><br><span class="line">	struct bprint_entry *entry;</span><br><span class="line">	unsigned long flags;</span><br><span class="line">	char *tbuffer;</span><br><span class="line">	int len = 0, size, pc;</span><br><span class="line"></span><br><span class="line">	if (unlikely(tracing_selftest_running || tracing_disabled))</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">	/* Don&apos;t pollute graph traces with trace_vprintk internals */</span><br><span class="line">	pause_graph_tracing();</span><br><span class="line"></span><br><span class="line">	pc = preempt_count();</span><br><span class="line">	preempt_disable_notrace();</span><br><span class="line"></span><br><span class="line">    /* (1.1.1) 使用trace_pintk()专用的临时空间 */</span><br><span class="line">	tbuffer = get_trace_buf();</span><br><span class="line">	if (!tbuffer) &#123;</span><br><span class="line">		len = 0;</span><br><span class="line">		goto out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (1.1.2) 仅保存“args”数据到ringbuffer */</span><br><span class="line">	len = vbin_printf((u32 *)tbuffer, TRACE_BUF_SIZE/sizeof(int), fmt, args);</span><br><span class="line"></span><br><span class="line">	if (len &gt; TRACE_BUF_SIZE/sizeof(int) || len &lt; 0)</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">	local_save_flags(flags);</span><br><span class="line">	size = sizeof(*entry) + sizeof(u32) * len;</span><br><span class="line">	buffer = tr-&gt;trace_buffer.buffer;</span><br><span class="line">	event = trace_buffer_lock_reserve(buffer, TRACE_BPRINT, size,</span><br><span class="line">					  flags, pc);</span><br><span class="line">	if (!event)</span><br><span class="line">		goto out;</span><br><span class="line">	/* (1.1.3) 保存ip和section(&quot;__trace_printk_fmt&quot;)中的“fmt”指针 */</span><br><span class="line">	entry = ring_buffer_event_data(event);</span><br><span class="line">	entry-&gt;ip			= ip;</span><br><span class="line">	entry-&gt;fmt			= fmt;</span><br><span class="line"></span><br><span class="line">	memcpy(entry-&gt;buf, tbuffer, sizeof(u32) * len);</span><br><span class="line">	if (!call_filter_check_discard(call, entry, buffer, event)) &#123;</span><br><span class="line">		__buffer_unlock_commit(buffer, event);</span><br><span class="line">		ftrace_trace_stack(tr, buffer, flags, 6, pc, NULL);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	preempt_enable_notrace();</span><br><span class="line">	unpause_graph_tracing();</span><br><span class="line"></span><br><span class="line">	return len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">__trace_printk() -&gt; trace_vprintk() -&gt; trace_array_vprintk() -&gt; __trace_array_vprintk():</span><br><span class="line"></span><br><span class="line">static int</span><br><span class="line">__trace_array_vprintk(struct ring_buffer *buffer,</span><br><span class="line">		      unsigned long ip, const char *fmt, va_list args)</span><br><span class="line">&#123;</span><br><span class="line">	struct trace_event_call *call = &amp;event_print;</span><br><span class="line">	struct ring_buffer_event *event;</span><br><span class="line">	int len = 0, size, pc;</span><br><span class="line">	struct print_entry *entry;</span><br><span class="line">	unsigned long flags;</span><br><span class="line">	char *tbuffer;</span><br><span class="line"></span><br><span class="line">	if (tracing_disabled || tracing_selftest_running)</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">	/* Don&apos;t pollute graph traces with trace_vprintk internals */</span><br><span class="line">	pause_graph_tracing();</span><br><span class="line"></span><br><span class="line">	pc = preempt_count();</span><br><span class="line">	preempt_disable_notrace();</span><br><span class="line"></span><br><span class="line">    /* (1.2.1) 使用trace_pintk()专用的临时空间 */</span><br><span class="line">	tbuffer = get_trace_buf();</span><br><span class="line">	if (!tbuffer) &#123;</span><br><span class="line">		len = 0;</span><br><span class="line">		goto out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (1.2.2) 保存“fmt”+“args”格式化好的数据到ringbuffer */</span><br><span class="line">	len = vscnprintf(tbuffer, TRACE_BUF_SIZE, fmt, args);</span><br><span class="line"></span><br><span class="line">	local_save_flags(flags);</span><br><span class="line">	size = sizeof(*entry) + len + 1;</span><br><span class="line">	event = trace_buffer_lock_reserve(buffer, TRACE_PRINT, size,</span><br><span class="line">					  flags, pc);</span><br><span class="line">	if (!event)</span><br><span class="line">		goto out;</span><br><span class="line">	/* (1.2.3) 保存ip和格式化字符串 */</span><br><span class="line">	entry = ring_buffer_event_data(event);</span><br><span class="line">	entry-&gt;ip = ip;</span><br><span class="line"></span><br><span class="line">	memcpy(&amp;entry-&gt;buf, tbuffer, len + 1);</span><br><span class="line">	if (!call_filter_check_discard(call, entry, buffer, event)) &#123;</span><br><span class="line">		stm_log(OST_ENTITY_TRACE_PRINTK, entry-&gt;buf, len + 1);</span><br><span class="line">		__buffer_unlock_commit(buffer, event);</span><br><span class="line">		ftrace_trace_stack(&amp;global_trace, buffer, flags, 6, pc, NULL);</span><br><span class="line">	&#125;</span><br><span class="line"> out:</span><br><span class="line">	preempt_enable_notrace();</span><br><span class="line">	unpause_graph_tracing();</span><br><span class="line"></span><br><span class="line">	return len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、trace_puts()的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">#define trace_puts(str) (&#123;						\</span><br><span class="line">	static const char *trace_printk_fmt __used			\</span><br><span class="line">		__attribute__((section(&quot;__trace_printk_fmt&quot;))) =	\</span><br><span class="line">		__builtin_constant_p(str) ? str : NULL;			\</span><br><span class="line">									\</span><br><span class="line">    /* (2.1) 如果格式字符串“fmt”是一个常量，在编译的时候就能确定 </span><br><span class="line">        将“fmt”存入到section(&quot;__trace_printk_fmt&quot;)，可以在“printk_formats”文件中查看</span><br><span class="line">        在保存trace的时候就不需要保存“fmt”到ringbuffer，只需保存“fmt”指针到ringbuffer</span><br><span class="line">        可以节约宝贵的ringbuffer空间</span><br><span class="line">        在数据读出的时候，再根据“fmt”的指针，打印出“fmt”内容</span><br><span class="line">        使用TRACE_BPUTS type的trace_event_call来处理数据</span><br><span class="line">     */</span><br><span class="line">	if (__builtin_constant_p(str))					\</span><br><span class="line">		__trace_bputs(_THIS_IP_, trace_printk_fmt);		\</span><br><span class="line"></span><br><span class="line">    /* (2.2) 如果格式字符串“fmt”是一个变量，比如引用的是一个字符串变量，在运行的时候才能确认 </span><br><span class="line">	    因为“fmt”是一个变量，所以不能事先保存</span><br><span class="line">	    在保存trace的时候保存“fmt”内容到ringbuffer</span><br><span class="line">	    比较浪费ringbuffer空间，但是没有办法</span><br><span class="line">	    在数据读出的时候，因为ringbuffer中存储的好的“fmt”字符串，只需读出即可</span><br><span class="line">        使用TRACE_PRINT type的trace_event_call来处理数据</span><br><span class="line">	 */</span><br><span class="line">	else								\</span><br><span class="line">		__trace_puts(_THIS_IP_, str, strlen(str));		\</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">int __trace_bputs(unsigned long ip, const char *str)</span><br><span class="line">&#123;</span><br><span class="line">	struct ring_buffer_event *event;</span><br><span class="line">	struct ring_buffer *buffer;</span><br><span class="line">	struct bputs_entry *entry;</span><br><span class="line">	unsigned long irq_flags;</span><br><span class="line">	int size = sizeof(struct bputs_entry);</span><br><span class="line">	int pc;</span><br><span class="line"></span><br><span class="line">	if (!(global_trace.trace_flags &amp; TRACE_ITER_PRINTK))</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">	pc = preempt_count();</span><br><span class="line"></span><br><span class="line">	if (unlikely(tracing_selftest_running || tracing_disabled))</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">	local_save_flags(irq_flags);</span><br><span class="line">	buffer = global_trace.trace_buffer.buffer;</span><br><span class="line">	event = trace_buffer_lock_reserve(buffer, TRACE_BPUTS, size,</span><br><span class="line">					  irq_flags, pc);</span><br><span class="line">	if (!event)</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">	entry = ring_buffer_event_data(event);</span><br><span class="line">	/* (2.1.1) 保存ip和section(&quot;__trace_printk_fmt&quot;)中的“fmt”指针到ringbuffer */</span><br><span class="line">	entry-&gt;ip			= ip;</span><br><span class="line">	entry-&gt;str			= str;</span><br><span class="line">	stm_log(OST_ENTITY_TRACE_PRINTK, entry-&gt;str, strlen(entry-&gt;str)+1);</span><br><span class="line"></span><br><span class="line">	__buffer_unlock_commit(buffer, event);</span><br><span class="line">	ftrace_trace_stack(&amp;global_trace, buffer, irq_flags, 4, pc, NULL);</span><br><span class="line"></span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">int __trace_puts(unsigned long ip, const char *str, int size)</span><br><span class="line">&#123;</span><br><span class="line">	struct ring_buffer_event *event;</span><br><span class="line">	struct ring_buffer *buffer;</span><br><span class="line">	struct print_entry *entry;</span><br><span class="line">	unsigned long irq_flags;</span><br><span class="line">	int alloc;</span><br><span class="line">	int pc;</span><br><span class="line"></span><br><span class="line">	if (!(global_trace.trace_flags &amp; TRACE_ITER_PRINTK))</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">	pc = preempt_count();</span><br><span class="line"></span><br><span class="line">	if (unlikely(tracing_selftest_running || tracing_disabled))</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">	alloc = sizeof(*entry) + size + 2; /* possible \n added */</span><br><span class="line"></span><br><span class="line">	local_save_flags(irq_flags);</span><br><span class="line">	buffer = global_trace.trace_buffer.buffer;</span><br><span class="line">	event = trace_buffer_lock_reserve(buffer, TRACE_PRINT, alloc, </span><br><span class="line">					  irq_flags, pc);</span><br><span class="line">	if (!event)</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">	entry = ring_buffer_event_data(event);</span><br><span class="line">	</span><br><span class="line">	/* (2.2.1) 保存ip到ringbuffer */</span><br><span class="line">	entry-&gt;ip = ip;</span><br><span class="line"></span><br><span class="line">    /* (2.2.2) 保存“fmt”字符串到ringbuffer */</span><br><span class="line">	memcpy(&amp;entry-&gt;buf, str, size);</span><br><span class="line"></span><br><span class="line">	/* Add a newline if necessary */</span><br><span class="line">	if (entry-&gt;buf[size - 1] != &apos;\n&apos;) &#123;</span><br><span class="line">		entry-&gt;buf[size] = &apos;\n&apos;;</span><br><span class="line">		entry-&gt;buf[size + 1] = &apos;\0&apos;;</span><br><span class="line">		stm_log(OST_ENTITY_TRACE_PRINTK, entry-&gt;buf, size + 2);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		entry-&gt;buf[size] = &apos;\0&apos;;</span><br><span class="line">		stm_log(OST_ENTITY_TRACE_PRINTK, entry-&gt;buf, size + 1);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	__buffer_unlock_commit(buffer, event);</span><br><span class="line">	ftrace_trace_stack(&amp;global_trace, buffer, irq_flags, 4, pc, NULL);</span><br><span class="line"></span><br><span class="line">	return size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-2、FTRACE-ENTRY-宏的展开"><a href="#4-2、FTRACE-ENTRY-宏的展开" class="headerlink" title="4.2、FTRACE_ENTRY()宏的展开"></a>4.2、FTRACE_ENTRY()宏的展开</h2><p>从上一节可以看到，为了优化对ringbuffer的消耗，不同情况下trace_printk()使用了3种type的trace_event_call来进行处理。分别是：TRACE_BPRINT、TRACE_PRINT、TRACE_BPUTS。</p>
<p>这3种系统默认trace_event_call，是通过FTRACE_ENTRY()宏来定义的。定义了trace_event_call可以直接使用现有的trace框架。具体过程如下：</p>
<p>1、kernel/trace/trace_entries.h：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * trace_printk entry:</span><br><span class="line"> */</span><br><span class="line">FTRACE_ENTRY(bprint, bprint_entry,</span><br><span class="line"></span><br><span class="line">	TRACE_BPRINT,</span><br><span class="line"></span><br><span class="line">	F_STRUCT(</span><br><span class="line">		__field(	unsigned long,	ip	)</span><br><span class="line">		__field(	const char *,	fmt	)</span><br><span class="line">		__dynamic_array(	u32,	buf	)</span><br><span class="line">	),</span><br><span class="line"></span><br><span class="line">	F_printk(&quot;%ps: %s&quot;,</span><br><span class="line">		 (void *)__entry-&gt;ip, __entry-&gt;fmt),</span><br><span class="line"></span><br><span class="line">	FILTER_OTHER</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">FTRACE_ENTRY(print, print_entry,</span><br><span class="line"></span><br><span class="line">	TRACE_PRINT,</span><br><span class="line"></span><br><span class="line">	F_STRUCT(</span><br><span class="line">		__field(	unsigned long,	ip	)</span><br><span class="line">		__dynamic_array(	char,	buf	)</span><br><span class="line">	),</span><br><span class="line"></span><br><span class="line">	F_printk(&quot;%ps: %s&quot;,</span><br><span class="line">		 (void *)__entry-&gt;ip, __entry-&gt;buf),</span><br><span class="line"></span><br><span class="line">	FILTER_OTHER</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">FTRACE_ENTRY(bputs, bputs_entry,</span><br><span class="line"></span><br><span class="line">	TRACE_BPUTS,</span><br><span class="line"></span><br><span class="line">	F_STRUCT(</span><br><span class="line">		__field(	unsigned long,	ip	)</span><br><span class="line">		__field(	const char *,	str	)</span><br><span class="line">	),</span><br><span class="line"></span><br><span class="line">	F_printk(&quot;%ps: %s&quot;,</span><br><span class="line">		 (void *)__entry-&gt;ip, __entry-&gt;str),</span><br><span class="line"></span><br><span class="line">	FILTER_OTHER</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>2、kernel/trace/trace.h：</p>
<p>FTRACE_ENTRY()宏第1次展开，定义了struct struct_name：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#undef __field</span><br><span class="line">#define __field(type, item)		type	item;</span><br><span class="line"></span><br><span class="line">#undef __field_struct</span><br><span class="line">#define __field_struct(type, item)	__field(type, item)</span><br><span class="line"></span><br><span class="line">#undef __field_desc</span><br><span class="line">#define __field_desc(type, container, item)</span><br><span class="line"></span><br><span class="line">#undef __array</span><br><span class="line">#define __array(type, item, size)	type	item[size];</span><br><span class="line"></span><br><span class="line">#undef __array_desc</span><br><span class="line">#define __array_desc(type, container, item, size)</span><br><span class="line"></span><br><span class="line">#undef __dynamic_array</span><br><span class="line">#define __dynamic_array(type, item)	type	item[];</span><br><span class="line"></span><br><span class="line">#undef F_STRUCT</span><br><span class="line">#define F_STRUCT(args...)		args</span><br><span class="line"></span><br><span class="line">#undef FTRACE_ENTRY</span><br><span class="line">#define FTRACE_ENTRY(name, struct_name, id, tstruct, print, filter)	\</span><br><span class="line">	struct struct_name &#123;						\</span><br><span class="line">		struct trace_entry	ent;				\</span><br><span class="line">		tstruct							\</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">#undef FTRACE_ENTRY_DUP</span><br><span class="line">#define FTRACE_ENTRY_DUP(name, name_struct, id, tstruct, printk, filter)</span><br><span class="line"></span><br><span class="line">#undef FTRACE_ENTRY_REG</span><br><span class="line">#define FTRACE_ENTRY_REG(name, struct_name, id, tstruct, print,	\</span><br><span class="line">			 filter, regfn) \</span><br><span class="line">	FTRACE_ENTRY(name, struct_name, id, PARAMS(tstruct), PARAMS(print), \</span><br><span class="line">		     filter)</span><br><span class="line"></span><br><span class="line">#include &quot;trace_entries.h&quot;</span><br></pre></td></tr></table></figure>
<p>FTRACE_ENTRY()宏第2次展开，定义了声明了外部变量extern struct trace_event_call event_##call：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#undef FTRACE_ENTRY</span><br><span class="line">#define FTRACE_ENTRY(call, struct_name, id, tstruct, print, filter)	\</span><br><span class="line">	extern struct trace_event_call					\</span><br><span class="line">	__aligned(4) event_##call;</span><br><span class="line">#undef FTRACE_ENTRY_DUP</span><br><span class="line">#define FTRACE_ENTRY_DUP(call, struct_name, id, tstruct, print, filter)	\</span><br><span class="line">	FTRACE_ENTRY(call, struct_name, id, PARAMS(tstruct), PARAMS(print), \</span><br><span class="line">		     filter)</span><br><span class="line">#include &quot;trace_entries.h&quot;</span><br></pre></td></tr></table></figure>
<p>3、kernel/trace/export.c：</p>
<p>FTRACE_ENTRY()宏第3次展开，定义了struct ____ftrace_##name：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#undef TRACE_SYSTEM</span><br><span class="line">#define TRACE_SYSTEM	ftrace</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * The FTRACE_ENTRY_REG macro allows ftrace entry to define register</span><br><span class="line"> * function and thus become accesible via perf.</span><br><span class="line"> */</span><br><span class="line">#undef FTRACE_ENTRY_REG</span><br><span class="line">#define FTRACE_ENTRY_REG(name, struct_name, id, tstruct, print, \</span><br><span class="line">			 filter, regfn) \</span><br><span class="line">	FTRACE_ENTRY(name, struct_name, id, PARAMS(tstruct), PARAMS(print), \</span><br><span class="line">		     filter)</span><br><span class="line"></span><br><span class="line">/* not needed for this file */</span><br><span class="line">#undef __field_struct</span><br><span class="line">#define __field_struct(type, item)</span><br><span class="line"></span><br><span class="line">#undef __field</span><br><span class="line">#define __field(type, item)				type item;</span><br><span class="line"></span><br><span class="line">#undef __field_desc</span><br><span class="line">#define __field_desc(type, container, item)		type item;</span><br><span class="line"></span><br><span class="line">#undef __array</span><br><span class="line">#define __array(type, item, size)			type item[size];</span><br><span class="line"></span><br><span class="line">#undef __array_desc</span><br><span class="line">#define __array_desc(type, container, item, size)	type item[size];</span><br><span class="line"></span><br><span class="line">#undef __dynamic_array</span><br><span class="line">#define __dynamic_array(type, item)			type item[];</span><br><span class="line"></span><br><span class="line">#undef F_STRUCT</span><br><span class="line">#define F_STRUCT(args...)				args</span><br><span class="line"></span><br><span class="line">#undef F_printk</span><br><span class="line">#define F_printk(fmt, args...) fmt, args</span><br><span class="line"></span><br><span class="line">#undef FTRACE_ENTRY</span><br><span class="line">#define FTRACE_ENTRY(name, struct_name, id, tstruct, print, filter)	\</span><br><span class="line">struct ____ftrace_##name &#123;						\</span><br><span class="line">	tstruct								\</span><br><span class="line">&#125;;									\</span><br><span class="line">static void __always_unused ____ftrace_check_##name(void)		\</span><br><span class="line">&#123;									\</span><br><span class="line">	struct ____ftrace_##name *__entry = NULL;			\</span><br><span class="line">									\</span><br><span class="line">	/* force compile-time check on F_printk() */			\</span><br><span class="line">	printk(print);							\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#undef FTRACE_ENTRY_DUP</span><br><span class="line">#define FTRACE_ENTRY_DUP(name, struct_name, id, tstruct, print, filter)	\</span><br><span class="line">	FTRACE_ENTRY(name, struct_name, id, PARAMS(tstruct), PARAMS(print), \</span><br><span class="line">		     filter)</span><br><span class="line"></span><br><span class="line">#include &quot;trace_entries.h&quot;</span><br></pre></td></tr></table></figure>
<p>FTRACE_ENTRY()宏第4次展开，定义了ftrace_define_fields_##name()：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#undef __field</span><br><span class="line">#define __field(type, item)						\</span><br><span class="line">	ret = trace_define_field(event_call, #type, #item,		\</span><br><span class="line">				 offsetof(typeof(field), item),		\</span><br><span class="line">				 sizeof(field.item),			\</span><br><span class="line">				 is_signed_type(type), filter_type);	\</span><br><span class="line">	if (ret)							\</span><br><span class="line">		return ret;</span><br><span class="line"></span><br><span class="line">#undef __field_desc</span><br><span class="line">#define __field_desc(type, container, item)	\</span><br><span class="line">	ret = trace_define_field(event_call, #type, #item,		\</span><br><span class="line">				 offsetof(typeof(field),		\</span><br><span class="line">					  container.item),		\</span><br><span class="line">				 sizeof(field.container.item),		\</span><br><span class="line">				 is_signed_type(type), filter_type);	\</span><br><span class="line">	if (ret)							\</span><br><span class="line">		return ret;</span><br><span class="line"></span><br><span class="line">#undef __array</span><br><span class="line">#define __array(type, item, len)					\</span><br><span class="line">	do &#123;								\</span><br><span class="line">		char *type_str = #type&quot;[&quot;__stringify(len)&quot;]&quot;;		\</span><br><span class="line">		BUILD_BUG_ON(len &gt; MAX_FILTER_STR_VAL);			\</span><br><span class="line">		ret = trace_define_field(event_call, type_str, #item,	\</span><br><span class="line">				 offsetof(typeof(field), item),		\</span><br><span class="line">				 sizeof(field.item),			\</span><br><span class="line">				 is_signed_type(type), filter_type);	\</span><br><span class="line">		if (ret)						\</span><br><span class="line">			return ret;					\</span><br><span class="line">	&#125; while (0);</span><br><span class="line"></span><br><span class="line">#undef __array_desc</span><br><span class="line">#define __array_desc(type, container, item, len)			\</span><br><span class="line">	BUILD_BUG_ON(len &gt; MAX_FILTER_STR_VAL);				\</span><br><span class="line">	ret = trace_define_field(event_call, #type &quot;[&quot; #len &quot;]&quot;, #item,	\</span><br><span class="line">				 offsetof(typeof(field),		\</span><br><span class="line">					  container.item),		\</span><br><span class="line">				 sizeof(field.container.item),		\</span><br><span class="line">				 is_signed_type(type), filter_type);	\</span><br><span class="line">	if (ret)							\</span><br><span class="line">		return ret;</span><br><span class="line"></span><br><span class="line">#undef __dynamic_array</span><br><span class="line">#define __dynamic_array(type, item)					\</span><br><span class="line">	ret = trace_define_field(event_call, #type, #item,		\</span><br><span class="line">				 offsetof(typeof(field), item),		\</span><br><span class="line">				 0, is_signed_type(type), filter_type);\</span><br><span class="line">	if (ret)							\</span><br><span class="line">		return ret;</span><br><span class="line"></span><br><span class="line">#undef FTRACE_ENTRY</span><br><span class="line">#define FTRACE_ENTRY(name, struct_name, id, tstruct, print, filter)	\</span><br><span class="line">static int __init							\</span><br><span class="line">ftrace_define_fields_##name(struct trace_event_call *event_call)	\</span><br><span class="line">&#123;									\</span><br><span class="line">	struct struct_name field;					\</span><br><span class="line">	int ret;							\</span><br><span class="line">	int filter_type = filter;					\</span><br><span class="line">									\</span><br><span class="line">	tstruct;							\</span><br><span class="line">									\</span><br><span class="line">	return ret;							\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#include &quot;trace_entries.h&quot;</span><br></pre></td></tr></table></figure>
<p>FTRACE_ENTRY()宏第5次展开，定义了struct trace_event_call <strong>used event_##call和struct trace_event_class </strong>refdata event_class_ftrace_##call：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#undef __entry</span><br><span class="line">#define __entry REC</span><br><span class="line"></span><br><span class="line">#undef __field</span><br><span class="line">#define __field(type, item)</span><br><span class="line"></span><br><span class="line">#undef __field_desc</span><br><span class="line">#define __field_desc(type, container, item)</span><br><span class="line"></span><br><span class="line">#undef __array</span><br><span class="line">#define __array(type, item, len)</span><br><span class="line"></span><br><span class="line">#undef __array_desc</span><br><span class="line">#define __array_desc(type, container, item, len)</span><br><span class="line"></span><br><span class="line">#undef __dynamic_array</span><br><span class="line">#define __dynamic_array(type, item)</span><br><span class="line"></span><br><span class="line">#undef F_printk</span><br><span class="line">#define F_printk(fmt, args...) __stringify(fmt) &quot;, &quot;  __stringify(args)</span><br><span class="line"></span><br><span class="line">#undef FTRACE_ENTRY_REG</span><br><span class="line">#define FTRACE_ENTRY_REG(call, struct_name, etype, tstruct, print, filter,\</span><br><span class="line">			 regfn)						\</span><br><span class="line">									\</span><br><span class="line">struct trace_event_class __refdata event_class_ftrace_##call = &#123;	\</span><br><span class="line">	.system			= __stringify(TRACE_SYSTEM),		\</span><br><span class="line">	.define_fields		= ftrace_define_fields_##call,		\</span><br><span class="line">	.fields			= LIST_HEAD_INIT(event_class_ftrace_##call.fields),\</span><br><span class="line">	.reg			= regfn,				\</span><br><span class="line">&#125;;									\</span><br><span class="line">									\</span><br><span class="line">struct trace_event_call __used event_##call = &#123;				\</span><br><span class="line">	.class			= &amp;event_class_ftrace_##call,		\</span><br><span class="line">	&#123;								\</span><br><span class="line">		.name			= #call,			\</span><br><span class="line">	&#125;,								\</span><br><span class="line">	.event.type		= etype,				\</span><br><span class="line">	.print_fmt		= print,				\</span><br><span class="line">	.flags			= TRACE_EVENT_FL_IGNORE_ENABLE,		\</span><br><span class="line">&#125;;									\</span><br><span class="line">struct trace_event_call __used						\</span><br><span class="line">__attribute__((section(&quot;_ftrace_events&quot;))) *__event_##call = &amp;event_##call;</span><br><span class="line"></span><br><span class="line">#undef FTRACE_ENTRY</span><br><span class="line">#define FTRACE_ENTRY(call, struct_name, etype, tstruct, print, filter)	\</span><br><span class="line">	FTRACE_ENTRY_REG(call, struct_name, etype,			\</span><br><span class="line">			 PARAMS(tstruct), PARAMS(print), filter, NULL)</span><br><span class="line"></span><br><span class="line">bool ftrace_event_is_function(struct trace_event_call *call)</span><br><span class="line">&#123;</span><br><span class="line">	return call == &amp;event_function;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#include &quot;trace_entries.h&quot;</span><br></pre></td></tr></table></figure>
<h2 id="4-3、数据存入"><a href="#4-3、数据存入" class="headerlink" title="4.3、数据存入"></a>4.3、数据存入</h2><p>在trace_printk()定义一节中已经详细描述了3种(TRACE_BPRINT、TRACE_PRINT、TRACE_BPUTS)trace_event_call的数据存入过程。这里简单图示一下它们的数据存储结构：</p>
<p><img src="/images/ftrace_trace_event/entry_tracepintk_format.png" alt="image"></p>
<h2 id="4-4、数据读出"><a href="#4-4、数据读出" class="headerlink" title="4.4、数据读出"></a>4.4、数据读出</h2><p>trace_printk()默认样式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> # cat trace</span><br><span class="line"># tracer: function</span><br><span class="line">#</span><br><span class="line"># entries-in-buffer/entries-written: 45/45   #P:8</span><br><span class="line">#</span><br><span class="line">#                              _-----=&gt; irqs-off</span><br><span class="line">#                             / _----=&gt; need-resched</span><br><span class="line">#                            | / _---=&gt; hardirq/softirq</span><br><span class="line">#                            || / _--=&gt; preempt-depth</span><br><span class="line">#                            ||| /     delay</span><br><span class="line">#           TASK-PID   CPU#  ||||    TIMESTAMP  FUNCTION</span><br><span class="line">#              | |       |   ||||       |         |</span><br><span class="line">              sh-18299 [000] .... 663030.727868: set_trigger_filter: [set_trigger_filter] data = 0xfffffff11a12cd00, filter_str = 0x0</span><br></pre></td></tr></table></figure>
<p>在kernel/trace/trace_ouput.c文件中，注册了系统默认的几种trace_event：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">static struct trace_event *events[] __initdata = &#123;</span><br><span class="line">	&amp;trace_fn_event,</span><br><span class="line">	&amp;trace_graph_ent_event,</span><br><span class="line">	&amp;trace_graph_ret_event,</span><br><span class="line">	&amp;trace_ctx_event,</span><br><span class="line">	&amp;trace_wake_event,</span><br><span class="line">	&amp;trace_stack_event,</span><br><span class="line">	&amp;trace_user_stack_event,</span><br><span class="line">	&amp;trace_bputs_event,</span><br><span class="line">	&amp;trace_bprint_event,</span><br><span class="line">	&amp;trace_print_event,</span><br><span class="line">	NULL</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">__init static int init_events(void)</span><br><span class="line">&#123;</span><br><span class="line">	struct trace_event *event;</span><br><span class="line">	int i, ret;</span><br><span class="line"></span><br><span class="line">	for (i = 0; events[i]; i++) &#123;</span><br><span class="line">		event = events[i];</span><br><span class="line"></span><br><span class="line">		ret = register_trace_event(event);</span><br><span class="line">		if (!ret) &#123;</span><br><span class="line">			printk(KERN_WARNING &quot;event %d failed to register\n&quot;,</span><br><span class="line">			       event-&gt;type);</span><br><span class="line">			WARN_ON_ONCE(1);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">/* (1) TRACE_BPUTS对应的trace_event 和 event-&gt;funcs-&gt;trace()函数 */</span><br><span class="line">static struct trace_event_functions trace_bputs_funcs = &#123;</span><br><span class="line">	.trace		= trace_bputs_print,</span><br><span class="line">	.raw		= trace_bputs_raw,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct trace_event trace_bputs_event = &#123;</span><br><span class="line">	.type		= TRACE_BPUTS,</span><br><span class="line">	.funcs		= &amp;trace_bputs_funcs,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">/* (2) TRACE_BPRINT对应的trace_event 和 event-&gt;funcs-&gt;trace()函数 */</span><br><span class="line">static struct trace_event_functions trace_bprint_funcs = &#123;</span><br><span class="line">	.trace		= trace_bprint_print,</span><br><span class="line">	.raw		= trace_bprint_raw,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct trace_event trace_bprint_event = &#123;</span><br><span class="line">	.type		= TRACE_BPRINT,</span><br><span class="line">	.funcs		= &amp;trace_bprint_funcs,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">/* (3) TRACE_PRINT对应的trace_event 和 event-&gt;funcs-&gt;trace()函数 */</span><br><span class="line">static struct trace_event_functions trace_print_funcs = &#123;</span><br><span class="line">	.trace		= trace_print_print,</span><br><span class="line">	.raw		= trace_print_raw,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct trace_event trace_print_event = &#123;</span><br><span class="line">	.type	 	= TRACE_PRINT,</span><br><span class="line">	.funcs		= &amp;trace_print_funcs,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在数据读出时，会调用到event对应的event-&gt;funcs-&gt;trace()函数，seq_read() -&gt; s_show() -&gt; print_trace_line() -&gt; print_trace_fmt() -&gt; event-&gt;funcs-&gt;trace()：</p>
<p>1、TRACE_BPUTS，event-&gt;funcs-&gt;trace()对应trace_bputs_print()：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static enum print_line_t</span><br><span class="line">trace_bputs_print(struct trace_iterator *iter, int flags,</span><br><span class="line">		   struct trace_event *event)</span><br><span class="line">&#123;</span><br><span class="line">	struct trace_entry *entry = iter-&gt;ent;</span><br><span class="line">	struct trace_seq *s = &amp;iter-&gt;seq;</span><br><span class="line">	struct bputs_entry *field;</span><br><span class="line"></span><br><span class="line">	trace_assign_type(field, entry);</span><br><span class="line"></span><br><span class="line">	seq_print_ip_sym(s, field-&gt;ip, flags);</span><br><span class="line">	trace_seq_puts(s, &quot;: &quot;);</span><br><span class="line">	trace_seq_puts(s, field-&gt;str);</span><br><span class="line"></span><br><span class="line">	return trace_handle_return(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、TRACE_BPRINT，event-&gt;funcs-&gt;trace()对应trace_bprint_print()：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static enum print_line_t</span><br><span class="line">trace_bprint_print(struct trace_iterator *iter, int flags,</span><br><span class="line">		   struct trace_event *event)</span><br><span class="line">&#123;</span><br><span class="line">	struct trace_entry *entry = iter-&gt;ent;</span><br><span class="line">	struct trace_seq *s = &amp;iter-&gt;seq;</span><br><span class="line">	struct bprint_entry *field;</span><br><span class="line"></span><br><span class="line">	trace_assign_type(field, entry);</span><br><span class="line"></span><br><span class="line">	seq_print_ip_sym(s, field-&gt;ip, flags);</span><br><span class="line">	trace_seq_puts(s, &quot;: &quot;);</span><br><span class="line">	trace_seq_bprintf(s, field-&gt;fmt, field-&gt;buf);</span><br><span class="line"></span><br><span class="line">	return trace_handle_return(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、TRACE_PRINT，event-&gt;funcs-&gt;trace()对应trace_print_print()：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static enum print_line_t trace_print_print(struct trace_iterator *iter,</span><br><span class="line">					   int flags, struct trace_event *event)</span><br><span class="line">&#123;</span><br><span class="line">	struct print_entry *field;</span><br><span class="line">	struct trace_seq *s = &amp;iter-&gt;seq;</span><br><span class="line"></span><br><span class="line">	trace_assign_type(field, iter-&gt;ent);</span><br><span class="line"></span><br><span class="line">	seq_print_ip_sym(s, field-&gt;ip, flags);</span><br><span class="line">	trace_seq_printf(s, &quot;: %s&quot;, field-&gt;buf);</span><br><span class="line"></span><br><span class="line">	return trace_handle_return(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p><a href="https://lwn.net/Articles/379903/" target="_blank" rel="noopener">1、Using the TRACE_EVENT() macro (Part 1)</a><br><a href="https://lwn.net/Articles/381064/" target="_blank" rel="noopener">2、Using the TRACE_EVENT() macro (Part 2)</a><br><a href="https://lwn.net/Articles/383362/" target="_blank" rel="noopener">3、Using the TRACE_EVENT() macro (Part 3)</a>  </p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/trace-event/" rel="tag"># trace event</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/05/24/ftrace_use_uprobe_event/" rel="next" title="Linux Ftrace 2.4、uprobe event的使用">
                <i class="fa fa-chevron-left"></i> Linux Ftrace 2.4、uprobe event的使用
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/06/08/ftrace_tracer/" rel="prev" title="Linux Ftrace 1.3、tracer (function、function_graph、irq_off)">
                Linux Ftrace 1.3、tracer (function、function_graph、irq_off) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/touxiang/ycqs.jpg" alt="pwl999">
            
              <p class="site-author-name" itemprop="name">pwl999</p>
              <p class="site-description motion-element" itemprop="description">RTFSC(Read The Fucking Source Code)</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives">
                
                    <span class="site-state-item-count">30</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">3</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">22</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1、函数插桩"><span class="nav-number">1.</span> <span class="nav-text">1、函数插桩</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1、trace-point"><span class="nav-number">1.1.</span> <span class="nav-text">1.1、trace point</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2、增加一个新的trace-event"><span class="nav-number">1.2.</span> <span class="nav-text">1.2、增加一个新的trace event</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3、TRACE-EVENT-宏的解析"><span class="nav-number">1.3.</span> <span class="nav-text">1.3、TRACE_EVENT()宏的解析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4、trace初始化"><span class="nav-number">1.4.</span> <span class="nav-text">1.4、trace初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-5、event-enable"><span class="nav-number">1.5.</span> <span class="nav-text">1.5、event enable</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-6、”soft-disable”模式"><span class="nav-number">1.6.</span> <span class="nav-text">1.6、”soft disable”模式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2、数据存入"><span class="nav-number">2.</span> <span class="nav-text">2、数据存入</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1、数据格式"><span class="nav-number">2.1.</span> <span class="nav-text">2.1、数据格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2、trigger-command"><span class="nav-number">2.2.</span> <span class="nav-text">2.2、trigger command</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3、filter"><span class="nav-number">2.3.</span> <span class="nav-text">2.3、filter</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3、数据取出"><span class="nav-number">3.</span> <span class="nav-text">3、数据取出</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1、“trace”文件的读取"><span class="nav-number">3.1.</span> <span class="nav-text">3.1、“trace”文件的读取</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4、trace-printk"><span class="nav-number">4.</span> <span class="nav-text">4、trace_printk()</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1、trace-printk-定义"><span class="nav-number">4.1.</span> <span class="nav-text">4.1、trace_printk()定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2、FTRACE-ENTRY-宏的展开"><span class="nav-number">4.2.</span> <span class="nav-text">4.2、FTRACE_ENTRY()宏的展开</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3、数据存入"><span class="nav-number">4.3.</span> <span class="nav-text">4.3、数据存入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4、数据读出"><span class="nav-number">4.4.</span> <span class="nav-text">4.4、数据读出</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考资料："><span class="nav-number">5.</span> <span class="nav-text">参考资料：</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">pwl999</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v6.6.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script src="/js/src/utils.js?v=6.6.0"></script>

  <script src="/js/src/motion.js?v=6.6.0"></script>



  
  


  <script src="/js/src/affix.js?v=6.6.0"></script>

  <script src="/js/src/schemes/pisces.js?v=6.6.0"></script>



  
  <script src="/js/src/scrollspy.js?v=6.6.0"></script>
<script src="/js/src/post-details.js?v=6.6.0"></script>



  


  <script src="/js/src/bootstrap.js?v=6.6.0"></script>



  

  
    <script id="dsq-count-scr" src="https://.disqus.com/count.js" async></script>
  

  





  











  





  

  

  

  

  

  
  

  

  

  

  

  

  

</body>
</html>
