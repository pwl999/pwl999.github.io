<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
































<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.6.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.6.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.6.0" color="#222">









<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.6.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="1、binder原理纵观现有市面上所有讲binder的文章，都存在一个最大的问题：没有讲清楚binder对象是什么？不清楚binder对象是什么，那就不能理解handle是什么？不能理解什么时候是binder什么时候是handle，那就不能真正理解整个IPC的通讯过程。 我们首先回到binder的目的，就是IPC(Inter-Process Communication)进程间通讯。那么怎么样实现进">
<meta name="keywords" content="binder">
<meta property="og:type" content="article">
<meta property="og:title" content="Android Binder">
<meta property="og:url" content="http://yoursite.com/2018/12/12/android_binder/index.html">
<meta property="og:site_name" content="pwl999&#39;s blog">
<meta property="og:description" content="1、binder原理纵观现有市面上所有讲binder的文章，都存在一个最大的问题：没有讲清楚binder对象是什么？不清楚binder对象是什么，那就不能理解handle是什么？不能理解什么时候是binder什么时候是handle，那就不能真正理解整个IPC的通讯过程。 我们首先回到binder的目的，就是IPC(Inter-Process Communication)进程间通讯。那么怎么样实现进">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/images/android_binder/binder_parcel_binder_object_format.png">
<meta property="og:image" content="http://yoursite.com/images/android_binder/binder_binderobj_and_handle.png">
<meta property="og:image" content="http://yoursite.com/images/android_binder/binder_parcel_fd_object_format.png">
<meta property="og:image" content="http://yoursite.com/images/android_binder/binder_fdobject_translate.png">
<meta property="og:image" content="http://yoursite.com/images/android_binder/binder_alloc_buffer.png">
<meta property="og:image" content="http://yoursite.com/images/android_binder/binder_alloc_buffer_transaction.png">
<meta property="og:image" content="http://yoursite.com/images/android_binder/binder_action_servicemanager_init.png">
<meta property="og:image" content="http://yoursite.com/images/android_binder/binder_action_serviceserver_addservice.png">
<meta property="og:image" content="http://yoursite.com/images/android_binder/binder_action_serviceclient_getservice_send.png">
<meta property="og:image" content="http://yoursite.com/images/android_binder/binder_action_serviceclient_getservice_reply.png">
<meta property="og:image" content="http://yoursite.com/images/android_binder/binder_action_serviceclient_callservice.png">
<meta property="og:image" content="http://yoursite.com/images/android_binder/binder_transcation_3_copy.png">
<meta property="og:image" content="http://yoursite.com/images/android_binder/binder_transcation_Scatter-gather_1_copy.png">
<meta property="og:image" content="http://yoursite.com/images/android_binder/binder_native_process_thread.png">
<meta property="og:image" content="http://yoursite.com/images/android_binder/binder_class_manager.jpg">
<meta property="og:image" content="http://yoursite.com/images/android_binder/binder_class_server.jpg">
<meta property="og:image" content="http://yoursite.com/images/android_binder/binder_class_client.jpg">
<meta property="og:updated_time" content="2019-01-14T02:21:26.888Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android Binder">
<meta name="twitter:description" content="1、binder原理纵观现有市面上所有讲binder的文章，都存在一个最大的问题：没有讲清楚binder对象是什么？不清楚binder对象是什么，那就不能理解handle是什么？不能理解什么时候是binder什么时候是handle，那就不能真正理解整个IPC的通讯过程。 我们首先回到binder的目的，就是IPC(Inter-Process Communication)进程间通讯。那么怎么样实现进">
<meta name="twitter:image" content="http://yoursite.com/images/android_binder/binder_parcel_binder_object_format.png">






  <link rel="canonical" href="http://yoursite.com/2018/12/12/android_binder/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Android Binder | pwl999's blog</title>
  












  <noscript>
  <style>
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion .logo-line-before i { left: initial; }
    .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">pwl999's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/12/android_binder/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="pwl999">
      <meta itemprop="description" content="RTFSC(Read The Fucking Source Code)">
      <meta itemprop="image" content="/images/touxiang/ycqs.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="pwl999's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Android Binder

              
            
          </h1>
        

        <div class="post-meta">

          
            <i class="fa fa-thumb-tack"></i>
            <font color="7D26CD">置顶</font>
            <span class="post-meta-divider">|</span>
          

        <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-12 19:32:31" itemprop="dateCreated datePublished" datetime="2018-12-12T19:32:31+08:00">2018-12-12</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-01-14 10:21:26" itemprop="dateModified" datetime="2019-01-14T10:21:26+08:00">2019-01-14</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/12/12/android_binder/#comments" itemprop="discussionUrl">
                
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/12/12/android_binder/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="1、binder原理"><a href="#1、binder原理" class="headerlink" title="1、binder原理"></a>1、binder原理</h1><p>纵观现有市面上所有讲binder的文章，都存在一个最大的问题：没有讲清楚binder对象是什么？<br>不清楚binder对象是什么，那就不能理解handle是什么？不能理解什么时候是binder什么时候是handle，那就不能真正理解整个IPC的通讯过程。</p>
<p>我们首先回到binder的目的，就是IPC(Inter-Process Communication)进程间通讯。那么怎么样实现进程间通讯呢？要素有三个：</p>
<ul>
<li>函数指针；</li>
<li>函数参数；</li>
<li>函数返回值；</li>
</ul>
<p>binder通讯的本质实际上非常简单，就是client、server双方在共享内存的基础上封装成自定义api函数，并无神奇之处。我们看看他是怎么和IPC三要素对应上的：</p>
<h2 id="1-1、IPC函数指针"><a href="#1-1、IPC函数指针" class="headerlink" title="1.1、IPC函数指针"></a>1.1、IPC函数指针</h2><p>binder的service_server可以向service_client提供service服务，但反过来不行。所以binder service其实是单向的，只有service_server端才能提供service函数，且函数只能在service_server端运行。</p>
<p>大部分情况下：<strong>service_server端提供的一组IPC服务本地函数</strong>，就是<strong>binder对象</strong>。</p>
<p>例如，mediaserver注册的一系列service中的一个”media.player”：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/frameworks/av/media/mediaserver/main_mediaserver.cpp:</span><br><span class="line">int main(int argc __unused, char **argv __unused)</span><br><span class="line">&#123;</span><br><span class="line">    MediaPlayerService::instantiate();</span><br><span class="line">&#125;</span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">/frameworks/av/media/libmediaplayerservice/MediaPlayerService.cpp:</span><br><span class="line">void MediaPlayerService::instantiate() &#123;</span><br><span class="line">    defaultServiceManager()-&gt;addService(</span><br><span class="line">            String16(&quot;media.player&quot;), new MediaPlayerService());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>service_server提供了一组可以在server本地运行的函数，即<strong>binder对象</strong>。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/frameworks/av/media/libmedia/IMediaPlayerService.cpp:</span><br><span class="line">status_t BnMediaPlayerService::onTransact(</span><br><span class="line">    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    switch (code) &#123;</span><br><span class="line">        case CREATE: &#123;</span><br><span class="line">            CHECK_INTERFACE(IMediaPlayerService, data, reply);</span><br><span class="line">            sp&lt;IMediaPlayerClient&gt; client =</span><br><span class="line">                interface_cast&lt;IMediaPlayerClient&gt;(data.readStrongBinder());</span><br><span class="line">            audio_session_t audioSessionId = (audio_session_t) data.readInt32();</span><br><span class="line">            sp&lt;IMediaPlayer&gt; player = create(client, audioSessionId);</span><br><span class="line">            reply-&gt;writeStrongBinder(IInterface::asBinder(player));</span><br><span class="line">            return NO_ERROR;</span><br><span class="line">        &#125; break;</span><br><span class="line">        case CREATE_MEDIA_RECORDER: &#123;</span><br><span class="line">            CHECK_INTERFACE(IMediaPlayerService, data, reply);</span><br><span class="line">            const String16 opPackageName = data.readString16();</span><br><span class="line">            sp&lt;IMediaRecorder&gt; recorder = createMediaRecorder(opPackageName);</span><br><span class="line">            reply-&gt;writeStrongBinder(IInterface::asBinder(recorder));</span><br><span class="line">            return NO_ERROR;</span><br><span class="line">        &#125; break;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在service_client端可以通过<strong>handle</strong>来引用这个<strong>binder对象</strong>，还封装了一系列与之对应的函数来组织数据。但是这些函数实际上是通讯用的，函数的实际功能并不能在client本地执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/frameworks/av/media/libmedia/IMediaPlayerService.cpp:</span><br><span class="line">class BpMediaPlayerService: public BpInterface&lt;IMediaPlayerService&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    virtual sp&lt;IMediaPlayer&gt; create(</span><br><span class="line">            const sp&lt;IMediaPlayerClient&gt;&amp; client, audio_session_t audioSessionId) &#123;</span><br><span class="line">        Parcel data, reply;</span><br><span class="line">        data.writeInterfaceToken(IMediaPlayerService::getInterfaceDescriptor());</span><br><span class="line">        data.writeStrongBinder(IInterface::asBinder(client));</span><br><span class="line">        data.writeInt32(audioSessionId);</span><br><span class="line"></span><br><span class="line">        remote()-&gt;transact(CREATE, data, &amp;reply);</span><br><span class="line">        return interface_cast&lt;IMediaPlayer&gt;(reply.readStrongBinder());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual sp&lt;IMediaRecorder&gt; createMediaRecorder(const String16 &amp;opPackageName)</span><br><span class="line">    &#123;</span><br><span class="line">        Parcel data, reply;</span><br><span class="line">        data.writeInterfaceToken(IMediaPlayerService::getInterfaceDescriptor());</span><br><span class="line">        data.writeString16(opPackageName);</span><br><span class="line">        remote()-&gt;transact(CREATE_MEDIA_RECORDER, data, &amp;reply);</span><br><span class="line">        return interface_cast&lt;IMediaRecorder&gt;(reply.readStrongBinder());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>所以理解<strong>binder对象</strong>和<strong>handle</strong>是非常关键的。service_server端需要在本地执行函数，所以执行时函数调用的3要素(函数、参数、返回值)都必须是本地的，所以它必须拥有一组函数的<strong>binder对象</strong>；service_client端不需要在本地执行，所以它没有函数集的<strong>binder对象</strong>，它只有函数集的远端引用<strong>handle</strong>。</p>
<p>binder通讯的3个主角：service_mannager、service_server、service_client。在各种场景下，分别的<strong>binder对象</strong>和<strong>handle</strong>关系如下：</p>
<table border="1"><br><caption> binder object_handle </caption><br><br><tr><br><th style="width: 200px;">场景</th><br><th style="width: 400px;">client</th><br><th style="width: 400px;">server</th><br></tr><br><br><tr><br><td> service_manage初始化 </td><br><td><br>service_manager:<br><br><br>本地的binder对象为svcmgr_handler()函数集；<br><br>通过ioctl BINDER_SET_CONTEXT_MGR命令把该binder对象注册成全局handle0；<br><br></td><br><td><br>binder device：<br><br><br>创建handle0引用，指向service_manager<br></td><br></tr><br><br><tr><br><td> service_server的addService </td><br><td><br>service_server:<br><br><br>target handle：handle0<br><br>data：binder对象为一组本地service函数集；<br><br></td><br><td><br>service_manager：<br><br><br>binder驱动会创建对该binder对象的引用handle<br><br>通过SVC_MGR_ADD_SERVICE命令把该handle加入到service_manage的handle链表中；<br><br></td><br></tr><br><br><tr><br><td> service_client的get_service </td><br><td><br>service_client:<br><br><br>target handle：handle0<br><br>data：service name。整个过程中没有binder对象的参与。<br><br>向service_manager获取service_server的service函数的handle；<br><br></td><br><td><br>service_manage：<br><br><br>SVC_MGR_GET_SERVICE命令，通过service的name在service_manage的handle链表中查找对应的handle，并且把handle返回给service_client；<br><br>这样对于service_server的binder对象，service_client和service_manage都持有它的handle了；<br></td><br></tr><br><br><tr><br><td> service_client调用service </td><br><td><br>service_client:<br><br><br>target handle：serive handle0。上一步获取的handle。<br><br>data：调用参数。调用参数中也可能包含handle/binder对象。(看server端的处理)<br><br></td><br><td><br>service_server：<br><br><br>驱动把target handle翻译成本地binder对象，调用对象提供的本地函数。<br><br>对于data中可能包含的含handle/binder对象的处理：<br><br>1、如果包含的handle是本进程binder的引用，把它翻译成本地binder，在本地可以运行；<br><br>2、如果包含的handle不是本进程binder的引用，只能给它创建一份新的引用handle。这个handle也不能在server进程中运行，只能向其他service_server请求服务；<br><br>3、不可能包含binder对象，因为client进程的binder对象在service_server进程中无法运行；<br><br></td><br></tr><br><br></table>

<p>衍生出的原则如下：</p>
<ul>
<li>service_server类的进程只有<strong>binder对象</strong>，没有<strong>handle</strong>(除了handle0)，因为它所有操作都必须本地执行，引用远程对象毫无意义；</li>
<li>service_client类的进程只有<strong>handle</strong>，没有<strong>binder对象</strong>，因为它需要远程执行service不需要本地执行；</li>
<li>service_mannager进程同时有<strong>binder对象</strong>和<strong>handle</strong>，它本地<strong>binder对象</strong>的作用就是操作所有其他进程的<strong>handle</strong>；</li>
</ul>
<h2 id="1-2、IPC函数参数"><a href="#1-2、IPC函数参数" class="headerlink" title="1.2、IPC函数参数"></a>1.2、IPC函数参数</h2><p>如上一节描述，service_client可以通过名字向service_manage查询得到handle。这个handle就相当于远程的函数集指针。<br>但是对于一个函数调用，我们除了需要函数指针，还需要传递参数。  </p>
<p>binder使用parcel方式来打包函数参数和返回值。parcel可以用来传递几种类型的数据：</p>
<ul>
<li>普通类型的少量数据；</li>
<li>binder对象/handle(struct flat_binder_object);</li>
<li>fd(struct binder_fd_object)；</li>
</ul>
<p>下面详细描述每种情况的parcel包格式和承载的内容。</p>
<ul>
<li>1、普通类型的少量数据：</li>
</ul>
<p>这种普通类型(int/long/string…)的少量数据存储最为简单，存入时按照一定的顺序存入，取出时按照数据的排列格式取出即可。</p>
<ul>
<li>2、<strong>binder对象</strong>/<strong>handle</strong>(struct flat_binder_object)：</li>
</ul>
<p>这一类型数据的parcel包格式如下： </p>
<p><img src="/images/android_binder/binder_parcel_binder_object_format.png" alt="binder_parcel_binder_object_format"></p>
<p>可以看到这种类型的parcel包中包含了两种数据：data0/data1/…是普通类型数据；binder_obj0/binder_obj1/…是binder对象，binder_obj0 offset/binder_obj1 offset/…指出了了binder对象在parcel包中的偏移；</p>
<p>binder对象和handle共用结构体struct flat_binder_object。</p>
<p>上一节说过<strong>binder对象</strong>其实就是一组函数的指针，但是一个指针只需要一个long类型就可以标识了，为什么还需要用一个结构体struct flat_binder_object来传递。我理解下来主要的思想如下：使用binder都是面向对象语言c++/java，它们把函数组也要实例化成一个对象，一个对象只有被引用时才不会被回收，远程引用也需要让本地引用加1。</p>
<p>一组service函数，对本地进程来说就是binder，对其他需要使用的进程来说需要远程引用，就是handle，是一对多的关系。关系图如下：</p>
<p><img src="/images/android_binder/binder_binderobj_and_handle.png" alt="binder_binderobj_and_handle"></p>
<p>binder object是service_server的一个“local binder object”，service_manager和service_client创建了多个远程引用“remote handle”。</p>
<p>这个其实就是binder的核心思想，binder花费了大量的代码在维护这个关系上面：</p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> service_server进程在驱动中创建了binder_node节点来保存<strong>binder对象</strong>，把本进程所有的binder_node都挂载在一颗红黑树proc-&gt;nodes上；</li>
<li style="list-style: none"><input type="checkbox" checked> service_manager和service_client每个新进程对这个<strong>binder对象</strong>引用，就创建一个新的binder_ref，它的值就是<strong>handle</strong>，并回指向binder_node。并且把本进程对其他service_server的引用都挂载到两颗红黑树proc-&gt;refs_by_node/proc-&gt;refs_by_desc上。并且远程引用会增加service_server进程关于<strong>binder对象</strong>的引用计数；</li>
</ul>
<p>binder驱动负责建立起<strong>binder对象</strong>和<strong>handle</strong>之间的映射关系，创建上述的数据结构，并负责翻译：</p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> service_server把本地<strong>binder对象</strong>向service_manager注册。会在service_manager进程本地建立起binder_node，驱动会在service_manager进程中建立起对应的binder_ref引用，那么service_manager进程能看到的其实就是本进程对service_server<strong>binder对象</strong>的一个引用，并不能看到<strong>binder对象</strong>原始值；</li>
<li style="list-style: none"><input type="checkbox" checked> service_client根据名字向service_manager查询service。service_manager会返回本进程的handle，在内核中该handle会转换成<strong>binder对象</strong>binder_node。因为service_client不是service的本地进程，所以service_client不能得到<strong>binder对象</strong>，它只能得到引用<strong>handle</strong>。所以再针对service的<strong>binder对象</strong>创建一份service_client进程的本地引用；</li>
<li><p>[x] service_client调用远程service_server的service。内核判断handle引用是service_server的本地对象，就把handle转换成service_server的<strong>binder对象</strong>；</p>
</li>
<li><p>3、fd(struct binder_fd_object)：</p>
</li>
</ul>
<p>parcel还能传输文件句柄fd，此时的包格式如下：</p>
<p><img src="/images/android_binder/binder_parcel_fd_object_format.png" alt="binder_parcel_fd_object_format"></p>
<p>传输fd的意义何在呢？当binder的两个进程间需要传输大量的数据。例如：图像声音数据、或者是一个对象。可以在匿名共享内存(Ashmem)中创建一块区域，源进程会得到一个相应的fd，再把这个fd使用binder传递给目的进程，就可以共享数据了。</p>
<p>需要特别说明的是对象的传递，在同一个进程内进行函数调用的话，参数对象通常是使用引用的方式传递的。但是如果是跨进程的调用，是没有办法引用的，只有把整个对象复制过去。这种操作叫做对象的序列化，java称为Serializable，android有优化的实现Parcelable。注意对象序列化的Parcelable和binder的parcel数据封装不是一回事，尽管他们原理上很相似。binder并没有提供对象Parcelable的接口，如果我们要跨进程传输对象，只能把对象序列化(Parcelable)到匿名共享内存中，再把对应fd通过binder传输给目的进程。</p>
<p><img src="/images/android_binder/binder_fdobject_translate.png" alt="binder_fdobject_translate"></p>
<p>binder驱动在检测到传输的是fd，会在新的进程中分配一个新的fd，并指向原来的file结构，这样fd就被跨进程duplicate了。两个进程使用各自的fd对匿名共享内存区域进行mmap映射，就能访问相同的内存区域了。</p>
<h2 id="1-3、IPC函数返回值"><a href="#1-3、IPC函数返回值" class="headerlink" title="1.3、IPC函数返回值"></a>1.3、IPC函数返回值</h2><p>函数返回值也是使用和函数参数一样的parcel结构来封装数据的。就不再重复叙述。</p>
<p>上面提到的原则需要再次强调，在一次service_client和service_server之间的通讯，在传递参数和返回值时都要遵循的准则：service_client只会有<strong>handle</strong>，service_server只会有<strong>binder对象</strong>。</p>
<h2 id="1-4、binder内存"><a href="#1-4、binder内存" class="headerlink" title="1.4、binder内存"></a>1.4、binder内存</h2><p>前面说过binder通讯的本质就是在共享内存上加上一层api，我们来看看他是怎么管理共享内存的。</p>
<p><img src="/images/android_binder/binder_alloc_buffer.png" alt="binder_alloc_buffer"></p>
<p>我们可以看到：</p>
<ul>
<li>binder驱动给每个进程分配最多4M的buffer空间，这段空间在内核通过binder_proc-&gt;alloc红黑树来管理，同时通过mmap映射到进程用户空间；</li>
<li>和所有的进程通讯机制类似，这段空间相当于进程的接收邮箱inbox，其他进程发过来的消息会从其他进程用户空间复制存放到这里；</li>
<li>因为是mmap的所有本进程的用户空间访问免除了一次拷贝；</li>
<li>另外因为进程支持多个线程，所以多个线程会共享本进程的binder buffer；</li>
</ul>
<p><img src="/images/android_binder/binder_alloc_buffer_transaction.png" alt="binder_alloc_buffer_transaction"></p>
<p>我们看一下process 0、process n进程和process 1进程进行binder通讯时的buffer使用情况：</p>
<ul>
<li>首先会在process 1进程的inbox(binder buffer)空间中分配buffer；</li>
<li>binder驱动把process 0、process n进程用户空间的消息拷贝到process 1进程的inbox内核buffer中；</li>
<li>因为mmap，process 1进程的用户空间也可以看见这些消息了；</li>
</ul>
<h1 id="2、binder驱动"><a href="#2、binder驱动" class="headerlink" title="2、binder驱动"></a>2、binder驱动</h1><p>驱动是整个binder通讯的核心，java和native都是对其的封装。<br>因为binder驱动代码比较繁杂，看代码比较不好理解。结合第一章讲的基础知识和binder通讯具体场景，我们使用图来分析每一个典型场景下binder驱动内的变化。</p>
<h2 id="2-1、service-manager的初始化"><a href="#2-1、service-manager的初始化" class="headerlink" title="2.1、service_manager的初始化"></a>2.1、service_manager的初始化</h2><p><img src="/images/android_binder/binder_action_servicemanager_init.png" alt="binder_action_servicemanager_init"></p>
<p>通过上图我们可以看到具体过程：</p>
<ul>
<li>1、binder驱动为service_manager进程创建一个新的binder_node结构，赋值：.ptr=0、.cookie=0、.proc=当前proc；</li>
<li>2、把这个binder_node新节点加入到当前进程的proc-&gt;nodes红黑树中；</li>
<li>3、把binder_device的全局handle 0指针binder_device-&gt;context.binder_context_mgr_node指向新创建的binder_node；这样其他人通过handle 0指针就能找到对应binder_node，进一步找到service_manager是哪一个进程；</li>
</ul>
<p>service_manager代码在<a href="http://androidxref.com/8.1.0_r33/xref/frameworks/native/cmds/servicemanager/service_manager.c" target="_blank" rel="noopener">service_manager.c</a>、<a href="http://androidxref.com/8.1.0_r33/xref/frameworks/native/cmds/servicemanager/binder.c" target="_blank" rel="noopener">binder.c</a>，可以具体查看。初始化过程为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main() -&gt; binder_open()、binder_become_context_manager()</span><br></pre></td></tr></table></figure>
<h2 id="2-2、service-server的addService"><a href="#2-2、service-server的addService" class="headerlink" title="2.2、service_server的addService"></a>2.2、service_server的addService</h2><p><img src="/images/android_binder/binder_action_serviceserver_addservice.png" alt="binder_action_serviceserver_addservice"></p>
<p>通过上图我们可以看到，在service_server向service_manager注册service的时候，在驱动中的具体流程如下：</p>
<ul>
<li>1、因为是向service_manager注册，所以target handle固定=0。通过binder_device-&gt;context找到handle 0对应的binder_node，也就找到了对应的binder_proc，找到了对应的service_manager进程；</li>
<li>2、在service_manager进程中分配binder buffer，把service_server传递过来的parcel数据全部复制进去；</li>
<li>3、翻译parcel数据中的binder对象，把binder翻译成handle；</li>
<li>4、可以看到service_manager进程的handle就是对service_server进程binder的一个引用。把handle加入到service_manager进程的handle缓存红黑树中；</li>
<li>5、把翻译后的parcel数据和其他信息打包成binder_transaction结构，并挂载到service_manager进程的proc-&gt;todo/thread-&gt;todo链表中，等待service_manager进程的读取；</li>
</ul>
<p>service_manager的读取响应和reply动作就不去具体分析了，因为都非常的清晰。service_manager代码在<a href="http://androidxref.com/8.1.0_r33/xref/frameworks/native/cmds/servicemanager/service_manager.c" target="_blank" rel="noopener">service_manager.c</a>、<a href="http://androidxref.com/8.1.0_r33/xref/frameworks/native/cmds/servicemanager/binder.c" target="_blank" rel="noopener">binder.c</a>，可以具体查看。service_manager在svcmgr_handler()函数中响应service_server的SVC_MGR_ADD_SERVICE请求，最终调用do_add_service()把handle和对应的service name加到svclist链表中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main() -&gt; binder_loop() -&gt; binder_parse() -&gt; svcmgr_handler() -&gt; do_add_service()</span><br></pre></td></tr></table></figure>
<h2 id="2-3、service-client的get-service"><a href="#2-3、service-client的get-service" class="headerlink" title="2.3、service_client的get service"></a>2.3、service_client的get service</h2><p><img src="/images/android_binder/binder_action_serviceclient_getservice_send.png" alt="binder_action_serviceclient_getservice_send"></p>
<p>如上图service_client向service_manager发送get service请求的数据比较简单：</p>
<ul>
<li>1、根据handle 0找到service_manager进程；</li>
<li>2、在service_manager进程中分配binder buffer，把service_client传递过来的parcel数据全部复制进去；</li>
<li>3、parcel的内容中没有binder或者handle，不需要翻译；</li>
<li>4、把parcel数据和其他信息打包成binder_transaction结构，并挂载到proc-&gt;todo/thread-&gt;todo链表中，等待service_manager进程的读取；</li>
</ul>
<p><img src="/images/android_binder/binder_action_serviceclient_getservice_reply.png" alt="binder_action_serviceclient_getservice_reply"></p>
<p>上图是service_manager给service_client回复信息的过程：</p>
<ul>
<li>1、service_manager根据service name在本地svclist链表中找到对应的handle，它把handle打包进parcel并reply给service_client；</li>
<li>2、根据service_manager所在线程thread-&gt;transaction_stack字段中保存的binder_transaction结构，从.from字段可以找到service_client所在的线程(binder_thread)和进程(binder_proc)；</li>
<li>3、在service_client进程中分配binder buffer，把service_manager传递过来的parcel数据全部复制进去；</li>
<li>4、翻译parcel中打包的handle结构，判断handle指向的binder_node进程不是service_client进程，所以新建service_client进程中对binder_node新的引用。新创建handle并加入到service_client进程的handle缓存红黑树中；</li>
<li>5、这样service_client就从service_manager中获取到了service_server binder对应的引用handle；</li>
<li>6、把翻译后的parcel数据和其他信息打包成binder_transaction结构，并挂载到service_client进程的proc-&gt;todo/thread-&gt;todo链表中，等待service_client进程读取reply；</li>
</ul>
<h2 id="2-4、service-client调用service"><a href="#2-4、service-client调用service" class="headerlink" title="2.4、service_client调用service"></a>2.4、service_client调用service</h2><p><img src="/images/android_binder/binder_action_serviceclient_callservice.png" alt="binder_action_serviceclient_callservice"></p>
<p>上图是service_client调用service_server的service的过程：</p>
<ul>
<li>1、service_client的target handle为上一步向service_manager查询得到的handle，根据handle能找到对应binder_node，进一步找到service_server所在进程；</li>
<li>2、在service_server进程中分配binder buffer，把service_client传递过来的parcel数据全部复制进去；</li>
<li>3、parcel中打包了函数参数，如果包含handle对象，需要进行翻译；不可能包含binder对象，因为service_client进程的binder对象在service_server进程中无法运行；</li>
<li>4、如果parcel中包含的handle指向的binder_noe和service_server是同一进程，把它翻译成本地binder，在本地可以运行；</li>
<li>5、如果parcel中包含的handle指向的binder_noe和service_server不是同一进程，那只能在service_server进程中给它创建一份新的引用handle。这个handle也不能在service_server进程中运行，只能向其他service_server请求服务；</li>
<li>6、把翻译后的parcel数据和其他信息打包成binder_transaction结构，并挂载到service_client进程的proc-&gt;todo/thread-&gt;todo链表中，等待service_client进程读取reply；</li>
</ul>
<h2 id="2-5、Scatter-gather模式"><a href="#2-5、Scatter-gather模式" class="headerlink" title="2.5、Scatter-gather模式"></a>2.5、Scatter-gather模式</h2><p>在Android O中binder增加了一种性能改进模式Scatter-gather，这是因为binder在传输IPC参数数据时，因为传输的量不大，binder实际上做了3次拷贝：</p>
<p><img src="/images/android_binder/binder_transcation_3_copy.png" alt="binder_transcation_3_copy"></p>
<p>Scatter-gather把3次copy优化成1次：</p>
<p><img src="/images/android_binder/binder_transcation_Scatter-gather_1_copy.png" alt="binder_transcation_Scatter-gather_1_copy"></p>
<p>具体的代码可以看驱动对BINDER_TYPE_PTR类型数据的处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">case BINDER_TYPE_PTR: &#123;</span><br><span class="line">	struct binder_buffer_object *bp =</span><br><span class="line">		to_binder_buffer_object(hdr);</span><br><span class="line">	size_t buf_left = sg_buf_end - sg_bufp;</span><br><span class="line"></span><br><span class="line">	if (bp-&gt;length &gt; buf_left) &#123;</span><br><span class="line">		binder_user_error(&quot;%d:%d got transaction with too large buffer\n&quot;,</span><br><span class="line">				  proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">		return_error = BR_FAILED_REPLY;</span><br><span class="line">		return_error_param = -EINVAL;</span><br><span class="line">		return_error_line = __LINE__;</span><br><span class="line">		goto err_bad_offset;</span><br><span class="line">	&#125;</span><br><span class="line">	if (copy_from_user(sg_bufp,</span><br><span class="line">			   (const void __user *)(uintptr_t)</span><br><span class="line">			   bp-&gt;buffer, bp-&gt;length)) &#123;</span><br><span class="line">		binder_user_error(&quot;%d:%d got transaction with invalid offsets ptr\n&quot;,</span><br><span class="line">				  proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">		return_error_param = -EFAULT;</span><br><span class="line">		return_error = BR_FAILED_REPLY;</span><br><span class="line">		return_error_line = __LINE__;</span><br><span class="line">		goto err_copy_data_failed;</span><br><span class="line">	&#125;</span><br><span class="line">	/* Fixup buffer pointer to target proc address space */</span><br><span class="line">	bp-&gt;buffer = (uintptr_t)sg_bufp +</span><br><span class="line">		binder_alloc_get_user_buffer_offset(</span><br><span class="line">				&amp;target_proc-&gt;alloc);</span><br><span class="line">	sg_bufp += ALIGN(bp-&gt;length, sizeof(u64));</span><br><span class="line"></span><br><span class="line">	ret = binder_fixup_parent(t, thread, bp, off_start,</span><br><span class="line">				  offp - off_start,</span><br><span class="line">				  last_fixup_obj,</span><br><span class="line">				  last_fixup_min_off);</span><br><span class="line">	if (ret &lt; 0) &#123;</span><br><span class="line">		return_error = BR_FAILED_REPLY;</span><br><span class="line">		return_error_param = ret;</span><br><span class="line">		return_error_line = __LINE__;</span><br><span class="line">		goto err_translate_failed;</span><br><span class="line">	&#125;</span><br><span class="line">	last_fixup_obj = bp;</span><br><span class="line">	last_fixup_min_off = 0;</span><br><span class="line">&#125; break;</span><br></pre></td></tr></table></figure>
<h2 id="2-6、多个binder-context"><a href="#2-6、多个binder-context" class="headerlink" title="2.6、多个binder context"></a>2.6、多个binder context</h2><p>Android O以后创建了3个misc设备，对应3个domain(contexts)，相互独立：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> # ls /dev/*binder</span><br><span class="line">/dev/binder /dev/hwbinder /dev/vndbinder</span><br></pre></td></tr></table></figure>
<p>因为在Android O以后HIDL也启用了binder通信，使用binder通信的进程越来越多，为了便于管理并且相互隔离，Android把binder划分成了3个domain(contexts)：</p>
<table>
<thead>
<tr>
<th>IPC Domain</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>/dev/binder</td>
<td>IPC between framework/app processes with AIDL interfaces</td>
</tr>
<tr>
<td>/dev/hwbinder</td>
<td>IPC between framework/vendor processes with HIDL interfacesIPC between vendor processes with HIDL interfaces</td>
</tr>
<tr>
<td>/dev/vndbinder</td>
<td>IPC between vendor/vendor processes with AIDL Interfaces</td>
</tr>
</tbody>
</table>
<h2 id="2-7、调试接口"><a href="#2-7、调试接口" class="headerlink" title="2.7、调试接口"></a>2.7、调试接口</h2><p>binder驱动创建了很多调试接口，可以方便的debug binder通讯的过程。</p>
<p>1、”/d/binder/state”</p>
<p>全局情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># more /d/binder/state</span><br><span class="line">binder state:</span><br><span class="line">dead nodes:</span><br><span class="line">  node 392820: u0000007b50bf75a0 c0000007b2b4d5b80 pri 0:139 hs 1 hw 1 ls 0 lw 0</span><br><span class="line"> is 1 iw 1 tr 1 proc 3021</span><br><span class="line">  node 176573: u0000007b50bf72c0 c0000007b4515a600 pri 0:139 hs 1 hw 1 ls 0 lw 0</span><br><span class="line"> is 1 iw 1 tr 1 proc 5571</span><br><span class="line">  node 56178: u0000007b50a8dfa0 c0000007b50bc31c0 pri 0:139 hs 1 hw 1 ls 0 lw 0</span><br><span class="line">is 1 iw 1 tr 1 proc 3135</span><br><span class="line">  node 47334: u0000007b47f0df40 c0000007b47f077c0 pri 0:139 hs 1 hw 1 ls 0 lw 0</span><br><span class="line">is 1 iw 1 tr 1 proc 1458</span><br><span class="line">  node 342153: u0000007b47f0d480 c0000007b451bf8c0 pri 0:139 hs 1 hw 1 ls 0 lw 0</span><br><span class="line"> is 1 iw 1 tr 1 proc 5571</span><br><span class="line">  node 50574: u0000007b451ffa20 c0000007b3519e5c0 pri 0:139 hs 1 hw 1 ls 0 lw 0</span><br><span class="line">is 1 iw 1 tr 1 proc 1458</span><br><span class="line">  node 49594: u0000007b451ff940 c0000007b3507f480 pri 0:139 hs 1 hw 1 ls 0 lw 0</span><br><span class="line">is 1 iw 1 tr 1 proc 2859</span><br></pre></td></tr></table></figure>
<p>2、”/d/binder/stats”</p>
<p>全局统计：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"># more /d/binder/stats</span><br><span class="line">binder stats:</span><br><span class="line">BC_TRANSACTION: 226132</span><br><span class="line">BC_REPLY: 201918</span><br><span class="line">BC_FREE_BUFFER: 633493</span><br><span class="line">BC_INCREFS: 9234</span><br><span class="line">BC_ACQUIRE: 9415</span><br><span class="line">BC_RELEASE: 6040</span><br><span class="line">BC_DECREFS: 6014</span><br><span class="line">BC_INCREFS_DONE: 5551</span><br><span class="line">BC_ACQUIRE_DONE: 5552</span><br><span class="line">BC_REGISTER_LOOPER: 355</span><br><span class="line">BC_ENTER_LOOPER: 229</span><br><span class="line">BC_REQUEST_DEATH_NOTIFICATION: 2908</span><br><span class="line">BC_CLEAR_DEATH_NOTIFICATION: 2146</span><br><span class="line">BC_DEAD_BINDER_DONE: 225</span><br><span class="line">BC_TRANSACTION_SG: 118790</span><br><span class="line">BC_REPLY_SG: 86885</span><br><span class="line">BR_TRANSACTION: 344921</span><br><span class="line">BR_REPLY: 288803</span><br><span class="line">BR_TRANSACTION_COMPLETE: 633725</span><br><span class="line">BR_INCREFS: 5559</span><br><span class="line">BR_ACQUIRE: 5560</span><br><span class="line">BR_RELEASE: 3436</span><br><span class="line">BR_DECREFS: 3435</span><br><span class="line">BR_SPAWN_LOOPER: 357</span><br><span class="line">BR_DEAD_BINDER: 226</span><br><span class="line">BR_CLEAR_DEATH_NOTIFICATION_DONE: 2146</span><br><span class="line">proc: active 163 total 232</span><br><span class="line">thread: active 852 total 3214</span><br><span class="line">node: active 1610 total 5564</span><br><span class="line">ref: active 2557 total 9384</span><br><span class="line">death: active 746 total 2908</span><br><span class="line">transaction: active 1 total 633725</span><br><span class="line">transaction_complete: active 0 total 633725</span><br><span class="line">proc 10578</span><br><span class="line">context binder</span><br><span class="line">  threads: 18</span><br><span class="line">  requested threads: 0+2/15</span><br><span class="line">  ready threads 3</span><br><span class="line">  free async space 520192</span><br><span class="line">  nodes: 41</span><br></pre></td></tr></table></figure>
<p>3、”/d/binder/proc/xxx”</p>
<p>具体进程的情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># cat /d/binder/proc/1037</span><br><span class="line">binder proc state:</span><br><span class="line">proc 1037</span><br><span class="line">context binder</span><br><span class="line">  thread 1037: l 12 need_return 0 tr 0</span><br><span class="line">  thread 1094: l 00 need_return 0 tr 0</span><br><span class="line">  thread 1096: l 12 need_return 0 tr 0</span><br><span class="line">  node 2758: u0000006fe9c10000 c0000006fe9c0d008 pri 0:139 hs 1 hw 1 ls 0 lw 0 is 1 iw 1 tr 1 proc 704</span><br><span class="line">  node 1192: u0000006fea02f620 c0000006fea029868 pri 0:139 hs 1 hw 1 ls 0 lw 0 is 1 iw 1 tr 1 proc 549</span><br><span class="line">  ref 1190: desc 0 node 2 s 1 w 1 d 0000000000000000</span><br><span class="line">  ref 1204: desc 1 node 170 s 1 w 1 d 0000000000000000</span><br><span class="line">  ref 249105: desc 2 node 5946 s 1 w 1 d 0000000000000000</span><br><span class="line">  buffer 249107: 0000000000000000 size 3600:0:0 delivered</span><br></pre></td></tr></table></figure>
<h1 id="3、service-manager实现"><a href="#3、service-manager实现" class="headerlink" title="3、service manager实现"></a>3、service manager实现</h1><p>service_manager逻辑很清晰，代码也不多，主要流程在上节中已经描述就不再详细分析。<a href="http://androidxref.com/8.1.0_r33/xref/frameworks/native/cmds/servicemanager/service_manager.c" target="_blank" rel="noopener">service_manager.c</a>、<a href="http://androidxref.com/8.1.0_r33/xref/frameworks/native/cmds/servicemanager/binder.c" target="_blank" rel="noopener">binder.c</a></p>
<h1 id="4、native实现"><a href="#4、native实现" class="headerlink" title="4、native实现"></a>4、native实现</h1><p>整个native层binder的实现还是以mediaserver为例来说明。</p>
<h2 id="4-1、process-thread"><a href="#4-1、process-thread" class="headerlink" title="4.1、process/thread"></a>4.1、process/thread</h2><p><img src="/images/android_binder/binder_native_process_thread.png" alt="binder_native_process_thread"></p>
<p>上图已经把native层binder通讯最重要的部分都画出来了，理解了这张图native的实现基本理解了大半：</p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> binder在server接收端会创建多个线程，在发送端不会创建专门的线程直接在发送者的线程中；</li>
<li><p>[x] binder在server端的通用对象是BBinder，在client端的通用引用对象是BpBinder。具体service的server端和client端的实现，只要继承这两个类就行了；</p>
</li>
<li><p>1、ProcessState类</p>
</li>
</ul>
<p>因为binder buffer是一个进程一份的，所以不论是client还是server进程，都只会创建一个binder fd，进行一次mmap映射。binder fd、mmap公共资源在本进程内的多个线程间共享。native使用了一个ProcessState类来管理这些进程公共资源。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;ProcessState&gt; proc(ProcessState::self());</span><br></pre></td></tr></table></figure>
<p>↓<br>frameworks/native/libs/binder/ProcessState.cpp:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;ProcessState&gt; ProcessState::self()</span><br><span class="line">&#123;</span><br><span class="line">    Mutex::Autolock _l(gProcessMutex);</span><br><span class="line">    if (gProcess != NULL) &#123;</span><br><span class="line">        return gProcess;</span><br><span class="line">    &#125;</span><br><span class="line">    /* (1) 创建新的ProcessState对象 */</span><br><span class="line">    gProcess = new ProcessState(&quot;/dev/binder&quot;);</span><br><span class="line">    return gProcess;</span><br><span class="line">&#125;</span><br><span class="line">↓ </span><br><span class="line">ProcessState::ProcessState(const char *driver)</span><br><span class="line">    : mDriverName(String8(driver))</span><br><span class="line">    , mDriverFD(open_driver(driver))    /* (1.1) open binder节点&quot;/dev/binder&quot;，获得文件句柄 */</span><br><span class="line">    , mVMStart(MAP_FAILED)</span><br><span class="line">    , mThreadCountLock(PTHREAD_MUTEX_INITIALIZER)</span><br><span class="line">    , mThreadCountDecrement(PTHREAD_COND_INITIALIZER)</span><br><span class="line">    , mExecutingThreadsCount(0)</span><br><span class="line">    , mMaxThreads(DEFAULT_MAX_BINDER_THREADS)</span><br><span class="line">    , mStarvationStartTimeMs(0)</span><br><span class="line">    , mManagesContexts(false)</span><br><span class="line">    , mBinderContextCheckFunc(NULL)</span><br><span class="line">    , mBinderContextUserData(NULL)</span><br><span class="line">    , mThreadPoolStarted(false)</span><br><span class="line">    , mThreadPoolSeq(1)</span><br><span class="line">&#123;</span><br><span class="line">    if (mDriverFD &gt;= 0) &#123;</span><br><span class="line">        // mmap the binder, providing a chunk of virtual address space to receive transactions.</span><br><span class="line">        /* (1.2) 根据fd映射1M的mmap空间 */</span><br><span class="line">        mVMStart = mmap(0, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, 0);</span><br><span class="line">        if (mVMStart == MAP_FAILED) &#123;</span><br><span class="line">            // *sigh*</span><br><span class="line">            ALOGE(&quot;Using /dev/binder failed: unable to mmap transaction memory.\n&quot;);</span><br><span class="line">            close(mDriverFD);</span><br><span class="line">            mDriverFD = -1;</span><br><span class="line">            mDriverName.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOG_ALWAYS_FATAL_IF(mDriverFD &lt; 0, &quot;Binder driver could not be opened.  Terminating.&quot;);</span><br><span class="line">&#125;</span><br><span class="line">↓ </span><br><span class="line">static int open_driver(const char *driver)</span><br><span class="line">&#123;</span><br><span class="line">    /* (1.1.1) open节点的具体操作 */</span><br><span class="line">    int fd = open(driver, O_RDWR | O_CLOEXEC);</span><br><span class="line">    if (fd &gt;= 0) &#123;</span><br><span class="line">        int vers = 0;</span><br><span class="line">        status_t result = ioctl(fd, BINDER_VERSION, &amp;vers);</span><br><span class="line">        if (result == -1) &#123;</span><br><span class="line">            ALOGE(&quot;Binder ioctl to obtain version failed: %s&quot;, strerror(errno));</span><br><span class="line">            close(fd);</span><br><span class="line">            fd = -1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (result != 0 || vers != BINDER_CURRENT_PROTOCOL_VERSION) &#123;</span><br><span class="line">          ALOGE(&quot;Binder driver protocol(%d) does not match user space protocol(%d)! ioctl() return value: %d&quot;,</span><br><span class="line">                vers, BINDER_CURRENT_PROTOCOL_VERSION, result);</span><br><span class="line">            close(fd);</span><br><span class="line">            fd = -1;</span><br><span class="line">        &#125;</span><br><span class="line">        /* (1.1.2) 设置默认最大接收线程数为15 */</span><br><span class="line">        size_t maxThreads = DEFAULT_MAX_BINDER_THREADS;</span><br><span class="line">        result = ioctl(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads);</span><br><span class="line">        if (result == -1) &#123;</span><br><span class="line">            ALOGE(&quot;Binder ioctl to set max threads failed: %s&quot;, strerror(errno));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ALOGW(&quot;Opening &apos;%s&apos; failed: %s\n&quot;, driver, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    return fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>2、IPCThreadState类</li>
</ul>
<p>native binder对线程也进行了封装。  </p>
<ul>
<li>2.1、对于server端来说，native binder创建一个线程池，可以多个接收线程来响应和运行service服务。例如</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># ps -eT | grep Binder</span><br><span class="line">mediaex       1028  1180     1 2179292  15664 binder_thread_read  0 S Binder:1028_1</span><br><span class="line">mediaex       1028  1886     1 2179292  15664 binder_thread_read  0 S Binder:1028_2</span><br><span class="line">mediaex       1028  1887     1 2179292  15664 binder_thread_read  0 S Binder:1028_3</span><br><span class="line">mediaex       1028  2489     1 2179292  15664 binder_thread_read  0 S Binder:1028_4</span><br><span class="line">mediaex       1028  5497     1 2179292  15664 binder_thread_read  0 S Binder:1028_5</span><br><span class="line">media         1034  1130     1 2140724  10968 binder_thread_read  0 S Binder:1034_1</span><br><span class="line">media         1034  8000     1 2140724  10968 binder_thread_read  0 S Binder:1034_2</span><br></pre></td></tr></table></figure>
<p>具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ProcessState::self()-&gt;startThreadPool();</span><br><span class="line">↓ </span><br><span class="line">void ProcessState::startThreadPool()</span><br><span class="line">&#123;</span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line">    if (!mThreadPoolStarted) &#123;</span><br><span class="line">        mThreadPoolStarted = true;</span><br><span class="line">        spawnPooledThread(true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">↓ </span><br><span class="line">void ProcessState::spawnPooledThread(bool isMain)</span><br><span class="line">&#123;</span><br><span class="line">    if (mThreadPoolStarted) &#123;</span><br><span class="line">        String8 name = makeBinderThreadName();</span><br><span class="line">        ALOGV(&quot;Spawning new pooled thread, name=%s\n&quot;, name.string());</span><br><span class="line">        /* (1)新创建一个PoolThread对象 </span><br><span class="line">            main的意思就是它是一个接收主线程，它不会动态的退出</span><br><span class="line">         */</span><br><span class="line">        sp&lt;Thread&gt; t = new PoolThread(isMain);</span><br><span class="line">        t-&gt;run(name.string());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>↓<br>PoolThread类继承了Thread类，并且实现了线程主循环函数：threadLoop()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class PoolThread : public Thread</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    explicit PoolThread(bool isMain)</span><br><span class="line">        : mIsMain(isMain)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">    virtual bool threadLoop()</span><br><span class="line">    &#123;</span><br><span class="line">        /* (1.1) 线程主循环，进一步调用 */</span><br><span class="line">        IPCThreadState::self()-&gt;joinThreadPool(mIsMain);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const bool mIsMain;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>↓<br>创建IPCThreadState对象<br>frameworks/native/libs/binder/IPCThreadState.cpp:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">IPCThreadState* IPCThreadState::self()</span><br><span class="line">&#123;</span><br><span class="line">    if (gHaveTLS) &#123;</span><br><span class="line">restart:</span><br><span class="line">        const pthread_key_t k = gTLS;</span><br><span class="line">        IPCThreadState* st = (IPCThreadState*)pthread_getspecific(k);</span><br><span class="line">        if (st) return st;</span><br><span class="line">        /* (1.1.1) 创建一个本地线程的IPCThreadState对象 */</span><br><span class="line">        return new IPCThreadState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (gShutdown) &#123;</span><br><span class="line">        ALOGW(&quot;Calling IPCThreadState::self() during shutdown is dangerous, expect a crash.\n&quot;);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;gTLSMutex);</span><br><span class="line">    if (!gHaveTLS) &#123;</span><br><span class="line">        int key_create_value = pthread_key_create(&amp;gTLS, threadDestructor);</span><br><span class="line">        if (key_create_value != 0) &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;gTLSMutex);</span><br><span class="line">            ALOGW(&quot;IPCThreadState::self() unable to create TLS key, expect a crash: %s\n&quot;,</span><br><span class="line">                    strerror(key_create_value));</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        gHaveTLS = true;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;gTLSMutex);</span><br><span class="line">    goto restart;</span><br><span class="line">&#125;</span><br><span class="line">↓ </span><br><span class="line">IPCThreadState::IPCThreadState()</span><br><span class="line">    : mProcess(ProcessState::self()),</span><br><span class="line">      mStrictModePolicy(0),</span><br><span class="line">      mLastTransactionBinderFlags(0)</span><br><span class="line">&#123;</span><br><span class="line">    pthread_setspecific(gTLS, this);</span><br><span class="line">    clearCaller();</span><br><span class="line">    // FLYME:duanlusheng@SHELL.Flyme.hips.Feature &#123;@</span><br><span class="line">    mRealCallingPid = -1;</span><br><span class="line">    // @&#125;</span><br><span class="line">    mIn.setDataCapacity(256);</span><br><span class="line">    mOut.setDataCapacity(256);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>↓<br>最后进入IPCThreadState类的线程主循环函数joinThreadPool()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">void IPCThreadState::joinThreadPool(bool isMain)</span><br><span class="line">&#123;</span><br><span class="line">    LOG_THREADPOOL(&quot;**** THREAD %p (PID %d) IS JOINING THE THREAD POOL\n&quot;, (void*)pthread_self(), getpid());</span><br><span class="line"></span><br><span class="line">    mOut.writeInt32(isMain ? BC_ENTER_LOOPER : BC_REGISTER_LOOPER);</span><br><span class="line"></span><br><span class="line">    status_t result;</span><br><span class="line">    do &#123;</span><br><span class="line">        processPendingDerefs();</span><br><span class="line">        // now get the next command to be processed, waiting if necessary</span><br><span class="line">        result = getAndExecuteCommand();</span><br><span class="line"></span><br><span class="line">        if (result &lt; NO_ERROR &amp;&amp; result != TIMED_OUT &amp;&amp; result != -ECONNREFUSED &amp;&amp; result != -EBADF) &#123;</span><br><span class="line">            ALOGE(&quot;getAndExecuteCommand(fd=%d) returned unexpected error %d, aborting&quot;,</span><br><span class="line">                  mProcess-&gt;mDriverFD, result);</span><br><span class="line">            abort();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Let this thread exit the thread pool if it is no longer</span><br><span class="line">        // needed and it is not the main process thread.</span><br><span class="line">        if(result == TIMED_OUT &amp;&amp; !isMain) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while (result != -ECONNREFUSED &amp;&amp; result != -EBADF);</span><br><span class="line"></span><br><span class="line">    LOG_THREADPOOL(&quot;**** THREAD %p (PID %d) IS LEAVING THE THREAD POOL err=%d\n&quot;,</span><br><span class="line">        (void*)pthread_self(), getpid(), result);</span><br><span class="line"></span><br><span class="line">    mOut.writeInt32(BC_EXIT_LOOPER);</span><br><span class="line">    talkWithDriver(false);</span><br><span class="line">&#125;</span><br><span class="line">↓</span><br><span class="line">status_t IPCThreadState::getAndExecuteCommand()</span><br><span class="line">&#123;</span><br><span class="line">    status_t result;</span><br><span class="line">    int32_t cmd;</span><br><span class="line"></span><br><span class="line">    /* (1.1.2.1) 和binder驱动交互：</span><br><span class="line">        把mOut中的数据发送给binder驱动</span><br><span class="line">        把接收驱动中的数据到mIn</span><br><span class="line">     */</span><br><span class="line">    result = talkWithDriver();</span><br><span class="line">    if (result &gt;= NO_ERROR) &#123;</span><br><span class="line">        size_t IN = mIn.dataAvail();</span><br><span class="line">        if (IN &lt; sizeof(int32_t)) return result;</span><br><span class="line">        </span><br><span class="line">        /* (1.1.2.2) 读出接收数据中的cmd */</span><br><span class="line">        cmd = mIn.readInt32();</span><br><span class="line">        IF_LOG_COMMANDS() &#123;</span><br><span class="line">            alog &lt;&lt; &quot;Processing top-level Command: &quot;</span><br><span class="line">                 &lt;&lt; getReturnString(cmd) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pthread_mutex_lock(&amp;mProcess-&gt;mThreadCountLock);</span><br><span class="line">        mProcess-&gt;mExecutingThreadsCount++;</span><br><span class="line">        if (mProcess-&gt;mExecutingThreadsCount &gt;= mProcess-&gt;mMaxThreads &amp;&amp;</span><br><span class="line">                mProcess-&gt;mStarvationStartTimeMs == 0) &#123;</span><br><span class="line">            mProcess-&gt;mStarvationStartTimeMs = uptimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;mProcess-&gt;mThreadCountLock);</span><br><span class="line"></span><br><span class="line">        /* (1.1.2.3) 执行cmd */</span><br><span class="line">        result = executeCommand(cmd);</span><br><span class="line"></span><br><span class="line">        pthread_mutex_lock(&amp;mProcess-&gt;mThreadCountLock);</span><br><span class="line">        mProcess-&gt;mExecutingThreadsCount--;</span><br><span class="line">        if (mProcess-&gt;mExecutingThreadsCount &lt; mProcess-&gt;mMaxThreads &amp;&amp;</span><br><span class="line">                mProcess-&gt;mStarvationStartTimeMs != 0) &#123;</span><br><span class="line">            int64_t starvationTimeMs = uptimeMillis() - mProcess-&gt;mStarvationStartTimeMs;</span><br><span class="line">            if (starvationTimeMs &gt; 100) &#123;</span><br><span class="line">                ALOGE(&quot;binder thread pool (%zu threads) starved for %&quot; PRId64 &quot; ms&quot;,</span><br><span class="line">                      mProcess-&gt;mMaxThreads, starvationTimeMs);</span><br><span class="line">            &#125;</span><br><span class="line">            mProcess-&gt;mStarvationStartTimeMs = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_cond_broadcast(&amp;mProcess-&gt;mThreadCountDecrement);</span><br><span class="line">        pthread_mutex_unlock(&amp;mProcess-&gt;mThreadCountLock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>↓<br>我们只需要关注其中BR_TRANSACTION命令的处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">status_t IPCThreadState::executeCommand(int32_t cmd)</span><br><span class="line">&#123;</span><br><span class="line">    BBinder* obj;</span><br><span class="line">    RefBase::weakref_type* refs;</span><br><span class="line">    status_t result = NO_ERROR;</span><br><span class="line"></span><br><span class="line">    switch ((uint32_t)cmd) &#123;</span><br><span class="line"></span><br><span class="line">    case BR_TRANSACTION:</span><br><span class="line">        &#123;</span><br><span class="line">            binder_transaction_data tr;</span><br><span class="line">            result = mIn.read(&amp;tr, sizeof(tr));</span><br><span class="line">            ALOG_ASSERT(result == NO_ERROR,</span><br><span class="line">                &quot;Not enough command data for brTRANSACTION&quot;);</span><br><span class="line">            if (result != NO_ERROR) break;</span><br><span class="line"></span><br><span class="line">            Parcel buffer;</span><br><span class="line">            buffer.ipcSetDataReference(</span><br><span class="line">                reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                tr.data_size,</span><br><span class="line">                reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                tr.offsets_size/sizeof(binder_size_t), freeBuffer, this);</span><br><span class="line"></span><br><span class="line">            const pid_t origPid = mCallingPid;</span><br><span class="line">            // FLYME:duanlusheng@SHELL.Flyme.hips.Feature &#123;@</span><br><span class="line">            const pid_t  origPidCopy = mRealCallingPid;</span><br><span class="line">            // @&#125;</span><br><span class="line">            const uid_t origUid = mCallingUid;</span><br><span class="line">            const int32_t origStrictModePolicy = mStrictModePolicy;</span><br><span class="line">            const int32_t origTransactionBinderFlags = mLastTransactionBinderFlags;</span><br><span class="line"></span><br><span class="line">            mCallingPid = tr.sender_pid;</span><br><span class="line">            // FLYME:duanlusheng@SHELL.Flyme.hips.Feature &#123;@</span><br><span class="line">            mRealCallingPid = tr.sender_pid;</span><br><span class="line">            // @&#125;</span><br><span class="line">            mCallingUid = tr.sender_euid;</span><br><span class="line">            mLastTransactionBinderFlags = tr.flags;</span><br><span class="line"></span><br><span class="line">            //ALOGI(&quot;&gt;&gt;&gt;&gt; TRANSACT from pid %d uid %d\n&quot;, mCallingPid, mCallingUid);</span><br><span class="line"></span><br><span class="line">            Parcel reply;</span><br><span class="line">            status_t error;</span><br><span class="line">            IF_LOG_TRANSACTIONS() &#123;</span><br><span class="line">                TextOutput::Bundle _b(alog);</span><br><span class="line">                alog &lt;&lt; &quot;BR_TRANSACTION thr &quot; &lt;&lt; (void*)pthread_self()</span><br><span class="line">                    &lt;&lt; &quot; / obj &quot; &lt;&lt; tr.target.ptr &lt;&lt; &quot; / code &quot;</span><br><span class="line">                    &lt;&lt; TypeCode(tr.code) &lt;&lt; &quot;: &quot; &lt;&lt; indent &lt;&lt; buffer</span><br><span class="line">                    &lt;&lt; dedent &lt;&lt; endl</span><br><span class="line">                    &lt;&lt; &quot;Data addr = &quot;</span><br><span class="line">                    &lt;&lt; reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer)</span><br><span class="line">                    &lt;&lt; &quot;, offsets addr=&quot;</span><br><span class="line">                    &lt;&lt; reinterpret_cast&lt;const size_t*&gt;(tr.data.ptr.offsets) &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            if (tr.target.ptr) &#123;</span><br><span class="line">                // We only have a weak reference on the target object, so we must first try to</span><br><span class="line">                // safely acquire a strong reference before doing anything else with it.</span><br><span class="line">                if (reinterpret_cast&lt;RefBase::weakref_type*&gt;(</span><br><span class="line">                        tr.target.ptr)-&gt;attemptIncStrong(this)) &#123;</span><br><span class="line">                    /* (1.1.2.3.1) 如果target是一个合法的本地对象， </span><br><span class="line">                        把tr.cookie转换成BBinder对象，并调用BBinder-&gt;transact()来处理数据</span><br><span class="line">                     */</span><br><span class="line">                    error = reinterpret_cast&lt;BBinder*&gt;(tr.cookie)-&gt;transact(tr.code, buffer,</span><br><span class="line">                            &amp;reply, tr.flags);</span><br><span class="line">                    reinterpret_cast&lt;BBinder*&gt;(tr.cookie)-&gt;decStrong(this);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    error = UNKNOWN_TRANSACTION;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                error = the_context_object-&gt;transact(tr.code, buffer, &amp;reply, tr.flags);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //ALOGI(&quot;&lt;&lt;&lt;&lt; TRANSACT from pid %d restore pid %d uid %d\n&quot;,</span><br><span class="line">            //     mCallingPid, origPid, origUid);</span><br><span class="line"></span><br><span class="line">            if ((tr.flags &amp; TF_ONE_WAY) == 0) &#123;</span><br><span class="line">                LOG_ONEWAY(&quot;Sending reply to %d!&quot;, mCallingPid);</span><br><span class="line">                if (error &lt; NO_ERROR) reply.setError(error);</span><br><span class="line">                sendReply(reply, 0);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                LOG_ONEWAY(&quot;NOT sending reply to %d!&quot;, mCallingPid);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mCallingPid = origPid;</span><br><span class="line">            // FLYME:duanlusheng@SHELL.Flyme.hips.Feature &#123;@</span><br><span class="line">            mRealCallingPid = origPidCopy;</span><br><span class="line">            // @&#125;</span><br><span class="line">            mCallingUid = origUid;</span><br><span class="line">            mStrictModePolicy = origStrictModePolicy;</span><br><span class="line">            mLastTransactionBinderFlags = origTransactionBinderFlags;</span><br><span class="line"></span><br><span class="line">            IF_LOG_TRANSACTIONS() &#123;</span><br><span class="line">                TextOutput::Bundle _b(alog);</span><br><span class="line">                alog &lt;&lt; &quot;BC_REPLY thr &quot; &lt;&lt; (void*)pthread_self() &lt;&lt; &quot; / obj &quot;</span><br><span class="line">                    &lt;&lt; tr.target.ptr &lt;&lt; &quot;: &quot; &lt;&lt; indent &lt;&lt; reply &lt;&lt; dedent &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>↓<br>BBinder是一个标准的通用binder对象，它的transact()函数会被具体的service子类重写，所以会调用到具体子类的transact()函数中<br>frameworks/native/libs/binder/Binder.cpp：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">status_t BBinder::onTransact(</span><br><span class="line">    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t /*flags*/)</span><br><span class="line">&#123;</span><br><span class="line">    switch (code) &#123;</span><br><span class="line">        case INTERFACE_TRANSACTION:</span><br><span class="line">            reply-&gt;writeString16(getInterfaceDescriptor());</span><br><span class="line">            return NO_ERROR;</span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">            return UNKNOWN_TRANSACTION;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>↓<br>BnMediaPlayerService是负责具体实现的子类，最后会调用进BnMediaPlayerService类的onTransact()函数中：<br>frameworks/av/media/libmedia/IMediaPlayerService.cpp：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">status_t BnMediaPlayerService::onTransact(</span><br><span class="line">    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    switch (code) &#123;</span><br><span class="line">        case CREATE: &#123;</span><br><span class="line">            CHECK_INTERFACE(IMediaPlayerService, data, reply);</span><br><span class="line">            sp&lt;IMediaPlayerClient&gt; client =</span><br><span class="line">                interface_cast&lt;IMediaPlayerClient&gt;(data.readStrongBinder());</span><br><span class="line">            audio_session_t audioSessionId = (audio_session_t) data.readInt32();</span><br><span class="line">            sp&lt;IMediaPlayer&gt; player = create(client, audioSessionId);</span><br><span class="line">            reply-&gt;writeStrongBinder(IInterface::asBinder(player));</span><br><span class="line">            return NO_ERROR;</span><br><span class="line">        &#125; break;</span><br><span class="line">        case CREATE_MEDIA_RECORDER: &#123;</span><br><span class="line">            CHECK_INTERFACE(IMediaPlayerService, data, reply);</span><br><span class="line">            const String16 opPackageName = data.readString16();</span><br><span class="line">            sp&lt;IMediaRecorder&gt; recorder = createMediaRecorder(opPackageName);</span><br><span class="line">            reply-&gt;writeStrongBinder(IInterface::asBinder(recorder));</span><br><span class="line">            return NO_ERROR;</span><br><span class="line">        &#125; break;</span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">            return BBinder::onTransact(code, data, reply, flags);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>2.2、对于client端来说是发送数据，native binder不会对其创建新的线程，但是IPCThreadState类也为client端的发送提供了封装。</li>
</ul>
<p>client端通用的binder远端代理类为BpBinder，它的发送数据到binder驱动的函数为transact()：<br>frameworks/native/libs/binder/BpBinder.cpp:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">status_t BpBinder::transact(</span><br><span class="line">    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    // Once a binder has died, it will never come back to life.</span><br><span class="line">    if (mAlive) &#123;</span><br><span class="line">        status_t status = IPCThreadState::self()-&gt;transact(</span><br><span class="line">            mHandle, code, data, reply, flags);</span><br><span class="line">        if (status == DEAD_OBJECT) mAlive = 0;</span><br><span class="line">        return status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return DEAD_OBJECT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>↓<br>最后调用到IPCThreadState类的相关方法：<br>frameworks/native/libs/binder/IPCThreadState.cpp</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">status_t IPCThreadState::transact(int32_t handle,</span><br><span class="line">                                  uint32_t code, const Parcel&amp; data,</span><br><span class="line">                                  Parcel* reply, uint32_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    status_t err = data.errorCheck();</span><br><span class="line"></span><br><span class="line">    flags |= TF_ACCEPT_FDS;</span><br><span class="line"></span><br><span class="line">    IF_LOG_TRANSACTIONS() &#123;</span><br><span class="line">        TextOutput::Bundle _b(alog);</span><br><span class="line">        alog &lt;&lt; &quot;BC_TRANSACTION thr &quot; &lt;&lt; (void*)pthread_self() &lt;&lt; &quot; / hand &quot;</span><br><span class="line">            &lt;&lt; handle &lt;&lt; &quot; / code &quot; &lt;&lt; TypeCode(code) &lt;&lt; &quot;: &quot;</span><br><span class="line">            &lt;&lt; indent &lt;&lt; data &lt;&lt; dedent &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (err == NO_ERROR) &#123;</span><br><span class="line">        LOG_ONEWAY(&quot;&gt;&gt;&gt;&gt; SEND from pid %d uid %d %s&quot;, getpid(), getuid(),</span><br><span class="line">            (flags &amp; TF_ONE_WAY) == 0 ? &quot;READ REPLY&quot; : &quot;ONE WAY&quot;);</span><br><span class="line">        </span><br><span class="line">        /* (1) 把数据写入mOut */</span><br><span class="line">        err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, NULL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (err != NO_ERROR) &#123;</span><br><span class="line">        if (reply) reply-&gt;setError(err);</span><br><span class="line">        return (mLastError = err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if ((flags &amp; TF_ONE_WAY) == 0) &#123;</span><br><span class="line">        #if 0</span><br><span class="line">        if (code == 4) &#123; // relayout</span><br><span class="line">            ALOGI(&quot;&gt;&gt;&gt;&gt;&gt;&gt; CALLING transaction 4&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ALOGI(&quot;&gt;&gt;&gt;&gt;&gt;&gt; CALLING transaction %d&quot;, code);</span><br><span class="line">        &#125;</span><br><span class="line">        #endif</span><br><span class="line">        </span><br><span class="line">        /* (2) 使用mOut、mIn和binder驱动进行通讯 */</span><br><span class="line">        if (reply) &#123;</span><br><span class="line">            err = waitForResponse(reply);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Parcel fakeReply;</span><br><span class="line">            err = waitForResponse(&amp;fakeReply);</span><br><span class="line">        &#125;</span><br><span class="line">        #if 0</span><br><span class="line">        if (code == 4) &#123; // relayout</span><br><span class="line">            ALOGI(&quot;&lt;&lt;&lt;&lt;&lt;&lt; RETURNING transaction 4&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ALOGI(&quot;&lt;&lt;&lt;&lt;&lt;&lt; RETURNING transaction %d&quot;, code);</span><br><span class="line">        &#125;</span><br><span class="line">        #endif</span><br><span class="line"></span><br><span class="line">        IF_LOG_TRANSACTIONS() &#123;</span><br><span class="line">            TextOutput::Bundle _b(alog);</span><br><span class="line">            alog &lt;&lt; &quot;BR_REPLY thr &quot; &lt;&lt; (void*)pthread_self() &lt;&lt; &quot; / hand &quot;</span><br><span class="line">                &lt;&lt; handle &lt;&lt; &quot;: &quot;;</span><br><span class="line">            if (reply) alog &lt;&lt; indent &lt;&lt; *reply &lt;&lt; dedent &lt;&lt; endl;</span><br><span class="line">            else alog &lt;&lt; &quot;(none requested)&quot; &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        err = waitForResponse(NULL, NULL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult)</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t cmd;</span><br><span class="line">    int32_t err;</span><br><span class="line"></span><br><span class="line">    while (1) &#123;</span><br><span class="line">        </span><br><span class="line">        /* (2.1) 和binder驱动通讯 */</span><br><span class="line">        if ((err=talkWithDriver()) &lt; NO_ERROR) break;</span><br><span class="line">        err = mIn.errorCheck();</span><br><span class="line">        if (err &lt; NO_ERROR) break;</span><br><span class="line">        if (mIn.dataAvail() == 0) continue;</span><br><span class="line"></span><br><span class="line">        cmd = (uint32_t)mIn.readInt32();</span><br><span class="line"></span><br><span class="line">        IF_LOG_COMMANDS() &#123;</span><br><span class="line">            alog &lt;&lt; &quot;Processing waitForResponse Command: &quot;</span><br><span class="line">                &lt;&lt; getReturnString(cmd) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        switch (cmd) &#123;</span><br><span class="line">        case BR_TRANSACTION_COMPLETE:</span><br><span class="line">            if (!reply &amp;&amp; !acquireResult) goto finish;</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-2、manager-proxy"><a href="#4-2、manager-proxy" class="headerlink" title="4.2、manager proxy"></a>4.2、manager proxy</h2><p>service_client service_server和service_manager通讯时，都是处于client角色，所以只能操作service_manager的代理对象。我们看一下具体的代理对象是怎么创建起来的。</p>
<p>server在注册service服务时，都需要获取到默认manager代理：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void MediaPlayerService::instantiate() &#123;</span><br><span class="line">    defaultServiceManager()-&gt;addService(</span><br><span class="line">            String16(&quot;media.player&quot;), new MediaPlayerService());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>↓<br>frameworks/native/libs/binder/IServiceManager.cpp：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IServiceManager&gt; defaultServiceManager()</span><br><span class="line">&#123;</span><br><span class="line">    if (gDefaultServiceManager != NULL) return gDefaultServiceManager;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        AutoMutex _l(gDefaultServiceManagerLock);</span><br><span class="line">        while (gDefaultServiceManager == NULL) &#123;</span><br><span class="line">            /* (1) 创建BpBinder对象，并在此基础上创建它的子类BpServiceManager对象 */</span><br><span class="line">            gDefaultServiceManager = interface_cast&lt;IServiceManager&gt;(</span><br><span class="line">                ProcessState::self()-&gt;getContextObject(NULL));</span><br><span class="line">            if (gDefaultServiceManager == NULL)</span><br><span class="line">                sleep(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return gDefaultServiceManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>|→<br>frameworks/native/libs/binder/ProcessState.cpp</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IBinder&gt; ProcessState::getContextObject(const sp&lt;IBinder&gt;&amp; /*caller*/)</span><br><span class="line">&#123;</span><br><span class="line">    /* (1.1) 为service_manager创建handle=0的BpBinder对象 */</span><br><span class="line">    return getStrongProxyForHandle(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sp&lt;IBinder&gt; ProcessState::getStrongProxyForHandle(int32_t handle)</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;IBinder&gt; result;</span><br><span class="line"></span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">    /* (1.1.1) 查询BpBinder对象缓存，相同handle是否已经创建 */</span><br><span class="line">    handle_entry* e = lookupHandleLocked(handle);</span><br><span class="line"></span><br><span class="line">    if (e != NULL) &#123;</span><br><span class="line">        // We need to create a new BpBinder if there isn&apos;t currently one, OR we</span><br><span class="line">        // are unable to acquire a weak reference on this current one.  See comment</span><br><span class="line">        // in getWeakProxyForHandle() for more info about this.</span><br><span class="line">        IBinder* b = e-&gt;binder;</span><br><span class="line">        if (b == NULL || !e-&gt;refs-&gt;attemptIncWeak(this)) &#123;</span><br><span class="line">            if (handle == 0) &#123;</span><br><span class="line">                // Special case for context manager...</span><br><span class="line">                // The context manager is the only object for which we create</span><br><span class="line">                // a BpBinder proxy without already holding a reference.</span><br><span class="line">                // Perform a dummy transaction to ensure the context manager</span><br><span class="line">                // is registered before we create the first local reference</span><br><span class="line">                // to it (which will occur when creating the BpBinder).</span><br><span class="line">                // If a local reference is created for the BpBinder when the</span><br><span class="line">                // context manager is not present, the driver will fail to</span><br><span class="line">                // provide a reference to the context manager, but the</span><br><span class="line">                // driver API does not return status.</span><br><span class="line">                //</span><br><span class="line">                // Note that this is not race-free if the context manager</span><br><span class="line">                // dies while this code runs.</span><br><span class="line">                //</span><br><span class="line">                // TODO: add a driver API to wait for context manager, or</span><br><span class="line">                // stop special casing handle 0 for context manager and add</span><br><span class="line">                // a driver API to get a handle to the context manager with</span><br><span class="line">                // proper reference counting.</span><br><span class="line"></span><br><span class="line">                Parcel data;</span><br><span class="line">                status_t status = IPCThreadState::self()-&gt;transact(</span><br><span class="line">                        0, IBinder::PING_TRANSACTION, data, NULL, 0);</span><br><span class="line">                if (status == DEAD_OBJECT)</span><br><span class="line">                   return NULL;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            /* (1.1.2) 给新handle新创建一个对应BpBinder对象 */</span><br><span class="line">            b = new BpBinder(handle);</span><br><span class="line">            e-&gt;binder = b;</span><br><span class="line">            if (b) e-&gt;refs = b-&gt;getWeakRefs();</span><br><span class="line">            result = b;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // This little bit of nastyness is to allow us to add a primary</span><br><span class="line">            // reference to the remote proxy when this team doesn&apos;t have one</span><br><span class="line">            // but another team is sending the handle to us.</span><br><span class="line">            result.force_set(b);</span><br><span class="line">            e-&gt;refs-&gt;decWeak(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>|→<br>在创建完标准BpBinder对象以后，使用了一个模板函数interface_cast<iservicemanager>()把子类对象也给创建了。interface_cast()的定义在</iservicemanager></p>
<p>frameworks/native/libs/binder/include/binder/IInterface.h:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename INTERFACE&gt;</span><br><span class="line">inline sp&lt;INTERFACE&gt; interface_cast(const sp&lt;IBinder&gt;&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">    return INTERFACE::asInterface(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>interface_cast<iservicemanager>()扩展为：</iservicemanager></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inline sp&lt;IServiceManager&gt; interface_cast(const sp&lt;IBinder&gt;&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">    return IServiceManager::asInterface(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>frameworks/native/libs/binder/include/binder/IInterface.h:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#define IMPLEMENT_META_INTERFACE(INTERFACE, NAME)                       \</span><br><span class="line">    const ::android::String16 I##INTERFACE::descriptor(NAME);           \</span><br><span class="line">    const ::android::String16&amp;                                          \</span><br><span class="line">            I##INTERFACE::getInterfaceDescriptor() const &#123;              \</span><br><span class="line">        return I##INTERFACE::descriptor;                                \</span><br><span class="line">    &#125;                                                                   \</span><br><span class="line">    ::android::sp&lt;I##INTERFACE&gt; I##INTERFACE::asInterface(              \</span><br><span class="line">            const ::android::sp&lt;::android::IBinder&gt;&amp; obj)               \</span><br><span class="line">    &#123;                                                                   \</span><br><span class="line">        ::android::sp&lt;I##INTERFACE&gt; intr;                               \</span><br><span class="line">        if (obj != NULL) &#123;                                              \</span><br><span class="line">            intr = static_cast&lt;I##INTERFACE*&gt;(                          \</span><br><span class="line">                obj-&gt;queryLocalInterface(                               \</span><br><span class="line">                        I##INTERFACE::descriptor).get());               \</span><br><span class="line">            if (intr == NULL) &#123;                                         \</span><br><span class="line">                intr = new Bp##INTERFACE(obj);                          \</span><br><span class="line">            &#125;                                                           \</span><br><span class="line">        &#125;                                                               \</span><br><span class="line">        return intr;                                                    \</span><br><span class="line">    &#125;                                                                   \</span><br><span class="line">    I##INTERFACE::I##INTERFACE() &#123; &#125;                                    \</span><br><span class="line">    I##INTERFACE::~I##INTERFACE() &#123; &#125;                                   \</span><br></pre></td></tr></table></figure>
<p>frameworks/native/libs/binder/IServiceManager.cpp:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IMPLEMENT_META_INTERFACE(ServiceManager, &quot;android.os.IServiceManager&quot;);</span><br></pre></td></tr></table></figure>
<p>扩展为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#define IMPLEMENT_META_INTERFACE(ServiceManager, &quot;android.os.IServiceManager&quot;)                       \</span><br><span class="line">    const ::android::String16 IServiceManager::descriptor(&quot;android.os.IServiceManager&quot;);           \</span><br><span class="line">    const ::android::String16&amp;                                          \</span><br><span class="line">            IServiceManager::getInterfaceDescriptor() const &#123;              \</span><br><span class="line">        return IServiceManager::descriptor;                                \</span><br><span class="line">    &#125;                                                                   \</span><br><span class="line">    ::android::sp&lt;IServiceManager&gt; IServiceManager::asInterface(              \</span><br><span class="line">            const ::android::sp&lt;::android::IBinder&gt;&amp; obj)               \</span><br><span class="line">    &#123;                                                                   \</span><br><span class="line">        ::android::sp&lt;IServiceManager&gt; intr;                               \</span><br><span class="line">        if (obj != NULL) &#123;                                              \</span><br><span class="line">            intr = static_cast&lt;IServiceManager*&gt;(                          \</span><br><span class="line">                obj-&gt;queryLocalInterface(                               \</span><br><span class="line">                        IServiceManager::descriptor).get());               \</span><br><span class="line">            if (intr == NULL) &#123;                                         \</span><br><span class="line">                intr = new BpServiceManager(obj);                          \</span><br><span class="line">            &#125;                                                           \</span><br><span class="line">        &#125;                                                               \</span><br><span class="line">        return intr;                                                    \</span><br><span class="line">    &#125;                                                                   \</span><br><span class="line">    IServiceManager::IServiceManager() &#123; &#125;                                    \</span><br><span class="line">    IServiceManager::~IServiceManager() &#123; &#125;                                   \</span><br></pre></td></tr></table></figure>
<p>所以defaultServiceManager()最后得到了一个BpServiceManager对象，利用它的::addService()方法来注册service。<br>frameworks/native/libs/binder/IServiceManager.cpp：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class BpServiceManager : public BpInterface&lt;IServiceManager&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    explicit BpServiceManager(const sp&lt;IBinder&gt;&amp; impl)</span><br><span class="line">        : BpInterface&lt;IServiceManager&gt;(impl)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual status_t addService(const String16&amp; name, const sp&lt;IBinder&gt;&amp; service,</span><br><span class="line">            bool allowIsolated)</span><br><span class="line">    &#123;</span><br><span class="line">        Parcel data, reply;</span><br><span class="line">        data.writeInterfaceToken(IServiceManager::getInterfaceDescriptor());</span><br><span class="line">        data.writeString16(name);</span><br><span class="line">        data.writeStrongBinder(service);</span><br><span class="line">        data.writeInt32(allowIsolated ? 1 : 0);</span><br><span class="line">        status_t err = remote()-&gt;transact(ADD_SERVICE_TRANSACTION, data, &amp;reply);</span><br><span class="line">        return err == NO_ERROR ? reply.readExceptionCode() : err;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    virtual sp&lt;IBinder&gt; checkService( const String16&amp; name) const</span><br><span class="line">    &#123;</span><br><span class="line">        Parcel data, reply;</span><br><span class="line">        data.writeInterfaceToken(IServiceManager::getInterfaceDescriptor());</span><br><span class="line">        data.writeString16(name);</span><br><span class="line">        remote()-&gt;transact(CHECK_SERVICE_TRANSACTION, data, &amp;reply);</span><br><span class="line">        return reply.readStrongBinder();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>remote()-&gt;transact()会调用到BpBinder的transact()函数，最后IPCThreadState的transact()函数。<br>frameworks/native/libs/binder/BpBinder.cpp:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">status_t BpBinder::transact(</span><br><span class="line">    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    // Once a binder has died, it will never come back to life.</span><br><span class="line">    if (mAlive) &#123;</span><br><span class="line">        status_t status = IPCThreadState::self()-&gt;transact(</span><br><span class="line">            mHandle, code, data, reply, flags);</span><br><span class="line">        if (status == DEAD_OBJECT) mAlive = 0;</span><br><span class="line">        return status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return DEAD_OBJECT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>借用老罗的一张图总结，service_manager类之间复杂的关系：</p>
<p><img src="/images/android_binder/binder_class_manager.jpg" alt="binder_class_manager"></p>
<h2 id="4-3、server"><a href="#4-3、server" class="headerlink" title="4.3、server"></a>4.3、server</h2><p>有了manager的代理对象以后，server就可以注册服务并且创建binder rx服务线程了。</p>
<p>frameworks/av/media/mediaserver/main_mediaserver.cpp:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc __unused, char **argv __unused)</span><br><span class="line">&#123;</span><br><span class="line">    signal(SIGPIPE, SIG_IGN);</span><br><span class="line"></span><br><span class="line">    sp&lt;ProcessState&gt; proc(ProcessState::self());</span><br><span class="line">    sp&lt;IServiceManager&gt; sm(defaultServiceManager());</span><br><span class="line">    ALOGI(&quot;ServiceManager: %p&quot;, sm.get());</span><br><span class="line">    InitializeIcuOrDie();</span><br><span class="line">    MediaPlayerService::instantiate();</span><br><span class="line">    ResourceManagerService::instantiate();</span><br><span class="line">    registerExtensions();</span><br><span class="line">    ProcessState::self()-&gt;startThreadPool();</span><br><span class="line">    IPCThreadState::self()-&gt;joinThreadPool();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>↓<br>frameworks/av/media/libmediaplayerservice/MediaPlayerService.cpp:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void MediaPlayerService::instantiate() &#123;</span><br><span class="line">    defaultServiceManager()-&gt;addService(</span><br><span class="line">            String16(&quot;media.player&quot;), new MediaPlayerService());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有的细节在上面几节都已经描述过了，还是借用老罗的一张图总结service_server类之间复杂的关系：</p>
<p><img src="/images/android_binder/binder_class_server.jpg" alt="binder_class_server"></p>
<h2 id="4-4、client-proxy"><a href="#4-4、client-proxy" class="headerlink" title="4.4、client proxy"></a>4.4、client proxy</h2><p>service_client也是创建代理对象，和manager代理非常相似。我们也来具体分析一下。<br>frameworks/av/media/libmedia/IMediaDeathNotifier.cpp:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">IMediaDeathNotifier::getMediaPlayerService()</span><br><span class="line">&#123;</span><br><span class="line">    ALOGV(&quot;getMediaPlayerService&quot;);</span><br><span class="line">    Mutex::Autolock _l(sServiceLock);</span><br><span class="line">    if (sMediaPlayerService == 0) &#123;</span><br><span class="line">        /* (1) 创建manager代理对象 */</span><br><span class="line">        sp&lt;IServiceManager&gt; sm = defaultServiceManager();</span><br><span class="line">        sp&lt;IBinder&gt; binder;</span><br><span class="line">        do &#123;</span><br><span class="line">            /* (2) 使用manager代理获取到service的handle, </span><br><span class="line">                并根据handle创建一个BpBinder对象</span><br><span class="line">             */</span><br><span class="line">            binder = sm-&gt;getService(String16(&quot;media.player&quot;));</span><br><span class="line">            if (binder != 0) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            ALOGW(&quot;Media player service not published, waiting...&quot;);</span><br><span class="line">            usleep(500000); // 0.5 s</span><br><span class="line">        &#125; while (true);</span><br><span class="line"></span><br><span class="line">        if (sDeathNotifier == NULL) &#123;</span><br><span class="line">            sDeathNotifier = new DeathNotifier();</span><br><span class="line">        &#125;</span><br><span class="line">        binder-&gt;linkToDeath(sDeathNotifier);</span><br><span class="line">        /* (3) 根据BpBinder对象，使用interface_cast&lt;IMediaPlayerService&gt;()函数创建一个BpMediaPlayerService对象 */</span><br><span class="line">        sMediaPlayerService = interface_cast&lt;IMediaPlayerService&gt;(binder);</span><br><span class="line">    &#125;</span><br><span class="line">    ALOGE_IF(sMediaPlayerService == 0, &quot;no media player service!?&quot;);</span><br><span class="line">    return sMediaPlayerService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了BpMediaPlayerService对象，即MediaPlayerService的远端代理，就可以调用远端service服务了。<br>frameworks/wilhelm/src/android/android_LocAVPlayer.cpp:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void LocAVPlayer::onPrepare() &#123;</span><br><span class="line">    SL_LOGD(&quot;LocAVPlayer::onPrepare()&quot;);</span><br><span class="line">    </span><br><span class="line">    /* (4.1) 获取到MediaPlayerService的远端代理 */</span><br><span class="line">    sp&lt;IMediaPlayerService&gt; mediaPlayerService(getMediaPlayerService());</span><br><span class="line">    if (mediaPlayerService != NULL) &#123;</span><br><span class="line">        switch (mDataLocatorType) &#123;</span><br><span class="line">        case kDataLocatorUri:</span><br><span class="line">        </span><br><span class="line">            /* (4.2) 调用远端service服务 */</span><br><span class="line">            mPlayer = mediaPlayerService-&gt;create(mPlayerClient /*IMediaPlayerClient*/,</span><br><span class="line">                    mPlaybackParams.sessionId);</span><br></pre></td></tr></table></figure>
<p>其中通过sm-&gt;getService(String16(“media.player”))返回BpBinder的过程如下：<br>frameworks/native/libs/binder/IServiceManager.cpp:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    virtual sp&lt;IBinder&gt; getService(const String16&amp; name) const&#123;&#125;</span><br><span class="line">↓</span><br><span class="line">    virtual sp&lt;IBinder&gt; checkService( const String16&amp; name) const</span><br><span class="line">    &#123;</span><br><span class="line">        Parcel data, reply;</span><br><span class="line">        data.writeInterfaceToken(IServiceManager::getInterfaceDescriptor());</span><br><span class="line">        data.writeString16(name);</span><br><span class="line">        /* (2.1) 向远程manager查询handle */</span><br><span class="line">        remote()-&gt;transact(CHECK_SERVICE_TRANSACTION, data, &amp;reply);</span><br><span class="line">        return reply.readStrongBinder();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>↓<br>frameworks/native/libs/binder/Parcel.cpp</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IBinder&gt; Parcel::readStrongBinder() const</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;IBinder&gt; val;</span><br><span class="line">    // Note that a lot of code in Android reads binders by hand with this</span><br><span class="line">    // method, and that code has historically been ok with getting nullptr</span><br><span class="line">    // back (while ignoring error codes).</span><br><span class="line">    readNullableStrongBinder(&amp;val);</span><br><span class="line">    return val;</span><br><span class="line">&#125;</span><br><span class="line">↓</span><br><span class="line">status_t Parcel::readNullableStrongBinder(sp&lt;IBinder&gt;* val) const</span><br><span class="line">&#123;</span><br><span class="line">    return unflatten_binder(ProcessState::self(), *this, val);</span><br><span class="line">&#125;</span><br><span class="line">↓</span><br><span class="line">status_t unflatten_binder(const sp&lt;ProcessState&gt;&amp; proc,</span><br><span class="line">    const Parcel&amp; in, sp&lt;IBinder&gt;* out)</span><br><span class="line">&#123;</span><br><span class="line">    const flat_binder_object* flat = in.readObject(false);</span><br><span class="line"></span><br><span class="line">    if (flat) &#123;</span><br><span class="line">        switch (flat-&gt;type) &#123;</span><br><span class="line">            case BINDER_TYPE_BINDER:</span><br><span class="line">                *out = reinterpret_cast&lt;IBinder*&gt;(flat-&gt;cookie);</span><br><span class="line">                return finish_unflatten_binder(NULL, *flat, in);</span><br><span class="line">            case BINDER_TYPE_HANDLE:</span><br><span class="line">                /* (2.1.1) 根据handle创建BpBinder */</span><br><span class="line">                *out = proc-&gt;getStrongProxyForHandle(flat-&gt;handle);</span><br><span class="line">                return finish_unflatten_binder(</span><br><span class="line">                    static_cast&lt;BpBinder*&gt;(out-&gt;get()), *flat, in);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return BAD_TYPE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>↓<br>然后就来到了创建manager代理对象同样的位置：<br>frameworks/native/libs/binder/ProcessState.cpp:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IBinder&gt; ProcessState::getStrongProxyForHandle(int32_t handle)</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;IBinder&gt; result;</span><br><span class="line"></span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">    /* (2.1.1.1) 查询BpBinder对象缓存，相同handle是否已经创建 */</span><br><span class="line">    handle_entry* e = lookupHandleLocked(handle);</span><br><span class="line"></span><br><span class="line">    if (e != NULL) &#123;</span><br><span class="line">        // We need to create a new BpBinder if there isn&apos;t currently one, OR we</span><br><span class="line">        // are unable to acquire a weak reference on this current one.  See comment</span><br><span class="line">        // in getWeakProxyForHandle() for more info about this.</span><br><span class="line">        IBinder* b = e-&gt;binder;</span><br><span class="line">        if (b == NULL || !e-&gt;refs-&gt;attemptIncWeak(this)) &#123;</span><br><span class="line">            if (handle == 0) &#123;</span><br><span class="line">                // Special case for context manager...</span><br><span class="line">                // The context manager is the only object for which we create</span><br><span class="line">                // a BpBinder proxy without already holding a reference.</span><br><span class="line">                // Perform a dummy transaction to ensure the context manager</span><br><span class="line">                // is registered before we create the first local reference</span><br><span class="line">                // to it (which will occur when creating the BpBinder).</span><br><span class="line">                // If a local reference is created for the BpBinder when the</span><br><span class="line">                // context manager is not present, the driver will fail to</span><br><span class="line">                // provide a reference to the context manager, but the</span><br><span class="line">                // driver API does not return status.</span><br><span class="line">                //</span><br><span class="line">                // Note that this is not race-free if the context manager</span><br><span class="line">                // dies while this code runs.</span><br><span class="line">                //</span><br><span class="line">                // TODO: add a driver API to wait for context manager, or</span><br><span class="line">                // stop special casing handle 0 for context manager and add</span><br><span class="line">                // a driver API to get a handle to the context manager with</span><br><span class="line">                // proper reference counting.</span><br><span class="line"></span><br><span class="line">                Parcel data;</span><br><span class="line">                status_t status = IPCThreadState::self()-&gt;transact(</span><br><span class="line">                        0, IBinder::PING_TRANSACTION, data, NULL, 0);</span><br><span class="line">                if (status == DEAD_OBJECT)</span><br><span class="line">                   return NULL;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            /* (2.1.1.2) 给新handle新创建一个对应BpBinder对象 */</span><br><span class="line">            b = new BpBinder(handle);</span><br><span class="line">            e-&gt;binder = b;</span><br><span class="line">            if (b) e-&gt;refs = b-&gt;getWeakRefs();</span><br><span class="line">            result = b;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // This little bit of nastyness is to allow us to add a primary</span><br><span class="line">            // reference to the remote proxy when this team doesn&apos;t have one</span><br><span class="line">            // but another team is sending the handle to us.</span><br><span class="line">            result.force_set(b);</span><br><span class="line">            e-&gt;refs-&gt;decWeak(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据BpBinder对象，使用interface_cast<imediaplayerservice>()函数创建一个BpMediaPlayerService对象的过程如下：</imediaplayerservice></p>
<p>interface_cast<imediaplayerservice>()扩展为：</imediaplayerservice></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inline sp&lt;IMediaPlayerService&gt; interface_cast(const sp&lt;IBinder&gt;&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">    return IMediaPlayerService::asInterface(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IMediaPlayerService定义在：<br>frameworks/av/media/libmedia/IMediaPlayerService.cpp：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IMPLEMENT_META_INTERFACE(MediaPlayerService, &quot;android.media.IMediaPlayerService&quot;);</span><br></pre></td></tr></table></figure>
<p>展开为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#define IMPLEMENT_META_INTERFACE(MediaPlayerService, &quot;android.os.IServiceManager&quot;)                       \</span><br><span class="line">    const ::android::String16 IMediaPlayerService::descriptor(&quot;android.os.IServiceManager&quot;);           \</span><br><span class="line">    const ::android::String16&amp;                                          \</span><br><span class="line">            IMediaPlayerService::getInterfaceDescriptor() const &#123;              \</span><br><span class="line">        return IMediaPlayerService::descriptor;                                \</span><br><span class="line">    &#125;                                                                   \</span><br><span class="line">    ::android::sp&lt;IMediaPlayerService&gt; IMediaPlayerService::asInterface(              \</span><br><span class="line">            const ::android::sp&lt;::android::IBinder&gt;&amp; obj)               \</span><br><span class="line">    &#123;                                                                   \</span><br><span class="line">        ::android::sp&lt;IMediaPlayerService&gt; intr;                               \</span><br><span class="line">        if (obj != NULL) &#123;                                              \</span><br><span class="line">            intr = static_cast&lt;IMediaPlayerService*&gt;(                          \</span><br><span class="line">                obj-&gt;queryLocalInterface(                               \</span><br><span class="line">                        IMediaPlayerService::descriptor).get());               \</span><br><span class="line">            if (intr == NULL) &#123;                                         \</span><br><span class="line">                /* (3.1) 根据BpBinder对象，创建一个BpMediaPlayerService对象 */</span><br><span class="line">                intr = new BpMediaPlayerService(obj);                          \</span><br><span class="line">            &#125;                                                           \</span><br><span class="line">        &#125;                                                               \</span><br><span class="line">        return intr;                                                    \</span><br><span class="line">    &#125;                                                                   \</span><br><span class="line">    IMediaPlayerService::IMediaPlayerService() &#123; &#125;                                    \</span><br><span class="line">    IMediaPlayerService::~IMediaPlayerService() &#123; &#125;                                   \</span><br></pre></td></tr></table></figure>
<p>BpMediaPlayerService的定义为：<br>frameworks/av/media/libmedia/IMediaPlayerService.cpp:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class BpMediaPlayerService: public BpInterface&lt;IMediaPlayerService&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    explicit BpMediaPlayerService(const sp&lt;IBinder&gt;&amp; impl)</span><br><span class="line">        : BpInterface&lt;IMediaPlayerService&gt;(impl)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual sp&lt;IMediaMetadataRetriever&gt; createMetadataRetriever()</span><br><span class="line">    &#123;</span><br><span class="line">        Parcel data, reply;</span><br><span class="line">        data.writeInterfaceToken(IMediaPlayerService::getInterfaceDescriptor());</span><br><span class="line">        remote()-&gt;transact(CREATE_METADATA_RETRIEVER, data, &amp;reply);</span><br><span class="line">        return interface_cast&lt;IMediaMetadataRetriever&gt;(reply.readStrongBinder());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>还是借用老罗的一张图总结service_client类之间复杂的关系：</p>
<p><img src="/images/android_binder/binder_class_client.jpg" alt="binder_class_client"></p>
<h2 id="4-5、service-thread管理"><a href="#4-5、service-thread管理" class="headerlink" title="4.5、service thread管理"></a>4.5、service thread管理</h2><p>binder service初始会启动2个main线程来提供服务，在等待service服务过多的情况下会动态的增加binder线程的数量，但是目前没有实现动态减少binder线程可能觉得cache着更好。</p>
<p>service一般默认最大考验开启15个线程，这个数值也可以通过ioctl的BINDER_SET_MAX_THREADS命令来修改。</p>
<p>动态增加binder线程的动作是binder驱动完成的，因为驱动可以看到service进程整个的阻塞情况。</p>
<p>具体驱动代码binder.c：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">static int binder_thread_read(struct binder_proc *proc,</span><br><span class="line">			      struct binder_thread *thread,</span><br><span class="line">			      binder_uintptr_t binder_buffer, size_t size,</span><br><span class="line">			      binder_size_t *consumed, int non_block)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	if (proc-&gt;requested_threads == 0 &amp;&amp;</span><br><span class="line">	    list_empty(&amp;thread-&gt;proc-&gt;waiting_threads) &amp;&amp;</span><br><span class="line">	    proc-&gt;requested_threads_started &lt; proc-&gt;max_threads &amp;&amp;</span><br><span class="line">	    (thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED |</span><br><span class="line">	     BINDER_LOOPER_STATE_ENTERED)) /* the user-space code fails to */</span><br><span class="line">	     /*spawn a new thread if we leave this out */) &#123;</span><br><span class="line">		proc-&gt;requested_threads++;</span><br><span class="line">		binder_inner_proc_unlock(proc);</span><br><span class="line">		binder_debug(BINDER_DEBUG_THREADS,</span><br><span class="line">			     &quot;%d:%d BR_SPAWN_LOOPER\n&quot;,</span><br><span class="line">			     proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">		</span><br><span class="line">		/* (1) 判断阻塞的情况下发送BR_SPAWN_LOOPER命令，通知native增加接收线程 */</span><br><span class="line">		if (put_user(BR_SPAWN_LOOPER, (uint32_t __user *)buffer))</span><br><span class="line">			return -EFAULT;</span><br><span class="line">		binder_stat_br(proc, thread, BR_SPAWN_LOOPER);</span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>frameworks/native/libs/binder/IPCThreadState.cpp：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">status_t IPCThreadState::executeCommand(int32_t cmd)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    case BR_SPAWN_LOOPER:</span><br><span class="line">        mProcess-&gt;spawnPooledThread(false);</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>↓<br>frameworks/native/libs/binder/ProcessState.cpp:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void ProcessState::spawnPooledThread(bool isMain)</span><br><span class="line">&#123;</span><br><span class="line">    if (mThreadPoolStarted) &#123;</span><br><span class="line">        String8 name = makeBinderThreadName();</span><br><span class="line">        ALOGV(&quot;Spawning new pooled thread, name=%s\n&quot;, name.string());</span><br><span class="line">        /* (1.1) 创建新的binder接收线程 */</span><br><span class="line">        sp&lt;Thread&gt; t = new PoolThread(isMain);</span><br><span class="line">        t-&gt;run(name.string());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-6、死亡通知-DeathRecipient"><a href="#4-6、死亡通知-DeathRecipient" class="headerlink" title="4.6、死亡通知(DeathRecipient)"></a>4.6、死亡通知(DeathRecipient)</h2><p>可以使用BC_REQUEST_DEATH_NOTIFICATION注册死亡通知，在server端正常或者异常死亡的情况下都能收到通知。</p>
<p>在server端进程正常或者异常退出时，会关闭进程所有打开的文件句柄：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">do_exit()</span><br><span class="line">↓</span><br><span class="line">exit_files()</span><br><span class="line">↓</span><br><span class="line">put_files_struct()</span><br><span class="line">↓</span><br><span class="line">static struct fdtable *close_files(struct files_struct * files)</span><br><span class="line">&#123;</span><br><span class="line">	/*</span><br><span class="line">	 * It is safe to dereference the fd table without RCU or</span><br><span class="line">	 * -&gt;file_lock because this is the last reference to the</span><br><span class="line">	 * files structure.</span><br><span class="line">	 */</span><br><span class="line">	struct fdtable *fdt = rcu_dereference_raw(files-&gt;fdt);</span><br><span class="line">	unsigned int i, j = 0;</span><br><span class="line"></span><br><span class="line">	for (;;) &#123;</span><br><span class="line">		unsigned long set;</span><br><span class="line">		i = j * BITS_PER_LONG;</span><br><span class="line">		if (i &gt;= fdt-&gt;max_fds)</span><br><span class="line">			break;</span><br><span class="line">		set = fdt-&gt;open_fds[j++];</span><br><span class="line">		while (set) &#123;</span><br><span class="line">			if (set &amp; 1) &#123;</span><br><span class="line">				struct file * file = xchg(&amp;fdt-&gt;fd[i], NULL);</span><br><span class="line">				if (file) &#123;</span><br><span class="line">					filp_close(file, files);</span><br><span class="line">					cond_resched_rcu_qs();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			i++;</span><br><span class="line">			set &gt;&gt;= 1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return fdt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终会调用到binder fd的release函数，调用到死亡通知的回调:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static int binder_release(struct inode *nodp, struct file *filp)</span><br><span class="line">&#123;</span><br><span class="line">	struct binder_proc *proc = filp-&gt;private_data;</span><br><span class="line"></span><br><span class="line">	debugfs_remove(proc-&gt;debugfs_entry);</span><br><span class="line">	binder_defer_work(proc, BINDER_DEFERRED_RELEASE);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">↓</span><br><span class="line">static void</span><br><span class="line">binder_defer_work(struct binder_proc *proc, enum binder_deferred_state defer)</span><br><span class="line">&#123;</span><br><span class="line">	mutex_lock(&amp;binder_deferred_lock);</span><br><span class="line">	proc-&gt;deferred_work |= defer;</span><br><span class="line">	if (hlist_unhashed(&amp;proc-&gt;deferred_work_node)) &#123;</span><br><span class="line">		hlist_add_head(&amp;proc-&gt;deferred_work_node,</span><br><span class="line">				&amp;binder_deferred_list);</span><br><span class="line">		schedule_work(&amp;binder_deferred_work);</span><br><span class="line">	&#125;</span><br><span class="line">	mutex_unlock(&amp;binder_deferred_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5、java实现"><a href="#5、java实现" class="headerlink" title="5、java实现"></a>5、java实现</h1><p>略</p>
<h1 id="6、AIDL-Android-Interface-Definition-Language"><a href="#6、AIDL-Android-Interface-Definition-Language" class="headerlink" title="6、AIDL(Android Interface Definition Language)"></a>6、AIDL(Android Interface Definition Language)</h1><p>略</p>
<h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p><a href="https://blog.csdn.net/Luoshengyang/article/details/6629298" target="_blank" rel="noopener">1、Android系统进程间通信（IPC）机制 罗升阳</a><br><a href="http://light3moon.com/2015/01/28/Android%20Binder%20%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92%E8%80%85%5BParcel%5D/" target="_blank" rel="noopener">2、Android Binder 分析</a><br><a href="https://blog.csdn.net/universus/article/details/6211589" target="_blank" rel="noopener">3、Android Bander设计与实现</a><br><a href="https://blog.csdn.net/chenying126/article/details/78989413#_Toc503017553" target="_blank" rel="noopener">4、Binder实现原理分析</a><br><a href="https://blog.csdn.net/freekiteyu/article/details/70082302" target="_blank" rel="noopener">5、一篇文章了解相见恨晚的 Android Binder 进程间通讯机制</a>  </p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/binder/" rel="tag"># binder</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/10/29/systrace/" rel="next" title="Systrace">
                <i class="fa fa-chevron-left"></i> Systrace
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/touxiang/ycqs.jpg" alt="pwl999">
            
              <p class="site-author-name" itemprop="name">pwl999</p>
              <p class="site-description motion-element" itemprop="description">RTFSC(Read The Fucking Source Code)</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives">
                
                    <span class="site-state-item-count">30</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">3</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">22</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1、binder原理"><span class="nav-number">1.</span> <span class="nav-text">1、binder原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1、IPC函数指针"><span class="nav-number">1.1.</span> <span class="nav-text">1.1、IPC函数指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2、IPC函数参数"><span class="nav-number">1.2.</span> <span class="nav-text">1.2、IPC函数参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3、IPC函数返回值"><span class="nav-number">1.3.</span> <span class="nav-text">1.3、IPC函数返回值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4、binder内存"><span class="nav-number">1.4.</span> <span class="nav-text">1.4、binder内存</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2、binder驱动"><span class="nav-number">2.</span> <span class="nav-text">2、binder驱动</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1、service-manager的初始化"><span class="nav-number">2.1.</span> <span class="nav-text">2.1、service_manager的初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2、service-server的addService"><span class="nav-number">2.2.</span> <span class="nav-text">2.2、service_server的addService</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3、service-client的get-service"><span class="nav-number">2.3.</span> <span class="nav-text">2.3、service_client的get service</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4、service-client调用service"><span class="nav-number">2.4.</span> <span class="nav-text">2.4、service_client调用service</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5、Scatter-gather模式"><span class="nav-number">2.5.</span> <span class="nav-text">2.5、Scatter-gather模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-6、多个binder-context"><span class="nav-number">2.6.</span> <span class="nav-text">2.6、多个binder context</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-7、调试接口"><span class="nav-number">2.7.</span> <span class="nav-text">2.7、调试接口</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3、service-manager实现"><span class="nav-number">3.</span> <span class="nav-text">3、service manager实现</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4、native实现"><span class="nav-number">4.</span> <span class="nav-text">4、native实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1、process-thread"><span class="nav-number">4.1.</span> <span class="nav-text">4.1、process/thread</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2、manager-proxy"><span class="nav-number">4.2.</span> <span class="nav-text">4.2、manager proxy</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3、server"><span class="nav-number">4.3.</span> <span class="nav-text">4.3、server</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4、client-proxy"><span class="nav-number">4.4.</span> <span class="nav-text">4.4、client proxy</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-5、service-thread管理"><span class="nav-number">4.5.</span> <span class="nav-text">4.5、service thread管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-6、死亡通知-DeathRecipient"><span class="nav-number">4.6.</span> <span class="nav-text">4.6、死亡通知(DeathRecipient)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5、java实现"><span class="nav-number">5.</span> <span class="nav-text">5、java实现</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6、AIDL-Android-Interface-Definition-Language"><span class="nav-number">6.</span> <span class="nav-text">6、AIDL(Android Interface Definition Language)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考资料："><span class="nav-number">7.</span> <span class="nav-text">参考资料：</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">pwl999</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v6.6.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script src="/js/src/utils.js?v=6.6.0"></script>

  <script src="/js/src/motion.js?v=6.6.0"></script>



  
  


  <script src="/js/src/affix.js?v=6.6.0"></script>

  <script src="/js/src/schemes/pisces.js?v=6.6.0"></script>



  
  <script src="/js/src/scrollspy.js?v=6.6.0"></script>
<script src="/js/src/post-details.js?v=6.6.0"></script>



  


  <script src="/js/src/bootstrap.js?v=6.6.0"></script>



  

  
    <script id="dsq-count-scr" src="https://.disqus.com/count.js" async></script>
  

  
    <script>
      var disqus_config = function () {
        this.page.url = "http://yoursite.com/2018/12/12/android_binder/";
        this.page.identifier = "2018/12/12/android_binder/";
        this.page.title = 'Android Binder';
        };
      function loadComments () {
        var d = document, s = d.createElement('script');
        s.src = 'https://.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      }
      
        loadComments();
      
    </script>
  





  











  





  

  

  

  

  

  
  

  

  

  

  

  

  

</body>
</html>
