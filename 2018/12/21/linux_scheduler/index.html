<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
































<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.6.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.6.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.6.0" color="#222">









<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.6.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="1、Linux schedule框架(调度的时刻) Linux进程调度(schedule)的框架如上图所示。  本文的代码分析基于linux kernel 4.4.22，最好的学习方法还是”RTFSC”  1.1、中心是rq(runqueue)rq其实是runnable queue，即本cpu上所有可运行进程的队列集合。每个cpu每种类型的rq(cfs/rt)只有一个，一个rq包含多个runnab">
<meta name="keywords" content="scheduler, pelt, welt, EAS">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux Schedule">
<meta property="og:url" content="http://yoursite.com/2018/12/21/linux_scheduler/index.html">
<meta property="og:site_name" content="pwl999&#39;s blog">
<meta property="og:description" content="1、Linux schedule框架(调度的时刻) Linux进程调度(schedule)的框架如上图所示。  本文的代码分析基于linux kernel 4.4.22，最好的学习方法还是”RTFSC”  1.1、中心是rq(runqueue)rq其实是runnable queue，即本cpu上所有可运行进程的队列集合。每个cpu每种类型的rq(cfs/rt)只有一个，一个rq包含多个runnab">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/images/scheduler/schedule_frame.png">
<meta property="og:image" content="http://yoursite.com/images/scheduler/schedule_26O1_scheduler.gif">
<meta property="og:image" content="http://yoursite.com/images/scheduler/schedule_rbtree.png">
<meta property="og:image" content="http://yoursite.com/images/scheduler/schedule_cfs_frame.png">
<meta property="og:image" content="http://yoursite.com/images/scheduler/schedule_cfs_bandwidth.png">
<meta property="og:image" content="http://yoursite.com/images/scheduler/schedule_rt-throttle.png">
<meta property="og:image" content="http://yoursite.com/images/scheduler/schedule_geometric_series.png">
<meta property="og:image" content="http://yoursite.com/images/scheduler/schedule_update_load_avg_3time.png">
<meta property="og:image" content="http://yoursite.com/images/scheduler/schedule_update_load_avg_scale_freq.png">
<meta property="og:image" content="http://yoursite.com/images/scheduler/schedule_update_load_avg_scale_cpu.png">
<meta property="og:image" content="http://yoursite.com/images/scheduler/schedule_geometric_series_sum.png">
<meta property="og:image" content="http://yoursite.com/images/scheduler/schedule_update_load_avg_loadwop_avg.png">
<meta property="og:image" content="http://yoursite.com/images/scheduler/schedule_update_load_avg_load_avg.png">
<meta property="og:image" content="http://yoursite.com/images/scheduler/schedule_update_load_avg_util_avg.png">
<meta property="og:image" content="http://yoursite.com/images/scheduler/schedule_update_load_avg_scale_freq.png">
<meta property="og:image" content="http://yoursite.com/images/scheduler/schedule_update_load_avg_scale_cpu.png">
<meta property="og:image" content="http://yoursite.com/images/scheduler/schedule_cpu_load.png">
<meta property="og:image" content="http://yoursite.com/images/scheduler/schedule_sys_load_avg.png">
<meta property="og:image" content="http://yoursite.com/images/scheduler/schedule_sched_domain_mt6799_8cpus.png">
<meta property="og:image" content="http://yoursite.com/images/scheduler/schedule_rebalance_domains_find_busiest_group.png">
<meta property="og:image" content="http://yoursite.com/images/scheduler/schedule_rebalance_domains_find_busiest_queue.png">
<meta property="og:image" content="http://yoursite.com/images/scheduler/schedule_nohz_balance_step1.png">
<meta property="og:image" content="http://yoursite.com/images/scheduler/schedule_nohz_balance_step2.png">
<meta property="og:image" content="http://yoursite.com/images/scheduler/schedule_nohz_balance_step3.png">
<meta property="og:image" content="http://yoursite.com/images/scheduler/schedule_select_task_energy_aware_wake_find_cluaster.png">
<meta property="og:image" content="http://yoursite.com/images/scheduler/schedule_select_task_energy_aware_find_cpu.png">
<meta property="og:image" content="http://yoursite.com/images/scheduler/schedule_select_task_energy_aware_migration_direct.png">
<meta property="og:image" content="http://yoursite.com/images/scheduler/schedule_select_task_energy_aware_energy_diff.png">
<meta property="og:image" content="http://yoursite.com/images/scheduler/schedule_hmp_domains_init.png">
<meta property="og:image" content="http://yoursite.com/images/scheduler/schedule_hmp_up_migration.png">
<meta property="og:image" content="http://yoursite.com/images/scheduler/schedule_hmp_force_up_migration_hmp_select_cpu.png">
<meta property="og:image" content="http://yoursite.com/images/scheduler/schedule_hmp_down_migration.png">
<meta property="og:image" content="http://yoursite.com/images/scheduler/schedule_hmp_force_down_migration_hmp_select_cpu.png">
<meta property="og:image" content="http://yoursite.com/images/scheduler/schedule_cpufreq_frame.png">
<meta property="og:image" content="http://yoursite.com/images/scheduler/schedule_cpufreq_mtk_frame.png">
<meta property="og:image" content="http://yoursite.com/images/scheduler/schedule_cpufreq_core.png">
<meta property="og:image" content="http://yoursite.com/images/scheduler/schedule_cpufreq_interactive.png">
<meta property="og:image" content="http://yoursite.com/images/scheduler/schedule_hotplug_cpu_up.png">
<meta property="og:image" content="http://yoursite.com/images/scheduler/schedule_hotplug_mtk.png">
<meta property="og:image" content="http://yoursite.com/images/scheduler/schedule_sched_governor.png">
<meta property="og:image" content="http://yoursite.com/images/scheduler/schedule_walt_update_task_demand.png">
<meta property="og:image" content="http://yoursite.com/images/scheduler/schedule_walt_update_history.png">
<meta property="og:image" content="http://yoursite.com/images/scheduler/schedule_walt_qualcom_interactive.png">
<meta property="og:image" content="http://yoursite.com/images/scheduler/schedule_cgroup_frame.png">
<meta property="og:image" content="http://yoursite.com/images/scheduler/schedule_cgroup_frame_detail.png">
<meta property="og:updated_time" content="2018-12-21T03:11:03.717Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Linux Schedule">
<meta name="twitter:description" content="1、Linux schedule框架(调度的时刻) Linux进程调度(schedule)的框架如上图所示。  本文的代码分析基于linux kernel 4.4.22，最好的学习方法还是”RTFSC”  1.1、中心是rq(runqueue)rq其实是runnable queue，即本cpu上所有可运行进程的队列集合。每个cpu每种类型的rq(cfs/rt)只有一个，一个rq包含多个runnab">
<meta name="twitter:image" content="http://yoursite.com/images/scheduler/schedule_frame.png">






  <link rel="canonical" href="http://yoursite.com/2018/12/21/linux_scheduler/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Linux Schedule | pwl999's blog</title>
  












  <noscript>
  <style>
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion .logo-line-before i { left: initial; }
    .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">pwl999's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/21/linux_scheduler/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="pwl999">
      <meta itemprop="description" content="RTFSC(Read The Fucking Source Code)">
      <meta itemprop="image" content="/images/touxiang/ycqs.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="pwl999's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Linux Schedule

              
            
          </h1>
        

        <div class="post-meta">

          
            <i class="fa fa-thumb-tack"></i>
            <font color="7D26CD">置顶</font>
            <span class="post-meta-divider">|</span>
          

        <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-21 10:18:21 / 修改时间：11:11:03" itemprop="dateCreated datePublished" datetime="2018-12-21T10:18:21+08:00">2018-12-21</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/12/21/linux_scheduler/#comments" itemprop="discussionUrl">
                
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/12/21/linux_scheduler/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="1、Linux-schedule框架-调度的时刻"><a href="#1、Linux-schedule框架-调度的时刻" class="headerlink" title="1、Linux schedule框架(调度的时刻)"></a>1、Linux schedule框架(调度的时刻)</h1><p><img src="/images/scheduler/schedule_frame.png" alt="schedule_frame"></p>
<p>Linux进程调度(schedule)的框架如上图所示。</p>
<blockquote>
<p>本文的代码分析基于linux kernel 4.4.22，最好的学习方法还是”RTFSC”</p>
</blockquote>
<h2 id="1-1、中心是rq-runqueue"><a href="#1-1、中心是rq-runqueue" class="headerlink" title="1.1、中心是rq(runqueue)"></a>1.1、中心是rq(runqueue)</h2><p>rq其实是runnable queue，即本cpu上所有可运行进程的队列集合。每个cpu每种类型的rq(cfs/rt)只有一个，一个rq包含多个runnable的task，但是rq当前正在运行的进程(current running task)只有一个。</p>
<p>既然rq是中心，那么以下几点就是关键路径：</p>
<ul>
<li>1、什么时候task入rq？</li>
<li>2、什么时候task出rq？</li>
<li>3、rq怎么样从多个可运行的进程(runnable tasks)中选取一个进程作为当前的运行进程(current running task)？</li>
</ul>
<p>我们下面就逐一解答这些疑问，理解了这些关键路径，你就对linux的进程调度框架有了一个清晰的认识。</p>
<h2 id="1-2、入rq-enqueue"><a href="#1-2、入rq-enqueue" class="headerlink" title="1.2、入rq(enqueue)"></a>1.2、入rq(enqueue)</h2><p>只有task新创建/或者task从blocked状态被唤醒(wakeup)，task才会被压入rq。涉及到进程调度相关的步骤如下：</p>
<ul>
<li><p>1、把task压入rq(enqueue)，且把task-&gt;state设置为TASK_RUNNING；</p>
</li>
<li><p>2、判断压入新task以后rq的负载情况，当前task需不需要被调度出去，如果需要把当前task的thread_info-&gt;flags其中TIF_NEED_RESCHED bit置位。</p>
</li>
</ul>
<p><strong><em>重点在这里</em></strong>：如果当前进程需要重新调度的条件成立，这里只是会设置TIF_NEED_RESCHED标志，并不会马上调用schedule()来进行调度。真正的调度时机发生在从中断/异常返回时，会判断当前进程有没有被设置TIF_NEED_RESCHED，如果设置则调用schedule()来进行调度。</p>
<p>为什么唤醒涉及到调度不会马上执行？而是只设置一个TIF_NEED_RESCHED，等到中断/异常返回的时候才执行？</p>
<p>我理解有几点：(1)唤醒操作经常在中断上下文中执行，在这个环境中直接调用schedule()进行调度是不行的；(2)为了维护非抢占内核以来的一些传统，不要轻易中断进程的处理逻辑除非他主动放弃；(3)在普通上下文中，唤醒后接着调用schedule()也是可以的，我们看到一些特殊函数就是这么干的(调用smp_send_reschedule()、resched_curr()的函数)。</p>
<ul>
<li>3、等待中断/异常的发生、返回，在返回时判读有TIF_NEED_RESCHED，则调用schedule()进行调度；</li>
</ul>
<h2 id="1-3、出rq-dequeue"><a href="#1-3、出rq-dequeue" class="headerlink" title="1.3、出rq(dequeue)"></a>1.3、出rq(dequeue)</h2><p>在当前进程调用系统函数进入blocked状态是，task会出rq(dequeue)。具体的步骤如下：</p>
<ul>
<li><p>1、当前进程把task-&gt;state设置为TASK_INTERRUPTIBLE/TASK_UNINTERRUPTIBLE;</p>
</li>
<li><p>2、立即调用schedule()进行调度；</p>
</li>
</ul>
<p><strong><em>这里block是和wakeup、scheduler_tick最大的不同</em></strong>，block是马上调用schedule()进行调度，而wakeup、scheduler_tick是设置TIF_NEED_RESCHED标志，等待中断/异常返回时才执行真正的schedule()操作；</p>
<ul>
<li>3、调用schedule()后，判断当前进程task-&gt;state已经非TASK_RUNNING，则进行dequeue操作，并且调度其他进程到rq-&gt;curr。</li>
</ul>
<h2 id="1-4、定时调度rq-scheduler-tick"><a href="#1-4、定时调度rq-scheduler-tick" class="headerlink" title="1.4、定时调度rq(scheduler_tick)"></a>1.4、定时调度rq(scheduler_tick)</h2><p>前面说了在rq的enqueue、dequeue时刻会计算rq负载，来决定把哪个runnable task放到current running task。除了enqueue/dequeue时候，系统还会周期性的计算rq负载来进行调度，确保多进程在1个cpu上都能得到服务。具体的步骤如下：</p>
<ul>
<li>1、每1 tick，local timer产生一次中断。中断中调用scheduler_tick()，计算rq的负载重新调度；</li>
<li>2、如果当前进程需要被调度，则设置TIF_NEED_RESCHED标志；</li>
<li>3、在local timer中断返回的时候，时判读有TIF_NEED_RESCHED，则调用schedule()进行调度；</li>
</ul>
<h2 id="1-5、中断-异常返回-Interrupt-Exception"><a href="#1-5、中断-异常返回-Interrupt-Exception" class="headerlink" title="1.5、中断/异常返回(Interrupt/Exception)"></a>1.5、中断/异常返回(Interrupt/Exception)</h2><p>在前面几节中有一个重要的概念，wakeup、scheduler_tick操作后，如果需要调度只会设置TIF_NEED_RESCHED，在中断/异常返回时才执行真正的调度schedule()操作；</p>
<p>那么在哪些中断/异常返回时会执行schedule()呢？</p>
<p>我们分析”arch/arm64/kernel/entry.S”，在ArmV8架构下用户态跑在el0、内核态跑在el1。</p>
<ul>
<li>1、内核态异常的返回el1_sync()：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">	.align	6</span><br><span class="line">el1_sync:</span><br><span class="line">	kernel_entry 1</span><br><span class="line">	mov	x0, sp</span><br><span class="line">	get_thread_info x20	// top of stack</span><br><span class="line">	ldr	w4, [x20, #TI_CPU_EXCP]</span><br><span class="line">	add	w4, w4, #0x1</span><br><span class="line">	str	w4, [x20, #TI_CPU_EXCP]</span><br><span class="line">	cmp	w4, #0x1</span><br><span class="line">	b.ne	el1_sync_nest</span><br><span class="line">	str	x0, [x20, #TI_REGS_ON_EXCP]</span><br><span class="line">el1_sync_nest:</span><br><span class="line">	mrs	x1, esr_el1			// read the syndrome register</span><br><span class="line">	lsr	x24, x1, #ESR_ELx_EC_SHIFT	// exception class</span><br><span class="line">	cmp	x24, #ESR_ELx_EC_DABT_CUR	// data abort in EL1</span><br><span class="line">	b.ne	el1_sync_nest_skip_dec</span><br><span class="line">	sub	w4, w4, #0x1</span><br><span class="line">	str	w4, [x20, #TI_CPU_EXCP]</span><br><span class="line">el1_sync_nest_skip_dec:</span><br><span class="line">	cmp	w4, #0x2</span><br><span class="line">	b.lt	el1_sync_nest_skip</span><br><span class="line">	bl	aee_stop_nested_panic</span><br><span class="line">el1_sync_nest_skip:</span><br><span class="line">	mrs	x1, esr_el1			// read the syndrome register</span><br><span class="line">	lsr	x24, x1, #ESR_ELx_EC_SHIFT	// exception class</span><br><span class="line">	cmp	x24, #ESR_ELx_EC_DABT_CUR	// data abort in EL1</span><br><span class="line">	b.eq	el1_da</span><br><span class="line">	cmp	x24, #ESR_ELx_EC_IABT_CUR	// instruction abort in EL1</span><br><span class="line">	b.eq	el1_ia</span><br><span class="line">	cmp	x24, #ESR_ELx_EC_SYS64		// configurable trap</span><br><span class="line">	b.eq	el1_undef</span><br><span class="line">	cmp	x24, #ESR_ELx_EC_SP_ALIGN	// stack alignment exception</span><br><span class="line">	b.eq	el1_sp_pc</span><br><span class="line">	cmp	x24, #ESR_ELx_EC_PC_ALIGN	// pc alignment exception</span><br><span class="line">	b.eq	el1_sp_pc</span><br><span class="line">	cmp	x24, #ESR_ELx_EC_UNKNOWN	// unknown exception in EL1</span><br><span class="line">	b.eq	el1_undef</span><br><span class="line">	cmp	x24, #ESR_ELx_EC_BREAKPT_CUR	// debug exception in EL1</span><br><span class="line">	b.ge	el1_dbg</span><br><span class="line">	b	el1_inv</span><br><span class="line"></span><br><span class="line">el1_ia:</span><br><span class="line">	/*</span><br><span class="line">	 * Fall through to the Data abort case</span><br><span class="line">	 */</span><br><span class="line">el1_da:</span><br><span class="line">	/*</span><br><span class="line">	 * Data abort handling</span><br><span class="line">	 */</span><br><span class="line">	mrs	x0, far_el1</span><br><span class="line">	enable_dbg</span><br><span class="line">	// re-enable interrupts if they were enabled in the aborted context</span><br><span class="line">	tbnz	x23, #7, 1f			// PSR_I_BIT</span><br><span class="line">	enable_irq</span><br><span class="line">1:</span><br><span class="line">	mov	x2, sp				// struct pt_regs</span><br><span class="line">	bl	do_mem_abort</span><br><span class="line">	cmp	x24, #ESR_ELx_EC_DABT_CUR	// data abort in EL1</span><br><span class="line">	b.eq	el1_da_nest_skip_dec</span><br><span class="line">	mov	x5, sp</span><br><span class="line">	get_thread_info x20	// top of stack</span><br><span class="line">	ldr	w4, [x20, #TI_CPU_EXCP]</span><br><span class="line">	sub	w4, w4, #0x1</span><br><span class="line">	str	w4, [x20, #TI_CPU_EXCP]</span><br><span class="line">el1_da_nest_skip_dec:</span><br><span class="line"></span><br><span class="line">	// disable interrupts before pulling preserved data off the stack</span><br><span class="line">	disable_irq</span><br><span class="line">	kernel_exit 1</span><br><span class="line">el1_sp_pc:</span><br><span class="line">	/*</span><br><span class="line">	 * Stack or PC alignment exception handling</span><br><span class="line">	 */</span><br><span class="line">	mrs	x0, far_el1</span><br><span class="line">	enable_dbg</span><br><span class="line">	mov	x2, sp</span><br><span class="line">	b	do_sp_pc_abort</span><br><span class="line">el1_undef:</span><br><span class="line">	/*</span><br><span class="line">	 * Undefined instruction</span><br><span class="line">	 */</span><br><span class="line">	enable_dbg</span><br><span class="line">	mov	x0, sp</span><br><span class="line">	bl	do_undefinstr</span><br><span class="line">el1_dbg:</span><br><span class="line">	/*</span><br><span class="line">	 * Debug exception handling</span><br><span class="line">	 */</span><br><span class="line">	cmp	x24, #ESR_ELx_EC_BRK64		// if BRK64</span><br><span class="line">	cinc	x24, x24, eq			// set bit &apos;0&apos;</span><br><span class="line">	tbz	x24, #0, el1_inv		// EL1 only</span><br><span class="line">	mrs	x0, far_el1</span><br><span class="line">	mov	x2, sp				// struct pt_regs</span><br><span class="line">	bl	do_debug_exception</span><br><span class="line">	mov	x5, sp</span><br><span class="line">	get_thread_info x20	// top of stack</span><br><span class="line">	ldr	w4, [x20, #TI_CPU_EXCP]</span><br><span class="line">	sub	w4, w4, #0x1</span><br><span class="line">	str	w4, [x20, #TI_CPU_EXCP]</span><br><span class="line"></span><br><span class="line">	kernel_exit 1</span><br><span class="line">el1_inv:</span><br><span class="line">	// TODO: add support for undefined instructions in kernel mode</span><br><span class="line">	enable_dbg</span><br><span class="line">	mov	x0, sp</span><br><span class="line">	mov	x2, x1</span><br><span class="line">	mov	x1, #BAD_SYNC</span><br><span class="line">	b	bad_mode</span><br><span class="line">ENDPROC(el1_sync)</span><br></pre></td></tr></table></figure>
<p>大部分的内核态异常都是不可恢复的，内核最终会调用panic()复位，所以根本不会再返回去判断TIF_NEED_RESCHED标志；另外一部分可以返回的也只是简单调用kernel_exit恢复，不会去判断TIF_NEED_RESCHED标志。</p>
<ul>
<li>2、内核态中断的返回el1_sync()：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">	.align	6</span><br><span class="line">el1_irq:</span><br><span class="line">	kernel_entry 1</span><br><span class="line">	enable_dbg</span><br><span class="line">#ifdef CONFIG_TRACE_IRQFLAGS</span><br><span class="line">	bl	trace_hardirqs_off</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	irq_handler</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_PREEMPT</span><br><span class="line">	ldr	w24, [tsk, #TI_PREEMPT]		// get preempt count</span><br><span class="line">	cbnz	w24, 1f				// preempt count != 0</span><br><span class="line">	                            // (1) 如果preempt count大于0，禁止抢占，直接返回</span><br><span class="line">	ldr	x0, [tsk, #TI_FLAGS]		// get flags</span><br><span class="line">	tbz	x0, #TIF_NEED_RESCHED, 1f	// needs rescheduling?</span><br><span class="line">	bl	el1_preempt             // (2) 如果preempt count=0且TIF_NEED_RESCHED被置位，</span><br><span class="line">	                            //  继续调用el1_preempt() -&gt; preempt_schedule_irq() -&gt; __schedule()</span><br><span class="line">1:</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_TRACE_IRQFLAGS</span><br><span class="line">	bl	trace_hardirqs_on</span><br><span class="line">#endif</span><br><span class="line">	kernel_exit 1</span><br><span class="line">ENDPROC(el1_irq)</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_PREEMPT</span><br><span class="line">el1_preempt:</span><br><span class="line">	mov	x24, lr</span><br><span class="line">1:	bl	preempt_schedule_irq		// irq en/disable is done inside</span><br><span class="line">	ldr	x0, [tsk, #TI_FLAGS]		// get new tasks TI_FLAGS</span><br><span class="line">	tbnz	x0, #TIF_NEED_RESCHED, 1b	// needs rescheduling?</span><br><span class="line">	ret	x24</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">asmlinkage __visible void __sched preempt_schedule_irq(void)</span><br><span class="line">&#123;</span><br><span class="line">	enum ctx_state prev_state;</span><br><span class="line"></span><br><span class="line">	/* Catch callers which need to be fixed */</span><br><span class="line">	BUG_ON(preempt_count() || !irqs_disabled());</span><br><span class="line"></span><br><span class="line">	prev_state = exception_enter();</span><br><span class="line"></span><br><span class="line">	do &#123;</span><br><span class="line">		preempt_disable();</span><br><span class="line">		local_irq_enable();</span><br><span class="line">		__schedule(true);</span><br><span class="line">		local_irq_disable();</span><br><span class="line">		sched_preempt_enable_no_resched();</span><br><span class="line">	&#125; while (need_resched());</span><br><span class="line"></span><br><span class="line">	exception_exit(prev_state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在内核态中断返回时：会首先判断当前进程的thread_info-&gt;preempt_count的值，如果大于0说明禁止抢占不做处理直接返回；如果等于0且thread_info-&gt;flags被置位TIF_NEED_RESCHED，调用preempt_schedule_irq()重新进行调度。</p>
<ul>
<li>3、用户态系统调用类异常的返回el0_svc()：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">	.align	6</span><br><span class="line">el0_sync:</span><br><span class="line">	kernel_entry 0</span><br><span class="line">	mrs	x25, esr_el1			// read the syndrome register</span><br><span class="line">	lsr	x24, x25, #ESR_ELx_EC_SHIFT	// exception class</span><br><span class="line">	cmp	x24, #ESR_ELx_EC_SVC64		// SVC in 64-bit state</span><br><span class="line">	b.eq	el0_svc                 // (1) 系统调用类的异常</span><br><span class="line">	cmp	x24, #ESR_ELx_EC_DABT_LOW	// data abort in EL0</span><br><span class="line">	b.eq	el0_da</span><br><span class="line">	cmp	x24, #ESR_ELx_EC_IABT_LOW	// instruction abort in EL0</span><br><span class="line">	b.eq	el0_ia</span><br><span class="line">	cmp	x24, #ESR_ELx_EC_FP_ASIMD	// FP/ASIMD access</span><br><span class="line">	b.eq	el0_fpsimd_acc</span><br><span class="line">	cmp	x24, #ESR_ELx_EC_FP_EXC64	// FP/ASIMD exception</span><br><span class="line">	b.eq	el0_fpsimd_exc</span><br><span class="line">	cmp	x24, #ESR_ELx_EC_SYS64		// configurable trap</span><br><span class="line">	b.eq	el0_undef</span><br><span class="line">	cmp	x24, #ESR_ELx_EC_SP_ALIGN	// stack alignment exception</span><br><span class="line">	b.eq	el0_sp_pc</span><br><span class="line">	cmp	x24, #ESR_ELx_EC_PC_ALIGN	// pc alignment exception</span><br><span class="line">	b.eq	el0_sp_pc</span><br><span class="line">	cmp	x24, #ESR_ELx_EC_UNKNOWN	// unknown exception in EL0</span><br><span class="line">	b.eq	el0_undef</span><br><span class="line">	cmp	x24, #ESR_ELx_EC_BREAKPT_LOW	// debug exception in EL0</span><br><span class="line">	b.ge	el0_dbg</span><br><span class="line">	b	el0_inv</span><br><span class="line">	</span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">	.align	6</span><br><span class="line">el0_svc:</span><br><span class="line">	adrp	stbl, sys_call_table		// load syscall table pointer</span><br><span class="line">	uxtw	scno, w8			// syscall number in w8</span><br><span class="line">	mov	sc_nr, #__NR_syscalls</span><br><span class="line">el0_svc_naked:					// compat entry point</span><br><span class="line">	stp	x0, scno, [sp, #S_ORIG_X0]	// save the original x0 and syscall number</span><br><span class="line">	enable_dbg_and_irq</span><br><span class="line">	ct_user_exit 1</span><br><span class="line"></span><br><span class="line">	ldr	x16, [tsk, #TI_FLAGS]		// check for syscall hooks</span><br><span class="line">	tst	x16, #_TIF_SYSCALL_WORK</span><br><span class="line">	b.ne	__sys_trace</span><br><span class="line">	cmp     scno, sc_nr                     // check upper syscall limit</span><br><span class="line">	b.hs	ni_sys</span><br><span class="line">	ldr	x16, [stbl, scno, lsl #3]	// address in the syscall table</span><br><span class="line">	blr	x16				// call sys_* routine</span><br><span class="line">	                    // (1.1) 系统调用的执行</span><br><span class="line">	b	ret_fast_syscall // (1.2) 系统调用异常的的返回</span><br><span class="line">ni_sys:</span><br><span class="line">	mov	x0, sp</span><br><span class="line">	bl	do_ni_syscall</span><br><span class="line">	b	ret_fast_syscall</span><br><span class="line">ENDPROC(el0_svc)</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * This is the fast syscall return path.  We do as little as possible here,</span><br><span class="line"> * and this includes saving x0 back into the kernel stack.</span><br><span class="line"> */</span><br><span class="line">ret_fast_syscall:</span><br><span class="line">	disable_irq				// disable interrupts</span><br><span class="line">	str	x0, [sp, #S_X0]			// returned x0</span><br><span class="line">	ldr	x1, [tsk, #TI_FLAGS]		// re-check for syscall tracing</span><br><span class="line">	and	x2, x1, #_TIF_SYSCALL_WORK  // (1.2.1) 判断thread_info-&gt;flags中_TIF_SYSCALL_WORK有没有被置位</span><br><span class="line">	                                // _TIF_WORK_MASK = (_TIF_NEED_RESCHED | _TIF_SIGPENDING | _TIF_NOTIFY_RESUME | _TIF_FOREIGN_FPSTATE)</span><br><span class="line">	                                // _TIF_NEED_RESCHED：当前进程需要调度</span><br><span class="line">	                                // _TIF_SIGPENDING：当前进程有pending的信号需要处理</span><br><span class="line">	cbnz	x2, ret_fast_syscall_trace</span><br><span class="line">	and	x2, x1, #_TIF_WORK_MASK</span><br><span class="line">	cbnz	x2, work_pending        // (1.2.2) 如果有wokr需要处理调用work_pending</span><br><span class="line">	enable_step_tsk x1, x2</span><br><span class="line">	kernel_exit 0</span><br><span class="line">ret_fast_syscall_trace:</span><br><span class="line">	enable_irq				// enable interrupts</span><br><span class="line">	b	__sys_trace_return_skipped	// we already saved x0</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Ok, we need to do extra processing, enter the slow path.</span><br><span class="line"> */</span><br><span class="line">work_pending:</span><br><span class="line">	tbnz	x1, #TIF_NEED_RESCHED, work_resched</span><br><span class="line">	/* TIF_SIGPENDING, TIF_NOTIFY_RESUME or TIF_FOREIGN_FPSTATE case */</span><br><span class="line">	mov	x0, sp				// &apos;regs&apos;</span><br><span class="line">	enable_irq				// enable interrupts for do_notify_resume()</span><br><span class="line">	bl	do_notify_resume        // (1.2.2.1) 如果signal、resume等work需要处理，</span><br><span class="line">	                            // 调用do_notify_resume()</span><br><span class="line">	b	ret_to_user</span><br><span class="line">work_resched:</span><br><span class="line">#ifdef CONFIG_TRACE_IRQFLAGS</span><br><span class="line">	bl	trace_hardirqs_off		// the IRQs are off here, inform the tracing code</span><br><span class="line">#endif</span><br><span class="line">	bl	schedule            // (1.2.2.2) 如果TIF_NEED_RESCHED被置位，调用schedule()进行任务调度</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * &quot;slow&quot; syscall return path.</span><br><span class="line"> */</span><br><span class="line">ret_to_user:</span><br><span class="line">	disable_irq				// disable interrupts</span><br><span class="line">	ldr	x1, [tsk, #TI_FLAGS]</span><br><span class="line">	and	x2, x1, #_TIF_WORK_MASK</span><br><span class="line">	cbnz	x2, work_pending</span><br><span class="line">	enable_step_tsk x1, x2</span><br><span class="line">	kernel_exit 0</span><br><span class="line">ENDPROC(ret_to_user)</span><br></pre></td></tr></table></figure>
<p>用户态的异常其中一个大类就是系统调用，这是用户主动调用svc命令陷入到内核态中执行系统调用。<br>在返回用户态的时候会判断thread_info-&gt;flags中的TIF_NEED_RESCHED bit有没有被置位，有置位则会调用schedule()；还会判断_TIF_SIGPENDING，有置位会进行信号处理do_signal()。</p>
<ul>
<li>4、用户态其他异常的返回el0_sync()：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">	.align	6</span><br><span class="line">el0_sync:</span><br><span class="line">	kernel_entry 0</span><br><span class="line">	mrs	x25, esr_el1			// read the syndrome register</span><br><span class="line">	lsr	x24, x25, #ESR_ELx_EC_SHIFT	// exception class</span><br><span class="line">	cmp	x24, #ESR_ELx_EC_SVC64		// SVC in 64-bit state</span><br><span class="line">	b.eq	el0_svc                 </span><br><span class="line">	cmp	x24, #ESR_ELx_EC_DABT_LOW	// data abort in EL0</span><br><span class="line">	b.eq	el0_da                  // (1) 其他类型的异常</span><br><span class="line">	cmp	x24, #ESR_ELx_EC_IABT_LOW	// instruction abort in EL0</span><br><span class="line">	b.eq	el0_ia</span><br><span class="line">	cmp	x24, #ESR_ELx_EC_FP_ASIMD	// FP/ASIMD access</span><br><span class="line">	b.eq	el0_fpsimd_acc</span><br><span class="line">	cmp	x24, #ESR_ELx_EC_FP_EXC64	// FP/ASIMD exception</span><br><span class="line">	b.eq	el0_fpsimd_exc</span><br><span class="line">	cmp	x24, #ESR_ELx_EC_SYS64		// configurable trap</span><br><span class="line">	b.eq	el0_undef</span><br><span class="line">	cmp	x24, #ESR_ELx_EC_SP_ALIGN	// stack alignment exception</span><br><span class="line">	b.eq	el0_sp_pc</span><br><span class="line">	cmp	x24, #ESR_ELx_EC_PC_ALIGN	// pc alignment exception</span><br><span class="line">	b.eq	el0_sp_pc</span><br><span class="line">	cmp	x24, #ESR_ELx_EC_UNKNOWN	// unknown exception in EL0</span><br><span class="line">	b.eq	el0_undef</span><br><span class="line">	cmp	x24, #ESR_ELx_EC_BREAKPT_LOW	// debug exception in EL0</span><br><span class="line">	b.ge	el0_dbg</span><br><span class="line">	b	el0_inv</span><br><span class="line">	</span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">el0_da:</span><br><span class="line">	/*</span><br><span class="line">	 * Data abort handling</span><br><span class="line">	 */</span><br><span class="line">	mrs	x26, far_el1</span><br><span class="line">	// enable interrupts before calling the main handler</span><br><span class="line">	enable_dbg_and_irq</span><br><span class="line">	ct_user_exit</span><br><span class="line">	bic	x0, x26, #(0xff &lt;&lt; 56)</span><br><span class="line">	mov	x1, x25</span><br><span class="line">	mov	x2, sp</span><br><span class="line">	bl	do_mem_abort        // (1.1) 调用异常处理</span><br><span class="line">	b	ret_to_user         // (1.2) 完成后调用ret_to_user返回</span><br><span class="line">el0_ia:</span><br><span class="line">	/*</span><br><span class="line">	 * Instruction abort handling</span><br><span class="line">	 */</span><br><span class="line">	mrs	x26, far_el1</span><br><span class="line">	// enable interrupts before calling the main handler</span><br><span class="line">	enable_dbg_and_irq</span><br><span class="line">	ct_user_exit</span><br><span class="line">	mov	x0, x26</span><br><span class="line">	mov	x1, x25</span><br><span class="line">	mov	x2, sp</span><br><span class="line">	bl	do_mem_abort</span><br><span class="line">	b	ret_to_user         </span><br><span class="line">	</span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Ok, we need to do extra processing, enter the slow path.</span><br><span class="line"> */</span><br><span class="line">work_pending:</span><br><span class="line">	tbnz	x1, #TIF_NEED_RESCHED, work_resched</span><br><span class="line">	/* TIF_SIGPENDING, TIF_NOTIFY_RESUME or TIF_FOREIGN_FPSTATE case */</span><br><span class="line">	mov	x0, sp				// &apos;regs&apos;</span><br><span class="line">	enable_irq				// enable interrupts for do_notify_resume()</span><br><span class="line">	bl	do_notify_resume        // (1.2.2.1) 如果signal、resume等work需要处理，</span><br><span class="line">	                            // 调用do_notify_resume()</span><br><span class="line">	b	ret_to_user</span><br><span class="line">work_resched:</span><br><span class="line">#ifdef CONFIG_TRACE_IRQFLAGS</span><br><span class="line">	bl	trace_hardirqs_off		// the IRQs are off here, inform the tracing code</span><br><span class="line">#endif</span><br><span class="line">	bl	schedule            // (1.2.2.2) 如果TIF_NEED_RESCHED被置位，调用schedule()进行任务调度</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * &quot;slow&quot; syscall return path.</span><br><span class="line"> */</span><br><span class="line">ret_to_user:</span><br><span class="line">	disable_irq				// disable interrupts</span><br><span class="line">	ldr	x1, [tsk, #TI_FLAGS]</span><br><span class="line">	and	x2, x1, #_TIF_WORK_MASK</span><br><span class="line">	cbnz	x2, work_pending    // (1.2.2) 如果有wokr需要处理调用work_pending</span><br><span class="line">	enable_step_tsk x1, x2</span><br><span class="line">	kernel_exit 0</span><br><span class="line">ENDPROC(ret_to_user)</span><br></pre></td></tr></table></figure>
<p>用户态的异常除了系统调用，剩下就是错误类型的异常，比如：data abort、instruction abort、其他错误等。<br>在返回用户态的时候会判断thread_info-&gt;flags中的TIF_NEED_RESCHED bit有没有被置位，有置位则会调用schedule()；还会判断_TIF_SIGPENDING，有置位会进行信号处理do_signal()。</p>
<ul>
<li>5、用户态中断的返回el0_irq()；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">	.align	6</span><br><span class="line">el0_irq:</span><br><span class="line">	kernel_entry 0</span><br><span class="line">el0_irq_naked:</span><br><span class="line">	enable_dbg</span><br><span class="line">#ifdef CONFIG_TRACE_IRQFLAGS</span><br><span class="line">	bl	trace_hardirqs_off</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	ct_user_exit</span><br><span class="line">	irq_handler             // (1) 调用irq处理程序</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_TRACE_IRQFLAGS</span><br><span class="line">	bl	trace_hardirqs_on</span><br><span class="line">#endif</span><br><span class="line">	b	ret_to_user         // (2) 最后也是调用ret_to_user返回，</span><br><span class="line">	                        // 会判断TIF_NEED_RESCHED、_TIF_SIGPENDING</span><br><span class="line">ENDPROC(el0_irq)</span><br></pre></td></tr></table></figure>
<p>用户态的中断处理和其他异常处理一样，最后都是调用ret_to_user返回用户态。<br>在返回用户态的时候会判断thread_info-&gt;flags中的TIF_NEED_RESCHED bit有没有被置位，有置位则会调用schedule()；还会判断_TIF_SIGPENDING，有置位会进行信号处理do_signal()。</p>
<h2 id="1-6、什么叫抢占-preempt-？"><a href="#1-6、什么叫抢占-preempt-？" class="headerlink" title="1.6、什么叫抢占(preempt)？"></a>1.6、什么叫抢占(preempt)？</h2><p>从上一节的分析中断/异常返回一共有5类路径：</p>
<ul>
<li>内核态异常的返回el1_sync()，不支持调度检测；</li>
<li>内核态中断的返回el1_sync()，支持对preempt_count和TIF_NEED_RESCHED的检测；</li>
<li>用户态系统调用类异常的返回el0_svc()，支持对TIF_NEED_RESCHED和_TIF_SIGPENDING的检测；</li>
<li>用户态其他异常的返回el0_sync()，支持对TIF_NEED_RESCHED和_TIF_SIGPENDING的检测；</li>
<li>用户态中断的返回el0_irq()，支持对TIF_NEED_RESCHED和_TIF_SIGPENDING的检测；</li>
</ul>
<p>我们可以看到是否支持抢占，只会影响”内核态中断的返回”这一条路径。</p>
<ul>
<li><strong><em>“抢占(preempt)”</em></strong>，如果抢占使能在内核态中断的返回时会检测是否需要进行进程调度schedule()，如果抢占不使能则在该路径下会直接返回原进程什么也不会做。</li>
</ul>
<h3 id="1-6-1、PREEMPT-ACTIVE标志"><a href="#1-6-1、PREEMPT-ACTIVE标志" class="headerlink" title="1.6.1、PREEMPT_ACTIVE标志"></a>1.6.1、PREEMPT_ACTIVE标志</h3><p>在之前的内核中会存在PREEMPT_ACTIVE这样一个标志，他是为了避免在如下代码被抢占会出现问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (; ;) &#123;</span><br><span class="line">1： prepare_to_wait(&amp;wq, &amp;__wait, TASK_UNINTERRUPTIBLE);</span><br><span class="line">2： if (condition)  </span><br><span class="line">3： 		break;              // 如果这里发生抢占</span><br><span class="line">4： schedule();</span><br><span class="line">&#125;</span><br><span class="line">finish_wait();</span><br></pre></td></tr></table></figure>
<p>假设如下场景：</p>
<ul>
<li>1、进程首先执行步骤1 prepare_to_wait()把自己设置为TASK_UNINTERRUPTIBLE，但是在执行步骤2时发现条件(condition)成立准备退出循环，调用finish_wait()恢复TASK_RUNNING状态，这时发生了抢占。</li>
<li>2、发生抢占以后调用schedule()的过程中会判断当前需要调度的进程是否为TASK_UNINTERRUPTIBLE/TASK_INTERRUPTIBLE睡眠状态，如果是的话schedule()认为进程是从主动blocked路径中进来的，会把当前进程退出runqueue(deactivate_task)。</li>
<li>3、正常的用户逻辑主动调用blocked操作进入睡眠状态是没有关系的，因为用户会设计其他的唤醒操作；但是上述场景违反了用户的正常逻辑，在条件(condition)成立的情况下把进程dequeue出运行队列，可能会造成进程无人唤醒永远不会被执行。</li>
</ul>
<p>为了避免以上的错误发生，在以前版本的内核中设计了PREEMPT_ACTIVE标志，如果是抢占发生首先设置PREEMPT_ACTIVE标志再调用schedule()，schedule()判断PREEMPT_ACTIVE的存在则不会进行dequeue/deactive操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage void __sched preempt_schedule_irq(void)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	add_preempt_count(PREEMPT_ACTIVE); // (1) 在抢占调度之前设置PREEMPT_ACTIVE标志</span><br><span class="line">	</span><br><span class="line">	local_irq_enable();</span><br><span class="line">	schedule();                         // (2) 调用schedule()进行实际调度</span><br><span class="line">	local_irq_disable();</span><br><span class="line">	</span><br><span class="line">	sub_preempt_count(PREEMPT_ACTIVE);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">asmlinkage void __sched schedule(void)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    /* (2.1) 如果进程state状态不为TASK_RUNNING &amp;&amp; 没有置位PREEMPT_ACTIVE标志，</span><br><span class="line">        以下代码会对这样的进程进行deactivate_task(dequeue)操作</span><br><span class="line">	if (prev-&gt;state &amp;&amp; !(preempt_count() &amp; PREEMPT_ACTIVE)) &#123;</span><br><span class="line">		switch_count = &amp;prev-&gt;nvcsw;</span><br><span class="line">		if (unlikely((prev-&gt;state &amp; TASK_INTERRUPTIBLE) &amp;&amp;</span><br><span class="line">				unlikely(signal_pending(prev))))</span><br><span class="line">			prev-&gt;state = TASK_RUNNING;</span><br><span class="line">		else &#123;</span><br><span class="line">			if (prev-&gt;state == TASK_UNINTERRUPTIBLE)</span><br><span class="line">				rq-&gt;nr_uninterruptible++;</span><br><span class="line">			deactivate_task(prev, rq);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最新的4.4内核中，已经取消PREEMPT_ACTIVE标志而改为使用__schedule(bool preempt)的函数参数传入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage __visible void __sched preempt_schedule_irq(void)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	do &#123;</span><br><span class="line">		preempt_disable();</span><br><span class="line">		local_irq_enable();</span><br><span class="line">		__schedule(true);       // (1) 使用preempt=true来调用__schedule()</span><br><span class="line">		local_irq_disable();</span><br><span class="line">		sched_preempt_enable_no_resched();</span><br><span class="line">	&#125; while (need_resched());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static void __sched notrace __schedule(bool preempt)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    // (1.1) 使用preempt代替了PREEMPT_ACTIVE标志的作用</span><br><span class="line">	if (!preempt &amp;&amp; prev-&gt;state) &#123;</span><br><span class="line">		if (unlikely(signal_pending_state(prev-&gt;state, prev))) &#123;</span><br><span class="line">			prev-&gt;state = TASK_RUNNING;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			deactivate_task(rq, prev, DEQUEUE_SLEEP);</span><br><span class="line">			prev-&gt;on_rq = 0;</span><br><span class="line"></span><br><span class="line">			/*</span><br><span class="line">			 * If a worker went to sleep, notify and ask workqueue</span><br><span class="line">			 * whether it wants to wake up a task to maintain</span><br><span class="line">			 * concurrency.</span><br><span class="line">			 */</span><br><span class="line">			if (prev-&gt;flags &amp; PF_WQ_WORKER) &#123;</span><br><span class="line">				struct task_struct *to_wakeup;</span><br><span class="line"></span><br><span class="line">				to_wakeup = wq_worker_sleeping(prev, cpu);</span><br><span class="line">				if (to_wakeup)</span><br><span class="line">					try_to_wake_up_local(to_wakeup);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		switch_count = &amp;prev-&gt;nvcsw;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-7、代码分析"><a href="#1-7、代码分析" class="headerlink" title="1.7、代码分析"></a>1.7、代码分析</h2><p>上述几节的内容讲述了调度相关的几个关键节点，所以理解调度你可以从以下的几个函数入手：</p>
<ul>
<li>try_to_wake_up()  // wakeup task</li>
<li>block task        // 类如：mutex_lock()、down()、schedule_timeout()、msleep()</li>
<li>scheduler_tick()</li>
<li>schedule()</li>
</ul>
<h1 id="2、调度算法"><a href="#2、调度算法" class="headerlink" title="2、调度算法"></a>2、调度算法</h1><p>linux进程一般分成了实时进程(RT)和普通进程，linux使用sched_class结构来管理不同类型进程的调度算法：rt_sched_class负责实时类进程(SCHED_FIFO/SCHED_RR)的调度，fair_sched_class负责普通进程(SCHED_NORMAL)的调度，还有idle_sched_class(SCHED_IDLE)、dl_sched_class(SCHED_DEADLINE)都比较简单和少见；</p>
<p>实时进程的调度算法移植都没什么变化，SCHED_FIFO类型的谁优先级高就一直抢占/SCHED_RR相同优先级的进行时间片轮转。</p>
<p>所以我们常说的调度算法一般指普通进程(SCHED_NORMAL)的调度算法，这类进程也在系统中占大多数。在2.6.24以后内核引入的是CFS算法，这个也是现在的主流；在这之前2.6内核使用的是一种O(1)算法；</p>
<h2 id="2-1、linux2-6的O-1-调度算法"><a href="#2-1、linux2-6的O-1-调度算法" class="headerlink" title="2.1、linux2.6的O(1)调度算法"></a>2.1、linux2.6的O(1)调度算法</h2><p><img src="/images/scheduler/schedule_26O1_scheduler.gif" alt="schedule_26O1_scheduler"></p>
<p>linux进程的优先级有140种，其中优先级(0-99)对应实时进程，优先级(100-139)对应普通进程，nice(0)对应优先级120，nice(-10)对应优先级100，nice(19)对应优先级139。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#define MAX_USER_RT_PRIO	100</span><br><span class="line">#define MAX_RT_PRIO		MAX_USER_RT_PRIO        // 优先级(1-99)对应实时进程</span><br><span class="line"></span><br><span class="line">#define MAX_PRIO		(MAX_RT_PRIO + 40)      // 优先级(100-139)对应普通进程</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Convert user-nice values [ -20 ... 0 ... 19 ]</span><br><span class="line"> * to static priority [ MAX_RT_PRIO..MAX_PRIO-1 ],</span><br><span class="line"> * and back.</span><br><span class="line"> */</span><br><span class="line">#define NICE_TO_PRIO(nice)	(MAX_RT_PRIO + (nice) + 20) // nice(0)对应优先级120，nice(-20)对应优先级100，nice(19)对应优先级139</span><br><span class="line">#define PRIO_TO_NICE(prio)	((prio) - MAX_RT_PRIO - 20)</span><br><span class="line">#define TASK_NICE(p)		PRIO_TO_NICE((p)-&gt;static_prio)</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * &apos;User priority&apos; is the nice value converted to something we</span><br><span class="line"> * can work with better when scaling various scheduler parameters,</span><br><span class="line"> * it&apos;s a [ 0 ... 39 ] range.</span><br><span class="line"> */</span><br><span class="line">#define USER_PRIO(p)		((p)-MAX_RT_PRIO)</span><br><span class="line">#define TASK_USER_PRIO(p)	USER_PRIO((p)-&gt;static_prio)</span><br><span class="line">#define MAX_USER_PRIO		(USER_PRIO(MAX_PRIO))</span><br></pre></td></tr></table></figure>
<p>O(1)调度算法主要包含以下内容：</p>
<ul>
<li>(1)、每个cpu的rq包含两个140个成员的链表数组rq-&gt;active、rq-&gt;expired；</li>
</ul>
<p>任务根据优先级挂载到不同的数组当中，时间片没有用完放在rq-&gt;active，时间片用完后放到rq-&gt;expired，在rq-&gt;active所有任务时间片用完为空后rq-&gt;active和rq-&gt;expired相互反转。</p>
<p>在schedule()中pcik next task时，首先会根据array-&gt;bitmap找出哪个最先优先级还有任务需要调度，然后根据index找到 对应的优先级任务链表。因为查找bitmap的在IA处理器上可以通过bsfl等一条指令来实现，所以他的复杂度为O(1)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage void __sched schedule(void)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	idx = sched_find_first_bit(array-&gt;bitmap);</span><br><span class="line">	queue = array-&gt;queue + idx;</span><br><span class="line">	next = list_entry(queue-&gt;next, task_t, run_list);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>(2)、进程优先级分为静态优先级(p-&gt;static_prio)、动态优先级(p-&gt;prio)；</li>
</ul>
<p>静态优先级(p-&gt;static_prio)决定进程时间片的大小:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * task_timeslice() scales user-nice values [ -20 ... 0 ... 19 ]</span><br><span class="line"> * to time slice values: [800ms ... 100ms ... 5ms]</span><br><span class="line"> *</span><br><span class="line"> * The higher a thread&apos;s priority, the bigger timeslices</span><br><span class="line"> * it gets during one round of execution. But even the lowest</span><br><span class="line"> * priority thread gets MIN_TIMESLICE worth of execution time.</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">/* 根据算法如果nice(0)的时间片为100mS，那么nice(-20)时间片为800ms、nice(19)时间片为5ms */</span><br><span class="line"></span><br><span class="line">#define SCALE_PRIO(x, prio) \</span><br><span class="line">	max(x * (MAX_PRIO - prio) / (MAX_USER_PRIO/2), MIN_TIMESLICE)</span><br><span class="line"></span><br><span class="line">static unsigned int task_timeslice(task_t *p)</span><br><span class="line">&#123;</span><br><span class="line">	if (p-&gt;static_prio &lt; NICE_TO_PRIO(0))</span><br><span class="line">		return SCALE_PRIO(DEF_TIMESLICE*4, p-&gt;static_prio);</span><br><span class="line">	else</span><br><span class="line">		return SCALE_PRIO(DEF_TIMESLICE, p-&gt;static_prio);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#define MIN_TIMESLICE		max(5 * HZ / 1000, 1)</span><br><span class="line">#define DEF_TIMESLICE		(100 * HZ / 1000)</span><br></pre></td></tr></table></figure>
<p>动态优先级决定进程在rq-&gt;active、rq-&gt;expired进程链表中的index：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static void enqueue_task(struct task_struct *p, prio_array_t *array)</span><br><span class="line">&#123;</span><br><span class="line">	sched_info_queued(p);</span><br><span class="line">	list_add_tail(&amp;p-&gt;run_list, array-&gt;queue + p-&gt;prio); // 根据动态优先级p-&gt;prio作为index，找到对应链表</span><br><span class="line">	__set_bit(p-&gt;prio, array-&gt;bitmap);</span><br><span class="line">	array-&gt;nr_active++;</span><br><span class="line">	p-&gt;array = array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>动态优先级和静态优先级之间的转换函数：动态优先级=max(100 , min(静态优先级 – bonus + 5) , 139)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * effective_prio - return the priority that is based on the static</span><br><span class="line"> * priority but is modified by bonuses/penalties.</span><br><span class="line"> *</span><br><span class="line"> * We scale the actual sleep average [0 .... MAX_SLEEP_AVG]</span><br><span class="line"> * into the -5 ... 0 ... +5 bonus/penalty range.</span><br><span class="line"> *</span><br><span class="line"> * We use 25% of the full 0...39 priority range so that:</span><br><span class="line"> *</span><br><span class="line"> * 1) nice +19 interactive tasks do not preempt nice 0 CPU hogs.</span><br><span class="line"> * 2) nice -20 CPU hogs do not get preempted by nice 0 tasks.</span><br><span class="line"> *</span><br><span class="line"> * Both properties are important to certain workloads.</span><br><span class="line"> */</span><br><span class="line">static int effective_prio(task_t *p)</span><br><span class="line">&#123;</span><br><span class="line">	int bonus, prio;</span><br><span class="line"></span><br><span class="line">	if (rt_task(p))</span><br><span class="line">		return p-&gt;prio;</span><br><span class="line"></span><br><span class="line">	bonus = CURRENT_BONUS(p) - MAX_BONUS / 2;  // MAX_BONUS = 10</span><br><span class="line"></span><br><span class="line">	prio = p-&gt;static_prio - bonus;</span><br><span class="line">	if (prio &lt; MAX_RT_PRIO)</span><br><span class="line">		prio = MAX_RT_PRIO;</span><br><span class="line">	if (prio &gt; MAX_PRIO-1)</span><br><span class="line">		prio = MAX_PRIO-1;</span><br><span class="line">	return prio;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面看出动态优先级是以静态优先级为基础，再加上相应的惩罚或奖励(bonus)。这个bonus并不是随机的产生，而是根据进程过去的平均睡眠时间做相应的惩罚或奖励。所谓平均睡眠时间（sleep_avg，位于task_struct结构中）就是进程在睡眠状态所消耗的总时间数，这里的平均并不是直接对时间求平均数。</p>
<ul>
<li>(3)、根据平均睡眠时间判断进程是否是交互式进程(INTERACTIVE);</li>
</ul>
<p>交互式进程的好处？交互式进程时间片用完会重新进入active队列；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void scheduler_tick(void)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	if (!--p-&gt;time_slice) &#123;     // (1) 时间片用完</span><br><span class="line">		dequeue_task(p, rq-&gt;active);    // (2) 退出actice队列</span><br><span class="line">		set_tsk_need_resched(p);</span><br><span class="line">		p-&gt;prio = effective_prio(p);</span><br><span class="line">		p-&gt;time_slice = task_timeslice(p);</span><br><span class="line">		p-&gt;first_time_slice = 0;</span><br><span class="line"></span><br><span class="line">		if (!rq-&gt;expired_timestamp)</span><br><span class="line">			rq-&gt;expired_timestamp = jiffies;</span><br><span class="line">		if (!TASK_INTERACTIVE(p) || EXPIRED_STARVING(rq)) &#123;</span><br><span class="line">			enqueue_task(p, rq-&gt;expired);       // (3) 普通进程进入expired队列</span><br><span class="line">			if (p-&gt;static_prio &lt; rq-&gt;best_expired_prio)</span><br><span class="line">				rq-&gt;best_expired_prio = p-&gt;static_prio;</span><br><span class="line">		&#125; else</span><br><span class="line">			enqueue_task(p, rq-&gt;active);    // (4) 如果是交互式进程，重新进入active队列</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断进程是否是交互式进程(INTERACTIVE)的公式：动态优先级≤3*静态优先级/4 + 28</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define TASK_INTERACTIVE(p) \</span><br><span class="line">	((p)-&gt;prio &lt;= (p)-&gt;static_prio - DELTA(p))</span><br></pre></td></tr></table></figure>
<p>平均睡眠时间的算法和交互进程的思想，我没有详细去看大家可以参考一下的一些描述：</p>
<blockquote>
<p>所谓平均睡眠时间（sleep_avg，位于task_struct结构中）就是进程在睡眠状态所消耗的总时间数，这里的平均并不是直接对时间求平均数。平均睡眠时间随着进程的睡眠而增长，随着进程的运行而减少。因此，平均睡眠时间记录了进程睡眠和执行的时间，它是用来判断进程交互性强弱的关键数据。如果一个进程的平均睡眠时间很大，那么它很可能是一个交互性很强的进程。反之，如果一个进程的平均睡眠时间很小，那么它很可能一直在执行。另外，平均睡眠时间也记录着进程当前的交互状态，有很快的反应速度。比如一个进程在某一小段时间交互性很强，那么sleep_avg就有可能暴涨（当然它不能超过 MAX_SLEEP_AVG），但如果之后都一直处于执行状态，那么sleep_avg就又可能一直递减。理解了平均睡眠时间，那么bonus的含义也就显而易见了。交互性强的进程会得到调度程序的奖励（bonus为正），而那些一直霸占CPU的进程会得到相应的惩罚（bonus为负）。其实bonus相当于平均睡眠时间的缩影，此时只是将sleep_avg调整成bonus数值范围内的大小。<br>O(1)调度器区分交互式进程和批处理进程的算法与以前虽大有改进，但仍然在很多情况下会失效。有一些著名的程序总能让该调度器性能下降，导致交互式进程反应缓慢。例如fiftyp.c, thud.c, chew.c, ring-test.c, massive_intr.c等。而且O(1)调度器对NUMA支持也不完善。</p>
</blockquote>
<h2 id="2-2、CFS调度算法"><a href="#2-2、CFS调度算法" class="headerlink" title="2.2、CFS调度算法"></a>2.2、CFS调度算法</h2><p>针对O(1)算法出现的问题(具体是哪些问题我也理解不深说不上来)，linux推出了CFS(Completely Fair Scheduler)完全公平调度算法。该算法从楼梯调度算法(staircase scheduler)和RSDL（Rotating Staircase Deadline Scheduler）发展而来，抛弃了复杂的active/expire数组和交互进程计算，把所有进程一视同仁都放到一个执行时间的红黑树中，实现了完全公平的思想。</p>
<p>CFS的主要思想如下：</p>
<ul>
<li>根据普通进程的优先级nice值来定一个比重(weight)，该比重用来计算进程的实际运行时间到虚拟运行时间(vruntime)的换算；不言而喻优先级高的进程运行更多的时间和优先级低的进程运行更少的时间在vruntime上市等价的；</li>
<li>根据rq-&gt;cfs_rq中进程的数量计算一个总的period周期，每个进程再根据自己的weight占整个的比重来计算自己的理想运行时间(ideal_runtime)，在scheduler_tick()中判断如果进程的实际运行时间(exec_runtime)已经达到理想运行时间(ideal_runtime)，则进程需要被调度test_tsk_need_resched(curr)。有了period，那么cfs_rq中所有进程在period以内必会得到调度；</li>
<li>根据进程的虚拟运行时间(vruntime)，把rq-&gt;cfs_rq中的进程组织成一个红黑树(平衡二叉树)，那么在pick_next_entity时树的最左节点就是运行时间最少的进程，是最好的需要调度的候选人；</li>
</ul>
<h3 id="2-2-1、vruntime"><a href="#2-2-1、vruntime" class="headerlink" title="2.2.1、vruntime"></a>2.2.1、vruntime</h3><p>每个进程的vruntime = runtime * (NICE_0_LOAD/nice_n_weight)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/* 该表的主要思想是，高一个等级的weight是低一个等级的 1.25 倍 */</span><br><span class="line">/*</span><br><span class="line"> * Nice levels are multiplicative, with a gentle 10% change for every</span><br><span class="line"> * nice level changed. I.e. when a CPU-bound task goes from nice 0 to</span><br><span class="line"> * nice 1, it will get ~10% less CPU time than another CPU-bound task</span><br><span class="line"> * that remained on nice 0.</span><br><span class="line"> *</span><br><span class="line"> * The &quot;10% effect&quot; is relative and cumulative: from _any_ nice level,</span><br><span class="line"> * if you go up 1 level, it&apos;s -10% CPU usage, if you go down 1 level</span><br><span class="line"> * it&apos;s +10% CPU usage. (to achieve that we use a multiplier of 1.25.</span><br><span class="line"> * If a task goes up by ~10% and another task goes down by ~10% then</span><br><span class="line"> * the relative distance between them is ~25%.)</span><br><span class="line"> */</span><br><span class="line">static const int prio_to_weight[40] = &#123;</span><br><span class="line"> /* -20 */     88761,     71755,     56483,     46273,     36291,</span><br><span class="line"> /* -15 */     29154,     23254,     18705,     14949,     11916,</span><br><span class="line"> /* -10 */      9548,      7620,      6100,      4904,      3906,</span><br><span class="line"> /*  -5 */      3121,      2501,      1991,      1586,      1277,</span><br><span class="line"> /*   0 */      1024,       820,       655,       526,       423,</span><br><span class="line"> /*   5 */       335,       272,       215,       172,       137,</span><br><span class="line"> /*  10 */       110,        87,        70,        56,        45,</span><br><span class="line"> /*  15 */        36,        29,        23,        18,        15,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>nice(0)对应的weight是NICE_0_LOAD(1024)，nice(-1)对应的weight是NICE_0_LOAD*1.25，nice(1)对应的weight是NICE_0_LOAD/1.25。</p>
<p>NICE_0_LOAD(1024)在schedule计算中是一个非常神奇的数字，他的含义就是基准”1”。因为kernel不能表示小数，所以把1放大称为1024。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">scheduler_tick() -&gt; task_tick_fair() -&gt; update_curr():</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static void update_curr(struct cfs_rq *cfs_rq)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	curr-&gt;sum_exec_runtime += delta_exec;       // (1) 累计当前进程的实际运行时间</span><br><span class="line">	schedstat_add(cfs_rq, exec_clock, delta_exec);</span><br><span class="line"></span><br><span class="line">	curr-&gt;vruntime += calc_delta_fair(delta_exec, curr);  // (2) 累计当前进程的vruntime</span><br><span class="line">	update_min_vruntime(cfs_rq);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static inline u64 calc_delta_fair(u64 delta, struct sched_entity *se)</span><br><span class="line">&#123;</span><br><span class="line">    // (2.1) 根据进程的weight折算vruntime</span><br><span class="line">	if (unlikely(se-&gt;load.weight != NICE_0_LOAD))</span><br><span class="line">		delta = __calc_delta(delta, NICE_0_LOAD, &amp;se-&gt;load);</span><br><span class="line"></span><br><span class="line">	return delta;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-2、period和ideal-runtime"><a href="#2-2-2、period和ideal-runtime" class="headerlink" title="2.2.2、period和ideal_runtime"></a>2.2.2、period和ideal_runtime</h3><p>scheduler_tick()中根据cfs_rq中的se数量计算period和ideal_time，判断当前进程时间是否用完需要调度：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">scheduler_tick() -&gt; task_tick_fair() -&gt; entity_tick() -&gt; check_preempt_tick():</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">check_preempt_tick(struct cfs_rq *cfs_rq, struct sched_entity *curr)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned long ideal_runtime, delta_exec;</span><br><span class="line">	struct sched_entity *se;</span><br><span class="line">	s64 delta;</span><br><span class="line"></span><br><span class="line">    /* (1) 计算period和ideal_time */</span><br><span class="line">	ideal_runtime = sched_slice(cfs_rq, curr);  </span><br><span class="line">	</span><br><span class="line">	/* (2) 计算实际运行时间 */</span><br><span class="line">	delta_exec = curr-&gt;sum_exec_runtime - curr-&gt;prev_sum_exec_runtime;  </span><br><span class="line">	</span><br><span class="line">	/* (3) 如果实际运行时间已经超过ideal_time，</span><br><span class="line">	      当前进程需要被调度，设置TIF_NEED_RESCHED标志</span><br><span class="line">	 */</span><br><span class="line">	if (delta_exec &gt; ideal_runtime) &#123;   </span><br><span class="line">		resched_curr(rq_of(cfs_rq));    </span><br><span class="line">		/*</span><br><span class="line">		 * The current task ran long enough, ensure it doesn&apos;t get</span><br><span class="line">		 * re-elected due to buddy favours.</span><br><span class="line">		 */</span><br><span class="line">		clear_buddies(cfs_rq, curr);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Ensure that a task that missed wakeup preemption by a</span><br><span class="line">	 * narrow margin doesn&apos;t have to wait for a full slice.</span><br><span class="line">	 * This also mitigates buddy induced latencies under load.</span><br><span class="line">	 */</span><br><span class="line">	if (delta_exec &lt; sysctl_sched_min_granularity)</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	se = __pick_first_entity(cfs_rq);</span><br><span class="line">	delta = curr-&gt;vruntime - se-&gt;vruntime;</span><br><span class="line"></span><br><span class="line">	if (delta &lt; 0)</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	if (delta &gt; ideal_runtime)</span><br><span class="line">		resched_curr(rq_of(cfs_rq));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static u64 sched_slice(struct cfs_rq *cfs_rq, struct sched_entity *se)</span><br><span class="line">&#123;</span><br><span class="line">    /* (1.1) 计算period值 */</span><br><span class="line">	u64 slice = __sched_period(cfs_rq-&gt;nr_running + !se-&gt;on_rq); </span><br><span class="line"></span><br><span class="line">    /* 疑问：这里是根据最底层se和cfq_rq来计算ideal_runtime，然后逐层按比重折算到上层时间</span><br><span class="line">        这种方法是不对的，应该是从顶层到底层分配时间下来才比较合理。</span><br><span class="line">        庆幸的是，在task_tick_fair()中会调用task_tick_fair递归的每层递归的计算时间，</span><br><span class="line">        所以最上面的一层也是判断的</span><br><span class="line">     */</span><br><span class="line">	for_each_sched_entity(se) &#123;     </span><br><span class="line">		struct load_weight *load;</span><br><span class="line">		struct load_weight lw;</span><br><span class="line"></span><br><span class="line">		cfs_rq = cfs_rq_of(se);</span><br><span class="line">		load = &amp;cfs_rq-&gt;load;</span><br><span class="line"></span><br><span class="line">		if (unlikely(!se-&gt;on_rq)) &#123;</span><br><span class="line">			lw = cfs_rq-&gt;load;</span><br><span class="line"></span><br><span class="line">			update_load_add(&amp;lw, se-&gt;load.weight);</span><br><span class="line">			load = &amp;lw;</span><br><span class="line">		&#125;</span><br><span class="line">		/* (1.2) 根据period值和进程weight在cfs_rq weight中的比重计算ideal_runtime</span><br><span class="line">		 */</span><br><span class="line">		slice = __calc_delta(slice, se-&gt;load.weight, load);</span><br><span class="line">	&#125;</span><br><span class="line">	return slice;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">/* (1.1.1) period的计算方法，从默认值看：</span><br><span class="line">    如果cfs_rq中的进程大于8(sched_nr_latency)个，则period=n*0.75ms(sysctl_sched_min_granularity)</span><br><span class="line">    如果小于等于8(sched_nr_latency)个，则period=6ms(sysctl_sched_latency)</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * The idea is to set a period in which each task runs once.</span><br><span class="line"> *</span><br><span class="line"> * When there are too many tasks (sched_nr_latency) we have to stretch</span><br><span class="line"> * this period because otherwise the slices get too small.</span><br><span class="line"> *</span><br><span class="line"> * p = (nr &lt;= nl) ? l : l*nr/nl</span><br><span class="line"> */</span><br><span class="line">static u64 __sched_period(unsigned long nr_running)</span><br><span class="line">&#123;</span><br><span class="line">	if (unlikely(nr_running &gt; sched_nr_latency))</span><br><span class="line">		return nr_running * sysctl_sched_min_granularity;</span><br><span class="line">	else</span><br><span class="line">		return sysctl_sched_latency;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Minimal preemption granularity for CPU-bound tasks:</span><br><span class="line"> * (default: 0.75 msec * (1 + ilog(ncpus)), units: nanoseconds)</span><br><span class="line"> */</span><br><span class="line">unsigned int sysctl_sched_min_granularity = 750000ULL;</span><br><span class="line">unsigned int normalized_sysctl_sched_min_granularity = 750000ULL;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * is kept at sysctl_sched_latency / sysctl_sched_min_granularity</span><br><span class="line"> */</span><br><span class="line">static unsigned int sched_nr_latency = 8;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Targeted preemption latency for CPU-bound tasks:</span><br><span class="line"> * (default: 6ms * (1 + ilog(ncpus)), units: nanoseconds)</span><br><span class="line"> *</span><br><span class="line"> * NOTE: this latency value is not the same as the concept of</span><br><span class="line"> * &apos;timeslice length&apos; - timeslices in CFS are of variable length</span><br><span class="line"> * and have no persistent notion like in traditional, time-slice</span><br><span class="line"> * based scheduling concepts.</span><br><span class="line"> *</span><br><span class="line"> * (to see the precise effective timeslice length of your workload,</span><br><span class="line"> *  run vmstat and monitor the context-switches (cs) field)</span><br><span class="line"> */</span><br><span class="line">unsigned int sysctl_sched_latency = 6000000ULL;</span><br><span class="line">unsigned int normalized_sysctl_sched_latency = 6000000ULL;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-3、红黑树-Red-Black-Tree"><a href="#2-2-3、红黑树-Red-Black-Tree" class="headerlink" title="2.2.3、红黑树(Red Black Tree)"></a>2.2.3、红黑树(Red Black Tree)</h3><p><img src="/images/scheduler/schedule_rbtree.png" alt="schedule_rbtree"></p>
<p>红黑树又称为平衡二叉树，它的特点：</p>
<ul>
<li>1、平衡。从根节点到叶子节点之间的任何路径，差值不会超过1。所以pick_next_task()复杂度为O(log n)。可以看到pick_next_task()复杂度是大于o(1)算法的，但是最大路径不会超过log2(n) - 1，复杂度是可控的。</li>
<li>2、排序。左边的节点一定小于右边的节点，所以最左边节点是最小值。</li>
</ul>
<p>按照进程的vruntime组成了红黑树：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">enqueue_task_fair() -&gt; enqueue_entity() -&gt; __enqueue_entity():</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static void __enqueue_entity(struct cfs_rq *cfs_rq, struct sched_entity *se)</span><br><span class="line">&#123;</span><br><span class="line">	struct rb_node **link = &amp;cfs_rq-&gt;tasks_timeline.rb_node;</span><br><span class="line">	struct rb_node *parent = NULL;</span><br><span class="line">	struct sched_entity *entry;</span><br><span class="line">	int leftmost = 1;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Find the right place in the rbtree:</span><br><span class="line">	 */</span><br><span class="line">	/* (1) 根据vruntime的值在rbtree中找到合适的插入点 */</span><br><span class="line">	while (*link) &#123;</span><br><span class="line">		parent = *link;</span><br><span class="line">		entry = rb_entry(parent, struct sched_entity, run_node);</span><br><span class="line">		/*</span><br><span class="line">		 * We dont care about collisions. Nodes with</span><br><span class="line">		 * the same key stay together.</span><br><span class="line">		 */</span><br><span class="line">		if (entity_before(se, entry)) &#123;</span><br><span class="line">			link = &amp;parent-&gt;rb_left;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			link = &amp;parent-&gt;rb_right;</span><br><span class="line">			leftmost = 0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Maintain a cache of leftmost tree entries (it is frequently</span><br><span class="line">	 * used):</span><br><span class="line">	 */</span><br><span class="line">	/* (2) 更新最左值最小值cache */</span><br><span class="line">	if (leftmost)</span><br><span class="line">		cfs_rq-&gt;rb_leftmost = &amp;se-&gt;run_node;</span><br><span class="line"></span><br><span class="line">    /* (3) 将节点插入rbtree */</span><br><span class="line">	rb_link_node(&amp;se-&gt;run_node, parent, link);</span><br><span class="line">	rb_insert_color(&amp;se-&gt;run_node, &amp;cfs_rq-&gt;tasks_timeline);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-4、sched-entity和task-group"><a href="#2-2-4、sched-entity和task-group" class="headerlink" title="2.2.4、sched_entity和task_group"></a>2.2.4、sched_entity和task_group</h3><p><img src="/images/scheduler/schedule_cfs_frame.png" alt="schedule_cfs_frame"></p>
<p>因为新的内核加入了task_group的概念，所以现在不是使用task_struct结构直接参与到schedule计算当中，而是使用sched_entity结构。一个sched_entity结构可能是一个task也可能是一个task_group-&gt;se[cpu]。上图非常好的描述了这些结构之间的关系。</p>
<p>其中主要的层次关系如下：</p>
<ul>
<li>1、一个cpu只对应一个rq;</li>
<li>2、一个rq有一个cfs_rq；</li>
<li>3、cfs_rq使用红黑树组织多个同一层级的sched_entity；</li>
<li>4、如果sched_entity对应的是一个task_struct，那sched_entity和task是一对一的关系；</li>
<li>5、如果sched_entity对应的是task_group，那么他是一个task_group多个sched_entity中的一个。task_group有一个数组se[cpu]，在每个cpu上都有一个sched_entity。这种类型的sched_entity有自己的cfs_rq，一个sched_entity对应一个cfs_rq(se-&gt;my_q)，cfs_rq再继续使用红黑树组织多个同一层级的sched_entity；3-5的层次关系可以继续递归下去。</li>
</ul>
<h3 id="2-2-5、scheduler-tick"><a href="#2-2-5、scheduler-tick" class="headerlink" title="2.2.5、scheduler_tick()"></a>2.2.5、scheduler_tick()</h3><p>关于算法，最核心的部分都在scheduler_tick()函数当中，所以我们来详细的解析这部分代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line">void scheduler_tick(void)</span><br><span class="line">&#123;</span><br><span class="line">	int cpu = smp_processor_id();</span><br><span class="line">	struct rq *rq = cpu_rq(cpu);</span><br><span class="line">	struct task_struct *curr = rq-&gt;curr;</span><br><span class="line">	</span><br><span class="line">	/* (1) sched_tick()的校准，x86 bug的修复 */</span><br><span class="line">	sched_clock_tick();     </span><br><span class="line">#ifdef CONFIG_MTK_SCHED_MONITOR</span><br><span class="line">	mt_trace_rqlock_start(&amp;rq-&gt;lock);</span><br><span class="line">#endif</span><br><span class="line">	raw_spin_lock(&amp;rq-&gt;lock);</span><br><span class="line">#ifdef CONFIG_MTK_SCHED_MONITOR</span><br><span class="line">	mt_trace_rqlock_end(&amp;rq-&gt;lock);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    /* (2) 计算cpu级别(rq)的运行时间 :</span><br><span class="line">        rq-&gt;clock是cpu总的运行时间  (疑问：这里没有考虑cpu hotplug？？)</span><br><span class="line">        rq-&gt;clock_task是进程的实际运行时间，= rq-&gt;clock总时间 - rq-&gt;prev_irq_time中断消耗的时间</span><br><span class="line">     */</span><br><span class="line">	update_rq_clock(rq);   </span><br><span class="line">	</span><br><span class="line">	/* (3) 调用进程所属sched_class的tick函数</span><br><span class="line">	    cfs对应的是task_tick_fair()</span><br><span class="line">	    rt对应的是task_tick_rt()</span><br><span class="line">	 */</span><br><span class="line">	curr-&gt;sched_class-&gt;task_tick(rq, curr, 0);</span><br><span class="line">	</span><br><span class="line">	/* (4) 更新cpu级别的负载 */</span><br><span class="line">	update_cpu_load_active(rq);</span><br><span class="line">	</span><br><span class="line">	/* (5) 更新系统级别的负载 */</span><br><span class="line">	calc_global_load_tick(rq);</span><br><span class="line">	</span><br><span class="line">	/* (6) cpufreq_sched governor，计算负载来进行cpu调频 */</span><br><span class="line">	sched_freq_tick(cpu);</span><br><span class="line">	raw_spin_unlock(&amp;rq-&gt;lock);</span><br><span class="line"></span><br><span class="line">	perf_event_task_tick();</span><br><span class="line">#ifdef CONFIG_MTK_SCHED_MONITOR</span><br><span class="line">	mt_save_irq_counts(SCHED_TICK);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_SMP</span><br><span class="line">    /* (7) 负载均衡 */</span><br><span class="line">	rq-&gt;idle_balance = idle_cpu(cpu);</span><br><span class="line">	trigger_load_balance(rq);</span><br><span class="line">#endif</span><br><span class="line">	rq_last_tick_reset(rq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">static void task_tick_fair(struct rq *rq, struct task_struct *curr, int queued)</span><br><span class="line">&#123;</span><br><span class="line">	struct cfs_rq *cfs_rq;</span><br><span class="line">	struct sched_entity *se = &amp;curr-&gt;se;</span><br><span class="line"></span><br><span class="line">    /* (3.1) 按照task_group组织的se父子关系，</span><br><span class="line">        逐级对se 和 se-&gt;parent 进行递归计算</span><br><span class="line">     */</span><br><span class="line">	for_each_sched_entity(se) &#123;</span><br><span class="line">		cfs_rq = cfs_rq_of(se);</span><br><span class="line">		/* (3.2) se对应的tick操作 */</span><br><span class="line">		entity_tick(cfs_rq, se, queued);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (3.3) NUMA负载均衡 */</span><br><span class="line">	if (static_branch_unlikely(&amp;sched_numa_balancing))</span><br><span class="line">		task_tick_numa(rq, curr);</span><br><span class="line"></span><br><span class="line">	if (!rq-&gt;rd-&gt;overutilized &amp;&amp; cpu_overutilized(task_cpu(curr)))</span><br><span class="line">		rq-&gt;rd-&gt;overutilized = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">||→</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">entity_tick(struct cfs_rq *cfs_rq, struct sched_entity *curr, int queued)</span><br><span class="line">&#123;</span><br><span class="line">	/*</span><br><span class="line">	 * Update run-time statistics of the &apos;current&apos;.</span><br><span class="line">	 */</span><br><span class="line">	/* (3.2.1) 更新cfs_rq-&gt;curr的se的实际运行时间curr-&gt;sum_exec_runtime和虚拟运行时间curr-&gt;vruntime</span><br><span class="line">	    更新cfs_rq的运行时间</span><br><span class="line">	 */</span><br><span class="line">	update_curr(cfs_rq);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Ensure that runnable average is periodically updated.</span><br><span class="line">	 */</span><br><span class="line">	/* (3.2.2) 更新entity级别的负载，PELT计算 */</span><br><span class="line">	update_load_avg(curr, 1);</span><br><span class="line">	</span><br><span class="line">	/* (3.2.3) 更新task_group的shares */</span><br><span class="line">	update_cfs_shares(cfs_rq);</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_SCHED_HRTICK</span><br><span class="line">	/*</span><br><span class="line">	 * queued ticks are scheduled to match the slice, so don&apos;t bother</span><br><span class="line">	 * validating it and just reschedule.</span><br><span class="line">	 */</span><br><span class="line">	if (queued) &#123;</span><br><span class="line">		resched_curr(rq_of(cfs_rq));</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	/*</span><br><span class="line">	 * don&apos;t let the period tick interfere with the hrtick preemption</span><br><span class="line">	 */</span><br><span class="line">	if (!sched_feat(DOUBLE_TICK) &amp;&amp;</span><br><span class="line">			hrtimer_active(&amp;rq_of(cfs_rq)-&gt;hrtick_timer))</span><br><span class="line">		return;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    /* (3.2.4) check当前任务的理想运行时间ideal_runtime是否已经用完，</span><br><span class="line">        是否需要重新调度</span><br><span class="line">     */</span><br><span class="line">	if (cfs_rq-&gt;nr_running &gt; 1)</span><br><span class="line">		check_preempt_tick(cfs_rq, curr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|||→</span><br><span class="line"></span><br><span class="line">static void update_curr(struct cfs_rq *cfs_rq)</span><br><span class="line">&#123;</span><br><span class="line">	struct sched_entity *curr = cfs_rq-&gt;curr;</span><br><span class="line">	u64 now = rq_clock_task(rq_of(cfs_rq));</span><br><span class="line">	u64 delta_exec;</span><br><span class="line"></span><br><span class="line">	if (unlikely(!curr))</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">    /* (3.2.1.1)  计算cfs_rq-&gt;curr se的实际执行时间 */ </span><br><span class="line">	delta_exec = now - curr-&gt;exec_start;</span><br><span class="line">	if (unlikely((s64)delta_exec &lt;= 0))</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	curr-&gt;exec_start = now;</span><br><span class="line"></span><br><span class="line">	schedstat_set(curr-&gt;statistics.exec_max,</span><br><span class="line">		      max(delta_exec, curr-&gt;statistics.exec_max));</span><br><span class="line"></span><br><span class="line">	curr-&gt;sum_exec_runtime += delta_exec;</span><br><span class="line">	// 更新cfs_rq的实际执行时间cfs_rq-&gt;exec_clock</span><br><span class="line">	schedstat_add(cfs_rq, exec_clock, delta_exec); </span><br><span class="line"></span><br><span class="line">    /* (3.2.1.2)  计算cfs_rq-&gt;curr se的虚拟执行时间vruntime */</span><br><span class="line">	curr-&gt;vruntime += calc_delta_fair(delta_exec, curr);</span><br><span class="line">	update_min_vruntime(cfs_rq);</span><br><span class="line"></span><br><span class="line">    /* (3.2.1.3)  如果se对应的是task，而不是task_group，</span><br><span class="line">        更新task对应的时间统计</span><br><span class="line">     */</span><br><span class="line">	if (entity_is_task(curr)) &#123;</span><br><span class="line">		struct task_struct *curtask = task_of(curr);</span><br><span class="line"></span><br><span class="line">		trace_sched_stat_runtime(curtask, delta_exec, curr-&gt;vruntime);</span><br><span class="line">		// 更新task所在cgroup之cpuacct的某个cpu运行时间ca-&gt;cpuusage[cpu]-&gt;cpuusage</span><br><span class="line">		cpuacct_charge(curtask, delta_exec);</span><br><span class="line">		// 统计task所在线程组(thread group)的运行时间：</span><br><span class="line">		// tsk-&gt;signal-&gt;cputimer.cputime_atomic.sum_exec_runtime</span><br><span class="line">		account_group_exec_runtime(curtask, delta_exec);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (3.2.1.4)  计算cfs_rq的运行时间，是否超过cfs_bandwidth的限制:</span><br><span class="line">        cfs_rq-&gt;runtime_remaining</span><br><span class="line">     */</span><br><span class="line">	account_cfs_rq_runtime(cfs_rq, delta_exec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-6、几个特殊时刻vruntime的变化"><a href="#2-2-6、几个特殊时刻vruntime的变化" class="headerlink" title="2.2.6、几个特殊时刻vruntime的变化"></a>2.2.6、几个特殊时刻vruntime的变化</h3><p>关于cfs调度和vruntime，除了正常的scheduler_tick()的计算，还有些特殊时刻需要特殊处理。这些细节用一些疑问来牵引出来：</p>
<ul>
<li>1、新进程的vruntime是多少？</li>
</ul>
<p>假如新进程的vruntime初值为0的话，比老进程的值小很多，那么它在相当长的时间内都会保持抢占CPU的优势，老进程就要饿死了，这显然是不公平的。</p>
<p>CFS的做法是：取父进程vruntime(curr-&gt;vruntime) 和 (cfs_rq-&gt;min_vruntime + 假设se运行过一轮的值)之间的最大值，赋给新创建进程。把新进程对现有进程的调度影响降到最小。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">_do_fork() -&gt; copy_process() -&gt; sched_fork() -&gt; task_fork_fair():</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static void task_fork_fair(struct task_struct *p)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    /* (1) 如果cfs_rq-&gt;current进程存在，</span><br><span class="line">        se-&gt;vruntime的值暂时等于curr-&gt;vruntime</span><br><span class="line">     */</span><br><span class="line">	if (curr)</span><br><span class="line">		se-&gt;vruntime = curr-&gt;vruntime;   </span><br><span class="line">		</span><br><span class="line">	/* (2) 设置新的se-&gt;vruntime */</span><br><span class="line">	place_entity(cfs_rq, se, 1);</span><br><span class="line"></span><br><span class="line">    /* (3) 如果sysctl_sched_child_runs_first标志被设置，</span><br><span class="line">        确保fork子进程比父进程先执行*/</span><br><span class="line">	if (sysctl_sched_child_runs_first &amp;&amp; curr &amp;&amp; entity_before(curr, se)) &#123;</span><br><span class="line">		/*</span><br><span class="line">		 * Upon rescheduling, sched_class::put_prev_task() will place</span><br><span class="line">		 * &apos;current&apos; within the tree based on its new key value.</span><br><span class="line">		 */</span><br><span class="line">		swap(curr-&gt;vruntime, se-&gt;vruntime);</span><br><span class="line">		resched_curr(rq);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (4) 防止新进程运行时是在其他cpu上运行的,</span><br><span class="line">        这样在加入另一个cfs_rq时再加上另一个cfs_rq队列的min_vruntime值即可</span><br><span class="line">        (具体可以看enqueue_entity函数)</span><br><span class="line">     */</span><br><span class="line">	se-&gt;vruntime -= cfs_rq-&gt;min_vruntime;</span><br><span class="line"></span><br><span class="line">	raw_spin_unlock_irqrestore(&amp;rq-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">place_entity(struct cfs_rq *cfs_rq, struct sched_entity *se, int initial)</span><br><span class="line">&#123;</span><br><span class="line">	u64 vruntime = cfs_rq-&gt;min_vruntime;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * The &apos;current&apos; period is already promised to the current tasks,</span><br><span class="line">	 * however the extra weight of the new task will slow them down a</span><br><span class="line">	 * little, place the new task so that it fits in the slot that</span><br><span class="line">	 * stays open at the end.</span><br><span class="line">	 */</span><br><span class="line">	/* (2.1) 计算cfs_rq-&gt;min_vruntime + 假设se运行过一轮的值，</span><br><span class="line">	    这样的做法是把新进程se放到红黑树的最后 */</span><br><span class="line">	if (initial &amp;&amp; sched_feat(START_DEBIT))</span><br><span class="line">		vruntime += sched_vslice(cfs_rq, se);</span><br><span class="line"></span><br><span class="line">	/* sleeps up to a single latency don&apos;t count. */</span><br><span class="line">	if (!initial) &#123;</span><br><span class="line">		unsigned long thresh = sysctl_sched_latency;</span><br><span class="line"></span><br><span class="line">		/*</span><br><span class="line">		 * Halve their sleep time&apos;s effect, to allow</span><br><span class="line">		 * for a gentler effect of sleepers:</span><br><span class="line">		 */</span><br><span class="line">		if (sched_feat(GENTLE_FAIR_SLEEPERS))</span><br><span class="line">			thresh &gt;&gt;= 1;</span><br><span class="line"></span><br><span class="line">		vruntime -= thresh;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (2.2) 在 (curr-&gt;vruntime) 和 (cfs_rq-&gt;min_vruntime + 假设se运行过一轮的值)，</span><br><span class="line">    之间取最大值</span><br><span class="line">     */</span><br><span class="line">	/* ensure we never gain time by being placed backwards. */</span><br><span class="line">	se-&gt;vruntime = max_vruntime(se-&gt;vruntime, vruntime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">enqueue_entity(struct cfs_rq *cfs_rq, struct sched_entity *se, int flags)</span><br><span class="line">&#123;</span><br><span class="line">	/*</span><br><span class="line">	 * Update the normalized vruntime before updating min_vruntime</span><br><span class="line">	 * through calling update_curr().</span><br><span class="line">	 */</span><br><span class="line">	/* (4.1) 在enqueue时给se-&gt;vruntime重新加上cfs_rq-&gt;min_vruntime */</span><br><span class="line">	if (!(flags &amp; ENQUEUE_WAKEUP) || (flags &amp; ENQUEUE_WAKING))</span><br><span class="line">		se-&gt;vruntime += cfs_rq-&gt;min_vruntime;</span><br><span class="line">		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>2、休眠进程的vruntime一直保持不变吗、</li>
</ul>
<p>如果休眠进程的 vruntime 保持不变，而其他运行进程的 vruntime 一直在推进，那么等到休眠进程终于唤醒的时候，它的vruntime比别人小很多，会使它获得长时间抢占CPU的优势，其他进程就要饿死了。这显然是另一种形式的不公平。</p>
<p>CFS是这样做的：在休眠进程被唤醒时重新设置vruntime值，以min_vruntime值为基础，给予一定的补偿，但不能补偿太多。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">static void</span><br><span class="line">enqueue_entity(struct cfs_rq *cfs_rq, struct sched_entity *se, int flags)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	if (flags &amp; ENQUEUE_WAKEUP) &#123;</span><br><span class="line">	    /* (1) 计算进程唤醒后的vruntime */</span><br><span class="line">		place_entity(cfs_rq, se, 0);</span><br><span class="line">		enqueue_sleeper(cfs_rq, se);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">place_entity(struct cfs_rq *cfs_rq, struct sched_entity *se, int initial)</span><br><span class="line">&#123;</span><br><span class="line">    /* (1.1) 初始值是cfs_rq的当前最小值min_vruntime */</span><br><span class="line">	u64 vruntime = cfs_rq-&gt;min_vruntime;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * The &apos;current&apos; period is already promised to the current tasks,</span><br><span class="line">	 * however the extra weight of the new task will slow them down a</span><br><span class="line">	 * little, place the new task so that it fits in the slot that</span><br><span class="line">	 * stays open at the end.</span><br><span class="line">	 */</span><br><span class="line">	if (initial &amp;&amp; sched_feat(START_DEBIT))</span><br><span class="line">		vruntime += sched_vslice(cfs_rq, se);</span><br><span class="line"></span><br><span class="line">	/* sleeps up to a single latency don&apos;t count. */</span><br><span class="line">	/* (1.2) 在最小值min_vruntime的基础上给予补偿，</span><br><span class="line">	    默认补偿值是6ms(sysctl_sched_latency)</span><br><span class="line">	 */</span><br><span class="line">	if (!initial) &#123;</span><br><span class="line">		unsigned long thresh = sysctl_sched_latency;</span><br><span class="line"></span><br><span class="line">		/*</span><br><span class="line">		 * Halve their sleep time&apos;s effect, to allow</span><br><span class="line">		 * for a gentler effect of sleepers:</span><br><span class="line">		 */</span><br><span class="line">		if (sched_feat(GENTLE_FAIR_SLEEPERS))</span><br><span class="line">			thresh &gt;&gt;= 1;</span><br><span class="line"></span><br><span class="line">		vruntime -= thresh;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* ensure we never gain time by being placed backwards. */</span><br><span class="line">	se-&gt;vruntime = max_vruntime(se-&gt;vruntime, vruntime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>3、休眠进程在唤醒时会立刻抢占CPU吗？</li>
</ul>
<p>进程被唤醒默认是会马上检查是否库抢占，因为唤醒的vruntime在cfs_rq的最小值min_vruntime基础上进行了补偿，所以他肯定会抢占当前的进程。</p>
<p>CFS可以通过禁止WAKEUP_PREEMPTION来禁止唤醒抢占，不过这也就失去了抢占特性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">try_to_wake_up() -&gt; ttwu_queue() -&gt; ttwu_do_activate() -&gt; ttwu_do_wakeup() -&gt; check_preempt_curr() -&gt; check_preempt_wakeup()</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static void check_preempt_wakeup(struct rq *rq, struct task_struct *p, int wake_flags)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Batch and idle tasks do not preempt non-idle tasks (their preemption</span><br><span class="line">	 * is driven by the tick):</span><br><span class="line">	 */</span><br><span class="line">	/* (1) 如果WAKEUP_PREEMPTION没有被设置，不进行唤醒时的抢占 */</span><br><span class="line">	if (unlikely(p-&gt;policy != SCHED_NORMAL) || !sched_feat(WAKEUP_PREEMPTION))</span><br><span class="line">		return;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">preempt:</span><br><span class="line">	resched_curr(rq);</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>4、进程从一个CPU迁移到另一个CPU上的时候vruntime会不会变？</li>
</ul>
<p>不同cpu的负载时不一样的，所以不同cfs_rq里se的vruntime水平是不一样的。如果进程迁移vruntime不变也是非常不公平的。</p>
<p>CFS使用了一个很聪明的做法：在退出旧的cfs_rq时减去旧cfs_rq的min_vruntime，在加入新的cfq_rq时重新加上新cfs_rq的min_vruntime。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">static void</span><br><span class="line">dequeue_entity(struct cfs_rq *cfs_rq, struct sched_entity *se, int flags)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">	 * Normalize the entity after updating the min_vruntime because the</span><br><span class="line">	 * update can refer to the -&gt;curr item and we need to reflect this</span><br><span class="line">	 * movement in our normalized position.</span><br><span class="line">	 */</span><br><span class="line">	/* (1) 退出旧的cfs_rq时减去旧cfs_rq的min_vruntime */</span><br><span class="line">	if (!(flags &amp; DEQUEUE_SLEEP))</span><br><span class="line">		se-&gt;vruntime -= cfs_rq-&gt;min_vruntime;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">enqueue_entity(struct cfs_rq *cfs_rq, struct sched_entity *se, int flags)</span><br><span class="line">&#123;</span><br><span class="line">	/*</span><br><span class="line">	 * Update the normalized vruntime before updating min_vruntime</span><br><span class="line">	 * through calling update_curr().</span><br><span class="line">	 */</span><br><span class="line">	/* (2) 加入新的cfq_rq时重新加上新cfs_rq的min_vruntime */</span><br><span class="line">	if (!(flags &amp; ENQUEUE_WAKEUP) || (flags &amp; ENQUEUE_WAKING))</span><br><span class="line">		se-&gt;vruntime += cfs_rq-&gt;min_vruntime;</span><br><span class="line">		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-7、cfs-bandwidth"><a href="#2-2-7、cfs-bandwidth" class="headerlink" title="2.2.7、cfs bandwidth"></a>2.2.7、cfs bandwidth</h3><p><img src="/images/scheduler/schedule_cfs_bandwidth.png" alt="schedule_cfs_bandwidth"></p>
<ul>
<li>1、cfs bandwidth是针对task_group的配置，一个task_group的bandwidth使用一个struct cfs_bandwidth *cfs_b数据结构来控制。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">struct cfs_bandwidth &#123;</span><br><span class="line">#ifdef CONFIG_CFS_BANDWIDTH</span><br><span class="line">	raw_spinlock_t lock;</span><br><span class="line">	ktime_t period;     // cfs bandwidth的监控周期，默认值是default_cfs_period() 0.1s</span><br><span class="line">	u64 quota;          // cfs task_group 在一个监控周期内的运行时间配额，默认值是RUNTIME_INF，无限大</span><br><span class="line">	u64 runtime;        // cfs task_group 在一个监控周期内剩余可运行的时间</span><br><span class="line">	s64 hierarchical_quota;</span><br><span class="line">	u64 runtime_expires;</span><br><span class="line"></span><br><span class="line">	int idle, period_active;</span><br><span class="line">	struct hrtimer period_timer;</span><br><span class="line">	struct hrtimer slack_timer;</span><br><span class="line">	struct list_head throttled_cfs_rq;</span><br><span class="line"></span><br><span class="line">	/* statistics */</span><br><span class="line">	int nr_periods, nr_throttled;</span><br><span class="line">	u64 throttled_time;</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中几个关键的数据结构：cfs_b-&gt;period是监控周期，cfs_b-&gt;quota是tg的运行配额，cfs_b-&gt;runtime是tg剩余可运行的时间。cfs_b-&gt;runtime在监控周期开始的时候等于cfs_b-&gt;quota，随着tg不断运行不断减少，如果cfs_b-&gt;runtime &lt; 0说明tg已经超过bandwidth，触发流量控制；</p>
<p>cfs bandwidth是提供给CGROUP_SCHED使用的，所以cfs_b-&gt;quota的初始值都是RUNTIME_INF无限大，所以在使能CGROUP_SCHED以后需要自己配置这些参数。</p>
<ul>
<li>2、因为一个task_group是在percpu上都创建了一个cfs_rq，所以cfs_b-&gt;quota的值是这些percpu cfs_rq中的进程共享的，每个percpu cfs_rq在运行时需要向tg-&gt;cfs_bandwidth-&gt;runtime来申请；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">scheduler_tick() -&gt; task_tick_fair() -&gt; entity_tick() -&gt; update_curr() -&gt; account_cfs_rq_runtime()</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static __always_inline</span><br><span class="line">void account_cfs_rq_runtime(struct cfs_rq *cfs_rq, u64 delta_exec)</span><br><span class="line">&#123;</span><br><span class="line">	if (!cfs_bandwidth_used() || !cfs_rq-&gt;runtime_enabled)</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	__account_cfs_rq_runtime(cfs_rq, delta_exec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">static void __account_cfs_rq_runtime(struct cfs_rq *cfs_rq, u64 delta_exec)</span><br><span class="line">&#123;</span><br><span class="line">    /* (1) 用cfs_rq已经申请的时间配额(cfs_rq-&gt;runtime_remaining)减去已经消耗的时间 */</span><br><span class="line">	/* dock delta_exec before expiring quota (as it could span periods) */</span><br><span class="line">	cfs_rq-&gt;runtime_remaining -= delta_exec;</span><br><span class="line">	</span><br><span class="line">	/* (2) expire超期时间的判断 */</span><br><span class="line">	expire_cfs_rq_runtime(cfs_rq);</span><br><span class="line"></span><br><span class="line">    /* (3) 如果cfs_rq已经申请的时间配额还没用完，返回 */</span><br><span class="line">	if (likely(cfs_rq-&gt;runtime_remaining &gt; 0))</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * if we&apos;re unable to extend our runtime we resched so that the active</span><br><span class="line">	 * hierarchy can be throttled</span><br><span class="line">	 */</span><br><span class="line">	/* (4) 如果cfs_rq申请的时间配额已经用完，尝试向tg的cfs_b-&gt;runtime申请新的时间片</span><br><span class="line">	    如果申请新时间片失败，说明整个tg已经没有可运行时间了，把本进程设置为需要重新调度，</span><br><span class="line">	    在中断返回，发起schedule()时，发现cfs_rq-&gt;runtime_remaining&lt;=0，会调用throttle_cfs_rq()对cfs_rq进行实质的限制</span><br><span class="line">	 */</span><br><span class="line">	if (!assign_cfs_rq_runtime(cfs_rq) &amp;&amp; likely(cfs_rq-&gt;curr))</span><br><span class="line">		resched_curr(rq_of(cfs_rq));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">||→</span><br><span class="line"></span><br><span class="line">static int assign_cfs_rq_runtime(struct cfs_rq *cfs_rq)</span><br><span class="line">&#123;</span><br><span class="line">	struct task_group *tg = cfs_rq-&gt;tg;</span><br><span class="line">	struct cfs_bandwidth *cfs_b = tg_cfs_bandwidth(tg);</span><br><span class="line">	u64 amount = 0, min_amount, expires;</span><br><span class="line"></span><br><span class="line">    /* (4.1) cfs_b的分配时间片的默认值是5ms */</span><br><span class="line">	/* note: this is a positive sum as runtime_remaining &lt;= 0 */</span><br><span class="line">	min_amount = sched_cfs_bandwidth_slice() - cfs_rq-&gt;runtime_remaining;</span><br><span class="line"></span><br><span class="line">	raw_spin_lock(&amp;cfs_b-&gt;lock);</span><br><span class="line">	if (cfs_b-&gt;quota == RUNTIME_INF)</span><br><span class="line">	    /* (4.2) RUNTIME_INF类型，时间是分配不完的 */</span><br><span class="line">		amount = min_amount;</span><br><span class="line">	else &#123;</span><br><span class="line">		start_cfs_bandwidth(cfs_b);</span><br><span class="line"></span><br><span class="line">        /* (4.3) 剩余时间cfs_b-&gt;runtime减去分配的时间片 */</span><br><span class="line">		if (cfs_b-&gt;runtime &gt; 0) &#123;</span><br><span class="line">			amount = min(cfs_b-&gt;runtime, min_amount);</span><br><span class="line">			cfs_b-&gt;runtime -= amount;</span><br><span class="line">			cfs_b-&gt;idle = 0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	expires = cfs_b-&gt;runtime_expires;</span><br><span class="line">	raw_spin_unlock(&amp;cfs_b-&gt;lock);</span><br><span class="line"></span><br><span class="line">    /* (4.4) 分配的时间片赋值给cfs_rq */</span><br><span class="line">	cfs_rq-&gt;runtime_remaining += amount;</span><br><span class="line">	/*</span><br><span class="line">	 * we may have advanced our local expiration to account for allowed</span><br><span class="line">	 * spread between our sched_clock and the one on which runtime was</span><br><span class="line">	 * issued.</span><br><span class="line">	 */</span><br><span class="line">	if ((s64)(expires - cfs_rq-&gt;runtime_expires) &gt; 0)</span><br><span class="line">		cfs_rq-&gt;runtime_expires = expires;</span><br><span class="line"></span><br><span class="line">    /* (4.5) 判断分配时间是否足够? */</span><br><span class="line">	return cfs_rq-&gt;runtime_remaining &gt; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>3、在enqueue_task_fair()、put_prev_task_fair()、pick_next_task_fair()这几个时刻，会check cfs_rq是否已经达到throttle，如果达到cfs throttle会把cfs_rq dequeue停止运行；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">enqueue_task_fair() -&gt; enqueue_entity() -&gt; check_enqueue_throttle() -&gt; throttle_cfs_rq()</span><br><span class="line">put_prev_task_fair() -&gt; put_prev_entity() -&gt; check_cfs_rq_runtime() -&gt; throttle_cfs_rq()</span><br><span class="line">pick_next_task_fair() -&gt; check_cfs_rq_runtime() -&gt; throttle_cfs_rq()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void check_enqueue_throttle(struct cfs_rq *cfs_rq)</span><br><span class="line">&#123;</span><br><span class="line">	if (!cfs_bandwidth_used())</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	/* an active group must be handled by the update_curr()-&gt;put() path */</span><br><span class="line">	if (!cfs_rq-&gt;runtime_enabled || cfs_rq-&gt;curr)</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">    /* (1.1) 如果已经throttle，直接返回 */</span><br><span class="line">	/* ensure the group is not already throttled */</span><br><span class="line">	if (cfs_rq_throttled(cfs_rq))</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	/* update runtime allocation */</span><br><span class="line">	/* (1.2) 更新最新的cfs运行时间 */</span><br><span class="line">	account_cfs_rq_runtime(cfs_rq, 0);</span><br><span class="line">	</span><br><span class="line">	/* (1.3) 如果cfs_rq-&gt;runtime_remaining&lt;=0，启动throttle */</span><br><span class="line">	if (cfs_rq-&gt;runtime_remaining &lt;= 0)</span><br><span class="line">		throttle_cfs_rq(cfs_rq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* conditionally throttle active cfs_rq&apos;s from put_prev_entity() */</span><br><span class="line">static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq)</span><br><span class="line">&#123;</span><br><span class="line">	if (!cfs_bandwidth_used())</span><br><span class="line">		return false;</span><br><span class="line"></span><br><span class="line">    /* (2.1) 如果cfs_rq-&gt;runtime_remaining还有运行时间，直接返回 */</span><br><span class="line">	if (likely(!cfs_rq-&gt;runtime_enabled || cfs_rq-&gt;runtime_remaining &gt; 0))</span><br><span class="line">		return false;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * it&apos;s possible for a throttled entity to be forced into a running</span><br><span class="line">	 * state (e.g. set_curr_task), in this case we&apos;re finished.</span><br><span class="line">	 */</span><br><span class="line">	/* (2.2) 如果已经throttle，直接返回 */</span><br><span class="line">	if (cfs_rq_throttled(cfs_rq))</span><br><span class="line">		return true;</span><br><span class="line"></span><br><span class="line">    /* (2.3) 已经throttle，执行throttle动作 */</span><br><span class="line">	throttle_cfs_rq(cfs_rq);</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void throttle_cfs_rq(struct cfs_rq *cfs_rq)</span><br><span class="line">&#123;</span><br><span class="line">	struct rq *rq = rq_of(cfs_rq);</span><br><span class="line">	struct cfs_bandwidth *cfs_b = tg_cfs_bandwidth(cfs_rq-&gt;tg);</span><br><span class="line">	struct sched_entity *se;</span><br><span class="line">	long task_delta, dequeue = 1;</span><br><span class="line">	bool empty;</span><br><span class="line"></span><br><span class="line">	se = cfs_rq-&gt;tg-&gt;se[cpu_of(rq_of(cfs_rq))];</span><br><span class="line"></span><br><span class="line">	/* freeze hierarchy runnable averages while throttled */</span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	walk_tg_tree_from(cfs_rq-&gt;tg, tg_throttle_down, tg_nop, (void *)rq);</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">	task_delta = cfs_rq-&gt;h_nr_running;</span><br><span class="line">	for_each_sched_entity(se) &#123;</span><br><span class="line">		struct cfs_rq *qcfs_rq = cfs_rq_of(se);</span><br><span class="line">		/* throttled entity or throttle-on-deactivate */</span><br><span class="line">		if (!se-&gt;on_rq)</span><br><span class="line">			break;</span><br><span class="line"></span><br><span class="line">        /* (3.1) throttle的动作1：将cfs_rq dequeue停止运行 */</span><br><span class="line">		if (dequeue)</span><br><span class="line">			dequeue_entity(qcfs_rq, se, DEQUEUE_SLEEP);</span><br><span class="line">		qcfs_rq-&gt;h_nr_running -= task_delta;</span><br><span class="line"></span><br><span class="line">		if (qcfs_rq-&gt;load.weight)</span><br><span class="line">			dequeue = 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (!se)</span><br><span class="line">		sub_nr_running(rq, task_delta);</span><br><span class="line"></span><br><span class="line">    /* (3.2) throttle的动作2：将cfs_rq-&gt;throttled置位 */</span><br><span class="line">	cfs_rq-&gt;throttled = 1;</span><br><span class="line">	cfs_rq-&gt;throttled_clock = rq_clock(rq);</span><br><span class="line">	raw_spin_lock(&amp;cfs_b-&gt;lock);</span><br><span class="line">	empty = list_empty(&amp;cfs_b-&gt;throttled_cfs_rq);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Add to the _head_ of the list, so that an already-started</span><br><span class="line">	 * distribute_cfs_runtime will not see us</span><br><span class="line">	 */</span><br><span class="line">	list_add_rcu(&amp;cfs_rq-&gt;throttled_list, &amp;cfs_b-&gt;throttled_cfs_rq);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * If we&apos;re the first throttled task, make sure the bandwidth</span><br><span class="line">	 * timer is running.</span><br><span class="line">	 */</span><br><span class="line">	if (empty)</span><br><span class="line">		start_cfs_bandwidth(cfs_b);</span><br><span class="line"></span><br><span class="line">	raw_spin_unlock(&amp;cfs_b-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>4、对每一个tg的cfs_b，系统会启动一个周期性定时器cfs_b-&gt;period_timer，运行周期为cfs_b-&gt;period。主要作用是period到期后检查是否有cfs_rq被throttle，如果被throttle恢复它，并进行新一轮的监控；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line">sched_cfs_period_timer() -&gt; do_sched_cfs_period_timer()</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static int do_sched_cfs_period_timer(struct cfs_bandwidth *cfs_b, int overrun)</span><br><span class="line">&#123;</span><br><span class="line">	u64 runtime, runtime_expires;</span><br><span class="line">	int throttled;</span><br><span class="line"></span><br><span class="line">	/* no need to continue the timer with no bandwidth constraint */</span><br><span class="line">	if (cfs_b-&gt;quota == RUNTIME_INF)</span><br><span class="line">		goto out_deactivate;</span><br><span class="line"></span><br><span class="line">	throttled = !list_empty(&amp;cfs_b-&gt;throttled_cfs_rq);</span><br><span class="line">	cfs_b-&gt;nr_periods += overrun;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * idle depends on !throttled (for the case of a large deficit), and if</span><br><span class="line">	 * we&apos;re going inactive then everything else can be deferred</span><br><span class="line">	 */</span><br><span class="line">	if (cfs_b-&gt;idle &amp;&amp; !throttled)</span><br><span class="line">		goto out_deactivate;</span><br><span class="line"></span><br><span class="line">    /* (1) 新周期的开始，给cfs_b-&gt;runtime重新赋值为cfs_b-&gt;quota */</span><br><span class="line">	__refill_cfs_bandwidth_runtime(cfs_b);</span><br><span class="line"></span><br><span class="line">	if (!throttled) &#123;</span><br><span class="line">		/* mark as potentially idle for the upcoming period */</span><br><span class="line">		cfs_b-&gt;idle = 1;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* account preceding periods in which throttling occurred */</span><br><span class="line">	cfs_b-&gt;nr_throttled += overrun;</span><br><span class="line"></span><br><span class="line">	runtime_expires = cfs_b-&gt;runtime_expires;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * This check is repeated as we are holding onto the new bandwidth while</span><br><span class="line">	 * we unthrottle. This can potentially race with an unthrottled group</span><br><span class="line">	 * trying to acquire new bandwidth from the global pool. This can result</span><br><span class="line">	 * in us over-using our runtime if it is all used during this loop, but</span><br><span class="line">	 * only by limited amounts in that extreme case.</span><br><span class="line">	 */</span><br><span class="line">	/* (2) 解除cfs_b-&gt;throttled_cfs_rq中所有被throttle住的cfs_rq */</span><br><span class="line">	while (throttled &amp;&amp; cfs_b-&gt;runtime &gt; 0) &#123;</span><br><span class="line">		runtime = cfs_b-&gt;runtime;</span><br><span class="line">		raw_spin_unlock(&amp;cfs_b-&gt;lock);</span><br><span class="line">		/* we can&apos;t nest cfs_b-&gt;lock while distributing bandwidth */</span><br><span class="line">		runtime = distribute_cfs_runtime(cfs_b, runtime,</span><br><span class="line">						 runtime_expires);</span><br><span class="line">		raw_spin_lock(&amp;cfs_b-&gt;lock);</span><br><span class="line"></span><br><span class="line">		throttled = !list_empty(&amp;cfs_b-&gt;throttled_cfs_rq);</span><br><span class="line"></span><br><span class="line">		cfs_b-&gt;runtime -= min(runtime, cfs_b-&gt;runtime);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * While we are ensured activity in the period following an</span><br><span class="line">	 * unthrottle, this also covers the case in which the new bandwidth is</span><br><span class="line">	 * insufficient to cover the existing bandwidth deficit.  (Forcing the</span><br><span class="line">	 * timer to remain active while there are any throttled entities.)</span><br><span class="line">	 */</span><br><span class="line">	cfs_b-&gt;idle = 0;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line">out_deactivate:</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">static u64 distribute_cfs_runtime(struct cfs_bandwidth *cfs_b,</span><br><span class="line">		u64 remaining, u64 expires)</span><br><span class="line">&#123;</span><br><span class="line">	struct cfs_rq *cfs_rq;</span><br><span class="line">	u64 runtime;</span><br><span class="line">	u64 starting_runtime = remaining;</span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	list_for_each_entry_rcu(cfs_rq, &amp;cfs_b-&gt;throttled_cfs_rq,</span><br><span class="line">				throttled_list) &#123;</span><br><span class="line">		struct rq *rq = rq_of(cfs_rq);</span><br><span class="line"></span><br><span class="line">		raw_spin_lock(&amp;rq-&gt;lock);</span><br><span class="line">		if (!cfs_rq_throttled(cfs_rq))</span><br><span class="line">			goto next;</span><br><span class="line"></span><br><span class="line">		runtime = -cfs_rq-&gt;runtime_remaining + 1;</span><br><span class="line">		if (runtime &gt; remaining)</span><br><span class="line">			runtime = remaining;</span><br><span class="line">		remaining -= runtime;</span><br><span class="line"></span><br><span class="line">		cfs_rq-&gt;runtime_remaining += runtime;</span><br><span class="line">		cfs_rq-&gt;runtime_expires = expires;</span><br><span class="line"></span><br><span class="line">        /* (2.1) 解除throttle */</span><br><span class="line">		/* we check whether we&apos;re throttled above */</span><br><span class="line">		if (cfs_rq-&gt;runtime_remaining &gt; 0)</span><br><span class="line">			unthrottle_cfs_rq(cfs_rq);</span><br><span class="line"></span><br><span class="line">next:</span><br><span class="line">		raw_spin_unlock(&amp;rq-&gt;lock);</span><br><span class="line"></span><br><span class="line">		if (!remaining)</span><br><span class="line">			break;</span><br><span class="line">	&#125;</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">	return starting_runtime - remaining;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">||→</span><br><span class="line"></span><br><span class="line">void unthrottle_cfs_rq(struct cfs_rq *cfs_rq)</span><br><span class="line">&#123;</span><br><span class="line">	struct rq *rq = rq_of(cfs_rq);</span><br><span class="line">	struct cfs_bandwidth *cfs_b = tg_cfs_bandwidth(cfs_rq-&gt;tg);</span><br><span class="line">	struct sched_entity *se;</span><br><span class="line">	int enqueue = 1;</span><br><span class="line">	long task_delta;</span><br><span class="line"></span><br><span class="line">	se = cfs_rq-&gt;tg-&gt;se[cpu_of(rq)];</span><br><span class="line"></span><br><span class="line">	cfs_rq-&gt;throttled = 0;</span><br><span class="line"></span><br><span class="line">	update_rq_clock(rq);</span><br><span class="line"></span><br><span class="line">	raw_spin_lock(&amp;cfs_b-&gt;lock);</span><br><span class="line">	cfs_b-&gt;throttled_time += rq_clock(rq) - cfs_rq-&gt;throttled_clock;</span><br><span class="line">	list_del_rcu(&amp;cfs_rq-&gt;throttled_list);</span><br><span class="line">	raw_spin_unlock(&amp;cfs_b-&gt;lock);</span><br><span class="line"></span><br><span class="line">	/* update hierarchical throttle state */</span><br><span class="line">	walk_tg_tree_from(cfs_rq-&gt;tg, tg_nop, tg_unthrottle_up, (void *)rq);</span><br><span class="line"></span><br><span class="line">	if (!cfs_rq-&gt;load.weight)</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	task_delta = cfs_rq-&gt;h_nr_running;</span><br><span class="line">	for_each_sched_entity(se) &#123;</span><br><span class="line">		if (se-&gt;on_rq)</span><br><span class="line">			enqueue = 0;</span><br><span class="line"></span><br><span class="line">		cfs_rq = cfs_rq_of(se);</span><br><span class="line">		/* (2.1.1) 重新enqueue运行 */</span><br><span class="line">		if (enqueue)</span><br><span class="line">			enqueue_entity(cfs_rq, se, ENQUEUE_WAKEUP);</span><br><span class="line">		cfs_rq-&gt;h_nr_running += task_delta;</span><br><span class="line"></span><br><span class="line">		if (cfs_rq_throttled(cfs_rq))</span><br><span class="line">			break;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (!se)</span><br><span class="line">		add_nr_running(rq, task_delta);</span><br><span class="line"></span><br><span class="line">	/* determine whether we need to wake up potentially idle cpu */</span><br><span class="line">	if (rq-&gt;curr == rq-&gt;idle &amp;&amp; rq-&gt;cfs.nr_running)</span><br><span class="line">		resched_curr(rq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-8、sched-sysctl参数"><a href="#2-2-8、sched-sysctl参数" class="headerlink" title="2.2.8、sched sysctl参数"></a>2.2.8、sched sysctl参数</h3><p>系统在sysctl中注册了很多sysctl参数供我们调优使用，在”/proc/sys/kernel/“目录下可以看到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> # ls /proc/sys/kernel/sched_*</span><br><span class="line">sched_cfs_boost                         </span><br><span class="line">sched_child_runs_first          // fork子进程后，子进程是否先于父进程运行</span><br><span class="line">sched_latency_ns                // 计算cfs period，如果runnable数量小于sched_nr_latency，返回的最小period值，单位ns     </span><br><span class="line">sched_migration_cost_ns                 </span><br><span class="line">sched_min_granularity_ns        // 计算cfs period，如果runnable数量大于sched_nr_latency，每个进程可占用的时间，单位ns</span><br><span class="line">                                // cfs period = nr_running * sysctl_sched_min_granularity;</span><br><span class="line">sched_nr_migrate                        </span><br><span class="line">sched_rr_timeslice_ms           // SCHED_RR类型的rt进程每个时间片的大小，单位ms</span><br><span class="line">sched_rt_period_us              // rt-throttle的计算周期</span><br><span class="line">sched_rt_runtime_us             // 一个rt-throttle计算周期内，rt进程可运行的时间</span><br><span class="line">sched_shares_window_ns</span><br><span class="line">sched_time_avg_ms               // rt负载(rq-&gt;rt_avg)的老化周期</span><br><span class="line">sched_tunable_scaling</span><br><span class="line">sched_wakeup_granularity_ns</span><br></pre></td></tr></table></figure>
<p>kern_table[]中也有相关的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line">static struct ctl_table kern_table[] = &#123;</span><br><span class="line">	&#123;</span><br><span class="line">		.procname	= &quot;sched_child_runs_first&quot;,</span><br><span class="line">		.data		= &amp;sysctl_sched_child_runs_first,</span><br><span class="line">		.maxlen		= sizeof(unsigned int),</span><br><span class="line">		.mode		= 0644,</span><br><span class="line">		.proc_handler	= proc_dointvec,</span><br><span class="line">	&#125;,</span><br><span class="line">#ifdef CONFIG_SCHED_DEBUG</span><br><span class="line">	&#123;</span><br><span class="line">		.procname	= &quot;sched_min_granularity_ns&quot;,</span><br><span class="line">		.data		= &amp;sysctl_sched_min_granularity,</span><br><span class="line">		.maxlen		= sizeof(unsigned int),</span><br><span class="line">		.mode		= 0644,</span><br><span class="line">		.proc_handler	= sched_proc_update_handler,</span><br><span class="line">		.extra1		= &amp;min_sched_granularity_ns,</span><br><span class="line">		.extra2		= &amp;max_sched_granularity_ns,</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		.procname	= &quot;sched_latency_ns&quot;,</span><br><span class="line">		.data		= &amp;sysctl_sched_latency,</span><br><span class="line">		.maxlen		= sizeof(unsigned int),</span><br><span class="line">		.mode		= 0644,</span><br><span class="line">		.proc_handler	= sched_proc_update_handler,</span><br><span class="line">		.extra1		= &amp;min_sched_granularity_ns,</span><br><span class="line">		.extra2		= &amp;max_sched_granularity_ns,</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		.procname	= &quot;sched_wakeup_granularity_ns&quot;,</span><br><span class="line">		.data		= &amp;sysctl_sched_wakeup_granularity,</span><br><span class="line">		.maxlen		= sizeof(unsigned int),</span><br><span class="line">		.mode		= 0644,</span><br><span class="line">		.proc_handler	= sched_proc_update_handler,</span><br><span class="line">		.extra1		= &amp;min_wakeup_granularity_ns,</span><br><span class="line">		.extra2		= &amp;max_wakeup_granularity_ns,</span><br><span class="line">	&#125;,</span><br><span class="line">#ifdef CONFIG_SMP</span><br><span class="line">	&#123;</span><br><span class="line">		.procname	= &quot;sched_tunable_scaling&quot;,</span><br><span class="line">		.data		= &amp;sysctl_sched_tunable_scaling,</span><br><span class="line">		.maxlen		= sizeof(enum sched_tunable_scaling),</span><br><span class="line">		.mode		= 0644,</span><br><span class="line">		.proc_handler	= sched_proc_update_handler,</span><br><span class="line">		.extra1		= &amp;min_sched_tunable_scaling,</span><br><span class="line">		.extra2		= &amp;max_sched_tunable_scaling,</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		.procname	= &quot;sched_migration_cost_ns&quot;,</span><br><span class="line">		.data		= &amp;sysctl_sched_migration_cost,</span><br><span class="line">		.maxlen		= sizeof(unsigned int),</span><br><span class="line">		.mode		= 0644,</span><br><span class="line">		.proc_handler	= proc_dointvec,</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		.procname	= &quot;sched_nr_migrate&quot;,</span><br><span class="line">		.data		= &amp;sysctl_sched_nr_migrate,</span><br><span class="line">		.maxlen		= sizeof(unsigned int),</span><br><span class="line">		.mode		= 0644,</span><br><span class="line">		.proc_handler	= proc_dointvec,</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		.procname	= &quot;sched_time_avg_ms&quot;,</span><br><span class="line">		.data		= &amp;sysctl_sched_time_avg,</span><br><span class="line">		.maxlen		= sizeof(unsigned int),</span><br><span class="line">		.mode		= 0644,</span><br><span class="line">		.proc_handler	= proc_dointvec,</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		.procname	= &quot;sched_shares_window_ns&quot;,</span><br><span class="line">		.data		= &amp;sysctl_sched_shares_window,</span><br><span class="line">		.maxlen		= sizeof(unsigned int),</span><br><span class="line">		.mode		= 0644,</span><br><span class="line">		.proc_handler	= proc_dointvec,</span><br><span class="line">	&#125;,</span><br><span class="line">#endif /* CONFIG_SMP */</span><br><span class="line"></span><br><span class="line">#endif /* CONFIG_SCHED_DEBUG */</span><br><span class="line">	&#123;</span><br><span class="line">		.procname	= &quot;sched_rt_period_us&quot;,</span><br><span class="line">		.data		= &amp;sysctl_sched_rt_period,</span><br><span class="line">		.maxlen		= sizeof(unsigned int),</span><br><span class="line">		.mode		= 0644,</span><br><span class="line">		.proc_handler	= sched_rt_handler,</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		.procname	= &quot;sched_rt_runtime_us&quot;,</span><br><span class="line">		.data		= &amp;sysctl_sched_rt_runtime,</span><br><span class="line">		.maxlen		= sizeof(int),</span><br><span class="line">		.mode		= 0644,</span><br><span class="line">		.proc_handler	= sched_rt_handler,</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		.procname	= &quot;sched_rr_timeslice_ms&quot;,</span><br><span class="line">		.data		= &amp;sched_rr_timeslice,</span><br><span class="line">		.maxlen		= sizeof(int),</span><br><span class="line">		.mode		= 0644,</span><br><span class="line">		.proc_handler	= sched_rr_handler,</span><br><span class="line">	&#125;,</span><br><span class="line">#ifdef CONFIG_SCHED_AUTOGROUP</span><br><span class="line">	&#123;</span><br><span class="line">		.procname	= &quot;sched_autogroup_enabled&quot;,</span><br><span class="line">		.data		= &amp;sysctl_sched_autogroup_enabled,</span><br><span class="line">		.maxlen		= sizeof(unsigned int),</span><br><span class="line">		.mode		= 0644,</span><br><span class="line">		.proc_handler	= proc_dointvec_minmax,</span><br><span class="line">		.extra1		= &amp;zero,</span><br><span class="line">		.extra2		= &amp;one,</span><br><span class="line">	&#125;,</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_CFS_BANDWIDTH</span><br><span class="line">	&#123;</span><br><span class="line">		.procname	= &quot;sched_cfs_bandwidth_slice_us&quot;,</span><br><span class="line">		.data		= &amp;sysctl_sched_cfs_bandwidth_slice,</span><br><span class="line">		.maxlen		= sizeof(unsigned int),</span><br><span class="line">		.mode		= 0644,</span><br><span class="line">		.proc_handler	= proc_dointvec_minmax,</span><br><span class="line">		.extra1		= &amp;one,</span><br><span class="line">	&#125;,</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_SCHED_TUNE</span><br><span class="line">	&#123;</span><br><span class="line">		.procname	= &quot;sched_cfs_boost&quot;,</span><br><span class="line">		.data		= &amp;sysctl_sched_cfs_boost,</span><br><span class="line">		.maxlen		= sizeof(sysctl_sched_cfs_boost),</span><br><span class="line">#ifdef CONFIG_CGROUP_SCHEDTUNE</span><br><span class="line">		.mode		= 0444,</span><br><span class="line">#else</span><br><span class="line">		.mode		= 0644,</span><br><span class="line">#endif</span><br><span class="line">		.proc_handler	= &amp;sysctl_sched_cfs_boost_handler,</span><br><span class="line">		.extra1		= &amp;zero,</span><br><span class="line">		.extra2		= &amp;one_hundred,</span><br><span class="line">	&#125;,</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-9、”-proc-sched-debug”"><a href="#2-2-9、”-proc-sched-debug”" class="headerlink" title="2.2.9、”/proc/sched_debug”"></a>2.2.9、”/proc/sched_debug”</h3><p>在/proc/sched_debug中会打印出详细的schedule相关的信息，对应的代码在”kernel/sched/debug.c”中实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br></pre></td><td class="code"><pre><span class="line"># cat /proc/sched_debug</span><br><span class="line">Sched Debug Version: v0.11, 4.4.22+ #95</span><br><span class="line">ktime                                   : 1036739325.473178</span><br><span class="line">sched_clk                               : 1036739500.521349</span><br><span class="line">cpu_clk                                 : 1036739500.521888</span><br><span class="line">jiffies                                 : 4554077128</span><br><span class="line"></span><br><span class="line">sysctl_sched</span><br><span class="line">  .sysctl_sched_latency                    : 10.000000</span><br><span class="line">  .sysctl_sched_min_granularity            : 2.250000</span><br><span class="line">  .sysctl_sched_wakeup_granularity         : 2.000000</span><br><span class="line">  .sysctl_sched_child_runs_first           : 0</span><br><span class="line">  .sysctl_sched_features                   : 233275</span><br><span class="line">  .sysctl_sched_tunable_scaling            : 0 (none)</span><br><span class="line"></span><br><span class="line">cpu#0: Online</span><br><span class="line">  .nr_running                    : 1                    // rq-&gt;nr_running，rq中总的可运行进程数，包括cfs_rq + cfs_rq + dl_rq</span><br><span class="line">  .load                          : 1024                 // rq-&gt;load.weight，rq总的weight值</span><br><span class="line">  .nr_switches                   : 288653745</span><br><span class="line">  .nr_load_updates               : 102586831</span><br><span class="line">  .nr_uninterruptible            : 386195</span><br><span class="line">  .next_balance                  : 4554.077177</span><br><span class="line">  .curr-&gt;pid                     : 5839                 // rq-&gt;curr当前进程的pid</span><br><span class="line">  .clock                         : 1036739583.441965    // rq总的运行时间，单位s</span><br><span class="line">  .clock_task                    : 1036739583.441965    // rq总的task运行时间，单位s</span><br><span class="line">  .cpu_load[0]                   : 178                  // cpu级别的负载值，rq-&gt;cpu_load[]</span><br><span class="line">  .cpu_load[1]                   : 341</span><br><span class="line">  .cpu_load[2]                   : 646</span><br><span class="line">  .cpu_load[3]                   : 633</span><br><span class="line">  .cpu_load[4]                   : 448</span><br><span class="line">  .yld_count                     : 495661</span><br><span class="line">  .sched_count                   : 290639530</span><br><span class="line">  .sched_goidle                  : 95041623</span><br><span class="line">  .avg_idle                      : 66000</span><br><span class="line">  .max_idle_balance_cost         : 33000</span><br><span class="line">  .ttwu_count                    : 169556205</span><br><span class="line">  .ttwu_local                    : 156832675</span><br><span class="line"></span><br><span class="line">cfs_rq[0]:/bg_non_interactive                           // 叶子cfs_rq，“/bg_non_interactive ”</span><br><span class="line">  .exec_clock                    : 2008394.796159       // cfs_rq-&gt;exec_clock)</span><br><span class="line">  .MIN_vruntime                  : 0.000001</span><br><span class="line">  .min_vruntime                  : 4932671.018182</span><br><span class="line">  .max_vruntime                  : 0.000001</span><br><span class="line">  .spread                        : 0.000000</span><br><span class="line">  .spread0                       : -148755265.877002</span><br><span class="line">  .nr_spread_over                : 5018</span><br><span class="line">  .nr_running                    : 0                    // cfs_rq-&gt;nr_running，cfs_rq中总的可运行进程数</span><br><span class="line">  .load                          : 0                    // cfs_rq-&gt;load.weight</span><br><span class="line">  .load_avg                      : 0                    // cfs_rq-&gt;avg.load_avg</span><br><span class="line">  .runnable_load_avg             : 0                    // cfs_rq-&gt;runnable_load_avg</span><br><span class="line">  .util_avg                      : 0                    // cfs_rq-&gt;avg.util_avg</span><br><span class="line">  .removed_load_avg              : 0</span><br><span class="line">  .removed_util_avg              : 0</span><br><span class="line">  .tg_load_avg_contrib           : 0</span><br><span class="line">  .tg_load_avg                   : 943</span><br><span class="line">  .se-&gt;exec_start                : 1036739470.724118    // print_cfs_group_stats()，se = cfs_rq-&gt;tg-&gt;se[cpu]</span><br><span class="line">  .se-&gt;vruntime                  : 153687902.677263</span><br><span class="line">  .se-&gt;sum_exec_runtime          : 2008952.798927</span><br><span class="line">  .se-&gt;statistics.wait_start     : 0.000000</span><br><span class="line">  .se-&gt;statistics.sleep_start    : 0.000000</span><br><span class="line">  .se-&gt;statistics.block_start    : 0.000000</span><br><span class="line">  .se-&gt;statistics.sleep_max      : 0.000000</span><br><span class="line">  .se-&gt;statistics.block_max      : 0.000000</span><br><span class="line">  .se-&gt;statistics.exec_max       : 384.672539</span><br><span class="line">  .se-&gt;statistics.slice_max      : 110.416539</span><br><span class="line">  .se-&gt;statistics.wait_max       : 461.053539</span><br><span class="line">  .se-&gt;statistics.wait_sum       : 4583320.426021</span><br><span class="line">  .se-&gt;statistics.wait_count     : 4310369</span><br><span class="line">  .se-&gt;load.weight               : 2</span><br><span class="line">  .se-&gt;avg.load_avg              : 0</span><br><span class="line">  .se-&gt;avg.util_avg              : 0</span><br><span class="line"></span><br><span class="line">cfs_rq[0]:/                                             // 根cfs_rq，“/”</span><br><span class="line">  .exec_clock                    : 148912219.736328</span><br><span class="line">  .MIN_vruntime                  : 0.000001</span><br><span class="line">  .min_vruntime                  : 153687936.895184</span><br><span class="line">  .max_vruntime                  : 0.000001</span><br><span class="line">  .spread                        : 0.000000</span><br><span class="line">  .spread0                       : 0.000000</span><br><span class="line">  .nr_spread_over                : 503579</span><br><span class="line">  .nr_running                    : 1</span><br><span class="line">  .load                          : 1024</span><br><span class="line">  .load_avg                      : 4815</span><br><span class="line">  .runnable_load_avg             : 168</span><br><span class="line">  .util_avg                      : 63</span><br><span class="line">  .removed_load_avg              : 0</span><br><span class="line">  .removed_util_avg              : 0</span><br><span class="line">  .tg_load_avg_contrib           : 4815</span><br><span class="line">  .tg_load_avg                   : 9051</span><br><span class="line"></span><br><span class="line">rt_rq[0]:/bg_non_interactive                            // 叶子rt_rq，“/bg_non_interactive ”</span><br><span class="line">  .rt_nr_running                 : 0</span><br><span class="line">  .rt_throttled                  : 0</span><br><span class="line">  .rt_time                       : 0.000000</span><br><span class="line">  .rt_runtime                    : 700.000000</span><br><span class="line"></span><br><span class="line">rt_rq[0]:/                                              // 根rt_rq，“/”</span><br><span class="line">  .rt_nr_running                 : 0</span><br><span class="line">  .rt_throttled                  : 0</span><br><span class="line">  .rt_time                       : 0.000000</span><br><span class="line">  .rt_runtime                    : 800.000000</span><br><span class="line"></span><br><span class="line">dl_rq[0]:                                               // dl_rq</span><br><span class="line">  .dl_nr_running                 : 0</span><br><span class="line"></span><br><span class="line">runnable tasks:                                         // 并不是rq中现在的runnable进程，而是逐个遍历进程，看看哪个进程最后是在当前cpu上运行。很多进程现在是睡眠状态；</span><br><span class="line">                                                        // 上述的rq-&gt;nr_running=1，只有一个进程处于runnable状态。但是打印出了几十条睡眠状态的进程；</span><br><span class="line">                                                        </span><br><span class="line">                                                        // 第一列&quot;R&quot;，说明是当前运行的进程rq-&gt;curr</span><br><span class="line">                                                        // &quot;tree-key&quot;，p-&gt;se.vruntime               // 进程的vruntime</span><br><span class="line">                                                        // &quot;wait-time&quot;，p-&gt;se.statistics.wait_sum   // 进程在整个运行队列中的时间，runnable+running时间</span><br><span class="line">                                                        // &quot;sum-exec&quot;，p-&gt;se.sum_exec_runtime       // 进程的执行累加时间,running时间</span><br><span class="line">                                                        // &quot;sum-sleep&quot;，p-&gt;se.statistics.sum_sleep_runtime  // 进程的睡眠时间</span><br><span class="line"></span><br><span class="line">            task   PID         tree-key  switches  prio     wait-time             sum-exec        sum-sleep</span><br><span class="line">----------------------------------------------------------------------------------------------------------</span><br><span class="line">            init     1 153554847.251576     11927   120     23938.628500     23714.949808 1036236697.068574 /</span><br><span class="line">        kthreadd     2 153613100.582264      7230   120      4231.780138     11601.352220 1036459940.732829 /</span><br><span class="line">     ksoftirqd/0     3 153687920.598799   2123535   120   2612543.672044    485896.233949 1033641057.952048 /</span><br><span class="line">    kworker/0:0H     5       867.040456         6   100         1.690538         2.306692     13011.504340 /</span><br><span class="line">     rcu_preempt     7 153687932.055261  38012901   120  19389366.435276   4762068.709434 1012596083.722693 /</span><br><span class="line">       rcu_sched     8 153687932.006723   9084101   120   9536442.439335    832973.285818 1026372474.208896 /</span><br><span class="line">          rcu_bh     9        44.056109         2   120         3.062001         0.071692         0.000000 /</span><br><span class="line">     migration/0    10         0.000000    810915     0         0.157999   1405490.418215         0.000000 /</span><br><span class="line">       writeback    41  75740016.734657        11   100         6.979694        22.657923 515725974.508217 /</span><br><span class="line">        cfg80211    68 145389776.829002        16   100        19.614385        22.409536 981346170.111828 /</span><br><span class="line">     pmic_thread    69        -4.853692        59     1         0.000000       416.570075     90503.424677 /</span><br><span class="line">   cfinteractive    70         0.000000   6128239     0         0.000000    835706.912900         0.000000 /</span><br><span class="line">     ion_history    74 153687775.391059   1077475   120    598925.096753    155563.560671 1035979729.028569 /</span><br><span class="line">          vmstat    88 153613102.428420       581   100       628.318084       213.543232 1036470246.848623 /</span><br><span class="line">          bioset   124       413.230915         2   100         0.000000         0.091461         0.065000 /</span><br><span class="line"> mt_gpufreq_inpu   135         0.000000        51     0         0.000000         2.947619         0.000000 /</span><br><span class="line">   kworker/u20:2   165 153687842.212961  19921527   120   1900166.780690   3504856.564055 1031329325.876435 /</span><br><span class="line">      disp_check   168         0.000000    345697    12         0.000000    254109.286291         0.049692 /</span><br><span class="line"> disp_delay_trig   172         0.000000     25049     5         0.000000      8460.322268         0.050769 /</span><br><span class="line"> kpi_wait_4_hw_v   184  77456637.322727     15150   120     17756.340357      2238.503671 525392630.298747 /</span><br><span class="line"> teei_switch_thr   202         0.000000       150    49         0.000000      4726.615934         0.000000 /</span><br><span class="line">     hang_detect   204         0.000000     34740     0         0.000000    190287.797938         0.063154 /</span><br><span class="line">  irq/680-stk_ps   220         0.000000         6    49         0.193308         0.703539         0.000000 /</span><br><span class="line"> sub_touch_resum   224       457.923116         2   100         0.000000         0.085691         0.046539 /</span><br><span class="line"> irq/677-sub_tou   226         0.000000         2    49         0.000000         0.073847         0.000000 /</span><br><span class="line"> irq/672-fuelg_i   228         0.000000         4    49         0.000000         0.415462         0.000000 /</span><br><span class="line"> irq/845-primary   230         0.000000         2    49         0.000000         0.074847         0.000000 /</span><br><span class="line">  dm_bufio_cache   231  61370971.457226         3   100         0.000000         0.924077 410081439.629970 /</span><br><span class="line"> binder_watchdog   233 153687520.358159    529297   120    133539.189144     70472.061275 1036525567.186647 /</span><br><span class="line">    cs35l35_eint   235       624.068320         2   100         0.000000         0.091923         0.049693 /</span><br><span class="line"> ipi_cpu_dvfs_rt   240 153687569.261082   4721359   120   3352016.787765   1096346.814808 1032281259.787992 /</span><br><span class="line">        hps_main   248 153687929.657234  24442793   100  11377751.354137  44892964.862782 980455478.318003 /</span><br><span class="line">           pd_wq   251       692.938392         2   100         0.000000         0.254461         0.050000 /</span><br><span class="line">         pd_task   254         0.000000   9095537    98         0.000000   1645126.407931         0.031231 /</span><br><span class="line">  pvr_defer_free   257 151412505.141936      2089   139      1592.921777      1280.969986 1023235084.781867 /</span><br><span class="line">  pvr_device_wdg   258 153178077.742167       379   120       242.453158        56.183535 1034057592.348265 /</span><br><span class="line">             mwp   259       744.637922         3   100         0.024154         0.092615         0.100154 /</span><br><span class="line"> dsx_rebuild_wor   267       753.712295         2   100         0.018384         0.100231         0.044077 /</span><br><span class="line">          wdtk-0   273         0.000000     51867     0       223.511770     83562.991491         0.044230 /</span><br><span class="line">          wdtk-2   275         0.310307     91023     0         7.662692     10810.010102         0.037154 /</span><br><span class="line">          wdtk-3   276         0.000000     57334     0         0.082539      7904.126023         4.045230 /</span><br><span class="line">          wdtk-4   277         0.000000    163449     0         0.102538     26621.315643         4.056077 /</span><br><span class="line">          wdtk-5   278         0.000000     93033     0         0.771692     11306.508550         4.061615 /</span><br><span class="line">          wdtk-6   280         0.000000     64678     0         0.490461      7293.603126         4.060538 /</span><br><span class="line">          wdtk-7   281         0.000000     56991     0         0.545615      8033.133066         4.036615 /</span><br><span class="line">          wdtk-8   282         0.007228    161917     0         0.490693     24287.956471         4.015231 /</span><br><span class="line">          wdtk-9   283         0.000000     75886     0         0.337153      7588.440841         4.041154 /</span><br><span class="line"> test_report_wor   287       771.952673         2   100         0.000000         0.084769         0.036000 /</span><br><span class="line">    kworker/0:1H   299 153685958.573414    448410   100     58503.103145     82742.839000 1036576533.452228 /</span><br><span class="line">         ueventd   301 153656034.928627     15997   120     11669.503522     30437.800780 1036570321.312576 /</span><br><span class="line">    jbd2/sdc40-8   313 153685266.285982    396029   120    211212.571451    243355.373101 1036254798.655632 /</span><br><span class="line"> ext4-rsv-conver   314      1322.048935         2   100         0.000000         0.449385         0.156692 /</span><br><span class="line"> ext4-rsv-conver   319      1347.134123         2   100         0.000000         0.441845         0.152924 /</span><br><span class="line"> ext4-rsv-conver   334      1417.595511         2   100         1.169616         0.066769         0.151307 /</span><br><span class="line">     logd.daemon   354      9386.287600         9   118         1.011306         6.314232     31502.758998 /</span><br><span class="line">     logd.writer   357 153687530.563333   4564190   118  11079641.119214   3866510.152188 1021777212.794489 /</span><br><span class="line">      logd.klogd   367 153687933.066482  12443269   118  13962178.199616  13536643.532358 1009225310.240325 /</span><br><span class="line">     logd.auditd   368 151566168.672440       664   118       174.122396      1168.889001 1023473784.526020 /</span><br><span class="line"> logd.reader.per 25015 153687529.628782   3044070   118   5119327.722443   3596227.191390 611872098.002749 /</span><br><span class="line">         ut_tlog   351 153687782.507327   1045264   120    281668.596996    111876.661992 1036325851.851125 /</span><br><span class="line">     Secure Call   352      1429.938486         3   100         0.655616         0.292616         4.131307 /</span><br><span class="line">       Bdrv Call   353      1430.041237         3   100         1.754154         0.239693         4.057077 /</span><br><span class="line">         kauditd   359 151566168.493297       673   120       183.702927       116.953237 1023475499.246642 /</span><br><span class="line">            vold   361 153474746.984645      1171   120       606.838765       528.611148 1036003350.481839 /</span><br><span class="line">            vold   369 153656032.048396     13109   120      6961.612001      2795.667768 1036595788.335188 /</span><br><span class="line">         healthd   375 153656044.500243     81262   120    161350.025885     79773.132743 1036363134.366245 /</span><br><span class="line">    wmt_launcher   379 153687737.287803    529032   120    118096.450849    111012.409314 1036487544.290047 /</span><br><span class="line">        ccci_fsd   380     12189.138243      5591   120      1909.518922      1859.451641     30157.790568 /</span><br><span class="line">     ccci_mdinit   639 152601161.552368       235   120       286.497775        85.485541 1031001695.298508 /</span><br><span class="line">  servicemanager   386 153687009.935692    331057   120     60490.993040    225025.657411 1036428012.292706 /</span><br><span class="line">    Binder:387_1   569 153673962.710154     37011   120     16969.489097     10516.923471 1036631468.909174 /</span><br><span class="line">        DispSync   570  77463667.708510     13571   111     11461.844394      2109.549787 525386479.722018 /</span><br><span class="line">      SWWatchDog   571  77456659.518056       472   112       814.071314      1794.955533 525392376.724733 /</span><br><span class="line"> UEventThreadHWC   598 153656031.843303     12856   112      2426.674847      1981.053513 1036597333.247354 /</span><br><span class="line">     EventThread   665 153674020.380964    154583   111     24005.323746     39757.314747 1036594592.994222 /</span><br><span class="line">   POSIX timer 1   666  77463665.520152       912   112      5421.412950       235.493060 525393470.823115 /</span><br><span class="line">     EventThread   667  77463667.698380     12525   111      1056.579887      1495.701448 525396630.173625 /</span><br><span class="line"> FpsPolicyTracke   702  77463667.723313      1187   120      1198.624090        80.131910 525397668.998965 /</span><br><span class="line">        DispSync  1004  77463667.697161      7586   111       664.793393       816.670690 525394660.200500 /</span><br><span class="line">    Binder:387_4  1342 153654956.018618     36048   120     15901.789224      9803.040051 1036556753.030703 /</span><br><span class="line">    Binder:387_5  1940 153674007.822615     35607   120     16223.410715      9976.729711 1036608951.069827 /</span><br><span class="line">          mtkmal   661      3661.416310         4   120         0.000000         1.598692      5697.205091 /</span><br><span class="line">          mtkmal   663  77445022.732913       225   120       155.111313        53.880768 525390350.424944 /</span><br><span class="line">          mtkmal   669  77445023.629606       305   120        94.783850       151.207084 525390304.632178 /</span><br><span class="line">          mtkmal   671  77445022.990682       191   120       113.968152        44.631693 525390385.130178 /</span><br><span class="line">          mtkmal   678 152475995.133042       161   120        39.026462        42.700918 1030000416.276366 /</span><br><span class="line">          mtkmal   682      2778.475734         7   120         8.099923         0.318693      4309.718933 /</span><br><span class="line">          mtkmal   684      3661.244943        13   120        11.790309         2.044921      5597.420014 /</span><br><span class="line">          mtkmal   718  77445022.557837       131   120       153.523075        12.365926 525390133.711180 /</span><br><span class="line">          mtkmal   734 153687521.348390    108018   120    181961.836117    101014.633238 1036429717.927166 /</span><br><span class="line">          mtkmal  1851      6974.069888         2   120         0.512769         0.163308         0.000000 /</span><br><span class="line">   POSIX timer 4  2811 153687521.439237    108769   120     43446.351322    109359.509249 1036527221.276171 /</span><br><span class="line">    atci_service   391 153687674.710468    209757   120     47042.339325     34923.832801 1036634061.208546 /</span><br><span class="line">          flymed   394 153477230.289829      1217   120       273.883295       486.930643 1036007855.567517 /</span><br><span class="line"> mobile_log_d.wc   506 141237736.186348        89   120       289.837463       107.019845 950555096.389882 /</span><br><span class="line"> mobile_log_d.rd 25016 153687930.745569   6882189   120  14953859.136289  13240534.261943 592393177.946476 /</span><br><span class="line"> mobile_log_d.wr 25017 153678844.144937    244541   120    596458.050128    787803.568717 619164112.957003 /</span><br><span class="line">         netdiag   405 141237342.607831       112   120       460.393235       376.842928 950555221.569565 /</span><br><span class="line">       mtk_agpsd   474 153374191.634415      3403   120     12677.808115      5107.769034 1035337663.690361 /</span><br><span class="line">       mtk_agpsd   841 153687840.736730   2147544   120    473399.968559    667501.048409 1035571519.822825 /</span><br><span class="line">       mtk_agpsd  1171 153687770.514828   1088984   120    263201.510383    199509.752374 1036244336.253205 /</span><br><span class="line">    mtkFlpDaemon   415      6840.625397         2   120        33.284307         3.262384     23108.778902 /</span><br><span class="line"> thermalloadalgo   413 153687898.801494    339396   120    199927.385588    403353.957413 1036113673.985265 /</span><br><span class="line">         thermal   422 153687095.661054   1044690   120   4462586.728269    889161.434459 1031361671.163426 /</span><br><span class="line">        thermald   423 153687155.456223     10504   120      2848.238660      1840.668258 1036708867.436449 /</span><br><span class="line">  batterywarning   440 153685708.507369    116056   120     35721.661430    164753.143311 1036506414.448146 /</span><br><span class="line">   POSIX timer 1   630      1585.897410         2   120        18.623538         0.225924         3.299769 /</span><br><span class="line">   POSIX timer 5   636      1589.659892         2   120        13.396539         0.161076         0.000000 /</span><br><span class="line">   POSIX timer 7   643      1604.389803         1   120        12.961769         0.105000         0.000000 /</span><br><span class="line">            mnld   644 141238163.728622        63   120        54.939462        65.431306 950553624.565953 /</span><br><span class="line">            MPED   496 141196342.567062        43   120       895.585007       158.467918 950400044.926280 /</span><br><span class="line">       wifi2agps   505 153374190.351338      2683   120      7730.432798      2788.876705 1035344823.135785 /</span><br><span class="line">     utgate_tlog   514 153687737.255265   1045413   120    281761.049313    113900.496416 1036319696.719148 /</span><br><span class="line">      AudioOut_D   811  77423572.027703      6631   102      6416.165867      5234.485977 525319030.522598 /</span><br><span class="line">  watchDogThread   818 153687899.963725   1059915   120    210673.948928    257611.952139 1036244853.299636 /</span><br><span class="line">    Binder:547_2  4943   6503838.926647       369   120        38.477388       127.843998    980298.123104 /</span><br><span class="line">        installd   549 141220149.178842     17422   120     13418.647450     33493.160461 950409754.346123 /</span><br><span class="line">    Binder:556_2   556 142104903.101144      1316   120       920.215623      2613.435619 957625545.508583 /</span><br><span class="line">            netd  1317 153656032.057473     12911   120      6132.675035      2951.387186 1036578597.684687 /</span><br><span class="line">            netd  1318 153374190.925194      4134   120     11135.394577      4135.800240 1035324323.853964 /</span><br><span class="line">            netd  1319      5431.697961         1   120         0.000000         0.087692         0.000000 /</span><br><span class="line">            netd  1320      5436.799650         1   120         0.000000         0.101692         0.000000 /</span><br><span class="line">            netd  1321      5441.983800         3   120         0.000000         0.184153         0.053539 /</span><br><span class="line">            netd  1323 152478198.472391       105   120        31.755690        93.771539 1030009624.229153 /</span><br><span class="line">            netd  1324      5991.620423         3   120         0.059615         0.512231      2836.775392 /</span><br><span class="line">    Binder:556_1  1326 142104887.497373       218   120       166.588700        60.492451 957614183.463558 /</span><br><span class="line">    Binder:556_3  1477 142104887.497066       193   120       119.942772        40.034222 957608875.916163 /</span><br><span class="line">    Binder:556_4  1479 142104887.518912       188   120       116.159925        43.184541 957608840.780691 /</span><br><span class="line">    Binder:556_5  1481 142104887.516605       193   120       106.840998        47.108921 957608809.474699 /</span><br><span class="line">    Binder:556_6  1492 142104887.495758       175   120       139.239848        41.452539 957608640.656693 /</span><br><span class="line">    Binder:556_7  1553 142104887.496527       171   120       146.211150        62.160151 957607996.415620 /</span><br><span class="line">    Binder:556_8  2094 142104887.520373       133   120       122.075769        36.036701 957601618.554284 /</span><br><span class="line">    Binder:556_9  7057 142104887.517527        57   120        66.348611        13.755926 435000933.554842 /</span><br><span class="line">    Binder:556_A 17406 142104887.514989        14   120        34.960308         4.101462  87600285.819691 /</span><br><span class="line">  mpower_manager   559 153687897.737416   2058840   120    650550.766640    301419.435846 1035763439.272171 /</span><br><span class="line">       perfprofd   562 152351479.437254       163   120        92.279305       176.774769 1029052135.266795 /</span><br><span class="line">   pvr_workqueue   588  26362955.609802         8   100         8.554077         3.945845 135759507.652276 /</span><br><span class="line">   pvr_workqueue   590  26362511.370661         5   100         9.110616         0.915768 135759481.943198 /</span><br><span class="line">  ksdioirqd/mmc0   654         0.000000    117198    98         6.680308     32557.476254         0.000000 /</span><br><span class="line">  md1_tx1_worker   705 153444892.135341       287   100       297.604536        76.314079 1035848754.686920 /</span><br><span class="line">  md1_rx1_worker   721 153583222.762631       106   100       244.276380        18.966851 1036352476.341197 /</span><br><span class="line">       debuggerd   791         0.630538      3574    71        32.939997      7428.480093         0.000000 /</span><br><span class="line">     debuggerd64   792         0.000000      3688    71         3.024383      6583.963700         0.000000 /</span><br><span class="line">   mdl_sock_host   829 141249041.826680        30   120        72.073771        22.491925 950555026.052644 /</span><br><span class="line">     gsm0710muxd   801 153687214.560068    218292   120     75692.773063    184409.357043 1036450373.720321 /</span><br><span class="line">     gsm0710muxd   876 153687527.227620    890806   120   5312280.396414   1466623.069152 1029932424.739024 /</span><br><span class="line">     gsm0710muxd   877 153687522.851544    394180   120    743239.234510    570686.925671 1035397099.085414 /</span><br><span class="line">     gsm0710muxd   880 153687523.645931    156234   120    487674.432388    283788.535172 1035939540.574625 /</span><br><span class="line">     gsm0710muxd   881 139142375.948393        20   120         2.802540        18.009922 936696798.663608 /</span><br><span class="line">     gsm0710muxd   882 153685959.385982    156328   120    170389.685231    301043.854569 1036232458.732792 /</span><br><span class="line">     gsm0710muxd   889     10768.359351         9   120         0.483231         2.677231     27507.196680 /</span><br><span class="line">   mdl_sock_host   838 141249047.147373        30   120        28.144001        20.794536 950554967.232957 /</span><br><span class="line">         viarild   840      2063.699187         2   120         6.901615         0.164154         0.000000 /</span><br><span class="line">         viarild   871 153687310.944561    213639   120     62270.218233     83803.863806 1036564286.141243 /</span><br><span class="line">         viarild   872 153687737.756496    217191   120     63014.313662    146525.224954 1036502324.133367 /</span><br><span class="line">         mtkrild   929 153687520.333774    347988   120    132221.700444     26801.640361 1036551734.599106 /</span><br><span class="line">         mtkrild   931 153687520.331621    348108   120    133117.404515     26691.766296 1036550947.317260 /</span><br><span class="line">         mtkrild   933 153687520.402929    479465   120    331792.023591    345246.430652 1036033729.862808 /</span><br><span class="line">         mtkrild   934 153687520.331775    348069   120    132799.233182     26599.578068 1036551355.411042 /</span><br><span class="line">         mtkrild   935 153687520.341929    348078   120    133441.763279     26741.501223 1036550570.000391 /</span><br><span class="line">         mtkrild   936 153687520.332313    348046   120    133788.852808     26777.614211 1036550184.801253 /</span><br><span class="line">         mtkrild   937 153687520.331775    348043   120    133228.990770     26875.716348 1036550649.353324 /</span><br><span class="line">         mtkrild   938 153687520.332467    348038   120    133501.124365     26662.167095 1036550589.456369 /</span><br><span class="line">         mtkrild   939 153687520.331929    348061   120    132156.945460     26586.273902 1036552009.306371 /</span><br><span class="line">         mtkrild   940 153687520.334005    348030   120    133021.017114     26700.422558 1036551031.429836 /</span><br><span class="line">         mtkrild   941 153687520.332621    348269   120    133436.975066     26864.353104 1036550451.167977 /</span><br><span class="line">         mtkrild   942 153687520.333005    348100   120    133154.415619     26837.357255 1036550760.611566 /</span><br><span class="line">         mtkrild   943 153687520.353082    348038   120    133009.144451     26694.200364 1036551050.495802 /</span><br><span class="line">         mtkrild   944 153687520.337852    348071   120    132950.072433     26756.505593 1036551044.787110 /</span><br><span class="line">         mtkrild   945 153687520.333544    348083   120    133514.303721     26838.344276 1036550399.324903 /</span><br><span class="line">         mtkrild   946 153687520.332620    348052   120    133207.367309     26844.250568 1036550699.317478 /</span><br><span class="line">         mtkrild   947 153687520.330698    348113   120    133400.468989     26808.496775 1036550541.446747 /</span><br><span class="line">         mtkrild   949 153687520.332928    348052   120    133417.180604     26858.239306 1036550472.776347 /</span><br><span class="line">         mtkrild   950 153687520.333160    348027   120    133224.433808     26717.650995 1036550805.224187 /</span><br><span class="line">         mtkrild   951 153687522.374083   2754901   120   2550376.949017    658618.042882 1033501808.790758 /</span><br><span class="line">         mtkrild   953     10785.121762        42   120         7.201923        29.732541     27506.773143 /</span><br><span class="line">         mtkrild   956  77445024.512068       302   120       196.371228       212.220923 525387908.394873 /</span><br><span class="line">         mtkrild   958 139142451.059438        27   120         5.617921        11.390847 936696615.508380 /</span><br><span class="line">         mtkrild   959 153685958.452443    231013   120     90066.001122    145704.528784 1036467955.730875 /</span><br><span class="line">         mtkrild   969     10768.257768        19   120         6.373771         4.768849     27341.750907 /</span><br><span class="line">         mtkrild  1086  77445022.840913       125   120       131.736455        40.676161 525386206.945787 /</span><br><span class="line">        rilproxy  1023      2549.934229         1   120         0.030077         0.166616         0.000000 /</span><br><span class="line"> Ril Proxy reque  1047 153687520.769313    106931   120     17870.276454     52232.745454 1036639095.001220 /</span><br><span class="line"> Ril Proxy reque  1049  77445023.025067       259   120        97.129004        76.282690 525386587.347481 /</span><br><span class="line">        rilproxy  1052 139142374.598801       255   120        75.081840        23.904236 936694971.100527 /</span><br><span class="line">   disp_queue_P0  1067         0.000000      7509     5         0.000000      6663.293293         0.065308 /</span><br><span class="line"> ReferenceQueueD  1081 153682594.530032    211902   120     64560.326125     55233.173286 1036568501.426237 /</span><br><span class="line"> FinalizerDaemon  1082 153682594.765725    170186   120     26702.126008     38259.289937 1036623415.578785 /</span><br><span class="line"> FinalizerWatchd  1083 153687276.748512    102967   120     38357.037158     15650.622791 1036653865.675069 /</span><br><span class="line">  HeapTaskDaemon  1084 153683632.246834    136781   120    126921.006335    456707.330349 1036109382.086557 /</span><br><span class="line">   Binder:1074_1  1088 153682111.709561    122841   120     78872.844413    146079.569769 1036461599.469990 /</span><br><span class="line">   Binder:1074_2  1089 153686856.027901    122796   120     80204.474188    145200.814182 1036480185.545158 /</span><br><span class="line">   Binder:1074_3  1097 153685009.264302    122627   120     76696.735939    146568.223790 1036474099.052120 /</span><br><span class="line"> MessageMonitorS  1100      2830.202676         5   120         0.318616         2.436076         0.560385 /</span><br><span class="line"> ActivityManager  1103 153676383.299721    239709   120    263545.893262    584063.260455 1035815536.534049 /</span><br><span class="line"> batterystats-sy  1108 153656039.928935     14942   120     12781.432829     32676.181237 1036551257.560695 /</span><br><span class="line">    FileObserver  1121 151366817.419279       825   120        65.442466       297.350079 1023092619.021270 /</span><br><span class="line">      android.fg  1123 153683533.983685    297083   120    105632.072176     98216.273033 1036487470.663107 /</span><br><span class="line"> AnrMonitorThrea  1130 153675160.550742     49419   120     52845.788084     11755.937488 1036592795.293345 /</span><br><span class="line">   system_server  1139 153686066.363307     91600   118     57301.637256    299581.131167 1036344126.422679 /</span><br><span class="line">  PackageManager  1151   2123074.948987      4759   130      1240.195620      2312.241251 415972413.085622 /bg_non_interactive</span><br><span class="line">   system_server  1328 153687842.490267  10515299   120   1661287.673016   4523982.148734 1030514093.832906 /</span><br><span class="line"> SensorEventAckR  1329  77380587.602801        25   112        81.965156         3.918613 525299961.227505 /</span><br><span class="line">   SensorService  1330 124660459.026176     11820   112       821.968447      3822.534369 842018700.920537 /</span><br><span class="line"> CameraService_p  1331      5562.977288         2   116         0.000000         1.979615         0.270770 /</span><br><span class="line">    AlarmManager  1333 153673687.683329    323475   120    440593.614441    313146.408706 1035888638.673051 /</span><br><span class="line"> InputDispatcher  1338 153683532.159714     65434   120      2443.774990      9054.607951 1036669512.885258 /</span><br><span class="line">     InputReader  1339 153683532.081450     69434   112       730.607083     18352.768368 1036661926.944220 /</span><br><span class="line"> UsageStatsManag  1352 141279253.303851        33   120       127.911920        11.011152 950737091.215010 /</span><br><span class="line"> RecordEventThre  1357 141279298.263923       305   120       248.339698       168.402070 950736943.730005 /</span><br><span class="line"> ConnectivitySer  1363      9598.972239        33   120        34.935611         9.438923     11220.329723 /</span><br><span class="line">          ranker  1372   4565371.160528       384   130      1349.076921       417.196927 950546588.719088 /bg_non_interactive</span><br><span class="line">        Thread-2  1380 153687523.448852    180049   120    398656.719490    360551.032935 1035936896.261191 /</span><br><span class="line">  UEventObserver  1382 153656032.077319     12889   120      4584.844190      2768.674498 1036577008.248908 /</span><br><span class="line"> LazyTaskWriterT  1399  77424893.172705       581   120       411.879232      3258.867779 525315760.112617 /</span><br><span class="line">        Thread-6  1407  62235633.721656        18   120       433.368077         7.805001 416049482.146046 /</span><br><span class="line">     WifiMonitor  1554 153685586.307786     58189   120     79983.829818     49360.832359 1036555234.885332 /</span><br><span class="line">   Binder:1074_4  1559 153687007.436001    123117   120     80382.236938    146363.086260 1036463979.975185 /</span><br><span class="line">   Binder:1074_5  1581 153685232.851598    122911   120     78403.314388    146576.526616 1036457766.535833 /</span><br><span class="line">        watchdog  1586 153683534.136868    190448   120    379190.269123    130147.942387 1036166833.749468 /</span><br><span class="line">   Binder:1074_6  1702 153684512.972293    121830   120     77062.555248    144379.772867 1036456834.918037 /</span><br><span class="line">   Binder:1074_7  1703 153685926.719162    122133   120     76991.508773    145227.034814 1036462079.016466 /</span><br><span class="line">   Binder:1074_8  1732 153685708.983522    122911   120     79298.708026    148578.064620 1036455350.025026 /</span><br><span class="line">   Binder:1074_9  1733 153683590.358220    122429   120     79839.075065    144017.716199 1036451351.341669 /</span><br><span class="line">   Binder:1074_A  1796 153683159.783045    123352   120     79372.426161    146617.312842 1036447028.127665 /</span><br><span class="line">   Binder:1074_B  1797 153684298.982037    122080   120     78931.959383    146000.895846 1036452104.223656 /</span><br><span class="line">   Binder:1074_C  2206 153686642.452142    120747   120     77223.220336    143600.665373 1036458341.297521 /</span><br><span class="line">   Binder:1074_D  2209 153682945.087426    121870   120     78295.881347    145648.265225 1036440169.904481 /</span><br><span class="line">   Binder:1074_E  2210 153687277.794050    121664   120     78439.285423    146604.981940 1036457122.950540 /</span><br><span class="line">   Binder:1074_F  2239 153684725.913929    121982   120     78355.280914    146470.241330 1036446240.651269 /</span><br><span class="line">  Binder:1074_10  2254 153686185.336303    121722   120     77501.592685    145260.973289 1036454263.745288 /</span><br><span class="line">  Binder:1074_11  2260 153681898.513704    121216   120     77819.367663    144912.080759 1036437254.447294 /</span><br><span class="line">  Binder:1074_12  2261 153685491.839055    121449   120     77906.308399    145427.732519 1036450679.182231 /</span><br><span class="line">  Binder:1074_13  2296 153682326.508649    122286   120     76514.209123    148391.056751 1036436897.203377 /</span><br><span class="line">  Binder:1074_14  2341 153687738.552957    121444   120     76185.676242    145166.095491 1036462300.297987 /</span><br><span class="line">  Binder:1074_15  2343 153687009.028000    120720   120     76485.907350    144045.950438 1036459886.356113 /</span><br><span class="line">  Binder:1074_16  2347 153687073.499568    121852   120     78299.015578    145664.956027 1036456682.439460 /</span><br><span class="line">  Binder:1074_17  2392 153687013.070538    121885   120     77183.446301    146149.328531 1036456944.487662 /</span><br><span class="line">  Binder:1074_18  6053 153682740.943569    118188   120     75940.600043    145263.284358 1036012198.311994 /</span><br><span class="line">  Binder:1074_19  6750 153687487.328692    116103   120     74612.769704    142644.254578 1031536447.077220 /</span><br><span class="line">  Binder:1074_1A 12662 153687007.525154    112196   120     73592.882672    137882.356743 982356495.324826 /</span><br><span class="line">  Binder:1074_1B 25851 153683370.953239     98198   120     63092.674811    120013.296472 870685204.714987 /</span><br><span class="line"> pool-2-thread-1 16027  52771351.371422        30   120        18.764846        15.623616         2.682615 /</span><br><span class="line">  Binder:1074_1C 27751 153683985.135331     65807   120     41683.217693     79776.753019 599143784.201869 /</span><br><span class="line">  Binder:1074_1D 13727 153686430.731973     47989   120     28144.572272     57754.509396 458075585.275814 /</span><br><span class="line">        Timer-27 26862 141218617.463102         1   120         0.263385         0.378461         0.000000 /</span><br><span class="line">  Binder:1074_1E 32757 153687011.000538      3742   120      2301.935495      4479.763321  35565800.170536 /</span><br><span class="line"> ndroid.systemui  1400 153674029.391078    802567   120   1490238.530816   4628618.280948 1030523400.937512 /</span><br><span class="line"> ReferenceQueueD  1436 153673937.126769     73659   120     37821.546018     17272.829365 1036584356.285985 /</span><br><span class="line"> FinalizerDaemon  1437 153673937.308999     73822   120     24221.339337     25821.406277 1036589594.767052 /</span><br><span class="line"> FinalizerWatchd  1438 153673936.982538     40858   120     15566.602241      8121.405435 1036615685.213122 /</span><br><span class="line">  HeapTaskDaemon  1439 153675166.817896     63267   120     43267.817027    111550.189765 1036489383.497280 /</span><br><span class="line">   Binder:1400_1  1447 153673962.942145     49230   120      9503.669122     34213.524599 1036595802.393532 /</span><br><span class="line">   Binder:1400_2  1452 153673939.918923     49655   120      9071.358508     34090.882542 1036596185.833424 /</span><br><span class="line">    RenderThread  1556 153674007.365555     64195   112     27370.470148     14443.562957 1036596480.179177 /</span><br><span class="line">        MyThread  2885 141248504.920054        38   120         3.848845         4.981075 950520975.351108 /</span><br><span class="line">   Binder:1400_4  4923 153673936.151570     50097   120      9323.427787     34303.515061 1036536054.355796 /</span><br><span class="line">   Binder:1400_5  5927 153673933.881075     49374   120      8240.784896     34283.732470 1036165417.973325 /</span><br><span class="line">          sdcard  1408 153686217.961120    104883   120     21650.043972     17745.547089 1036649863.504007 /</span><br><span class="line">     main_thread  1494 153687901.920217   1284074   110    289499.966978    331088.372259 1036074898.881126 /</span><br><span class="line">       rx_thread  1496 153373839.784383      7013   110       930.462637      1284.975880 1035329748.058253 /</span><br><span class="line">  wpa_supplicant  1514 153687072.408030    208118   120    186723.731824    205163.663067 1036299761.764675 /</span><br><span class="line">  HeapTaskDaemon  1541 151566333.012431       114   120       129.560234       157.358381 1023451645.526521 /</span><br><span class="line"> m.android.phone  1671 153456065.341099     64738   120    195994.153122    325378.857233 1035397260.336678 /</span><br><span class="line"> Jit thread pool  1679  77423413.821127        73   129        53.345773       209.406305 525308578.502602 /</span><br><span class="line"> FinalizerWatchd  1685 153463169.693062      6682   120      2438.317711       957.194008 1035934990.536875 /</span><br><span class="line">  HeapTaskDaemon  1688 153457991.293170      6942   120      6695.183963     13460.020589 1035903235.530626 /</span><br><span class="line">   Binder:1671_1  1691 153659557.463568     10613   120      3858.494484      6653.202366 1036580667.771911 /</span><br><span class="line">   Binder:1671_2  1694 153607348.422901     10664   120      3205.023918      6702.303852 1036400964.310939 /</span><br><span class="line">      RILSender0  1861 153329911.871220      2121   120      1607.180561       865.875215 1035083991.782486 /</span><br><span class="line">    RILReceiver0  1865 153321181.240054      2839   120      1860.458266      1432.889846 1035023160.965003 /</span><br><span class="line">      RILSender1  1868  77476210.646389       164   120       200.306774        39.500845 525431599.693432 /</span><br><span class="line">    RILReceiver1  1873  77457270.897605       292   120        64.582928        81.521462 525371714.312672 /</span><br><span class="line"> GsmCellBroadcas  1945      8962.110350         7   120         0.817309         1.174846      3043.696699 /</span><br><span class="line"> CdmaServiceCate  1987      9429.867167        10   120         2.032384         2.115232      3005.261160 /</span><br><span class="line"> GsmCellBroadcas  1988      9432.047638        12   120         3.924230         1.928154      3014.447700 /</span><br><span class="line">   Binder:1671_4  1993 153552758.731165     10401   120      3323.964976      6607.310729 1036218459.324407 /</span><br><span class="line">   Binder:1671_5  2024 153589050.115160     10324   120      3529.102910      6600.056412 1036338014.995942 /</span><br><span class="line">   Binder:1671_6  2026 153641306.051963     10528   120      3122.379892      6619.962136 1036518666.920672 /</span><br><span class="line">   Binder:1671_7  2617 153570598.690730     10588   120      3468.699128      6753.670053 1036270365.111438 /</span><br><span class="line">   Binder:1671_8  7549 153677965.304393      4408   120      1162.151387      2956.835001 511350611.110490 /</span><br><span class="line"> FinalizerWatchd  1698 151576580.353577        42   120         7.126770         5.592614 1023465080.110165 /</span><br><span class="line">  HeapTaskDaemon  1699 151566333.654969        42   120        19.806463        38.214304 1023450037.195515 /</span><br><span class="line"> FinalizerWatchd  1714 151576580.329116        36   120         4.931231         5.621228 1023465095.884322 /</span><br><span class="line">  HeapTaskDaemon  1715 151566332.464584        31   120         5.117924        11.575690 1023450047.112130 /</span><br><span class="line"> FinalizerWatchd  1728 153376151.014309      1621   120       486.819523       243.113634 1035346365.269257 /</span><br><span class="line"> FinalizerWatchd  1790 151576580.539038       229   120        56.336471        30.870218 1023464770.365013 /</span><br><span class="line">  HeapTaskDaemon  1791 151566333.973816       186   120        78.831768       162.237079 1023449615.313051 /</span><br><span class="line"> RxIoScheduler-1  1832 153676477.864536     17754   120      4113.629535      8966.233206 1036632495.957774 /</span><br><span class="line"> RxScheduledExec  1835 153687675.010237     17865   120      4751.072474      9183.679586 1036677067.938482 /</span><br><span class="line"> RxScheduledExec  1838 153687674.928391     15844   120      5789.074048      4375.085370 1036680839.553045 /</span><br><span class="line"> RxNewThreadSche 31106  69087254.271291         5   120        17.820460         8.964001         7.879308 /</span><br><span class="line">   disp_queue_E3  1990         0.000000        86     5         0.000000       376.258772         0.085077 /</span><br><span class="line"> FinalizerDaemon  2072 153674034.688385     51524   120      9512.676458     14715.380138 1036607876.510080 /</span><br><span class="line"> FinalizerWatchd  2073 153679286.754743     43941   120     12494.389720      7128.944986 1036632366.528259 /</span><br><span class="line">  HeapTaskDaemon  2074 153675302.360345     57451   120    149522.657893    139337.098866 1036348083.156224 /</span><br><span class="line">   Binder:2062_1  2075 153673973.768306     11285   120      3139.434684      9548.625798 1036619240.539446 /</span><br><span class="line">   Binder:2062_2  2076 153654957.116080     11190   120      2993.360505      9517.939179 1036559336.023332 /</span><br><span class="line"> RxCachedWorkerP  2149 153678943.910673     17873   120      3839.018438     10731.506063 1036632895.123627 /</span><br><span class="line"> RxComputationTh  2164 153672609.883688     16840   120      4270.907654     13509.856036 1036606176.066075 /</span><br><span class="line"> RxComputationTh  2165 153672609.716765     16410   120      3629.842658     11332.828742 1036609039.139982 /</span><br><span class="line"> nisdk-scheduler  2281 153546949.324479      1805   120       318.169318      1174.158093 1036201387.906121 /</span><br><span class="line">  nisdk-report-1  6142  62424951.596934        22   120        36.502229        56.420464 415801174.001914 /</span><br><span class="line"> Jit thread pool  2085  62378341.351194        10   129        33.833536        27.625772 416103721.586098 /</span><br><span class="line"> FinalizerWatchd  2097 151576580.456347        67   120       111.016693         9.214770 1023460096.280458 /</span><br><span class="line">  HeapTaskDaemon  2098 151566322.173200        68   120        42.300923        23.884536 1023445159.309658 /</span><br><span class="line">         ged_srv  2083  77423135.704185       187   120        44.149235       110.398853 525303294.270431 /</span><br><span class="line"> GpuAppSpectator  2104 153687738.459726   2160184   120    755577.199069   1512779.840696 1034419258.894172 /</span><br><span class="line">           perfd  2084 153687840.601372    211760   119     53153.054786     49705.241204 1036585108.675781 /</span><br><span class="line"> FinalizerWatchd  2126 152546329.433530       188   120        70.506622        26.516007 1030532222.706690 /</span><br><span class="line">  HeapTaskDaemon  2127 152544607.401489       143   120       474.503920       100.198778 1030516752.539432 /</span><br><span class="line">    FileObserver  2409  62201600.153920         7   120        54.950925         1.227537 415941577.149096 /</span><br><span class="line"> UsageStatsManag  2411   6268494.336682        19   120        78.708385         3.489001    480079.140913 /</span><br><span class="line"> RecordEventThre  2420   6268507.562295        22   120        47.589308        15.183999    480079.662145 /</span><br><span class="line"> ReferenceQueueD  2160 151450933.763303        56   120        39.550846         5.384996 1023437149.642796 /</span><br><span class="line"> FinalizerWatchd  2162 151576580.451653        40   120         4.036462         3.982302 1023457129.538612 /</span><br><span class="line">  HeapTaskDaemon  2166 151566332.706585        33   120        13.801077        11.243384 1023442096.833804 /</span><br><span class="line"> FinalizerWatchd  2189 151576580.605347        37   120        14.746846         5.262695 1023456934.182605 /</span><br><span class="line">  HeapTaskDaemon  2190 151566332.461354        30   120        11.163617        10.963231 1023441931.182722 /</span><br><span class="line">   Binder:2177_2  2193 139200814.188103        26   120        12.388310         8.698081 937031713.330632 /</span><br><span class="line">  HeapTaskDaemon  2205 151566332.390354        30   120         8.136229         9.787697 1023441912.484260 /</span><br><span class="line">   Binder:2194_2  2208 139200813.697488        28   120        19.682154         8.721074 937031680.843718 /</span><br><span class="line"> FinalizerWatchd  2221 151576580.519807        38   120        11.323151         4.252845 1023456929.196456 /</span><br><span class="line">  HeapTaskDaemon  2222 151566332.450508        31   120         3.717387        10.947227 1023441845.396880 /</span><br><span class="line">   Binder:2211_2  2227 139200813.629103        24   120        15.103385         8.661615 937031627.576252 /</span><br><span class="line"> ReferenceQueueD  2233 151442919.732524       188   120        79.365155        29.001766 1023436721.333256 /</span><br><span class="line"> FinalizerDaemon  2234 151442919.780140       228   120       108.763538       154.227619 1023436562.439018 /</span><br><span class="line"> FinalizerWatchd  2235 151442919.587756       116   120        51.441159        17.624764 1023436756.013866 /</span><br><span class="line">  HeapTaskDaemon  2236 151566323.557892       117   120        27.663614       131.189233 1023441579.164415 /</span><br><span class="line">   Binder:2224_2  2238 148354476.558177       310   120       207.696612       271.060709 1002071329.768687 /</span><br><span class="line">       broadcast  2332  77699955.616123       460   120      1187.023147       227.887298 527342963.096088 /</span><br><span class="line"> SystemStateMach  2439  77699954.307046       134   120        80.804307        66.102156 527343633.204301 /</span><br><span class="line">   Binder:2224_6  4524 147011030.987069       335   120       329.767461       445.461836 993695051.215202 /</span><br><span class="line">   thread-pool-3  4750   2715120.454983        37   130       137.140383        22.439542 525149496.160915 /bg_non_interactive</span><br><span class="line"> FinalizerWatchd  2250 151576580.618577        37   120         6.792383         4.873234 1023456804.009681 /</span><br><span class="line">  HeapTaskDaemon  2251 151566332.856969        28   120         3.593539        14.216156 1023441797.217721 /</span><br><span class="line"> zu.monitorphone  2255 153374507.053347     23313   120     30658.942099     74396.118788 1035219141.535851 /</span><br><span class="line"> Jit thread pool  2263  60121326.754303        53   129       185.753537        50.066694 400269352.323963 /</span><br><span class="line"> FinalizerWatchd  2269 153376165.871944      1668   120       490.878603       294.966324 1035338231.130007 /</span><br><span class="line">  HeapTaskDaemon  2270 153374487.329086      1615   120      1288.813696       943.774773 1035321780.758123 /</span><br><span class="line">            JDWP  2316    165621.976191        12   120         6.464693         2.573615      5709.260706 /bg_non_interactive</span><br><span class="line">  HeapTaskDaemon  2323   4929615.720344      4105   120     12540.049633      2464.617233 1035899780.482442 /bg_non_interactive</span><br><span class="line">   Binder:2306_2  2325 153455937.357636       572   120       499.884461       356.031295 1035908849.044926 /</span><br><span class="line">   Profile Saver  2368    165627.237879        17   120         9.563385         6.197307     41999.177408 /bg_non_interactive</span><br><span class="line">   Binder:2306_3  2775 153272239.142669       511   120       454.633548       345.553139 1034803416.102666 /</span><br><span class="line">   Binder:2306_4  3580 153214247.576015       567   120       426.434140       372.572249 1034350337.741113 /</span><br><span class="line">   Binder:2306_6  3583 153386539.590118       508   120       434.018464       328.658239 1035427640.735906 /</span><br><span class="line">   Binder:2306_8  4082 153398802.779254       446   120       518.737922       336.860931 1035443926.459100 /</span><br><span class="line"> Jit thread pool  2376 129117639.281574        46   129       306.059766        88.577768 873723055.073558 /</span><br><span class="line">  HeapTaskDaemon  2383 153457988.740632      4632   120      2572.219385      4838.282863 1035907172.107135 /</span><br><span class="line">    PowerService  2494 153455935.916095      3642   112      1243.145921      1767.676394 1035905845.788520 /</span><br><span class="line"> PowerBroadcastC  2498 153455937.470790      4387   120      4546.316927      2240.978539 1035902049.731286 /</span><br><span class="line"> AppManagerThrea  2521  77700159.379244       957   120       788.123930      1250.029387 527341924.509988 /</span><br><span class="line">   Binder:2370_3  2634 153398802.626477      1031   120      1196.700778       754.020696 1035464986.272766 /</span><br><span class="line"> DataBuryManager  2755 153457811.822403      4486   120      4388.477662      3318.852159 1035904451.511173 /</span><br><span class="line"> CalculateHandle  2756 153455936.573637      5196   120      4485.102201     10217.561808 1035892449.315728 /</span><br><span class="line">   Binder:2370_4  4601 153455937.164021      1024   120      1082.080305       746.937702 1035875274.488751 /</span><br><span class="line">   Binder:2370_5 17183 153373172.295877       589   120       642.641694       431.542241 684317939.848991 /</span><br><span class="line"> Jit thread pool  2393 135184516.056864       180   129       450.197538       250.721163 912965606.827107 /</span><br><span class="line">   Binder:2386_1  2400 152941683.503012      1048   120       305.336614       458.842168 1033516019.755495 /</span><br><span class="line"> launcher-loader  2464 147640609.291375      1965   120       480.978096      1410.193368 997499150.594798 /</span><br><span class="line">         GslbLog  2515  77423738.694114         5   120         0.281844         4.914384        65.480924 /</span><br><span class="line">            JDWP  2465   2718229.696057         6   120         5.063693         2.972921      4968.774629 /bg_non_interactive</span><br><span class="line"> FinalizerWatchd  2468   4926896.250988      1707   120      2994.854231       235.679996 1035334808.499933 /bg_non_interactive</span><br><span class="line">  HeapTaskDaemon  2469   4926837.599030      1539   120      9832.421495       502.375003 1035312707.367791 /bg_non_interactive</span><br><span class="line">   Binder:2453_1  2470 153373574.290838      2452   120      2383.459523      1602.088245 1035316282.873895 /</span><br><span class="line"> InternalService  2573   4926837.556569      4404   120     28527.467460      1607.263485 1035292487.911507 /bg_non_interactive</span><br><span class="line"> FinalizerDaemon  2483   4874469.760561        53   120        11.876234        11.116998 1023436226.733171 /bg_non_interactive</span><br><span class="line"> FinalizerWatchd  2484   4875071.360861        41   120        16.975924         5.060533 1023456228.459763 /bg_non_interactive</span><br><span class="line">  HeapTaskDaemon  2485   4874940.515605        38   120         7.086154        33.866692 1023441083.109646 /bg_non_interactive</span><br><span class="line">   Binder:2471_1  2487 139200812.526239        30   120        64.471383        10.477311 937030423.559631 /</span><br><span class="line">            JDWP  2526   4879494.229494         9   120         6.907539         3.492152      4606.546397 /bg_non_interactive</span><br><span class="line"> ReferenceQueueD  2528   4879494.229494       343   120       444.815227        83.319386 1023751969.999695 /bg_non_interactive</span><br><span class="line"> FinalizerDaemon  2529   4879494.229494      1461   120       977.744310      1377.863377 1023750155.018392 /bg_non_interactive</span><br><span class="line"> FinalizerWatchd  2531   4879494.229494       219   120       221.557460        43.858011 1023772233.182348 /bg_non_interactive</span><br><span class="line">  HeapTaskDaemon  2535   4879494.229494       900   120      2340.425708      3026.118835 1023435451.820717 /bg_non_interactive</span><br><span class="line">   Binder:2516_1  2536 152859025.446139      1625   120      1366.220917      2129.038387 1032748974.039854 /</span><br><span class="line">   Binder:2516_2  2537 153019628.312271      1596   120      1606.599778      1969.122159 1033648898.918982 /</span><br><span class="line"> ComputationThre  2624   4879494.229494        49   120        72.545233        25.741844 605101606.088220 /bg_non_interactive</span><br><span class="line">    MmsSpamUtils  2725   4879494.229494        66   120       199.600079        51.753692 950701141.719919 /bg_non_interactive</span><br><span class="line"> ComputationThre  2765   4879494.229494        20   120        61.870923        12.047308 691500801.022200 /bg_non_interactive</span><br><span class="line"> ComputationThre  2766   4879494.229494        30   120        69.029157        12.513998 777900901.637951 /bg_non_interactive</span><br><span class="line">   Binder:2516_3  4024 153592065.417199      1525   120      1130.701234      2088.736609 1036328049.366219 /</span><br><span class="line">   Binder:2516_4  4741 153389149.265276      1411   120       928.597086      2088.525466 1035410703.845248 /</span><br><span class="line">   Binder:2516_5  5465 153235556.413354      1240   120       952.652701      1814.625088 1034458839.176286 /</span><br><span class="line"> ComputationThre  5667   4879494.229494        49   120        68.687153        30.131848 864001108.437218 /bg_non_interactive</span><br><span class="line"> ComputationThre 16641   4879494.229494        47   120       126.310156        21.785538 864001088.180450 /bg_non_interactive</span><br><span class="line"> ComputationThre  6275   4879494.229494        21   120        61.856846        11.021078         1.312538 /bg_non_interactive</span><br><span class="line"> ComputationThre 16592   4879494.229494        15   120        30.146769         9.996615        13.905769 /bg_non_interactive</span><br><span class="line"> ComputationThre  6607   4879494.229494        22   120       104.020385        10.908232         2.720153 /bg_non_interactive</span><br><span class="line"> ReferenceQueueD  2565   4926818.317371      2627   120      3417.470781       304.652145 1035315913.779735 /bg_non_interactive</span><br><span class="line"> FinalizerDaemon  2566   4926818.601678      2136   120      1424.990830       546.505455 1035317669.947364 /bg_non_interactive</span><br><span class="line"> FinalizerWatchd  2567   4926905.075009      1547   120      1058.899160       276.491403 1035338246.872981 /bg_non_interactive</span><br><span class="line"> UsageStatsManag  2583     55273.961031        72   120        27.364000        26.052228     16743.314038 /bg_non_interactive</span><br><span class="line"> FinalizerWatchd  2659   4875071.371554        57   120       222.673691         8.677461 1023454596.091141 /bg_non_interactive</span><br><span class="line">  HeapTaskDaemon  2660   4874936.157603        63   120       188.704770        57.936768 1023439456.924643 /bg_non_interactive</span><br><span class="line">   Binder:2648_1  2661 139200782.447872        79   120        57.664844        33.099161 937029347.862321 /</span><br><span class="line">       EventCore  2715    173164.499246        14   120         7.286692        13.048232       562.757540 /bg_non_interactive</span><br><span class="line"> pool-2-thread-1  2717   2715515.195643        68   120       196.756694        62.666078 525189046.979238 /bg_non_interactive</span><br><span class="line">            adbd  2981 153687909.196880       354   120       286.601932       428.353245 1036678457.142419 /</span><br><span class="line">     -&gt;transport  2983 153687903.166956        75   120        35.155772        25.443308 1036679086.988433 /</span><br><span class="line">     &lt;-transport  2984 153687902.908341        47   120         7.993075        28.124463 1036679110.021974 /</span><br><span class="line"> shell srvc 5914  5915 153684076.539986         1   120        10.262769         0.316693         0.000000 /</span><br><span class="line"> FinalizerDaemon  3013   4874463.747252        69   120        76.556153        21.954766 1023431328.734781 /bg_non_interactive</span><br><span class="line"> FinalizerWatchd  3014   4875071.204631        52   120        92.466612         6.623930 1023451219.747589 /bg_non_interactive</span><br><span class="line">  HeapTaskDaemon  3015   4874940.686758        50   120       323.734614        48.424845 1023435944.795789 /bg_non_interactive</span><br><span class="line">   Binder:3004_2  3017 139200655.179608        60   120        33.663157        30.861542 937025621.225387 /</span><br><span class="line"> m.meizu.account  3235   4874493.568021       463   120      6298.587483      1214.190996 1023421449.367754 /bg_non_interactive</span><br><span class="line"> FinalizerWatchd  3245   4875071.101016        36   120        30.210387         4.336692 1023448688.910201 /bg_non_interactive</span><br><span class="line">  HeapTaskDaemon  3246   4874940.658221        36   120        91.133772        47.492309 1023433585.694240 /bg_non_interactive</span><br><span class="line"> FinalizerDaemon  3297   4874469.753792        42   120       108.651154         8.881619 1023427853.577842 /bg_non_interactive</span><br><span class="line"> FinalizerWatchd  3298   4875071.446246        36   120        15.184770         5.157227 1023447810.395511 /bg_non_interactive</span><br><span class="line">  HeapTaskDaemon  3299   4874941.003912        41   120       127.383078        37.825307 1023432665.853779 /bg_non_interactive</span><br><span class="line">   Binder:3288_2  3301 139200780.983322        32   120        17.559460        11.666309 937022193.168922 /</span><br><span class="line"> FinalizerWatchd  3699 151576580.609577        61   120       464.238694         7.161152 1023437936.517409 /</span><br><span class="line">  HeapTaskDaemon  3700 151566322.811431        54   120       159.171768        32.943850 1023423213.327216 /</span><br><span class="line"> IntentService[S  3720  77463776.013014        64   120       241.037999        28.528075 525350955.662628 /</span><br><span class="line"> FinalizerDaemon  3993   4874403.669944       128   120        86.522923        71.100691 1023415025.929199 /bg_non_interactive</span><br><span class="line"> FinalizerWatchd  3994   4875071.119015        72   120        20.989154         9.073075 1023435005.832326 /bg_non_interactive</span><br><span class="line">  HeapTaskDaemon  3995   4874940.931990       198   120      1681.085695       554.542687 1023417801.220905 /bg_non_interactive</span><br><span class="line"> UsageStats_Logg  4006   2717866.055833        83   120        53.857616        86.775307 525311519.039916 /bg_non_interactive</span><br><span class="line"> pool-1-thread-1  4011   2717369.824107        42   120        18.573846        47.764231 525277923.379144 /bg_non_interactive</span><br><span class="line"> Worker.Thread.A  4045   2717369.824107         6   139         4.305153         1.320000         9.863924 /bg_non_interactive</span><br><span class="line"> pool-10-thread-  4077   2717369.824107         3   120        11.546923         5.484539         8.515847 /bg_non_interactive</span><br><span class="line"> xy_update_pubin  4733   2717369.824107        22   130         8.302540        17.555998      2005.064928 /bg_non_interactive</span><br><span class="line">   MonitorThread  5486   4874319.506486        91   120       185.583844         3.911225 1023336899.373176 /bg_non_interactive</span><br><span class="line"> FinalizerDaemon  4191   4874470.304323        41   120         7.524078         8.646614 1023411084.924190 /bg_non_interactive</span><br><span class="line"> FinalizerWatchd  4192   4875071.109938        37   120         8.843078         4.674229 1023430928.153160 /bg_non_interactive</span><br><span class="line">  HeapTaskDaemon  4193   4874940.546759        35   120        31.777077        35.682696 1023415874.435197 /bg_non_interactive</span><br><span class="line">   Binder:4182_1  4194 139200654.974223        31   120        23.097769        12.786766 937005303.862117 /</span><br><span class="line"> izu.flyme.input  4368   4874413.890944      1848   120     11106.884570      5997.001699 1023390626.755446 /bg_non_interactive</span><br><span class="line"> FinalizerWatchd  4381   4875071.177169       101   120       116.400768        16.009385 1023427369.903230 /bg_non_interactive</span><br><span class="line">  HeapTaskDaemon  4383   4874942.181528       124   120       526.631686       111.917009 1023411856.708576 /bg_non_interactive</span><br><span class="line">   Binder:4368_1  4384 139200655.216223       135   120        43.088457        61.384469 937002006.730256 /</span><br><span class="line"> RecordEventThre  9831   4763572.323871        68   120       147.170854        35.100995 968031669.072467 /bg_non_interactive</span><br><span class="line"> mecommunication  4486   4874824.917215       834   120      8407.227405      2529.794082 1023396259.220537 /bg_non_interactive</span><br><span class="line"> FinalizerWatchd  4500   4875071.363477       103   120        71.722766        17.089162 1023425569.173064 /bg_non_interactive</span><br><span class="line">  HeapTaskDaemon  4502   4874939.004679        93   120       373.878386       165.223309 1023410103.036569 /bg_non_interactive</span><br><span class="line">   Binder:4486_1  4503 151442910.903269        75   120        40.915386        32.767545 1023405240.779553 /</span><br><span class="line">   Binder:4486_2  4504 151558719.429287        67   120        17.583153        28.219616 1023407087.343563 /</span><br><span class="line"> FinalizerDaemon  4516   4874471.660791        59   120         4.393537        14.496154 1023405833.895948 /bg_non_interactive</span><br><span class="line"> FinalizerWatchd  4517   4875071.084169        47   120        37.573462         6.350847 1023425694.079377 /bg_non_interactive</span><br><span class="line">  HeapTaskDaemon  4518   4874943.648913        49   120        10.575691        62.207307 1023410647.703651 /bg_non_interactive</span><br><span class="line">   Binder:4507_3  5469 125822732.500103        20   120         9.547999        11.114385 850479948.852447 /</span><br><span class="line"> Jit thread pool  4562   4932487.687306        58   129       272.066846       122.068154 1023038020.410839 /bg_non_interactive</span><br><span class="line"> ReferenceQueueD  4565   4932487.687306        39   120       389.864691        17.409464 997474450.844815 /bg_non_interactive</span><br><span class="line"> FinalizerDaemon  4566   4932487.687306       171   120       136.802156       607.694072 997474112.467049 /bg_non_interactive</span><br><span class="line"> FinalizerWatchd  4567   4932487.687306        45   120        26.990538         8.104925 997474820.224047 /bg_non_interactive</span><br><span class="line">  HeapTaskDaemon  4568   4932487.687306       197   120       321.725461      1536.712006 979840373.683157 /bg_non_interactive</span><br><span class="line">   Binder:4556_2  4570   4932487.687306     12588   120      3170.012024      9894.166677 1036462901.908176 /bg_non_interactive</span><br><span class="line"> pool-2-thread-1  4581   4932487.687306        63   120        16.174769        33.924854     60121.161290 /bg_non_interactive</span><br><span class="line"> pool-3-thread-1  4585   4932487.687306      1002   120      3354.127324       400.006363 1033834562.641973 /bg_non_interactive</span><br><span class="line">   Binder:4556_3 30310   4932487.687306       449   120        54.693382       345.959694  56698532.472949 /bg_non_interactive</span><br><span class="line"> FinalizerDaemon  4595   4874473.639945       106   120        16.911463        26.406768 1023404570.199635 /bg_non_interactive</span><br><span class="line"> FinalizerWatchd  4596   4875071.255862        94   120        92.491845        12.901697 1023424383.698603 /bg_non_interactive</span><br><span class="line">  HeapTaskDaemon  4597   4874944.279836       105   120       464.528156       145.433234 1023408878.431796 /bg_non_interactive</span><br><span class="line"> UsageStatsManag  5454    166013.123625        28   120         3.736692         7.303461      2259.492547 /bg_non_interactive</span><br><span class="line"> ReferenceQueueD  4676   4910959.490989       411   120       352.937851        44.359372 1031682076.525765 /bg_non_interactive</span><br><span class="line"> FinalizerWatchd  4678   4911158.926681       159   120       173.740456        27.154920 1031702277.606272 /bg_non_interactive</span><br><span class="line">   Binder:4667_4  4690 152544946.497651       602   120       399.673303       329.037221 1030480462.449134 /</span><br><span class="line"> Jit thread pool  4775   4676806.937632        46   129       584.051773        42.575534 977649836.816554 /bg_non_interactive</span><br><span class="line"> ReferenceQueueD  4778   4929598.950938     10766   120     12425.656847      1177.020436 1035855083.415536 /bg_non_interactive</span><br><span class="line"> FinalizerWatchd  4780   4929683.948035      5397   120      9073.970941      1432.005829 1035878083.124398 /bg_non_interactive</span><br><span class="line">  HeapTaskDaemon  4781   4929617.753216      4944   120     17246.513660      3386.164492 1035852959.703211 /bg_non_interactive</span><br><span class="line">   Binder:4770_1  4782 153455937.324790      1999   120      1364.448929      1482.585784 1035865597.476943 /</span><br><span class="line">         GslbLog  4788   2718236.732285        29   120         4.840078        35.634228    181009.474510 /bg_non_interactive</span><br><span class="line">   Picasso-Stats  4789   4932671.018182   1135788   130   1156678.064264    388576.250197 1035097223.872074 /bg_non_interactive</span><br><span class="line"> Picasso-Dispatc  4790   4932668.013223   1136455   130   1153701.173067    390023.714073 1035098268.297291 /bg_non_interactive</span><br><span class="line"> Picasso-refQueu  4791   4932668.680573   1105559   130   1108971.651174    357981.978098 1035175806.485399 /bg_non_interactive</span><br><span class="line"> Auto Update Han  4795   2718236.732285       126   120        18.471618        43.528536 525322997.882021 /bg_non_interactive</span><br><span class="line"> UpdateCheckerDb  4811   2718236.732285        22   120         5.695768        22.241387         3.827460 /bg_non_interactive</span><br><span class="line"> pool-5-thread-1  4822   4580680.916630        89   120       144.582386        83.838150 953955259.782065 /bg_non_interactive</span><br><span class="line">     checkThread  4833   2718236.732285         4   120        30.073615         5.264231    180196.976738 /bg_non_interactive</span><br><span class="line">        Thread-5  4855    167204.271450        19   130        20.805920        14.629311         2.252384 /bg_non_interactive</span><br><span class="line">        Thread-7  4903    170543.208437       118   130        50.924775       109.628070    177290.785962 /bg_non_interactive</span><br><span class="line">        Thread-9  4905    167204.271450        60   130        13.859845        31.225922        72.239310 /bg_non_interactive</span><br><span class="line"> UsageStats_Logg  4909   4926760.340217      5964   120     22053.790798      5761.618276 1035245874.753318 /bg_non_interactive</span><br><span class="line"> StatsUploadThre  4912   4926759.146834     12999   120     54240.817566      9151.491249 1035210290.136870 /bg_non_interactive</span><br><span class="line">    RenderThread  5557   4926807.417005      1889   112      1250.415468       357.573920 1035200281.077223 /bg_non_interactive</span><br><span class="line"> ConditionReceiv  5860   2718236.732285         1   120         0.000000         0.452077         0.000000 /bg_non_interactive</span><br><span class="line"> ConditionReceiv  7537   2718236.732285         1   120         0.870385         0.589769         0.000000 /bg_non_interactive</span><br><span class="line"> ReferenceQueueD  5119   4874824.395524       623   120       247.946313        60.611858 1023381907.948260 /bg_non_interactive</span><br><span class="line"> FinalizerDaemon  5120   4874824.636218       472   120       439.513615       151.602623 1023381629.713423 /bg_non_interactive</span><br><span class="line"> FinalizerWatchd  5121   4875071.132092       321   120       175.652843        46.923088 1023400547.552312 /bg_non_interactive</span><br><span class="line">  HeapTaskDaemon  5122   4874941.189912       336   120      1268.151007       282.455313 1023384219.224809 /bg_non_interactive</span><br><span class="line">   Binder:5111_1  5123 151562740.236414       620   120       234.087695       534.092152 1023381599.064658 /</span><br><span class="line"> RecordEventThre  5128   2717244.946023         3   120         0.000000         1.235154       351.413308 /bg_non_interactive</span><br><span class="line"> ContactsProvide  5130    164725.945930        77   130         3.492922       355.248080        59.653076 /bg_non_interactive</span><br><span class="line"> ShadowCallLogPr  5131    164199.748667         2   130         0.221615         0.885231         0.000000 /bg_non_interactive</span><br><span class="line">   Binder:5111_3  5550 151588383.731263       566   120       138.195767       338.813849 1023377208.928262 /</span><br><span class="line"> FinalizerDaemon  5940   4926802.467679      2996   120      1211.203446       921.037418 1034895345.976093 /bg_non_interactive</span><br><span class="line"> FinalizerWatchd  5941   4926896.333372      1551   120      1382.823089       259.089685 1034915738.585768 /bg_non_interactive</span><br><span class="line">  HeapTaskDaemon  5942   4926837.855107      1400   120      7606.161641       747.696530 1034894159.126035 /bg_non_interactive</span><br><span class="line">    RenderThread  5958   4926817.971183      2040   112       256.337921       364.432690 1034896104.914733 /bg_non_interactive</span><br><span class="line"> pool-1-thread-4  5978   2718422.397701         4   120         0.094307         2.826308         0.099539 /bg_non_interactive</span><br><span class="line"> FinalizerWatchd  6034   4926896.301757      1625   120      1309.874313       246.169316 1034910838.694057 /bg_non_interactive</span><br><span class="line">  HeapTaskDaemon  6035   4926837.642415      1549   120      7602.939161       607.713152 1034889208.386257 /bg_non_interactive</span><br><span class="line"> pool-3-thread-1  6105    176683.651475         5   120         2.044231         6.268077         1.515308 /bg_non_interactive</span><br><span class="line">            JDWP  6363    189383.083640         5   120         2.577309         3.248076         1.101769 /bg_non_interactive</span><br><span class="line"> FinalizerWatchd  6366   4875071.128477        33   120         4.719311         5.176692 1021571573.815724 /bg_non_interactive</span><br><span class="line">  HeapTaskDaemon  6367   4874949.929220        54   120        28.675620       137.207768 1021556426.199150 /bg_non_interactive</span><br><span class="line">   Binder:6356_1  6368 139200655.027685        27   120        13.769384        17.090851 935145903.597830 /</span><br><span class="line">   Profile Saver  6370    502518.947288        16   120         0.525539        12.477845  53705005.221652 /bg_non_interactive</span><br><span class="line"> ActivatePhone-E  6371   4932663.825490    116283   120     29060.985439     25698.987260 1034743433.584097 /bg_non_interactive</span><br><span class="line"> pool-1-thread-1  6372   4932551.087247    379405   120    493087.468487    117425.493907 1034146432.703501 /bg_non_interactive</span><br><span class="line"> u.flyme.weather  8508   4905811.948491      5163   120     32263.811569     12932.488929 1011798084.250727 /bg_non_interactive</span><br><span class="line"> Jit thread pool  8515   3406445.199813        11   129       515.446693        21.770309 663649283.376569 /bg_non_interactive</span><br><span class="line"> FinalizerWatchd  8520   4905919.728867       330   120       540.873161        51.405691 1011862451.056423 /bg_non_interactive</span><br><span class="line">  HeapTaskDaemon  8521   4905823.533323       370   120      2163.653919       173.199539 1011845714.509549 /bg_non_interactive</span><br><span class="line">   Binder:8508_1  8522 152543520.689689       517   120       254.493609       357.255224 1011842468.014930 /</span><br><span class="line"> izu.filemanager 22235   4926838.092492     14687   120     88515.185914     40241.578170 900070775.600047 /bg_non_interactive</span><br><span class="line"> FinalizerWatchd 22245   4926896.305372      1210   120      1057.282075       176.189841 900213058.864104 /bg_non_interactive</span><br><span class="line">  HeapTaskDaemon 22246   4926837.523491      1058   120      6561.753559       396.577236 900192486.234959 /bg_non_interactive</span><br><span class="line">  Binder:22235_1 22247 153373763.845287      1679   120       643.323002       972.536144 900194930.243593 /</span><br><span class="line">  Binder:22235_2 22249 153374509.821315      1681   120       927.923146       945.608908 900197520.775242 /</span><br><span class="line">   Profile Saver 22254   4404127.941539         6   120        11.033231         7.011000      2006.106389 /bg_non_interactive</span><br><span class="line"> RecordEventThre 22278   4404127.941539         7   120        11.476077        10.047846       486.063540 /bg_non_interactive</span><br><span class="line">         netdiag 25003 153686677.010546     72720   120     23727.429479    138365.018860 620420216.077324 /</span><br><span class="line">         tcpdump 25007 153687840.646576    661806   120    136663.612588    141003.425955 620309679.813657 /</span><br><span class="line"> Jit thread pool 32200   4905688.355315       114   129       531.165236       262.794842 548860639.510215 /bg_non_interactive</span><br><span class="line"> ReferenceQueueD 32203   4931408.375734      4990   120      2664.916953       735.110252 560697699.213534 /bg_non_interactive</span><br><span class="line"> FinalizerDaemon 32204   4931408.910788      5162   120      3258.085998      2519.146186 560695332.192561 /bg_non_interactive</span><br><span class="line">  Binder:32195_1 32207   4905688.355315       288   120       965.093920       144.552158 548099770.003167 /bg_non_interactive</span><br><span class="line"> eServiceManager 32217   4905692.405392        37   120        61.290693       100.176846     29858.050073 /bg_non_interactive</span><br><span class="line"> load task queue 32225   4905692.405392         2   120         1.388846         1.530538         0.055461 /bg_non_interactive</span><br><span class="line"> RxIoScheduler-1 32230   4932632.476062     10111   120      6998.219256      4827.876811 561007206.105590 /bg_non_interactive</span><br><span class="line"> ndHandlerThread 32233   4905692.405392         1   120         1.320077         1.304769         0.000000 /bg_non_interactive</span><br><span class="line">         Timer-0 32239   4905692.405392         8   120         9.669155         2.807460 518400098.723286 /bg_non_interactive</span><br><span class="line"> ConnectivityThr 32255   4905692.405392         1   120         0.578231         3.009769         0.000000 /bg_non_interactive</span><br><span class="line">  Binder:32195_C 21697   4905700.773777        47   120        38.927382        16.638927 117194938.540326 /bg_non_interactive</span><br><span class="line"> eizu.net.search  7374   4874526.505708       563   120      3817.714257      1792.029295 498315682.619555 /bg_non_interactive</span><br><span class="line"> FinalizerDaemon  7384   4874487.087331        75   120        38.659155       619.698844 498320574.611186 /bg_non_interactive</span><br><span class="line"> FinalizerWatchd  7385   4875071.103016        41   120        38.801924         6.240234 498340998.706537 /bg_non_interactive</span><br><span class="line">  HeapTaskDaemon  7386   4874941.416989        45   120         6.312769       189.854542 498325847.371117 /bg_non_interactive</span><br><span class="line">   Binder:7374_1  7387 151388627.489882        60   120        22.970614        24.918078 497952907.628462 /</span><br><span class="line"> RecordEventThre  7395   2708751.986536         3   120         0.000000         1.197384        52.350001 /bg_non_interactive</span><br><span class="line">        Thread-5  7399   2708733.441875         6   130         0.000000         1.308616         2.880846 /bg_non_interactive</span><br><span class="line"> xiaoyuan_taskqu  7413   2711349.434600        47   130         7.209923        83.617154       216.662232 /bg_non_interactive</span><br><span class="line">   Binder:7374_3  7419 150603778.359888        41   120        27.433076        17.922618 492202363.782363 /</span><br><span class="line"> tcontactservice  7438   4926822.916447      9328   120     34532.478719     25485.498125 510128204.376491 /bg_non_interactive</span><br><span class="line"> FinalizerWatchd  7448   4926896.504680       801   120       648.024688       124.142688 510207191.928763 /bg_non_interactive</span><br><span class="line">  HeapTaskDaemon  7449   4926837.782569       690   120      2899.197323       396.883075 510189813.455169 /bg_non_interactive</span><br><span class="line">   Binder:7438_1  7450 153361658.893905       782   120       231.238922       408.341308 510187290.110555 /</span><br><span class="line">   Profile Saver  7452   2717244.946023         3   120        16.336847        10.979385      1999.089389 /bg_non_interactive</span><br><span class="line"> StatsUploadThre  7465   4926768.377294      6690   120     21795.181484      4891.672419 510160959.193273 /bg_non_interactive</span><br><span class="line">   kworker/u21:1  7528  77456579.022522        29   100         2.079615         2.696386     79018.115341 /</span><br><span class="line">  Signal Catcher 26897 141247121.961602         1   120         0.072384         1.705077         0.000000 /</span><br><span class="line"> FinalizerWatchd 26901 151576580.448038        11   120        12.091385         1.284922  72933188.080650 /</span><br><span class="line">  HeapTaskDaemon 26902 151566336.109277        14   120         9.638461        21.348229  72918114.231922 /</span><br><span class="line"> pool-1-thread-1 26907 141247124.102425        20   120         4.840536         4.694618       595.173231 /</span><br><span class="line">        Thread-2 26908 141247165.375599         5   120         2.529615         9.752539         4.382000 /</span><br><span class="line">        Thread-3 26909 141247289.081469         5   120         3.092537         1.270462         0.344539 /</span><br><span class="line">        Thread-5 26911 141247289.081469         1   120         0.281538         0.917385         0.000000 /</span><br><span class="line">        Thread-7 26913 141247616.858611         2   120         1.230692         1.083308         0.000000 /</span><br><span class="line">        Thread-8 26914 141249054.473219        39   120       102.416694        62.661384      3005.702622 /</span><br><span class="line">        Thread-9 26915 153687017.260693     22712   120     35826.112336     14820.009771  86105692.741905 /</span><br><span class="line">       Thread-10 26916 141247616.858611         2   120        33.137616         3.859154         0.000000 /</span><br><span class="line">       Thread-11 26917 141249050.508089         2   120        13.911385         1.536846         0.000000 /</span><br><span class="line">       Thread-12 26918 141249059.488678         1   120         5.745231         1.408308         0.000000 /</span><br><span class="line"> ReferenceQueueD  4204   4926810.873294        57   120        38.779382         7.243154  11881209.951559 /bg_non_interactive</span><br><span class="line"> FinalizerWatchd  4206   4926896.324680        20   120        40.476922         4.574999  11900937.558912 /bg_non_interactive</span><br><span class="line">  HeapTaskDaemon  4207   4926837.998953        29   120       163.482307        92.142231  11886043.970876 /bg_non_interactive</span><br><span class="line">   Binder:4185_1  4208 152682089.243315        17   120        22.831307        19.882538   8279296.350892 /</span><br><span class="line">   Binder:4185_2  4209 153358867.541611        12   120        19.765231         7.029537  11880834.676019 /</span><br><span class="line">   Binder:4185_3  4210 152941815.748155        11   120         6.345691         7.885924  10079893.571877 /</span><br><span class="line">   Profile Saver  4211   4874938.486445         5   120         6.651539        22.292616      1999.705158 /bg_non_interactive</span><br><span class="line"> AsyncQueryWorke  4213   4874809.596223        13   120        10.297616         8.320231        37.206691 /bg_non_interactive</span><br><span class="line"> RxScheduledExec  4216   4932517.764388       207   120       188.374771       114.464999  13198706.400390 /bg_non_interactive</span><br><span class="line"> RxScheduledExec  4217   4932517.485080       216   120       294.389230        50.240241  13198661.174919 /bg_non_interactive</span><br><span class="line"> RxIoScheduler-1  4218   4932520.674991       239   120       100.250163       112.263457  13200160.377083 /bg_non_interactive</span><br><span class="line"> RecordEventThre  4223   4874916.402142         2   120         0.000000         1.628307       133.367924 /bg_non_interactive</span><br><span class="line"> pool-3-thread-1  4225   4874899.422758         2   120         0.515923         0.997692         0.000000 /bg_non_interactive</span><br><span class="line">     kworker/0:3  5730 153681617.910271      2437   120      1631.211916      2204.719392   1580708.999166 /</span><br><span class="line">   kworker/u20:3  5821 153687520.776697       694   120       570.427698       306.502469    862766.286894 /</span><br><span class="line">     kworker/0:2  5839 153687946.923183      8382   120      6399.375723      9281.080705    700862.506975 /</span><br><span class="line">     kworker/0:0  5871 153687675.097160      1551   120       755.621222      1569.718394    413031.572758 /</span><br><span class="line">   kworker/u20:1  5878 153687902.579266       340   120       281.762769       133.692472    361061.771160 /</span><br><span class="line">     kworker/0:1  5888 153613107.461324         3   120         3.720154         0.158000         4.040308 /</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cpu#1: Online</span><br><span class="line">  .nr_running                    : 2</span><br><span class="line">  .load                          : 2048</span><br><span class="line">  .nr_switches                   : 50330891</span><br><span class="line">  .nr_load_updates               : 18465962</span><br><span class="line">  .nr_uninterruptible            : -282929</span><br><span class="line">  .next_balance                  : 4554.077177</span><br><span class="line">  .curr-&gt;pid                     : 5914</span><br><span class="line">  .clock                         : 1036739631.224580</span><br><span class="line">  .clock_task                    : 1036739631.224580</span><br><span class="line">  .cpu_load[0]                   : 304</span><br><span class="line">  .cpu_load[1]                   : 271</span><br><span class="line">  .cpu_load[2]                   : 371</span><br><span class="line">  .cpu_load[3]                   : 442</span><br><span class="line">  .cpu_load[4]                   : 451</span><br><span class="line">  .yld_count                     : 328297</span><br><span class="line">  .sched_count                   : 52031170</span><br><span class="line">  .sched_goidle                  : 13402190</span><br><span class="line">  .avg_idle                      : 157078</span><br><span class="line">  .max_idle_balance_cost         : 78539</span><br><span class="line">  .ttwu_count                    : 28394891</span><br><span class="line">  .ttwu_local                    : 19995708</span><br><span class="line"></span><br><span class="line">cfs_rq[1]:/bg_non_interactive</span><br><span class="line">  .exec_clock                    : 577939.399761</span><br><span class="line">  .MIN_vruntime                  : 0.000001</span><br><span class="line">  .min_vruntime                  : 879925.689476</span><br><span class="line">  .max_vruntime                  : 0.000001</span><br><span class="line">  .spread                        : 0.000000</span><br><span class="line">  .spread0                       : -152808035.003624</span><br><span class="line">  .nr_spread_over                : 3440</span><br><span class="line">  .nr_running                    : 0</span><br><span class="line">  .load                          : 0</span><br><span class="line">  .load_avg                      : 0</span><br><span class="line">  .runnable_load_avg             : 0</span><br><span class="line">  .util_avg                      : 0</span><br><span class="line">  .removed_load_avg              : 0</span><br><span class="line">  .removed_util_avg              : 0</span><br><span class="line">  .tg_load_avg_contrib           : 0</span><br><span class="line">  .tg_load_avg                   : 943</span><br><span class="line">  .se-&gt;exec_start                : 1036722623.319617</span><br><span class="line">  .se-&gt;vruntime                  : 56084769.222524</span><br><span class="line">  .se-&gt;sum_exec_runtime          : 578346.130491</span><br><span class="line">  .se-&gt;statistics.wait_start     : 0.000000</span><br><span class="line">  .se-&gt;statistics.sleep_start    : 0.000000</span><br><span class="line">  .se-&gt;statistics.block_start    : 0.000000</span><br><span class="line">  .se-&gt;statistics.sleep_max      : 0.000000</span><br><span class="line">  .se-&gt;statistics.block_max      : 0.000000</span><br><span class="line">  .se-&gt;statistics.exec_max       : 268.577308</span><br><span class="line">  .se-&gt;statistics.slice_max      : 158.383846</span><br><span class="line">  .se-&gt;statistics.wait_max       : 449.603155</span><br><span class="line">  .se-&gt;statistics.wait_sum       : 474626.775818</span><br><span class="line">  .se-&gt;statistics.wait_count     : 405003</span><br><span class="line">  .se-&gt;load.weight               : 2</span><br><span class="line">  .se-&gt;avg.load_avg              : 0</span><br><span class="line">  .se-&gt;avg.util_avg              : 1</span><br><span class="line"></span><br><span class="line">cfs_rq[1]:/</span><br><span class="line">  .exec_clock                    : 42386409.280566</span><br><span class="line">  .MIN_vruntime                  : 0.000001</span><br><span class="line">  .min_vruntime                  : 56084976.869536</span><br><span class="line">  .max_vruntime                  : 0.000001</span><br><span class="line">  .spread                        : 0.000000</span><br><span class="line">  .spread0                       : -97602983.874333</span><br><span class="line">  .nr_spread_over                : 104638</span><br><span class="line">  .nr_running                    : 1</span><br><span class="line">  .load                          : 1024</span><br><span class="line">  .load_avg                      : 2629</span><br><span class="line">  .runnable_load_avg             : 303</span><br><span class="line">  .util_avg                      : 194</span><br><span class="line">  .removed_load_avg              : 230</span><br><span class="line">  .removed_util_avg              : 55</span><br><span class="line">  .tg_load_avg_contrib           : 2629</span><br><span class="line">  .tg_load_avg                   : 8008</span><br><span class="line"></span><br><span class="line">rt_rq[1]:/bg_non_interactive</span><br><span class="line">  .rt_nr_running                 : 0</span><br><span class="line">  .rt_throttled                  : 0</span><br><span class="line">  .rt_time                       : 0.000000</span><br><span class="line">  .rt_runtime                    : 700.000000</span><br><span class="line"></span><br><span class="line">rt_rq[1]:/</span><br><span class="line">  .rt_nr_running                 : 0</span><br><span class="line">  .rt_throttled                  : 0</span><br><span class="line">  .rt_time                       : 0.240462</span><br><span class="line">  .rt_runtime                    : 800.000000</span><br><span class="line"></span><br><span class="line">dl_rq[1]:</span><br><span class="line">  .dl_nr_running                 : 0</span><br><span class="line"></span><br><span class="line">runnable tasks:</span><br><span class="line">            task   PID         tree-key  switches  prio     wait-time             sum-exec        sum-sleep</span><br><span class="line">----------------------------------------------------------------------------------------------------------</span><br><span class="line">        kthreadd     2  56084963.882383      7231   120      4231.780138     11602.057297 1036723552.983919 /</span><br><span class="line">     rcu_preempt     7  56084971.464306  38012914   120  19389373.432429   4762070.363433 1012596123.004465 /</span><br><span class="line">     migration/1    11         0.000000    920361     0         0.195462   1119760.329035         0.000000 /</span><br><span class="line">     ksoftirqd/1    12  56084941.917306   1503624   120   2051568.246464    208690.852721  84770006.156114 /</span><br><span class="line">     kworker/1:0    13  56084928.574845   1593806   120   2819612.156152   3042907.328028 1030879705.296110 /</span><br><span class="line">    kworker/1:0H    14  56084928.506641    769028   100     87134.568064     44580.172387 1036607480.393581 /</span><br><span class="line">  conn-md-thread    66  56032835.789987      1290   120       897.904397       265.639693 1035373385.155010 /</span><br><span class="line">     ion_mm_heap    71  33752638.207281     11146   120       880.444199      1770.794336 525416463.703157 /</span><br><span class="line"> gpu_dvfs_host_r   134  33752390.546093       127   120      1065.321542        11.329230 525417797.621171 /</span><br><span class="line">     kworker/1:1   156  56084933.544153   1480308   120   2649053.709056   2762215.380543 1031325843.420206 /</span><br><span class="line"> present_fence_w   174         0.000000      9298    12         0.000000      1922.959458         0.047924 /</span><br><span class="line">      ccci_ipc_3   192     19044.703054         9   120         0.000000         1.116384     47963.967653 /</span><br><span class="line"> sub_touch_suspe   225       186.599518         2   100         0.000000         0.084307         0.045385 /</span><br><span class="line">          binder   234  21304801.244018        10   100        13.929847         5.653460 294186699.162210 /</span><br><span class="line">    cs43130_eint   236       300.244655         2   100         0.000000         0.093307         0.049693 /</span><br><span class="line">         deferwq   239       312.671963         2   100         0.000000         0.447693         0.026615 /</span><br><span class="line"> ipi_cpu_dvfs_rt   240  56084971.606382   4721361   120   3352016.787765   1096347.393886 1032282573.766225 /</span><br><span class="line">        hps_main   248  56084961.982216  24442794   100  11377751.354137  44892965.375321 980455518.350080 /</span><br><span class="line">     kworker/1:2   253  56084928.546614    396668   120   1203003.599743     57758.489925 1035468059.093820 /</span><br><span class="line"> tspdrv_workqueu   264       354.950809         2   100         0.000000         0.087309         0.043307 /</span><br><span class="line">    charger_pe30   271       388.244648         2   120         0.023230         0.076770         0.044384 /</span><br><span class="line">          wdtk-1   274         0.000000    431664     0         0.066230     47351.786026         4.055385 /</span><br><span class="line"> irq/681-inv_irq   286         0.000000     42650    49         0.000000      7706.968076         0.000000 /</span><br><span class="line">    kworker/1:1H   298  56084928.506220    934189   100   1239206.746474    130105.400793 1035357234.967516 /</span><br><span class="line"> ext4-rsv-conver   339       539.640231         2   100         0.000000         0.064077         0.071000 /</span><br><span class="line"> ext4-rsv-conver   344       550.112265         2   100         0.008846         0.432692         0.189308 /</span><br><span class="line">     teei_daemon   347      2195.663032       161   120        90.583849       116.936697      6587.161548 /</span><br><span class="line">     logd.reader   355  56032980.178008      4583   118      3264.198461      7344.057700 1035348005.371874 /</span><br><span class="line">  surfaceflinger   387  33752399.837783     10181   112      4546.362293     40562.144613 525356774.143072 /</span><br><span class="line">    Binder:387_2   572  56081748.643697     36132   120     17463.768519     10239.252491 1036571219.337219 /</span><br><span class="line">         ged-swd   591  33719968.867936      1395   112        17.363224       110.643873 525334077.194950 /</span><br><span class="line">    Dispatcher_0   600  33737930.380606      4578   112       227.688896      1541.349714 525392407.423655 /</span><br><span class="line">  surfaceflinger   601      1331.493639         3   112         0.134923         0.380923         0.061846 /</span><br><span class="line">   POSIX timer 0   664  56083429.748978     54059   112     32477.850144     18576.148154 1036607201.578018 /</span><br><span class="line">     SceneThread  1005    667002.152976       125   130       287.304917         6.417922 525395419.028202 /bg_non_interactive</span><br><span class="line">    Binder:387_3  1020  56083383.295191     36625   120     16490.325650     10295.973974 1036627444.532135 /</span><br><span class="line">          mtkmal   674      2885.809776        11   120         2.375308         2.284615      4352.146780 /</span><br><span class="line">          mtkmal   681  56084916.647847    216612   120    189561.945738    122792.805958 1036400650.395202 /</span><br><span class="line">          mtkmal   691      6116.721328         9   120        15.282844         1.301617     22385.949054 /</span><br><span class="line">          mtkmal   695  56084916.437540    107969   120     19794.837281     45825.955143 1036647275.325944 /</span><br><span class="line">          mtkmal   703      6088.699496        12   120         5.913077         4.226999     22134.655515 /</span><br><span class="line">          mtkmal   706  56084916.313308    107384   120     37367.077785     35296.931397 1036640172.506429 /</span><br><span class="line">          mtkmal   733  56084917.083001    183879   120     56196.013705    120004.179848 1036536562.988102 /</span><br><span class="line"> mobile_log_d.rd 25016  56084963.608614   6882190   120  14953859.358904  13240534.693251 592393228.035553 /</span><br><span class="line">    Binder:402_1   605  33674260.181807        22   120        13.631922        11.849771 525315422.061848 /</span><br><span class="line">    Binder:402_3  5381  33673729.693961         8   120         2.242077         3.615307 525223555.280785 /</span><br><span class="line">  AALServiceMain   550  33744414.178102     21323   116     14364.783386     30645.313177 525349866.786645 /</span><br><span class="line">    Binder:403_1   551  33731747.557534        87   120        29.063926        22.879080 525394222.701955 /</span><br><span class="line">    Binder:406_2  1485   6436626.900390      1437   120        84.571312       654.617231     72026.841326 /</span><br><span class="line"> OMXCallbackDisp  2019      8318.329531        92   118        97.916078         8.736992      1231.909242 /</span><br><span class="line">       mtk_agpsd   517      1084.858079         4   120        12.049385         1.693538       337.371155 /</span><br><span class="line">  POSIX timer 24   538      1103.398786         1   120         0.000000         0.132462         0.000000 /</span><br><span class="line">  POSIX timer 25   539      1106.293924         1   120         0.000000         0.077307         0.000000 /</span><br><span class="line">  POSIX timer 26   540      2529.862698         4   120        25.179538         3.483001      3981.455856 /</span><br><span class="line">       mtk_agpsd  1174      6034.783670         7   120         0.020153         0.918078     13910.320725 /</span><br><span class="line">    mtkFlpDaemon   414      6034.966768         4   120        27.891771         1.919154     23114.983054 /</span><br><span class="line"> nvram_agent_bin   412      1046.923260        26   120       836.205694        51.939692         5.564923 /</span><br><span class="line">     mtk_stp_psm   430  56032836.320371      4293   120      5001.201496       535.902918 1035349932.070863 /</span><br><span class="line">     mtk_stp_btm   450  56032836.042372      1703   120      5220.534637      2280.545230 1035347923.092032 /</span><br><span class="line">            mnld   628      1477.884085         6   120         8.254462         1.145461        10.269154 /</span><br><span class="line">     audioserver   546  56084917.923701    171755   120     11857.801841    106574.623287 1036595591.446154 /</span><br><span class="line">        ApmAudio   620  33718836.887086       138   104        18.553383        41.281532 525329069.429581 /</span><br><span class="line">    Binder:546_1   819  56084918.966086    171246   120     10954.483405    105797.817593 1036594962.559220 /</span><br><span class="line">    Binder:546_2  1378  56084918.195386    171057   120     10723.934008    105760.220095 1036579702.363216 /</span><br><span class="line">    Binder:546_3  1379  56084918.462393    171242   120     11209.847543    105840.313395 1036579136.780463 /</span><br><span class="line">    Binder:546_4  2033  56084860.297265    171247   120     10728.922457    106000.168897 1036562034.898080 /</span><br><span class="line">    Binder:547_1  1193   6856488.335266       435   120        41.523615       419.513922   1051334.737197 /</span><br><span class="line">        keystore   552   6640621.380343        35   120        47.693384        73.121536    444400.458292 /</span><br><span class="line">       NPDecoder  2015      8365.785309       103   104        12.976155        11.382152      1575.555620 /</span><br><span class="line">    NPDecoder-CL  2016      8365.784179       328   104        43.169999        44.040685      1511.266779 /</span><br><span class="line">            netd  1322  55796180.978847       757   120       929.629850       742.595078 1030525637.599231 /</span><br><span class="line">            netd  1325  55802490.599096       115   120        77.339538       120.681461 1030532294.556477 /</span><br><span class="line">    Binder:556_2  1327  56009784.674785      2855   120      5756.591947      7942.906612 1035321139.251679 /</span><br><span class="line">     gatekeeperd   561      1211.097265        25   120        69.088234        62.568842         6.285386 /</span><br><span class="line">  stp_sdio_tx_rx   655  56032838.212448      6228   120      8626.732756      2927.322581 1035341675.696095 /</span><br><span class="line">  md1_rx0_worker   720      1771.193680         4   100         0.095308         0.076231         4.023307 /</span><br><span class="line">  md1_rx3_worker   723      1781.226273         2   100         0.000000         0.084076         0.053539 /</span><br><span class="line">      cldma_rxq3   724      1786.333962         3   120         0.023231         0.107692         0.102385 /</span><br><span class="line">      rx1_worker   740      1797.484147         4   100         7.173154         0.167001         4.110923 /</span><br><span class="line">      rx5_worker   744      1799.266610         3   100         2.276538         0.181155         3.744000 /</span><br><span class="line">      emdlogger3   833      2272.858487        27   120        11.823074        56.420155         3.626386 /</span><br><span class="line">         viarild   859      2394.923245         6   120         0.270616         4.706925       349.505615 /</span><br><span class="line">         viarild   928  33744440.692595       177   120        33.165922        38.994162 525391645.720026 /</span><br><span class="line">         viarild   948      2392.951474         2   120         2.479846         1.405999        35.829231 /</span><br><span class="line">         viarild   955  33672778.596621       184   120        64.992847        80.666316 525312612.229837 /</span><br><span class="line">         mtkrild   901      2391.007168        95   120         6.483773        93.618459        20.904234 /</span><br><span class="line">         mtkrild   930  56084917.935957    579410   120    672630.096924    303377.183368 1035734813.591619 /</span><br><span class="line">         mtkrild   957  56084916.729881    218023   120     54871.580685    138727.014655 1036517202.838331 /</span><br><span class="line">         mtkrild   960      8393.666937        15   120         8.117076         1.977388     23764.926979 /</span><br><span class="line">         mtkrild   964      3347.244361       179   120        21.393846        56.120012      3287.045534 /</span><br><span class="line">         mtkrild   966  33672845.577626        91   120        23.128384        44.858461 525312682.366841 /</span><br><span class="line">         mtkrild   968      2392.262859         5   120         4.087923         0.583923         9.196077 /</span><br><span class="line">         mtkrild   973      2392.920531         4   120         2.636769         0.535000         0.480538 /</span><br><span class="line">        rilproxy  1042  55995455.819203      1134   120       509.634301       736.952397 1035044007.965842 /</span><br><span class="line"> Ril Proxy Main   1045  56084917.853693    378235   120    383504.315587    317343.468843 1036008437.445670 /</span><br><span class="line"> Ril Proxy reque  1048  56084916.522232    110603   120     21405.950388     59619.857487 1036628229.168552 /</span><br><span class="line">        rilproxy  1050  56084916.352078    274756   120    241832.597538     54217.691363 1036413213.716060 /</span><br><span class="line">     StateThread  5649  56084916.041231       515   120       977.280146       398.396472   2378692.334362 /</span><br><span class="line"> android.display  1126  56033064.723570     16435   120      8984.296074      8017.095512 1035331623.792675 /</span><br><span class="line">         Scanner  1291  56084920.981847   1134864   120   1716767.334229   4642037.257448 1030334663.149114 /</span><br><span class="line">   system_server  1311  33731654.076557      2195   120       572.202625       563.199516 525378661.383784 /</span><br><span class="line">   NetdConnector  1347  56032840.369217      9707   120     20449.771483      9725.707400 1035307228.786430 /</span><br><span class="line">    NetworkStats  1354  56009792.254610     12568   120     42826.472921     20716.647153 1035269129.920753 /</span><br><span class="line">   NetworkPolicy  1355  56033064.606031      8445   120      9703.243873      2762.269520 1035325421.396398 /</span><br><span class="line">     WifiService  1358  56051587.806532      6453   120      4912.990426      3459.065001 1035915378.949281 /</span><br><span class="line"> notification-sq  1373    843199.427417      1856   130      3926.209923      1073.862834 950533385.828158 /bg_non_interactive</span><br><span class="line">       intercept  1374  27364674.588161        18   118         1.953539         8.846612 416111875.421965 /</span><br><span class="line">    AudioService  1376  33717662.807677       217   120       110.230613        59.044003 525311743.419377 /</span><br><span class="line"> PhotonicModulat  1391  33744500.025595       325   120       204.420156       284.282093 525376155.377218 /</span><br><span class="line"> NetworkStatsObs  1501  56009482.741520       993   120       254.506925       215.775040 1035328228.342561 /</span><br><span class="line">        Thread-7  1513  56032836.816371      2632   120      5037.018218       552.389622 1035328187.929843 /</span><br><span class="line">   MonitorThread  1558   6724125.901720       556   120      1293.751714        25.241840    484036.380374 /</span><br><span class="line"> UsageStatsManag  1677  33752235.347986        43   120         3.085000         8.958466 525377323.973147 /</span><br><span class="line">         ged-swd  1969  33752390.246457      2074   112       137.238021       155.401375 525375503.744679 /</span><br><span class="line">        MyThread  3070  52248501.979094      5563   120      1863.725947      1680.411822 950515136.032666 /</span><br><span class="line">   Binder:1400_6  7473  56083412.858083     22852   120      3892.280790     15923.404363 511472757.682134 /</span><br><span class="line">      hif_thread  1495  56032836.220330    175874   110     59579.713866     87697.692535 1035186727.668677 /</span><br><span class="line">   Binder:1671_3  1949  56079125.099768     10534   120      3044.774771      6646.219846 1036459779.411004 /</span><br><span class="line"> ReferenceQueueD  1712  55372150.642508        58   120        10.395077         6.460153 1023445115.112964 /</span><br><span class="line"> Jit thread pool  1723  49827287.387788        35   129       367.794229        37.047156 896766777.170798 /</span><br><span class="line">   Binder:1717_2  1731  56009786.034402       570   120       384.757617       385.461928 1035326176.435974 /</span><br><span class="line"> Jit thread pool  1768  53531939.000335        28   129        20.202768        37.296691 979877338.655096 /</span><br><span class="line"> ReferenceQueueD  1786  55373094.329253       341   120       131.093085        43.539385 1023444761.311879 /</span><br><span class="line"> FinalizerDaemon  1788  55373094.298715       322   120        62.295772       131.639779 1023444740.041949 /</span><br><span class="line"> RxNewThreadSche  1840      6119.851604        26   120         3.419463        14.600922        23.673923 /</span><br><span class="line">   Binder:1753_3  3021  53784801.228364       215   120       153.913072       127.704533 986068421.052480 /</span><br><span class="line"> RxNewThreadSche 10997   9439014.868541         5   120         3.811076         6.952154        30.429232 /</span><br><span class="line"> RxNewThreadSche 21098  13494962.180242         4   120         0.107923         7.587538        12.558923 /</span><br><span class="line"> RxNewThreadSche 31291  17537336.349316         3   120         9.650924         6.877922         4.645384 /</span><br><span class="line"> e.systemuitools  2062  56083504.148183    215715   120    301648.420330   1953993.205708 1034376431.451683 /</span><br><span class="line"> ReferenceQueueD  2092  55379666.962636       105   120        55.141998        12.229083 1023440389.673409 /</span><br><span class="line">   Binder:2077_1  2099  52248473.912729       417   120       235.546998       247.534690 950528189.597516 /</span><br><span class="line">         ged_srv  2103  33719180.903614       115   120        38.081692        23.509616 525303284.086359 /</span><br><span class="line"> FinalizerDaemon  2125  55802309.698736       274   120        96.433851       103.236384 1030512152.509959 /</span><br><span class="line">   Binder:2177_1  2191  55341260.904215        37   120        27.967996        12.658083 1023436701.924710 /</span><br><span class="line"> FinalizerWatchd  2204  55372679.127459        36   120         3.917000         3.638614 1023437016.050484 /</span><br><span class="line">   Binder:2194_1  2207  55341262.013907        38   120        40.090463        12.871308 1023436657.741634 /</span><br><span class="line">   Binder:2224_1  2237  52840358.835322       298   120       119.847542       320.998538 963843199.328171 /</span><br><span class="line"> PowerStateThrea  2458  33847236.869347      5759   120      4796.854263      3483.595340 527336075.580471 /</span><br><span class="line">   Binder:2224_3  4026  52860138.850868       289   120       175.050225       233.801392 964420595.304321 /</span><br><span class="line"> ReferenceQueueD  2248  55376226.178730        52   120         8.831307         5.933614 1023436902.906330 /</span><br><span class="line">   Binder:2240_1  2252  51593020.581062        42   120        63.704311        33.440381 937031490.822944 /</span><br><span class="line">   Binder:2255_1  2271  56033154.562491      1671   120       962.166530      1343.565687 1035321796.022525 /</span><br><span class="line">   Binder:2255_3  2404  56032004.813208      1639   120       923.998699      1365.694478 1035318382.826100 /</span><br><span class="line"> Jit thread pool  2314    840760.926861       401   129       636.509446       598.174388 944615143.691963 /bg_non_interactive</span><br><span class="line">   Binder:2306_1  2324  56027408.099977       552   120       455.434147       356.177158 1035319812.922354 /</span><br><span class="line"> downloadProvice  2763    178132.398145        47   120        14.689535        16.208308     21739.367670 /bg_non_interactive</span><br><span class="line">   Binder:2306_5  3581  56045598.148836       519   120       415.198611       336.687553 1035673768.634104 /</span><br><span class="line">   Binder:2306_7  3584  55995714.222897       493   120       435.668924       510.319458 1035011806.970693 /</span><br><span class="line"> m.meizu.battery  2370  56053359.922863     45451   120    160503.684888    224282.216651 1035524983.063264 /</span><br><span class="line">   Binder:2370_1  2384  56045598.193297      1082   120      1151.307926       831.756778 1035686997.443211 /</span><br><span class="line"> UsageStatsManag  2496  55078712.476754       131   120        23.518922        35.905766 1017318302.990434 /</span><br><span class="line"> RecordEventThre  2501  55078733.528312       420   120       405.771683       738.061080 1017317238.547050 /</span><br><span class="line">   Binder:2370_6 27759  56035894.128884       501   120       591.378993       360.080085 598035997.279291 /</span><br><span class="line"> .flyme.launcher  2386  56010160.110427     22479   120     54606.318514     83348.324293 1035180494.096128 /</span><br><span class="line">   Binder:2386_2  2401  56009786.082311      1001   120       304.616536       434.117314 1035317407.078800 /</span><br><span class="line">   Binder:2386_3  2445  55829592.869138       959   120       447.393002       387.808844 1031715452.154068 /</span><br><span class="line"> UsageStatsManag  2508  54248979.366717        85   120         6.142921        34.401921 997500729.044958 /</span><br><span class="line"> UsageStats_Logg  2509  56009809.946065      4695   120     12749.501791      6244.805194 1035298548.627207 /</span><br><span class="line"> ndroid.location  2453    879441.504554     25067   120    172125.929571     57697.885234 1035093322.990406 /bg_non_interactive</span><br><span class="line">   Binder:2453_2  2476  56033064.928108      2441   120      2363.857383      1541.900081 1035319107.345273 /</span><br><span class="line"> ConnectivityThr  2580    666797.790817         1   120         0.000000         0.628846         0.000000 /bg_non_interactive</span><br><span class="line"> trafficPollingT  2722    874614.094853       115   120        65.401389        33.299768 525283562.975460 /bg_non_interactive</span><br><span class="line"> ComputationThre 26893    874614.094853        19   120        97.621847        10.583385        25.370769 /bg_non_interactive</span><br><span class="line"> ComputationThre 27152    874618.017314        20   120       107.045311        11.177075         2.826846 /bg_non_interactive</span><br><span class="line"> u.mzsyncservice  2557    879443.225708     18720   120     45340.206087     69031.127777 1035208250.288716 /bg_non_interactive</span><br><span class="line">  HeapTaskDaemon  2568    879441.558707      1491   120      1773.618784       837.339138 1035321975.979135 /bg_non_interactive</span><br><span class="line">   Binder:2557_1  2569  56031944.102234      1427   120       452.224756      1366.056482 1035317857.740724 /</span><br><span class="line">   Binder:2557_2  2570  56033065.499878      1461   120       451.642318      1434.576522 1035320632.156899 /</span><br><span class="line"> UsageStats_Logg  2586    873023.866714       407   120      1244.391839       517.626861 1023070746.628069 /bg_non_interactive</span><br><span class="line"> RecordEventThre  2589     59246.247671         3   120         0.125692         1.544616     16777.821424 /bg_non_interactive</span><br><span class="line"> StatsUploadThre  2602    873020.640639       990   120      8619.253869       829.768078 1023063005.462051 /bg_non_interactive</span><br><span class="line">            JDWP  2656    184202.989590        12   120         8.830693         3.254845      3848.387855 /bg_non_interactive</span><br><span class="line"> FinalizerDaemon  2658    873804.763280        90   120       134.453234        29.832462 1023434665.586243 /bg_non_interactive</span><br><span class="line">   Profile Saver  2680    184202.989590         8   120         2.344231         6.287692      1999.479082 /bg_non_interactive</span><br><span class="line"> FinalizerDaemon  3244    873933.193119        43   120       130.746692         9.167776 1023428731.903995 /bg_non_interactive</span><br><span class="line">   Profile Saver  3256     26637.242212        10   120         5.319307         6.626540      1999.544697 /bg_non_interactive</span><br><span class="line"> com.meizu.cloud  3288    873963.986808       486   120      6609.332174      1175.332080 1023420288.479594 /bg_non_interactive</span><br><span class="line"> pool-1-thread-1  3304    177796.982104        14   120         1.710077         8.185537     60058.760683 /bg_non_interactive</span><br><span class="line"> Jit thread pool  3694   6336221.838045        13   129         4.989386        25.141231     28019.900604 /</span><br><span class="line"> UsageStatsManag  4005    666446.370581        30   120         9.254616        16.404769 525281525.981613 /bg_non_interactive</span><br><span class="line"> RecordEventThre  4007    666592.986501        59   120        11.412001        21.220767 525311575.022840 /bg_non_interactive</span><br><span class="line"> xiaoyuan_taskqu  4146    666445.965658        70   130        32.387618        65.221074     14545.066189 /bg_non_interactive</span><br><span class="line">    RenderThread  5485    873753.210070       668   112       826.587074       404.358791 1023335862.970144 /bg_non_interactive</span><br><span class="line"> ReferenceQueueD  4377    873842.548267       200   120       163.293619        26.327696 1023407430.025945 /bg_non_interactive</span><br><span class="line"> FinalizerDaemon  4378    873842.579344       174   120       109.215692        59.261463 1023407449.739333 /bg_non_interactive</span><br><span class="line">    input_worker  4874    666932.530464        45   125       112.201770       714.529155     60134.851374 /bg_non_interactive</span><br><span class="line"> FinalizerDaemon  4499    873808.280352       108   120         8.892074        29.538537 1023405691.530181 /bg_non_interactive</span><br><span class="line">   Binder:4507_2  4520  51592920.101288        44   120         7.668691        13.387922 937000053.623719 /</span><br><span class="line">   Profile Saver  4525    178132.398145        12   120         0.000000         5.718693      1999.577004 /bg_non_interactive</span><br><span class="line"> UsageStatsManag  4527    178132.398145        15   120         8.885155        12.735612        14.708695 /bg_non_interactive</span><br><span class="line"> RecordEventThre  4528    178132.398145         1   120         5.583000         0.965000         0.000000 /bg_non_interactive</span><br><span class="line"> u.net.pedometer  4556    879917.915367     27654   120     29182.461965     31458.080646 1036535463.372010 /bg_non_interactive</span><br><span class="line">   Binder:4556_1  4569    879917.915367     12524   120      4035.936612      9933.564723 1036582099.286509 /bg_non_interactive</span><br><span class="line"> pool-1-thread-1  4574    879917.915367        78   120       231.954385        93.533460 968654758.328956 /bg_non_interactive</span><br><span class="line"> UsageStatsManag  4576    879917.915367        69   120         8.294002        42.423770        56.545690 /bg_non_interactive</span><br><span class="line"> UsageStats_Logg  4578    879917.915367         6   120         1.695847         1.279999         0.000000 /bg_non_interactive</span><br><span class="line"> RecordEventThre  4579    879917.915367         4   120         4.040537         1.019694         0.000000 /bg_non_interactive</span><br><span class="line"> StatsUploadThre  4582    879917.915367       721   120      9082.140566       701.243915 1023031913.555590 /bg_non_interactive</span><br><span class="line"> Jit thread pool  4672    844089.347915        99   129       219.860997       259.771081 951215140.006606 /bg_non_interactive</span><br><span class="line"> FinalizerDaemon  4677    877719.567480       411   120       357.755000       122.855144 1031681992.910303 /bg_non_interactive</span><br><span class="line">  HeapTaskDaemon  4679    877980.730985       169   120      1445.022084       131.623924 1031685964.605067 /bg_non_interactive</span><br><span class="line">   Binder:4667_3  4682  55803735.812095       738   120       410.726773       385.035131 1030480627.597531 /</span><br><span class="line">   Binder:4667_5  4692  55804292.061990       600   120       154.926688       340.477836 1030502748.706264 /</span><br><span class="line">   Binder:4667_6  4693  55804292.501836       639   120       516.432305       419.259317 1030502299.149784 /</span><br><span class="line">   Binder:4667_7  5069  55804292.599837       424   120       310.832921       295.324386 1030484320.120593 /</span><br><span class="line"> FinalizerDaemon  4779    879649.286904      8457   120      8624.741429      2411.221798 1035857640.758367 /bg_non_interactive</span><br><span class="line">   Binder:4770_2  4784  56040636.909456      1998   120      1417.464308      1494.671607 1035424488.218074 /</span><br><span class="line">   Profile Saver  4785    666861.514442        18   120       178.477925        14.420152 273671965.767069 /bg_non_interactive</span><br><span class="line"> ConditionReceiv  4794    879588.434399      3360   120     43331.675105      1305.894766 1035823588.266414 /bg_non_interactive</span><br><span class="line">        Thread-8  4904    181262.101046        56   130        20.672769        33.496619        48.157075 /bg_non_interactive</span><br><span class="line"> RecordEventThre  4910    666861.514442        49   120        17.687151        27.858386    103904.768787 /bg_non_interactive</span><br><span class="line">   Binder:4770_3  5561  56045598.341527      1909   120      1528.026623      1455.445159 1035569117.759708 /</span><br><span class="line">       Thread-16  5575    181248.254014         7   130         3.434847         6.637921         2.019385 /bg_non_interactive</span><br><span class="line"> d.process.acore  5111    874184.523887      4096   120     21237.654214     10989.644702 1023350227.407823 /bg_non_interactive</span><br><span class="line">   Binder:5111_2  5124  55483396.307495       596   120       169.122607       325.324772 1023395587.511312 /</span><br><span class="line">   kworker/u21:0  5687  33744440.423756       102   100        40.813461        14.185077 524973868.959958 /</span><br><span class="line">   Binder:5931_1  5943  56009944.247145       627   120       562.623919       337.453074 1034896321.554501 /</span><br><span class="line"> StatsUploadThre  5975    879102.820921     12964   120     56768.383155     10396.350566 1034828927.067921 /bg_non_interactive</span><br><span class="line"> Jit thread pool  6029    427550.143762        29   129       152.545075        54.487619 300292195.461302 /bg_non_interactive</span><br><span class="line">   Profile Saver  6041    185485.753638         5   120         0.283693         8.097461      1999.721390 /bg_non_interactive</span><br><span class="line">     kworker/1:3  6056  56084928.535768    448944   120   1279332.124868    159772.562317 1034815615.660702 /</span><br><span class="line"> Jit thread pool  6361    342485.585058        33   129        83.270536        61.345310 160816105.186243 /bg_non_interactive</span><br><span class="line"> ReferenceQueueD  8518    877556.086560       686   120       559.598381        68.911077 1011842445.257233 /bg_non_interactive</span><br><span class="line">   Binder:8508_2  8523  55802328.453773       525   120       225.832153       331.340910 1011842507.836394 /</span><br><span class="line">   Profile Saver  8526    264257.453028        11   120        28.885769         7.460693      1999.320081 /bg_non_interactive</span><br><span class="line"> pool-1-thread-1 22257    827072.120048        26   120       164.788613       236.237080      2974.943391 /bg_non_interactive</span><br><span class="line"> UsageStatsManag 22276    827072.120048        26   120        47.843462        33.031229       512.854541 /bg_non_interactive</span><br><span class="line"> UsageStats_Logg 22277    827072.120048         3   120         0.206154        19.030845       449.737925 /bg_non_interactive</span><br><span class="line">     kworker/1:4  3613  56084928.545460    466968   120   1049002.550413    368339.677530 794046072.191231 /</span><br><span class="line"> fe:MzSecService 32195    879888.601495     22266   120     58229.455896    151346.434086 560491639.947313 /bg_non_interactive</span><br><span class="line"> FinalizerWatchd 32205    879888.204058      1875   120      1640.302002       380.980634 560718993.852163 /bg_non_interactive</span><br><span class="line">  HeapTaskDaemon 32206    879884.804111      2065   120      3651.827370      3054.816190 560699306.952971 /bg_non_interactive</span><br><span class="line">   Profile Saver 32209    877466.255866        31   120        14.999769        33.448307  42300740.930388 /bg_non_interactive</span><br><span class="line"> pool-1-thread-1 32211    877466.255866        58   120        17.607848        35.805462     13491.527491 /bg_non_interactive</span><br><span class="line"> TMS_THREAD_POOL 32216    877466.255866         6   120        17.231384         4.979692      3223.318085 /bg_non_interactive</span><br><span class="line"> RxComputationSc 32231    879700.294340     12062   120     46238.573074     13109.753767 560640684.713513 /bg_non_interactive</span><br><span class="line">  Binder:32195_3  4536    877466.255866       217   120       178.859617        98.341914 518701970.511164 /bg_non_interactive</span><br><span class="line">  Binder:32195_5 11799    877466.255866       225   120        49.848075        88.434609 461756243.003943 /bg_non_interactive</span><br><span class="line">  Binder:32195_6 11800    877466.255866       199   120        78.836919        82.805016 461756167.823158 /bg_non_interactive</span><br><span class="line">  Binder:32195_7 16999    877466.641636       168   120        47.848227        73.005323 425629509.722716 /bg_non_interactive</span><br><span class="line">  Binder:32195_8 21958  55802342.747157       155   120        43.053926        55.632616 382425104.003803 /</span><br><span class="line">  Binder:32195_9 32130    877466.255866       129   120        57.017692        30.586010 288948228.980481 /bg_non_interactive</span><br><span class="line">  Binder:32195_A 11525    877466.255866        75   120        41.355383        21.630611 202529484.478545 /bg_non_interactive</span><br><span class="line">  Binder:32195_B 11526    877466.255866        66   120         8.906075        27.998465 202529490.582460 /bg_non_interactive</span><br><span class="line">  Binder:32195_D 31879    877470.176251        32   120         2.393538         5.008769  29704629.972819 /bg_non_interactive</span><br><span class="line"> pool-1-thread-1  7402    659166.582163        10   120         0.423385         6.709615        56.299231 /bg_non_interactive</span><br><span class="line"> StatsUploadThre  7403    873024.303640       283   120      4181.570620       329.628774 497953384.596307 /bg_non_interactive</span><br><span class="line"> pool-10-thread-  7411    659200.182852        17   120         2.788923         7.052540        21.836768 /bg_non_interactive</span><br><span class="line"> xiaoyuan-ipool2  7416    660020.226869        71   139        24.325766        84.926388        72.681924 /bg_non_interactive</span><br><span class="line"> xy_update_pubin  7427    663033.103871        25   130        10.895387        21.876152      2000.079235 /bg_non_interactive</span><br><span class="line"> Jit thread pool  7443    872285.772842        25   129       416.071385        34.537771 497582451.763115 /bg_non_interactive</span><br><span class="line">   Binder:7438_2  7451  56011891.861905       792   120       359.527154       444.379243 510187118.842846 /</span><br><span class="line"> RecordEventThre  7457    666234.679271        53   120        20.782694        21.278077       227.769233 /bg_non_interactive</span><br><span class="line"> pool-1-thread-1  7464    847435.328289        57   120       117.316072        51.842235 435111434.820875 /bg_non_interactive</span><br><span class="line">         GslbLog  7466    666234.679271         5   120        14.529231         5.980308        36.965692 /bg_non_interactive</span><br><span class="line"> iatek.mtklogger 26890  55341346.736371       196   120       400.568619       554.115002  72912363.573059 /</span><br><span class="line">            JDWP 26898  52248143.841881         3   120        10.140000         2.687847         0.337077 /</span><br><span class="line">  Binder:26890_2 26904  52248147.021651         4   120         0.979847         3.568539      1442.756541 /</span><br><span class="line">        Thread-4 26910  52248145.619651         9   120         9.059616         7.356615         0.000000 /</span><br><span class="line">        Thread-6 26912  52248145.619651         8   120         6.151538         7.693923        12.106539 /</span><br><span class="line"> calendar:remote  4185    879173.282384       405   120      1205.021839      1177.336782  11878945.360857 /bg_non_interactive</span><br><span class="line"> UsageStatsManag  4221    874255.869878        22   120        16.338923        10.703769       180.499846 /bg_non_interactive</span><br><span class="line"> UsageStats_Logg  4222    879077.960539        66   120       434.468075        78.005699  11880008.743782 /bg_non_interactive</span><br><span class="line"> StatsUploadThre  4226    879083.960922       151   120       749.630460       139.289086  11879550.132628 /bg_non_interactive</span><br><span class="line">         GslbLog  4227    874243.192648        14   120         5.584462         5.669845        22.937154 /bg_non_interactive</span><br><span class="line">R             sh  5914  56084976.869536        76   120        55.309925       185.528918     16060.396349 /</span><br></pre></td></tr></table></figure>
<h3 id="2-2-10、”-proc-schedstat”-amp-“-proc-pid-schedstat”"><a href="#2-2-10、”-proc-schedstat”-amp-“-proc-pid-schedstat”" class="headerlink" title="2.2.10、”/proc/schedstat” &amp; “/proc/pid/schedstat”"></a>2.2.10、”/proc/schedstat” &amp; “/proc/pid/schedstat”</h3><p>我们可以通过”/proc/schedstat”读出cpu级别的一些调度统计，具体的代码实现在kernel/sched/stats.c show_schedstat()中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># cat /proc/schedstat</span><br><span class="line">version 15</span><br><span class="line">timestamp 4555707576</span><br><span class="line">cpu0 498206 0 292591647 95722605 170674079 157871909 155819980602662 147733290481281 195127878      /* runqueue-specific stats */</span><br><span class="line">domain0 003 5 5 0 0 0 0 0 5 0 0 0 0 0 0 0 0 7 7 0 0 0 0 7 0 0 0 0 0 0 0 0 0 0 14 1 0                /* domain-specific stats */</span><br><span class="line">domain1 113 5 5 0 0 0 0 0 5 0 0 0 0 0 0 0 0 7 7 0 0 0 0 0 7 0 0 0 0 0 0 0 0 0 17 0 0</span><br><span class="line">cpu1 329113 0 52366034 13481657 28584254 20127852 44090575379688 34066018366436 37345579</span><br><span class="line">domain0 003 4 4 0 0 0 0 1 3 0 0 0 0 0 0 0 0 4 3 0 2 1 0 2 1 0 0 0 0 0 0 0 0 0 9 3 0</span><br><span class="line">domain1 113 4 4 0 0 0 0 0 1 0 0 0 0 0 0 0 0 3 3 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 7 0 0</span><br><span class="line">cpu4 18835 0 13439942 5205662 8797513 2492988 14433736408037 4420752361838 7857723</span><br><span class="line">domain0 113 0 0 0 0 1 0 0 0 1 1 0 0 0 0 0 1 3 2 1 201 0 0 0 2 1 0 1 0 0 0 0 0 0 8 7 0</span><br><span class="line">cpu8 32417 0 13380391 4938475 9351290 2514217 10454988559488 3191584640696 7933881</span><br><span class="line">domain0 113 1 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 7 8 0</span><br></pre></td></tr></table></figure>
<p>可以通过”/proc/pid/schedstat”读出进程级别的调度统计，具体的代码在fs/proc/base.c proc_pid_schedstat()中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># cat /proc/824/schedstat</span><br><span class="line">29099619 5601999 20             /* task-&gt;se.sum_exec_runtime, task-&gt;sched_info.run_delay, task-&gt;sched_info.pcount */</span><br></pre></td></tr></table></figure>
<h2 id="2-3、RT调度算法"><a href="#2-3、RT调度算法" class="headerlink" title="2.3、RT调度算法"></a>2.3、RT调度算法</h2><p>分析完normal进程的cfs调度算法，我们再来看看rt进程(SCHED_RR/SCHED_FIFO)的调度算法。RT的调度算法改动很小，组织形式还是以前的链表数组，rq-&gt;rt_rq.active.queue[MAX_RT_PRIO]包含100个(0-99)个数组链表用来存储runnable的rt线程。rt进程的调度通过rt_sched_class系列函数来实现。</p>
<ul>
<li><p>SCHED_FIFO类型的rt进程调度比较简单，优先级最高的一直运行，直到主动放弃运行。</p>
</li>
<li><p>SCHED_RR类型的rt进程在相同优先级下进行时间片调度，每个时间片的时间长短可以通过sched_rr_timeslice变量来控制：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># cat /proc/sys/kernel/sched_rr_timeslice_ms  // SCHED_RR的时间片为25ms</span><br><span class="line">25</span><br></pre></td></tr></table></figure>
<h3 id="2-3-1、task-tick-rt"><a href="#2-3-1、task-tick-rt" class="headerlink" title="2.3.1、task_tick_rt()"></a>2.3.1、task_tick_rt()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line">scheduler_tick() -&gt; task_tick_rt()</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static void task_tick_rt(struct rq *rq, struct task_struct *p, int queued)</span><br><span class="line">&#123;</span><br><span class="line">	struct sched_rt_entity *rt_se = &amp;p-&gt;rt;</span><br><span class="line"></span><br><span class="line">    /* (1) 更新时间统计、rt-throttle计算 */</span><br><span class="line">	update_curr_rt(rq);</span><br><span class="line">    </span><br><span class="line">    /* (2) 更新rt的capacity request */</span><br><span class="line">	sched_rt_update_capacity_req(rq);</span><br><span class="line"></span><br><span class="line">	watchdog(rq, p);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * RR tasks need a special form of timeslice management.</span><br><span class="line">	 * FIFO tasks have no timeslices.</span><br><span class="line">	 */</span><br><span class="line">	/* (3) 如果是SCHED_FIFO类型的rt进行，不进行时间片调度直接返回 */</span><br><span class="line">	if (p-&gt;policy != SCHED_RR)</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	if (--p-&gt;rt.time_slice)</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">    /* (4) SCHED_RR类型的时间片用完重置时间片，</span><br><span class="line">        时间片大小为sched_rr_timeslice </span><br><span class="line">     */</span><br><span class="line">	p-&gt;rt.time_slice = sched_rr_timeslice;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Requeue to the end of queue if we (and all of our ancestors) are not</span><br><span class="line">	 * the only element on the queue</span><br><span class="line">	 */</span><br><span class="line">	/* (5) 如果SCHED_RR类型的时间片已经用完，进行Round-Robin，</span><br><span class="line">	    将当前进程移到本优先级的链表尾部，换链表头部进程运行</span><br><span class="line">	 */</span><br><span class="line">	for_each_sched_rt_entity(rt_se) &#123;</span><br><span class="line">		if (rt_se-&gt;run_list.prev != rt_se-&gt;run_list.next) &#123;</span><br><span class="line">			requeue_task_rt(rq, p, 0);</span><br><span class="line">			resched_curr(rq);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">static void update_curr_rt(struct rq *rq)</span><br><span class="line">&#123;</span><br><span class="line">	struct task_struct *curr = rq-&gt;curr;</span><br><span class="line">	struct sched_rt_entity *rt_se = &amp;curr-&gt;rt;</span><br><span class="line">	u64 delta_exec;</span><br><span class="line">	int cpu = rq_cpu(rq);</span><br><span class="line">#ifdef CONFIG_MTK_RT_THROTTLE_MON</span><br><span class="line">	struct rt_rq *cpu_rt_rq;</span><br><span class="line">	u64 runtime;</span><br><span class="line">	u64 old_exec_start;</span><br><span class="line"></span><br><span class="line">	old_exec_start = curr-&gt;se.exec_start;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	if (curr-&gt;sched_class != &amp;rt_sched_class)</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	per_cpu(update_exec_start, rq-&gt;cpu) = curr-&gt;se.exec_start;</span><br><span class="line">	/* (1.1) 计算距离上一次的delta时间 */</span><br><span class="line">	delta_exec = rq_clock_task(rq) - curr-&gt;se.exec_start;</span><br><span class="line">	if (unlikely((s64)delta_exec &lt;= 0))</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	schedstat_set(curr-&gt;se.statistics.exec_max,</span><br><span class="line">		      max(curr-&gt;se.statistics.exec_max, delta_exec));</span><br><span class="line"></span><br><span class="line">	/* sched:update rt exec info*/</span><br><span class="line">	/* (1.2) 记录当前rt的exec info，在故障时吐出 */</span><br><span class="line">	per_cpu(exec_task, cpu).pid = curr-&gt;pid;</span><br><span class="line">	per_cpu(exec_task, cpu).prio = curr-&gt;prio;</span><br><span class="line">	strncpy(per_cpu(exec_task, cpu).comm, curr-&gt;comm, sizeof(per_cpu(exec_task, cpu).comm));</span><br><span class="line">	per_cpu(exec_delta_time, cpu) = delta_exec;</span><br><span class="line">	per_cpu(clock_task, cpu) = rq-&gt;clock_task;</span><br><span class="line">	per_cpu(exec_start, cpu) = curr-&gt;se.exec_start;</span><br><span class="line"></span><br><span class="line">    /* (1.3) 统计task所在线程组(thread group)的运行时间：</span><br><span class="line">		tsk-&gt;signal-&gt;cputimer.cputime_atomic.sum_exec_runtime</span><br><span class="line">	 */</span><br><span class="line">	curr-&gt;se.sum_exec_runtime += delta_exec;</span><br><span class="line">	account_group_exec_runtime(curr, delta_exec);</span><br><span class="line"></span><br><span class="line">    /* (1.4) 更新task所在cgroup之cpuacct的某个cpu运行时间ca-&gt;cpuusage[cpu]-&gt;cpuusage */</span><br><span class="line">	curr-&gt;se.exec_start = rq_clock_task(rq);</span><br><span class="line">	cpuacct_charge(curr, delta_exec);</span><br><span class="line"></span><br><span class="line">    /* (1.5) 累加时间*freq_capacity到rq-&gt;rt_avg */</span><br><span class="line">	sched_rt_avg_update(rq, delta_exec);</span><br><span class="line"></span><br><span class="line">	per_cpu(sched_update_exec_start, rq-&gt;cpu) = per_cpu(update_curr_exec_start, rq-&gt;cpu);</span><br><span class="line">	per_cpu(update_curr_exec_start, rq-&gt;cpu) = sched_clock_cpu(rq-&gt;cpu);</span><br><span class="line"></span><br><span class="line">    /* (1.6) 流控使能则进行流控计算  */</span><br><span class="line">	if (!rt_bandwidth_enabled())</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_MTK_RT_THROTTLE_MON</span><br><span class="line">	cpu_rt_rq = rt_rq_of_se(rt_se);</span><br><span class="line">	runtime = sched_rt_runtime(cpu_rt_rq);</span><br><span class="line">	if (cpu_rt_rq-&gt;rt_time == 0 &amp;&amp; !(cpu_rt_rq-&gt;rt_throttled)) &#123;</span><br><span class="line">		if (old_exec_start &lt; per_cpu(rt_period_time, cpu) &amp;&amp;</span><br><span class="line">			(per_cpu(old_rt_time, cpu) + delta_exec) &gt; runtime) &#123;</span><br><span class="line">			save_mt_rt_mon_info(cpu, delta_exec, curr);</span><br><span class="line">			mt_rt_mon_switch(MON_STOP, cpu);</span><br><span class="line">			mt_rt_mon_print_task(cpu);</span><br><span class="line">		&#125;</span><br><span class="line">		mt_rt_mon_switch(MON_RESET, cpu);</span><br><span class="line">		mt_rt_mon_switch(MON_START, cpu);</span><br><span class="line">		update_mt_rt_mon_start(cpu, delta_exec);</span><br><span class="line">	&#125;</span><br><span class="line">	save_mt_rt_mon_info(cpu, delta_exec, curr);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	for_each_sched_rt_entity(rt_se) &#123;</span><br><span class="line">		struct rt_rq *rt_rq = rt_rq_of_se(rt_se);</span><br><span class="line"></span><br><span class="line">		if (sched_rt_runtime(rt_rq) != RUNTIME_INF) &#123;</span><br><span class="line">			raw_spin_lock(&amp;rt_rq-&gt;rt_runtime_lock);</span><br><span class="line">			/* (1.7) 流控计算：</span><br><span class="line">			    rt_rq-&gt;rt_time：为rt_rq在本周期内已经运行的时间</span><br><span class="line">			    rt_rq-&gt;rt_runtime：为rt_rq在本周期内可以运行的时间  //950ms</span><br><span class="line">			    rt_rq-&gt;tg-&gt;rt_bandwidth.rt_period：为一个周期的大小  //1s</span><br><span class="line">			    如果rt_rq-&gt;rt_time &gt; rt_rq-&gt;rt_runtime，则发生rt-throttle了</span><br><span class="line">			 */</span><br><span class="line">			rt_rq-&gt;rt_time += delta_exec;</span><br><span class="line">			if (sched_rt_runtime_exceeded(rt_rq))</span><br><span class="line">				resched_curr(rq);</span><br><span class="line">			raw_spin_unlock(&amp;rt_rq-&gt;rt_runtime_lock);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">static inline void sched_rt_avg_update(struct rq *rq, u64 rt_delta)</span><br><span class="line">&#123;</span><br><span class="line">    /* (1.5.1) 累加时间*freq_capacity到rq-&gt;rt_avg ，</span><br><span class="line">        注意时间单位都是ns</span><br><span class="line">     */</span><br><span class="line">	rq-&gt;rt_avg += rt_delta * arch_scale_freq_capacity(NULL, cpu_of(rq));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-2、rq-gt-rt-avg"><a href="#2-3-2、rq-gt-rt-avg" class="headerlink" title="2.3.2、rq-&gt;rt_avg"></a>2.3.2、rq-&gt;rt_avg</h3><p>我们计算rq-&gt;rt_avg(累加时间*freq_capacity)，主要目的是给CPU_FREQ_GOV_SCHED使用。</p>
<p>CONFIG_CPU_FREQ_GOV_SCHED的主要思想是cfs和rt分别计算cpu_sched_capacity_reqs中的rt、cfs部分，在update_cpu_capacity_request()中综合cfs和rt的freq_capacity request，调用cpufreq框架调整一个合适的cpu频率。CPU_FREQ_GOV_SCHED是用来取代interactive governor的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">/* (1) cfs对cpu freq capcity的request，</span><br><span class="line">    per_cpu(cpu_sched_capacity_reqs, cpu).cfs</span><br><span class="line"> */</span><br><span class="line">static inline void set_cfs_cpu_capacity(int cpu, bool request,</span><br><span class="line">					unsigned long capacity, int type)</span><br><span class="line">&#123;</span><br><span class="line">#ifdef CONFIG_CPU_FREQ_SCHED_ASSIST</span><br><span class="line">	if (true) &#123;</span><br><span class="line">#else</span><br><span class="line">	if (per_cpu(cpu_sched_capacity_reqs, cpu).cfs != capacity) &#123;</span><br><span class="line">#endif</span><br><span class="line">		per_cpu(cpu_sched_capacity_reqs, cpu).cfs = capacity;</span><br><span class="line">		update_cpu_capacity_request(cpu, request, type);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* (2) rt对cpu freq capcity的request，</span><br><span class="line">    per_cpu(cpu_sched_capacity_reqs, cpu).rt</span><br><span class="line"> */</span><br><span class="line">static inline void set_rt_cpu_capacity(int cpu, bool request,</span><br><span class="line">				       unsigned long capacity,</span><br><span class="line">					int type)</span><br><span class="line">&#123;</span><br><span class="line">#ifdef CONFIG_CPU_FREQ_SCHED_ASSIST</span><br><span class="line">	if (true) &#123;</span><br><span class="line">#else</span><br><span class="line">	if (per_cpu(cpu_sched_capacity_reqs, cpu).rt != capacity) &#123;</span><br><span class="line">#endif</span><br><span class="line">		per_cpu(cpu_sched_capacity_reqs, cpu).rt = capacity;</span><br><span class="line">		update_cpu_capacity_request(cpu, request, type);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* (3) 综合cfs、rt的request，</span><br><span class="line">    调整cpu频率</span><br><span class="line"> */</span><br><span class="line">void update_cpu_capacity_request(int cpu, bool request, int type)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned long new_capacity;</span><br><span class="line">	struct sched_capacity_reqs *scr;</span><br><span class="line"></span><br><span class="line">	/* The rq lock serializes access to the CPU&apos;s sched_capacity_reqs. */</span><br><span class="line">	lockdep_assert_held(&amp;cpu_rq(cpu)-&gt;lock);</span><br><span class="line"></span><br><span class="line">	scr = &amp;per_cpu(cpu_sched_capacity_reqs, cpu);</span><br><span class="line"></span><br><span class="line">	new_capacity = scr-&gt;cfs + scr-&gt;rt;</span><br><span class="line">	new_capacity = new_capacity * capacity_margin_dvfs</span><br><span class="line">		/ SCHED_CAPACITY_SCALE;</span><br><span class="line">	new_capacity += scr-&gt;dl;</span><br><span class="line"></span><br><span class="line">#ifndef CONFIG_CPU_FREQ_SCHED_ASSIST</span><br><span class="line">	if (new_capacity == scr-&gt;total)</span><br><span class="line">		return;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	scr-&gt;total = new_capacity;</span><br><span class="line">	if (request)</span><br><span class="line">		update_fdomain_capacity_request(cpu, type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>针对CONFIG_CPU_FREQ_GOV_SCHED，rt有3条关键计算路径：</p>
<ul>
<li>1、rt负载的(rq-&gt;rt_avg)的累加：scheduler_tick() -&gt; task_tick_rt() -&gt; update_curr_rt() -&gt; sched_rt_avg_update()</li>
<li><p>2、rt负载的老化：scheduler_tick() -&gt; <strong>update_cpu_load() -&gt; </strong>update_cpu_load() -&gt; sched_avg_update()</p>
<pre><code>或者scheduler_tick() -&gt; task_tick_rt() -&gt; sched_rt_update_capacity_req() -&gt; sched_avg_update()
</code></pre></li>
<li><p>3、rt request的更新：scheduler_tick() -&gt; task_tick_rt() -&gt; sched_rt_update_capacity_req() -&gt; set_rt_cpu_capacity()</p>
</li>
</ul>
<p>同样，cfs也有3条关键计算路径：</p>
<ul>
<li>1、cfs负载的(rq-&gt;rt_avg)的累加：</li>
<li>2、cfs负载的老化：</li>
<li>3、cfs request的更新：scheduler_tick() -&gt; sched_freq_tick() -&gt; set_cfs_cpu_capacity()</li>
</ul>
<p>在进行smp的loadbalance时也有相关计算：run_rebalance_domains() -&gt; rebalance_domains() -&gt; load_balance() -&gt; find_busiest_group() -&gt; update_sd_lb_stats() -&gt; update_group_capacity() -&gt; update_cpu_capacity() -&gt; scale_rt_capacity()</p>
<p>我们首先对rt部分的路径进行分析：</p>
<ul>
<li>rt负载老化sched_avg_update()：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">void sched_avg_update(struct rq *rq)</span><br><span class="line">&#123;</span><br><span class="line">    /* (1) 默认老化周期为1s/2 = 500ms */</span><br><span class="line">	s64 period = sched_avg_period();</span><br><span class="line"></span><br><span class="line">	while ((s64)(rq_clock(rq) - rq-&gt;age_stamp) &gt; period) &#123;</span><br><span class="line">		/*</span><br><span class="line">		 * Inline assembly required to prevent the compiler</span><br><span class="line">		 * optimising this loop into a divmod call.</span><br><span class="line">		 * See __iter_div_u64_rem() for another example of this.</span><br><span class="line">		 */</span><br><span class="line">		asm(&quot;&quot; : &quot;+rm&quot; (rq-&gt;age_stamp));</span><br><span class="line">		rq-&gt;age_stamp += period;</span><br><span class="line">		/* (2) 每个老化周期，负载老化为原来的1/2 */</span><br><span class="line">		rq-&gt;rt_avg /= 2;</span><br><span class="line">		rq-&gt;dl_avg /= 2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">static inline u64 sched_avg_period(void)</span><br><span class="line">&#123;</span><br><span class="line">    /* (1.1) 老化周期 = sysctl_sched_time_avg/2 = 500ms */</span><br><span class="line">	return (u64)sysctl_sched_time_avg * NSEC_PER_MSEC / 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * period over which we average the RT time consumption, measured</span><br><span class="line"> * in ms.</span><br><span class="line"> *</span><br><span class="line"> * default: 1s</span><br><span class="line"> */</span><br><span class="line">const_debug unsigned int sysctl_sched_time_avg = MSEC_PER_SEC;</span><br></pre></td></tr></table></figure>
<ul>
<li>rt frq_capability request的更新：scheduler_tick() -&gt; task_tick_rt() -&gt; sched_rt_update_capacity_req() -&gt; set_rt_cpu_capacity()</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">static void sched_rt_update_capacity_req(struct rq *rq)</span><br><span class="line">&#123;</span><br><span class="line">	u64 total, used, age_stamp, avg;</span><br><span class="line">	s64 delta;</span><br><span class="line"></span><br><span class="line">	if (!sched_freq())</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">    /* (1) 最新的负载进行老化 */</span><br><span class="line">	sched_avg_update(rq);</span><br><span class="line">	/*</span><br><span class="line">	 * Since we&apos;re reading these variables without serialization make sure</span><br><span class="line">	 * we read them once before doing sanity checks on them.</span><br><span class="line">	 */</span><br><span class="line">	age_stamp = READ_ONCE(rq-&gt;age_stamp);</span><br><span class="line">	/* (2) avg=老化后的负载 */</span><br><span class="line">	avg = READ_ONCE(rq-&gt;rt_avg);</span><br><span class="line">	delta = rq_clock(rq) - age_stamp;</span><br><span class="line"></span><br><span class="line">	if (unlikely(delta &lt; 0))</span><br><span class="line">		delta = 0;</span><br><span class="line"></span><br><span class="line">    /* (3) total时间=一个老化周期+上次老化剩余时间 */</span><br><span class="line">	total = sched_avg_period() + delta;</span><br><span class="line"></span><br><span class="line">    /* (4) avg/total=request，(最大频率=1024) */</span><br><span class="line">	used = div_u64(avg, total);</span><br><span class="line">	if (unlikely(used &gt; SCHED_CAPACITY_SCALE))</span><br><span class="line">		used = SCHED_CAPACITY_SCALE;</span><br><span class="line"></span><br><span class="line">    /* (5) update request */</span><br><span class="line">	set_rt_cpu_capacity(rq-&gt;cpu, true, (unsigned long)(used), SCHE_ONESHOT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-3、rt-bandwidth-rt-throttle"><a href="#2-3-3、rt-bandwidth-rt-throttle" class="headerlink" title="2.3.3、rt bandwidth(rt-throttle)"></a>2.3.3、rt bandwidth(rt-throttle)</h3><p>基于时间我们还可以对的rt进程进行带宽控制(bandwidth)，超过流控禁止进程运行。这也叫rt-throttle。</p>
<ul>
<li>rt-throttle的原理是：规定一个监控周期，在这个周期里rt进程的运行时间不能超过一定时间，如果超过则进入rt-throttle状态，进程被强行停止运行退出rt_rq，且rt_rq也不能接受新的进程来运行，直到下一个周期开始才能退出rt-throttle状态，同时开始下一个周期的bandwidth计算。这样就达到了带宽控制的目的。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># cat /proc/sys/kernel/sched_rt_period_us  // rt-throttle的周期是1s</span><br><span class="line">1000000</span><br><span class="line"></span><br><span class="line"># cat /proc/sys/kernel/sched_rt_runtime_us // rt-throttle在一个周期里，可运行的时间为950ms</span><br><span class="line">950000</span><br></pre></td></tr></table></figure>
<p>上面这个实例的意思就是rt-throttle的周期是1s，1s周期内可以运行的时间为950ms。rt进程在1s以内如果运行时间达到950ms则会被强行停止，1s时间到了以后才会被恢复，这样进程就被强行停止了50ms。</p>
<p><img src="/images/scheduler/schedule_rt-throttle.png" alt="schedule_rt-throttle"></p>
<p>下面我们来具体分析一下具体代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line">scheduler_tick() -&gt; task_tick_rt()</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static void task_tick_rt(struct rq *rq, struct task_struct *p, int queued)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    /* (1) 更新时间统计、rt-throttle计算 */</span><br><span class="line">	update_curr_rt(rq);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">static void update_curr_rt(struct rq *rq)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /* (1.6) 流控使能则进行流控计算  */</span><br><span class="line">	if (!rt_bandwidth_enabled())</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_MTK_RT_THROTTLE_MON</span><br><span class="line">	cpu_rt_rq = rt_rq_of_se(rt_se);</span><br><span class="line">	runtime = sched_rt_runtime(cpu_rt_rq);</span><br><span class="line">	if (cpu_rt_rq-&gt;rt_time == 0 &amp;&amp; !(cpu_rt_rq-&gt;rt_throttled)) &#123;</span><br><span class="line">		if (old_exec_start &lt; per_cpu(rt_period_time, cpu) &amp;&amp;</span><br><span class="line">			(per_cpu(old_rt_time, cpu) + delta_exec) &gt; runtime) &#123;</span><br><span class="line">			save_mt_rt_mon_info(cpu, delta_exec, curr);</span><br><span class="line">			mt_rt_mon_switch(MON_STOP, cpu);</span><br><span class="line">			mt_rt_mon_print_task(cpu);</span><br><span class="line">		&#125;</span><br><span class="line">		mt_rt_mon_switch(MON_RESET, cpu);</span><br><span class="line">		mt_rt_mon_switch(MON_START, cpu);</span><br><span class="line">		update_mt_rt_mon_start(cpu, delta_exec);</span><br><span class="line">	&#125;</span><br><span class="line">	save_mt_rt_mon_info(cpu, delta_exec, curr);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	for_each_sched_rt_entity(rt_se) &#123;</span><br><span class="line">		struct rt_rq *rt_rq = rt_rq_of_se(rt_se);</span><br><span class="line"></span><br><span class="line">		if (sched_rt_runtime(rt_rq) != RUNTIME_INF) &#123;</span><br><span class="line">			raw_spin_lock(&amp;rt_rq-&gt;rt_runtime_lock);</span><br><span class="line">			/* (1.7) 流控计算：</span><br><span class="line">			    rt_rq-&gt;rt_time：为rt_rq在本周期内已经运行的时间</span><br><span class="line">			    rt_rq-&gt;rt_runtime：为rt_rq在本周期内可以运行的时间  //950ms</span><br><span class="line">			    rt_rq-&gt;tg-&gt;rt_bandwidth.rt_period：为一个周期的大小  //1s</span><br><span class="line">			    如果rt_rq-&gt;rt_time &gt; rt_rq-&gt;rt_runtime，则发生rt-throttle了</span><br><span class="line">			 */</span><br><span class="line">			rt_rq-&gt;rt_time += delta_exec;</span><br><span class="line">			if (sched_rt_runtime_exceeded(rt_rq))</span><br><span class="line">				resched_curr(rq);</span><br><span class="line">			raw_spin_unlock(&amp;rt_rq-&gt;rt_runtime_lock);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">||→</span><br><span class="line"></span><br><span class="line">static int sched_rt_runtime_exceeded(struct rt_rq *rt_rq)</span><br><span class="line">&#123;</span><br><span class="line">	u64 runtime = sched_rt_runtime(rt_rq);</span><br><span class="line">	u64 runtime_pre;</span><br><span class="line"></span><br><span class="line">	if (rt_rq-&gt;rt_throttled)</span><br><span class="line">		return rt_rq_throttled(rt_rq);</span><br><span class="line"></span><br><span class="line">	if (runtime &gt;= sched_rt_period(rt_rq))</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">	/* sched:get runtime*/</span><br><span class="line">	/* (1.7.1) 如果已经达到条件(rt_rq-&gt;rt_time &gt; rt_rq-&gt;rt_runtime)</span><br><span class="line">	    尝试向同一root_domain的其他cpu来借运行时间进行loadbalance，// 那其他cpu也必须在跑rt任务吧？</span><br><span class="line">	    借了时间以后其他cpu的实时额度会减少iter-&gt;rt_runtime -= diff，</span><br><span class="line">	    本cpu的实时额度会增大rt_rq-&gt;rt_runtime += diff，</span><br><span class="line">	 */</span><br><span class="line">	runtime_pre = runtime;</span><br><span class="line">	balance_runtime(rt_rq);</span><br><span class="line">	runtime = sched_rt_runtime(rt_rq);</span><br><span class="line">	if (runtime == RUNTIME_INF)</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">    /* (1.7.2) 做完loadbalance以后，已运行时间还是超过了额度时间，</span><br><span class="line">        说明已经达到rt-throttle</span><br><span class="line">     */</span><br><span class="line">	if (rt_rq-&gt;rt_time &gt; runtime) &#123;</span><br><span class="line">		struct rt_bandwidth *rt_b = sched_rt_bandwidth(rt_rq);</span><br><span class="line">#ifdef CONFIG_RT_GROUP_SCHED</span><br><span class="line">		int cpu = rq_cpu(rt_rq-&gt;rq);</span><br><span class="line">		/* sched:print throttle*/</span><br><span class="line">		printk_deferred(&quot;[name:rt&amp;]sched: initial rt_time %llu, start at %llu\n&quot;,</span><br><span class="line">				per_cpu(init_rt_time, cpu), per_cpu(rt_period_time, cpu));</span><br><span class="line">		printk_deferred(&quot;[name:rt&amp;]sched: cpu=%d rt_time %llu &lt;-&gt; runtime&quot;,</span><br><span class="line">				cpu, rt_rq-&gt;rt_time);</span><br><span class="line">		printk_deferred(&quot; [%llu -&gt; %llu], exec_task[%d:%s], prio=%d, exec_delta_time[%llu]&quot;,</span><br><span class="line">				runtime_pre, runtime,</span><br><span class="line">				per_cpu(exec_task, cpu).pid,</span><br><span class="line">				per_cpu(exec_task, cpu).comm,</span><br><span class="line">				per_cpu(exec_task, cpu).prio,</span><br><span class="line">				per_cpu(exec_delta_time, cpu));</span><br><span class="line">		printk_deferred(&quot;, clock_task[%llu], exec_start[%llu]\n&quot;,</span><br><span class="line">				per_cpu(clock_task, cpu), per_cpu(exec_start, cpu));</span><br><span class="line">		printk_deferred(&quot;[name:rt&amp;]update[%llu,%llu], pick[%llu, %llu], set_curr[%llu, %llu]\n&quot;,</span><br><span class="line">				per_cpu(update_exec_start, cpu), per_cpu(sched_update_exec_start, cpu),</span><br><span class="line">				per_cpu(pick_exec_start, cpu), per_cpu(sched_pick_exec_start, cpu),</span><br><span class="line">				per_cpu(set_curr_exec_start, cpu), per_cpu(sched_set_curr_exec_start, cpu));</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">		/*</span><br><span class="line">		 * Don&apos;t actually throttle groups that have no runtime assigned</span><br><span class="line">		 * but accrue some time due to boosting.</span><br><span class="line">		 */</span><br><span class="line">		if (likely(rt_b-&gt;rt_runtime)) &#123;</span><br><span class="line">		    /* (1.7.3) rt-throttle标志置位 */</span><br><span class="line">			rt_rq-&gt;rt_throttled = 1;</span><br><span class="line">			/* sched:print throttle every time*/</span><br><span class="line">			printk_deferred(&quot;sched: RT throttling activated\n&quot;);</span><br><span class="line">#ifdef CONFIG_RT_GROUP_SCHED</span><br><span class="line">			mt_sched_printf(sched_rt_info, &quot;cpu=%d rt_throttled=%d&quot;,</span><br><span class="line">					cpu, rt_rq-&gt;rt_throttled);</span><br><span class="line">			per_cpu(rt_throttling_start, cpu) = rq_clock_task(rt_rq-&gt;rq);</span><br><span class="line">#ifdef CONFIG_MTK_RT_THROTTLE_MON</span><br><span class="line">			/* sched:rt throttle monitor */</span><br><span class="line">			mt_rt_mon_switch(MON_STOP, cpu);</span><br><span class="line">			mt_rt_mon_print_task(cpu);</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			/*</span><br><span class="line">			 * In case we did anyway, make it go away,</span><br><span class="line">			 * replenishment is a joke, since it will replenish us</span><br><span class="line">			 * with exactly 0 ns.</span><br><span class="line">			 */</span><br><span class="line">			rt_rq-&gt;rt_time = 0;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        /* (1.7.4) 如果达到rt-throttle，将rt_rq强行退出运行 */</span><br><span class="line">		if (rt_rq_throttled(rt_rq)) &#123;</span><br><span class="line">			sched_rt_rq_dequeue(rt_rq);</span><br><span class="line">			return 1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码中可以看到rt-throttle的计算方法大概如下：每个tick累加运行时间rt_rq-&gt;rt_time，周期内可运行的额度时间为rt_rq-&gt;rt_runtime(950ms)，一个周期大小为rt_rq-&gt;tg-&gt;rt_bandwidth.rt_period(默认1s)。如果(rt_rq-&gt;rt_time &gt; rt_rq-&gt;rt_runtime)，则发生rt-throttle了。</p>
<p>发生rt-throttle以后，rt_rq被强行退出，rt进程被强行停止运行。如果period 1s, runtime 950ms，那么任务会被强制停止50ms。但是下一个周期到来以后，任务需要退出rt-throttle状态。系统把周期计时和退出rt-throttle状态的工作放在hrtimer do_sched_rt_period_timer()中完成。</p>
<p>每个rt进程组task_group公用一个hrtimer sched_rt_period_timer()，在rt task_group创建时分配，在有进程入tg任何一个rt_rq时启动，在没有任务运行时hrtimer会停止运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">void init_rt_bandwidth(struct rt_bandwidth *rt_b, u64 period, u64 runtime)</span><br><span class="line">&#123;</span><br><span class="line">	rt_b-&gt;rt_period = ns_to_ktime(period);</span><br><span class="line">	rt_b-&gt;rt_runtime = runtime;</span><br><span class="line"></span><br><span class="line">	raw_spin_lock_init(&amp;rt_b-&gt;rt_runtime_lock);</span><br><span class="line"></span><br><span class="line">    /* (1) 初始化hrtimer的到期时间为rt_period_timer，默认1s */</span><br><span class="line">	hrtimer_init(&amp;rt_b-&gt;rt_period_timer,</span><br><span class="line">			CLOCK_MONOTONIC, HRTIMER_MODE_REL);</span><br><span class="line">	rt_b-&gt;rt_period_timer.function = sched_rt_period_timer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void start_rt_bandwidth(struct rt_bandwidth *rt_b)</span><br><span class="line">&#123;</span><br><span class="line">	if (!rt_bandwidth_enabled() || rt_b-&gt;rt_runtime == RUNTIME_INF)</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	raw_spin_lock(&amp;rt_b-&gt;rt_runtime_lock);</span><br><span class="line">	if (!rt_b-&gt;rt_period_active) &#123;</span><br><span class="line">		rt_b-&gt;rt_period_active = 1;</span><br><span class="line">		/* (2) 启动hrtimer */</span><br><span class="line">		hrtimer_forward_now(&amp;rt_b-&gt;rt_period_timer, rt_b-&gt;rt_period);</span><br><span class="line">		hrtimer_start_expires(&amp;rt_b-&gt;rt_period_timer, HRTIMER_MODE_ABS_PINNED);</span><br><span class="line">	&#125;</span><br><span class="line">	raw_spin_unlock(&amp;rt_b-&gt;rt_runtime_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看看timer时间到期后的操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line">static enum hrtimer_restart sched_rt_period_timer(struct hrtimer *timer)</span><br><span class="line">&#123;</span><br><span class="line">	struct rt_bandwidth *rt_b =</span><br><span class="line">		container_of(timer, struct rt_bandwidth, rt_period_timer);</span><br><span class="line">	int idle = 0;</span><br><span class="line">	int overrun;</span><br><span class="line"></span><br><span class="line">	raw_spin_lock(&amp;rt_b-&gt;rt_runtime_lock);</span><br><span class="line">	for (;;) &#123;</span><br><span class="line">		overrun = hrtimer_forward_now(timer, rt_b-&gt;rt_period);</span><br><span class="line">		if (!overrun)</span><br><span class="line">			break;</span><br><span class="line"></span><br><span class="line">		raw_spin_unlock(&amp;rt_b-&gt;rt_runtime_lock);</span><br><span class="line">		/* (1) 实际的timer处理 */</span><br><span class="line">		idle = do_sched_rt_period_timer(rt_b, overrun);</span><br><span class="line">		raw_spin_lock(&amp;rt_b-&gt;rt_runtime_lock);</span><br><span class="line">	&#125;</span><br><span class="line">	if (idle)</span><br><span class="line">		rt_b-&gt;rt_period_active = 0;</span><br><span class="line">	raw_spin_unlock(&amp;rt_b-&gt;rt_runtime_lock);</span><br><span class="line"></span><br><span class="line">    /* (2) 如果没有rt进程运行，idle状态，则hrtimer退出运行 */</span><br><span class="line">	return idle ? HRTIMER_NORESTART : HRTIMER_RESTART;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">static int do_sched_rt_period_timer(struct rt_bandwidth *rt_b, int overrun)</span><br><span class="line">&#123;</span><br><span class="line">	int i, idle = 1, throttled = 0;</span><br><span class="line">	const struct cpumask *span;</span><br><span class="line"></span><br><span class="line">	span = sched_rt_period_mask();</span><br><span class="line">#ifdef CONFIG_RT_GROUP_SCHED</span><br><span class="line">	/*</span><br><span class="line">	 * FIXME: isolated CPUs should really leave the root task group,</span><br><span class="line">	 * whether they are isolcpus or were isolated via cpusets, lest</span><br><span class="line">	 * the timer run on a CPU which does not service all runqueues,</span><br><span class="line">	 * potentially leaving other CPUs indefinitely throttled.  If</span><br><span class="line">	 * isolation is really required, the user will turn the throttle</span><br><span class="line">	 * off to kill the perturbations it causes anyway.  Meanwhile,</span><br><span class="line">	 * this maintains functionality for boot and/or troubleshooting.</span><br><span class="line">	 */</span><br><span class="line">	if (rt_b == &amp;root_task_group.rt_bandwidth)</span><br><span class="line">		span = cpu_online_mask;</span><br><span class="line">#endif</span><br><span class="line">    /* (1.1) 遍历root domain中的每一个cpu */</span><br><span class="line">	for_each_cpu(i, span) &#123;</span><br><span class="line">		int enqueue = 0;</span><br><span class="line">		struct rt_rq *rt_rq = sched_rt_period_rt_rq(rt_b, i);</span><br><span class="line">		struct rq *rq = rq_of_rt_rq(rt_rq);</span><br><span class="line"></span><br><span class="line">		raw_spin_lock(&amp;rq-&gt;lock);</span><br><span class="line">		per_cpu(rt_period_time, i) = rq_clock_task(rq);</span><br><span class="line"></span><br><span class="line">		if (rt_rq-&gt;rt_time) &#123;</span><br><span class="line">			u64 runtime;</span><br><span class="line">			/* sched:get runtime*/</span><br><span class="line">			u64 runtime_pre = 0, rt_time_pre = 0;</span><br><span class="line"></span><br><span class="line">			raw_spin_lock(&amp;rt_rq-&gt;rt_runtime_lock);</span><br><span class="line">			per_cpu(old_rt_time, i) = rt_rq-&gt;rt_time;</span><br><span class="line">			</span><br><span class="line">			/* (1.2) 如果已经rt_throttled，首先尝试进行load balance */</span><br><span class="line">			if (rt_rq-&gt;rt_throttled) &#123;</span><br><span class="line">				runtime_pre = rt_rq-&gt;rt_runtime;</span><br><span class="line">				balance_runtime(rt_rq);</span><br><span class="line">				rt_time_pre = rt_rq-&gt;rt_time;</span><br><span class="line">			&#125;</span><br><span class="line">			runtime = rt_rq-&gt;rt_runtime;</span><br><span class="line">			</span><br><span class="line">			/* (1.3) 减少rt_rq-&gt;rt_time，一般情况下经过减操作，rt_rq-&gt;rt_time=0，</span><br><span class="line">			    相当于新周期重新开始计数</span><br><span class="line">			 */</span><br><span class="line">			rt_rq-&gt;rt_time -= min(rt_rq-&gt;rt_time, overrun*runtime);</span><br><span class="line">			per_cpu(init_rt_time, i) = rt_rq-&gt;rt_time;</span><br><span class="line">			/* sched:print throttle*/</span><br><span class="line">			if (rt_rq-&gt;rt_throttled) &#123;</span><br><span class="line">				printk_deferred(&quot;[name:rt&amp;]sched: cpu=%d, [%llu -&gt; %llu]&quot;,</span><br><span class="line">						i, rt_time_pre, rt_rq-&gt;rt_time);</span><br><span class="line">				printk_deferred(&quot; -= min(%llu, %d*[%llu -&gt; %llu])\n&quot;,</span><br><span class="line">						rt_time_pre, overrun, runtime_pre, runtime);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			/* (1.4)如果之前是rt-throttle，且throttle条件已经不成立(rt_rq-&gt;rt_time &lt; runtime)，</span><br><span class="line">			    退出rt-throttle</span><br><span class="line">			 */</span><br><span class="line">			if (rt_rq-&gt;rt_throttled &amp;&amp; rt_rq-&gt;rt_time &lt; runtime) &#123;</span><br><span class="line">				/* sched:print throttle*/</span><br><span class="line">				printk_deferred(&quot;sched: RT throttling inactivated cpu=%d\n&quot;, i);</span><br><span class="line">				rt_rq-&gt;rt_throttled = 0;</span><br><span class="line">				mt_sched_printf(sched_rt_info, &quot;cpu=%d rt_throttled=%d&quot;,</span><br><span class="line">						rq_cpu(rq), rq-&gt;rt.rt_throttled);</span><br><span class="line">				enqueue = 1;</span><br><span class="line">#ifdef CONFIG_MTK_RT_THROTTLE_MON</span><br><span class="line">				if (rt_rq-&gt;rt_time != 0) &#123;</span><br><span class="line">					mt_rt_mon_switch(MON_RESET, i);</span><br><span class="line">					mt_rt_mon_switch(MON_START, i);</span><br><span class="line">				&#125;</span><br><span class="line">#endif</span><br><span class="line">				/*</span><br><span class="line">				 * When we&apos;re idle and a woken (rt) task is</span><br><span class="line">				 * throttled check_preempt_curr() will set</span><br><span class="line">				 * skip_update and the time between the wakeup</span><br><span class="line">				 * and this unthrottle will get accounted as</span><br><span class="line">				 * &apos;runtime&apos;.</span><br><span class="line">				 */</span><br><span class="line">				if (rt_rq-&gt;rt_nr_running &amp;&amp; rq-&gt;curr == rq-&gt;idle)</span><br><span class="line">					rq_clock_skip_update(rq, false);</span><br><span class="line">			&#125;</span><br><span class="line">			if (rt_rq-&gt;rt_time || rt_rq-&gt;rt_nr_running)</span><br><span class="line">				idle = 0;</span><br><span class="line">			raw_spin_unlock(&amp;rt_rq-&gt;rt_runtime_lock);</span><br><span class="line">		&#125; else if (rt_rq-&gt;rt_nr_running) &#123;</span><br><span class="line">			idle = 0;</span><br><span class="line">			if (!rt_rq_throttled(rt_rq))</span><br><span class="line">				enqueue = 1;</span><br><span class="line">		&#125;</span><br><span class="line">		if (rt_rq-&gt;rt_throttled)</span><br><span class="line">			throttled = 1;</span><br><span class="line"></span><br><span class="line">        /* (1.5) 退出rt-throttle，将rt_rq重新入队列运行 */</span><br><span class="line">		if (enqueue)</span><br><span class="line">			sched_rt_rq_enqueue(rt_rq);</span><br><span class="line">		raw_spin_unlock(&amp;rq-&gt;lock);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (!throttled &amp;&amp; (!rt_bandwidth_enabled() || rt_b-&gt;rt_runtime == RUNTIME_INF))</span><br><span class="line">		return 1;</span><br><span class="line"></span><br><span class="line">	return idle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3、负载计算"><a href="#3、负载计算" class="headerlink" title="3、负载计算"></a>3、负载计算</h1><p>schedule里面这个负载(load average)的概念常常被理解成cpu占用率，这个有比较大的偏差。schedule不使用cpu占用率来评估负载，而是使用平均时间runnable的数量来评估负载。</p>
<p>shedule也分了几个层级来计算负载：</p>
<ul>
<li>1、entity级负载计算：update_load_avg()</li>
<li>2、cpu级负载计算：update_cpu_load_active()</li>
<li>3、系统级负载计算：calc_global_load_tick()</li>
</ul>
<p>计算负载的目的是为了去做负载均衡，下面我们逐个介绍各个层级负载算法和各种负载均衡算法。</p>
<h2 id="3-1、PELT-Per-Entity-Load-Tracking-Entity级的负载计算"><a href="#3-1、PELT-Per-Entity-Load-Tracking-Entity级的负载计算" class="headerlink" title="3.1、PELT(Per-Entity Load Tracking)Entity级的负载计算"></a>3.1、PELT(Per-Entity Load Tracking)Entity级的负载计算</h2><ul>
<li>Entity级的负载计算也称作PELT(Per-Entity Load Tracking)。</li>
<li>注意负载计算时使用的时间都是实际运行时间而不是虚拟运行时间vruntime。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">scheduler_tick() -&gt; task_tick_fair() -&gt; entity_tick() -&gt; update_load_avg():</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">/* Update task and its cfs_rq load average */</span><br><span class="line">static inline void update_load_avg(struct sched_entity *se, int update_tg)</span><br><span class="line">&#123;</span><br><span class="line">	struct cfs_rq *cfs_rq = cfs_rq_of(se);</span><br><span class="line">	u64 now = cfs_rq_clock_task(cfs_rq);</span><br><span class="line">	int cpu = cpu_of(rq_of(cfs_rq));</span><br><span class="line">	unsigned long runnable_delta = 0;</span><br><span class="line">	unsigned long prev_load;</span><br><span class="line">	int on_rq_task = entity_is_task(se) &amp;&amp; se-&gt;on_rq;</span><br><span class="line"></span><br><span class="line">	if (on_rq_task) &#123;</span><br><span class="line">#ifdef CONFIG_MTK_SCHED_RQAVG_US</span><br><span class="line">		inc_nr_heavy_running(&quot;__update_load_avg-&quot;, task_of(se), -1, false);</span><br><span class="line">#endif</span><br><span class="line">		prev_load = se_load(se);</span><br><span class="line">	&#125;</span><br><span class="line">	/*</span><br><span class="line">	 * Track task load average for carrying it to new CPU after migrated, and</span><br><span class="line">	 * track group sched_entity load average for task_h_load calc in migration</span><br><span class="line">	 */</span><br><span class="line">	 /* (1) 计算se的负载 */</span><br><span class="line">	__update_load_avg(now, cpu, &amp;se-&gt;avg,</span><br><span class="line">			  se-&gt;on_rq * scale_load_down(se-&gt;load.weight),</span><br><span class="line">			  cfs_rq-&gt;curr == se, NULL);</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_MTK_SCHED_RQAVG_US</span><br><span class="line">	if (entity_is_task(se) &amp;&amp; se-&gt;on_rq)</span><br><span class="line">		inc_nr_heavy_running(&quot;__update_load_avg+&quot;, task_of(se), 1, false);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    /* (2) 计算cfs_rq的负载 */</span><br><span class="line">	if (update_cfs_rq_load_avg(now, cfs_rq) &amp;&amp; update_tg)</span><br><span class="line">		update_tg_load_avg(cfs_rq, 0);</span><br><span class="line"></span><br><span class="line">	/* sched: add trace_sched */</span><br><span class="line">	if (entity_is_task(se)) &#123;</span><br><span class="line">		trace_sched_task_entity_avg(1, task_of(se), &amp;se-&gt;avg);</span><br><span class="line">		trace_sched_load_avg_task(task_of(se), &amp;se-&gt;avg);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (on_rq_task) &#123;</span><br><span class="line">		runnable_delta = prev_load - se_load(se);</span><br><span class="line">#ifdef CONFIG_HMP_TRACER</span><br><span class="line">		trace_sched_cfs_load_update(task_of(se), se_load(se), runnable_delta, cpu);</span><br><span class="line">#endif</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	trace_sched_load_avg_cpu(cpu, cfs_rq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">/* Group cfs_rq&apos;s load_avg is used for task_h_load and update_cfs_share */</span><br><span class="line">static inline int update_cfs_rq_load_avg(u64 now, struct cfs_rq *cfs_rq)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    /* (2.1) 同样调用__update_load_avg()函数来计算cfs_rq的负载 */</span><br><span class="line">	decayed = __update_load_avg(now, cpu_of(rq_of(cfs_rq)), sa,</span><br><span class="line">		scale_load_down(cfs_rq-&gt;load.weight), cfs_rq-&gt;curr != NULL, cfs_rq);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-1-1、核心函数-update-load-avg"><a href="#3-1-1、核心函数-update-load-avg" class="headerlink" title="3.1.1、核心函数__update_load_avg()"></a>3.1.1、核心函数__update_load_avg()</h3><p>__update_load_avg()函数是计算负载的核心，他的核心思想还是求一个相对值。这时1024变量又登场了，前面说过因为内核不能表示分数，所以把1扩展成1024。和负载相关的各个变量因子都使用1024来表达相对能力：时间、weight(nice优先级)、cpufreq、cpucapacity。</p>
<ul>
<li><strong><em>1、等比队列(geometric series)的求和；</em></strong></li>
</ul>
<p>把时间分成1024us(1ms)的等分。除了当前等分，过去等分负载都要进行衰减，linux引入了衰减比例 y = 0.978520621，y^32 = 0.5。也就是说一个负载经过1024us(1ms)以后不能以原来的值参与计算了，要衰减到原来的0.978520621倍，衰减32个1024us(1ms)周期以后达到原来的0.5倍。</p>
<p>每个等分的衰减比例都是不一样的，所以最后的负载计算变成了一个等比队列(geometric series)的求和。等比队列的特性和求和公式如下(y即是公式中的等比比例q)：</p>
<p><img src="/images/scheduler/schedule_geometric_series.png" alt="schedule_geometric_series"></p>
<ul>
<li><strong><em>2、时间分段；</em></strong></li>
</ul>
<p>在计算一段超过1024us(1ms)的时间负载时，__update_load_avg()会把需要计算的时间分成3份：时间段A和之前计算的负载补齐1024us，时间段B是多个1024us的取整，时间段C是最后不能取整1024us的余数；</p>
<p><img src="/images/scheduler/schedule_update_load_avg_3time.png" alt="schedule_update_load_avg_3time"></p>
<ul>
<li><strong><em>3、scale_freq、scale_cpu的含义；</em></strong></li>
</ul>
<p><strong><em>scale_freq</em></strong>表示 当前freq 相对 本cpu最大freq 的比值：scale_freq = (cpu_curr_freq / cpu_max_freq) * 1024：</p>
<p><img src="/images/scheduler/schedule_update_load_avg_scale_freq.png" alt="schedule_update_load_avg_scale_freq"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">static __always_inline int</span><br><span class="line">__update_load_avg(u64 now, int cpu, struct sched_avg *sa,</span><br><span class="line">		  unsigned long weight, int running, struct cfs_rq *cfs_rq)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    scale_freq = arch_scale_freq_capacity(NULL, cpu);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">unsigned long arch_scale_freq_capacity(struct sched_domain *sd, int cpu)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned long curr = atomic_long_read(&amp;per_cpu(cpu_freq_capacity, cpu));</span><br><span class="line"></span><br><span class="line">	if (!curr)</span><br><span class="line">		return SCHED_CAPACITY_SCALE;</span><br><span class="line"></span><br><span class="line">    /* (1) 返回per_cpu(cpu_freq_capacity, cpu) */</span><br><span class="line">	return curr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void arch_scale_set_curr_freq(int cpu, unsigned long freq)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned long max = atomic_long_read(&amp;per_cpu(cpu_max_freq, cpu));</span><br><span class="line">	unsigned long curr;</span><br><span class="line"></span><br><span class="line">	if (!max)</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">    /* (1.1) cpu的 cpu_curr_freq / cpu_max_freq * 1024 */</span><br><span class="line">	curr = (freq * SCHED_CAPACITY_SCALE) / max;</span><br><span class="line"></span><br><span class="line">	atomic_long_set(&amp;per_cpu(cpu_freq_capacity, cpu), curr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>scale_cpu</em></strong>表示 (当前cpu最大运算能力 相对 所有cpu中最大的运算能力 的比值) <em> (cpufreq_policy的最大频率 相对 本cpu最大频率 的比值)，：scale_cpu = cpu_scale </em> max_freq_scale / 1024。后续的rebalance计算中经常使用capacity的叫法，和scale_cpu是同一含义。因为max_freq_scale基本=1024，所以scale_cpu基本就是cpu_scale的值：</p>
<p><img src="/images/scheduler/schedule_update_load_avg_scale_cpu.png" alt="schedule_update_load_avg_scale_cpu"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">unsigned long arch_scale_cpu_capacity(struct sched_domain *sd, int cpu)</span><br><span class="line">&#123;</span><br><span class="line">#ifdef CONFIG_CPU_FREQ</span><br><span class="line">	unsigned long max_freq_scale = cpufreq_scale_max_freq_capacity(cpu);</span><br><span class="line"></span><br><span class="line">	return per_cpu(cpu_scale, cpu) * max_freq_scale &gt;&gt; SCHED_CAPACITY_SHIFT;</span><br><span class="line">#else</span><br><span class="line">	return per_cpu(cpu_scale, cpu);</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>cpu_scale</em></strong>表示 当前cpu最大运算能力 相对 所有cpu中最大的运算能力 的比值：cpu_scale = ((cpu_max_freq <em> efficiency) / max_cpu_perf) </em> 1024</p>
<p>当前cpu的最大运算能力等于当前cpu的最大频率乘以当前cpu每clk的运算能力efficiency，efficiency相当于DMIPS，A53/A73不同架构每个clk的运算能力是不一样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">/* (1.1) 不同架构的efficiency */</span><br><span class="line">static const struct cpu_efficiency table_efficiency[] = &#123;</span><br><span class="line">	&#123; &quot;arm,cortex-a73&quot;, 3630 &#125;,</span><br><span class="line">	&#123; &quot;arm,cortex-a72&quot;, 4186 &#125;,</span><br><span class="line">	&#123; &quot;arm,cortex-a57&quot;, 3891 &#125;,</span><br><span class="line">	&#123; &quot;arm,cortex-a53&quot;, 2048 &#125;,</span><br><span class="line">	&#123; &quot;arm,cortex-a35&quot;, 1661 &#125;,</span><br><span class="line">	&#123; NULL, &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static void __init parse_dt_cpu_capacity(void)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    for_each_possible_cpu(cpu) &#123;</span><br><span class="line">    </span><br><span class="line">        rate = of_get_property(cn, &quot;clock-frequency&quot;, &amp;len);</span><br><span class="line">        </span><br><span class="line">        /* (1) 计算当前cpu的perf能力 = clkrate * efficiency */</span><br><span class="line">        cpu_perf = ((be32_to_cpup(rate)) &gt;&gt; 20) * cpu_eff-&gt;efficiency;</span><br><span class="line">		cpu_capacity(cpu) = cpu_perf;</span><br><span class="line">		</span><br><span class="line">		/* (2) 计算soc中最强cpu的perf能力max_cpu_perf </span><br><span class="line">		 */</span><br><span class="line">		max_cpu_perf = max(max_cpu_perf, cpu_perf);</span><br><span class="line">		min_cpu_perf = min(min_cpu_perf, cpu_perf);</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void update_cpu_capacity(unsigned int cpu)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned long capacity = cpu_capacity(cpu);</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_MTK_SCHED_EAS_PLUS</span><br><span class="line">	if (cpu_core_energy(cpu)) &#123;</span><br><span class="line">#else</span><br><span class="line">	if (0) &#123;</span><br><span class="line">#endif</span><br><span class="line">		/* if power table is found, get capacity of CPU from it */</span><br><span class="line">		int max_cap_idx = cpu_core_energy(cpu)-&gt;nr_cap_states - 1;</span><br><span class="line"></span><br><span class="line">        /* (3.1) 使用查表法得到相对perf能力cpu_scale */</span><br><span class="line">		capacity = cpu_core_energy(cpu)-&gt;cap_states[max_cap_idx].cap;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		if (!capacity || !max_cpu_perf) &#123;</span><br><span class="line">			cpu_capacity(cpu) = 0;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        /* (3.1) 使用计算法得到相对perf能力cpu_scale,</span><br><span class="line">            cpu_scale = (capacity / max_cpu_perf) * 1024</span><br><span class="line">         */</span><br><span class="line">		capacity *= SCHED_CAPACITY_SCALE;</span><br><span class="line">		capacity /= max_cpu_perf;</span><br><span class="line">	&#125;</span><br><span class="line">	set_capacity_scale(cpu, capacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void set_capacity_scale(unsigned int cpu, unsigned long capacity)</span><br><span class="line">&#123;</span><br><span class="line">	per_cpu(cpu_scale, cpu) = capacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如mt6799一共有10个cpu，为“4 A35 + 4 A53 + 2 A73”架构。使用计算法计算的cpu_scale相关值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* rate是从dts读取的和实际不符合，只是表达一下算法 */</span><br><span class="line">cpu = 0, rate = 1190, efficiency = 1661, cpu_perf = 1976590 </span><br><span class="line">cpu = 1, rate = 1190, efficiency = 1661, cpu_perf = 1976590 </span><br><span class="line">cpu = 2, rate = 1190, efficiency = 1661, cpu_perf = 1976590 </span><br><span class="line">cpu = 3, rate = 1190, efficiency = 1661, cpu_perf = 1976590 </span><br><span class="line">cpu = 4, rate = 1314, efficiency = 2048, cpu_perf = 2691072 </span><br><span class="line">cpu = 5, rate = 1314, efficiency = 2048, cpu_perf = 2691072 </span><br><span class="line">cpu = 6, rate = 1314, efficiency = 2048, cpu_perf = 2691072 </span><br><span class="line">cpu = 7, rate = 1314, efficiency = 2048, cpu_perf = 2691072 </span><br><span class="line">cpu = 8, rate = 1562, efficiency = 3630, cpu_perf = 5670060 </span><br><span class="line">cpu = 9, rate = 1562, efficiency = 3630, cpu_perf = 5670060</span><br></pre></td></tr></table></figure>
<p>mt6799实际是使用查表法直接得到cpu_scale的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">struct upower_tbl upower_tbl_ll_1_FY = &#123;</span><br><span class="line">	.row = &#123;</span><br><span class="line">		&#123;.cap = 100, .volt = 75000, .dyn_pwr = 9994, .lkg_pwr = &#123;13681, 13681, 13681, 13681, 13681, 13681&#125; &#125;,</span><br><span class="line">		&#123;.cap = 126, .volt = 75000, .dyn_pwr = 12585, .lkg_pwr = &#123;13681, 13681, 13681, 13681, 13681, 13681&#125; &#125;,</span><br><span class="line">		&#123;.cap = 148, .volt = 75000, .dyn_pwr = 14806, .lkg_pwr = &#123;13681, 13681, 13681, 13681, 13681, 13681&#125; &#125;,</span><br><span class="line">		&#123;.cap = 167, .volt = 75000, .dyn_pwr = 16656, .lkg_pwr = &#123;13681, 13681, 13681, 13681, 13681, 13681&#125; &#125;,</span><br><span class="line">		&#123;.cap = 189, .volt = 75000, .dyn_pwr = 18877, .lkg_pwr = &#123;13681, 13681, 13681, 13681, 13681, 13681&#125; &#125;,</span><br><span class="line">		&#123;.cap = 212, .volt = 75000, .dyn_pwr = 21098, .lkg_pwr = &#123;13681, 13681, 13681, 13681, 13681, 13681&#125; &#125;,</span><br><span class="line">		&#123;.cap = 230, .volt = 75700, .dyn_pwr = 23379, .lkg_pwr = &#123;13936, 13936, 13936, 13936, 13936, 13936&#125; &#125;,</span><br><span class="line">		&#123;.cap = 245, .volt = 78100, .dyn_pwr = 26490, .lkg_pwr = &#123;14811, 14811, 14811, 14811, 14811, 14811&#125; &#125;,</span><br><span class="line">		&#123;.cap = 263, .volt = 81100, .dyn_pwr = 30729, .lkg_pwr = &#123;15958, 15958, 15958, 15958, 15958, 15958&#125; &#125;,</span><br><span class="line">		&#123;.cap = 278, .volt = 83500, .dyn_pwr = 34409, .lkg_pwr = &#123;16949, 16949, 16949, 16949, 16949, 16949&#125; &#125;,</span><br><span class="line">		&#123;.cap = 293, .volt = 86000, .dyn_pwr = 38447, .lkg_pwr = &#123;18036, 18036, 18036, 18036, 18036, 18036&#125; &#125;,</span><br><span class="line">		&#123;.cap = 304, .volt = 88400, .dyn_pwr = 42166, .lkg_pwr = &#123;19159, 19159, 19159, 19159, 19159, 19159&#125; &#125;,</span><br><span class="line">		&#123;.cap = 319, .volt = 90800, .dyn_pwr = 46657, .lkg_pwr = &#123;20333, 20333, 20333, 20333, 20333, 20333&#125; &#125;,</span><br><span class="line">		&#123;.cap = 334, .volt = 93200, .dyn_pwr = 51442, .lkg_pwr = &#123;21605, 21605, 21605, 21605, 21605, 21605&#125; &#125;,</span><br><span class="line">		&#123;.cap = 345, .volt = 95000, .dyn_pwr = 55230, .lkg_pwr = &#123;22560, 22560, 22560, 22560, 22560, 22560&#125; &#125;,</span><br><span class="line">		&#123;.cap = 356, .volt = 97400, .dyn_pwr = 59928, .lkg_pwr = &#123;24002, 24002, 24002, 24002, 24002, 24002&#125; &#125;,</span><br><span class="line">	&#125;,</span><br><span class="line">	.lkg_idx = DEFAULT_LKG_IDX,</span><br><span class="line">	.row_num = UPOWER_OPP_NUM,</span><br><span class="line">	.nr_idle_states = NR_UPOWER_CSTATES,</span><br><span class="line">	.idle_states = &#123;</span><br><span class="line">		&#123;&#123;0&#125;, &#123;7321&#125; &#125;,</span><br><span class="line">		&#123;&#123;0&#125;, &#123;7321&#125; &#125;,</span><br><span class="line">		&#123;&#123;0&#125;, &#123;7321&#125; &#125;,</span><br><span class="line">		&#123;&#123;0&#125;, &#123;7321&#125; &#125;,</span><br><span class="line">		&#123;&#123;0&#125;, &#123;7321&#125; &#125;,</span><br><span class="line">		&#123;&#123;0&#125;, &#123;7321&#125; &#125;,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct upower_tbl upower_tbl_l_1_FY = &#123;</span><br><span class="line">	.row = &#123;</span><br><span class="line">		&#123;.cap = 116, .volt = 75000, .dyn_pwr = 16431, .lkg_pwr = &#123;22973, 22973, 22973, 22973, 22973, 22973&#125; &#125;,</span><br><span class="line">		&#123;.cap = 152, .volt = 75000, .dyn_pwr = 21486, .lkg_pwr = &#123;22973, 22973, 22973, 22973, 22973, 22973&#125; &#125;,</span><br><span class="line">		&#123;.cap = 179, .volt = 75000, .dyn_pwr = 25278, .lkg_pwr = &#123;22973, 22973, 22973, 22973, 22973, 22973&#125; &#125;,</span><br><span class="line">		&#123;.cap = 201, .volt = 75000, .dyn_pwr = 28437, .lkg_pwr = &#123;22973, 22973, 22973, 22973, 22973, 22973&#125; &#125;,</span><br><span class="line">		&#123;.cap = 228, .volt = 75000, .dyn_pwr = 32229, .lkg_pwr = &#123;22973, 22973, 22973, 22973, 22973, 22973&#125; &#125;,</span><br><span class="line">		&#123;.cap = 255, .volt = 75000, .dyn_pwr = 36021, .lkg_pwr = &#123;22973, 22973, 22973, 22973, 22973, 22973&#125; &#125;,</span><br><span class="line">		&#123;.cap = 282, .volt = 75700, .dyn_pwr = 40559, .lkg_pwr = &#123;23423, 23423, 23423, 23423, 23423, 23423&#125; &#125;,</span><br><span class="line">		&#123;.cap = 304, .volt = 78100, .dyn_pwr = 46598, .lkg_pwr = &#123;24968, 24968, 24968, 24968, 24968, 24968&#125; &#125;,</span><br><span class="line">		&#123;.cap = 331, .volt = 81100, .dyn_pwr = 54680, .lkg_pwr = &#123;26999, 26999, 26999, 26999, 26999, 26999&#125; &#125;,</span><br><span class="line">		&#123;.cap = 349, .volt = 83500, .dyn_pwr = 61098, .lkg_pwr = &#123;28760, 28760, 28760, 28760, 28760, 28760&#125; &#125;,</span><br><span class="line">		&#123;.cap = 371, .volt = 86000, .dyn_pwr = 68965, .lkg_pwr = &#123;30698, 30698, 30698, 30698, 30698, 30698&#125; &#125;,</span><br><span class="line">		&#123;.cap = 393, .volt = 88400, .dyn_pwr = 77258, .lkg_pwr = &#123;32706, 32706, 32706, 32706, 32706, 32706&#125; &#125;,</span><br><span class="line">		&#123;.cap = 416, .volt = 90800, .dyn_pwr = 86141, .lkg_pwr = &#123;34808, 34808, 34808, 34808, 34808, 34808&#125; &#125;,</span><br><span class="line">		&#123;.cap = 438, .volt = 93200, .dyn_pwr = 95634, .lkg_pwr = &#123;37097, 37097, 37097, 37097, 37097, 37097&#125; &#125;,</span><br><span class="line">		&#123;.cap = 452, .volt = 95000, .dyn_pwr = 102406, .lkg_pwr = &#123;38814, 38814, 38814, 38814, 38814, 38814&#125; &#125;,</span><br><span class="line">		&#123;.cap = 474, .volt = 97400, .dyn_pwr = 112974, .lkg_pwr = &#123;41424, 41424, 41424, 41424, 41424, 41424&#125; &#125;,</span><br><span class="line">	&#125;,</span><br><span class="line">	.lkg_idx = DEFAULT_LKG_IDX,</span><br><span class="line">	.row_num = UPOWER_OPP_NUM,</span><br><span class="line">	.nr_idle_states = NR_UPOWER_CSTATES,</span><br><span class="line">	.idle_states = &#123;</span><br><span class="line">		&#123;&#123;0&#125;, &#123;11926&#125; &#125;,</span><br><span class="line">		&#123;&#123;0&#125;, &#123;11926&#125; &#125;,</span><br><span class="line">		&#123;&#123;0&#125;, &#123;11926&#125; &#125;,</span><br><span class="line">		&#123;&#123;0&#125;, &#123;11926&#125; &#125;,</span><br><span class="line">		&#123;&#123;0&#125;, &#123;11926&#125; &#125;,</span><br><span class="line">		&#123;&#123;0&#125;, &#123;11926&#125; &#125;,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct upower_tbl upower_tbl_b_1_FY = &#123;</span><br><span class="line">	.row = &#123;</span><br><span class="line">		&#123;.cap = 211, .volt = 75000, .dyn_pwr = 61732, .lkg_pwr = &#123;71164, 71164, 71164, 71164, 71164, 71164&#125; &#125;,</span><br><span class="line">		&#123;.cap = 268, .volt = 75000, .dyn_pwr = 78352, .lkg_pwr = &#123;71164, 71164, 71164, 71164, 71164, 71164&#125; &#125;,</span><br><span class="line">		&#123;.cap = 317, .volt = 75000, .dyn_pwr = 92598, .lkg_pwr = &#123;71164, 71164, 71164, 71164, 71164, 71164&#125; &#125;,</span><br><span class="line">		&#123;.cap = 358, .volt = 75000, .dyn_pwr = 104469, .lkg_pwr = &#123;71164, 71164, 71164, 71164, 71164, 71164&#125; &#125;,</span><br><span class="line">		&#123;.cap = 406, .volt = 75000, .dyn_pwr = 118715, .lkg_pwr = &#123;71164, 71164, 71164, 71164, 71164, 71164&#125; &#125;,</span><br><span class="line">		&#123;.cap = 447, .volt = 75000, .dyn_pwr = 130587, .lkg_pwr = &#123;71164, 71164, 71164, 71164, 71164, 71164&#125; &#125;,</span><br><span class="line">		&#123;.cap = 504, .volt = 75700, .dyn_pwr = 149968, .lkg_pwr = &#123;72438, 72438, 72438, 72438, 72438, 72438&#125; &#125;,</span><br><span class="line">		&#123;.cap = 561, .volt = 78100, .dyn_pwr = 177650, .lkg_pwr = &#123;76806, 76806, 76806, 76806, 76806, 76806&#125; &#125;,</span><br><span class="line">		&#123;.cap = 634, .volt = 81100, .dyn_pwr = 216546, .lkg_pwr = &#123;82521, 82521, 82521, 82521, 82521, 82521&#125; &#125;,</span><br><span class="line">		&#123;.cap = 691, .volt = 83500, .dyn_pwr = 250153, .lkg_pwr = &#123;87447, 87447, 87447, 87447, 87447, 87447&#125; &#125;,</span><br><span class="line">		&#123;.cap = 748, .volt = 86000, .dyn_pwr = 287210, .lkg_pwr = &#123;92841, 92841, 92841, 92841, 92841, 92841&#125; &#125;,</span><br><span class="line">		&#123;.cap = 805, .volt = 88400, .dyn_pwr = 326553, .lkg_pwr = &#123;98397, 98397, 98397, 98397, 98397, 98397&#125; &#125;,</span><br><span class="line">	&#123;.cap = 861, .volt = 90800, .dyn_pwr = 368886, .lkg_pwr = &#123;104190, 104190, 104190, 104190, 104190, 104190&#125; &#125;,</span><br><span class="line">	&#123;.cap = 918, .volt = 93200, .dyn_pwr = 414309, .lkg_pwr = &#123;110456, 110456, 110456, 110456, 110456, 110456&#125; &#125;,</span><br><span class="line">	&#123;.cap = 959, .volt = 95000, .dyn_pwr = 449514, .lkg_pwr = &#123;115156, 115156, 115156, 115156, 115156, 115156&#125; &#125;,</span><br><span class="line">	&#123;.cap = 1024, .volt = 97400, .dyn_pwr = 504548, .lkg_pwr = &#123;122224, 122224, 122224, 122224, 122224, 122224&#125; &#125;,</span><br><span class="line">	&#125;,</span><br><span class="line">	.lkg_idx = DEFAULT_LKG_IDX,</span><br><span class="line">	.row_num = UPOWER_OPP_NUM,</span><br><span class="line">	.nr_idle_states = NR_UPOWER_CSTATES,</span><br><span class="line">	.idle_states = &#123;</span><br><span class="line">		&#123;&#123;0&#125;, &#123;38992&#125; &#125;,</span><br><span class="line">		&#123;&#123;0&#125;, &#123;38992&#125; &#125;,</span><br><span class="line">		&#123;&#123;0&#125;, &#123;38992&#125; &#125;,</span><br><span class="line">		&#123;&#123;0&#125;, &#123;38992&#125; &#125;,</span><br><span class="line">		&#123;&#123;0&#125;, &#123;38992&#125; &#125;,</span><br><span class="line">		&#123;&#123;0&#125;, &#123;38992&#125; &#125;,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong><em>max_freq_scale</em></strong>表示 cpufreq_policy的最大频率 相对 本cpu最大频率 的比值：max_freq_scale = (policy-&gt;max / cpuinfo-&gt;max_freq) * 1024</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static void</span><br><span class="line">scale_freq_capacity(struct cpufreq_policy *policy, struct cpufreq_freqs *freqs)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    scale = (policy-&gt;max &lt;&lt; SCHED_CAPACITY_SHIFT) / cpuinfo-&gt;max_freq;</span><br><span class="line">    </span><br><span class="line">    for_each_cpu(cpu, &amp;cls_cpus)</span><br><span class="line">		per_cpu(max_freq_scale, cpu) = scale;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><em>4、decay_load()；</em></strong></li>
</ul>
<p>decay_load(val,n)的意思就是负载值val经过n个衰减周期(1024us)以后的值，主要用来计算时间段A即之前的值的衰减值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"> * Approximate:</span><br><span class="line"> *   val * y^n,    where y^32 ~= 0.5 (~1 scheduling period)</span><br><span class="line"> */</span><br><span class="line">static __always_inline u64 decay_load(u64 val, u64 n)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned int local_n;</span><br><span class="line"></span><br><span class="line">	if (!n)</span><br><span class="line">		return val;</span><br><span class="line">	else if (unlikely(n &gt; LOAD_AVG_PERIOD * 63))</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">	/* after bounds checking we can collapse to 32-bit */</span><br><span class="line">	local_n = n;</span><br><span class="line"></span><br><span class="line">    /* (1) 如果n是32的整数倍，因为2^32 = 1/2，相当于右移一位，</span><br><span class="line">        计算n有多少个32，每个32右移一位</span><br><span class="line">     */</span><br><span class="line">	/*</span><br><span class="line">	 * As y^PERIOD = 1/2, we can combine</span><br><span class="line">	 *    y^n = 1/2^(n/PERIOD) * y^(n%PERIOD)</span><br><span class="line">	 * With a look-up table which covers y^n (n&lt;PERIOD)</span><br><span class="line">	 *</span><br><span class="line">	 * To achieve constant time decay_load.</span><br><span class="line">	 */</span><br><span class="line">	if (unlikely(local_n &gt;= LOAD_AVG_PERIOD)) &#123;</span><br><span class="line">		val &gt;&gt;= local_n / LOAD_AVG_PERIOD;</span><br><span class="line">		local_n %= LOAD_AVG_PERIOD;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /*  (2) 剩下的值计算 val * y^n，</span><br><span class="line">        把y^n计算转换成 (val * runnable_avg_yN_inv[n] &gt;&gt; 32) </span><br><span class="line">     */</span><br><span class="line">	val = mul_u64_u32_shr(val, runnable_avg_yN_inv[local_n], 32);</span><br><span class="line">	return val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Precomputed fixed inverse multiplies for multiplication by y^n */</span><br><span class="line">static const u32 runnable_avg_yN_inv[] = &#123;</span><br><span class="line">	0xffffffff, 0xfa83b2da, 0xf5257d14, 0xefe4b99a, 0xeac0c6e6, 0xe5b906e6,</span><br><span class="line">	0xe0ccdeeb, 0xdbfbb796, 0xd744fcc9, 0xd2a81d91, 0xce248c14, 0xc9b9bd85,</span><br><span class="line">	0xc5672a10, 0xc12c4cc9, 0xbd08a39e, 0xb8fbaf46, 0xb504f333, 0xb123f581,</span><br><span class="line">	0xad583ee9, 0xa9a15ab4, 0xa5fed6a9, 0xa2704302, 0x9ef5325f, 0x9b8d39b9,</span><br><span class="line">	0x9837f050, 0x94f4efa8, 0x91c3d373, 0x8ea4398a, 0x8b95c1e3, 0x88980e80,</span><br><span class="line">	0x85aac367, 0x82cd8698,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><em>5、__compute_runnable_contrib()；</em></strong></li>
</ul>
<p>decay_load()只是计算y^n，而__compute_runnable_contrib()是计算一个对比队列的和：y + y^2 + y^3 … + y^n。计算时间段B的负载。</p>
<p>runnable_avg_yN_sum[]数组是使用查表法来计算n=32位内的等比队列求和:</p>
<p>runnable_avg_yN_sum[1] = y^1 <em> 1024 = 0.978520621 </em> 1024 = 1002<br>runnable_avg_yN_sum[1] = (y^1 + y^2) <em> 1024 = 1982<br>…<br>runnable_avg_yN_sum[1] = (y^1 + y^2 .. + y^32) </em> 1024 = 23371</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * For updates fully spanning n periods, the contribution to runnable</span><br><span class="line"> * average will be: \Sum 1024*y^n</span><br><span class="line"> *</span><br><span class="line"> * We can compute this reasonably efficiently by combining:</span><br><span class="line"> *   y^PERIOD = 1/2 with precomputed \Sum 1024*y^n &#123;for  n &lt;PERIOD&#125;</span><br><span class="line"> */</span><br><span class="line">static u32 __compute_runnable_contrib(u64 n)</span><br><span class="line">&#123;</span><br><span class="line">	u32 contrib = 0;</span><br><span class="line"></span><br><span class="line">	if (likely(n &lt;= LOAD_AVG_PERIOD))</span><br><span class="line">		return runnable_avg_yN_sum[n];</span><br><span class="line">	else if (unlikely(n &gt;= LOAD_AVG_MAX_N))</span><br><span class="line">		return LOAD_AVG_MAX;</span><br><span class="line"></span><br><span class="line">    /* (1) 如果n&gt;32，计算32的整数部分 */</span><br><span class="line">	/* Compute \Sum k^n combining precomputed values for k^i, \Sum k^j */</span><br><span class="line">	do &#123;</span><br><span class="line">	    /* (1.1) 每整数32的衰减就是0.5 */</span><br><span class="line">		contrib /= 2; /* y^LOAD_AVG_PERIOD = 1/2 */</span><br><span class="line">		contrib += runnable_avg_yN_sum[LOAD_AVG_PERIOD];</span><br><span class="line"></span><br><span class="line">		n -= LOAD_AVG_PERIOD;</span><br><span class="line">	&#125; while (n &gt; LOAD_AVG_PERIOD);</span><br><span class="line"></span><br><span class="line">    /* (2.1) 将整数部分对余数n进行衰减 */</span><br><span class="line">	contrib = decay_load(contrib, n);</span><br><span class="line">	</span><br><span class="line">	/* (2.2) 剩余余数n，使用查表法计算 */</span><br><span class="line">	return contrib + runnable_avg_yN_sum[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Precomputed \Sum y^k &#123; 1&lt;=k&lt;=n &#125;.  These are floor(true_value) to prevent</span><br><span class="line"> * over-estimates when re-combining.</span><br><span class="line"> */</span><br><span class="line">static const u32 runnable_avg_yN_sum[] = &#123;</span><br><span class="line">	    0, 1002, 1982, 2941, 3880, 4798, 5697, 6576, 7437, 8279, 9103,</span><br><span class="line">	 9909,10698,11470,12226,12966,13690,14398,15091,15769,16433,17082,</span><br><span class="line">	17718,18340,18949,19545,20128,20698,21256,21802,22336,22859,23371,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><em>6、se-&gt;on_rq；</em></strong></li>
</ul>
<p>在系统从睡眠状态被唤醒，睡眠时间会不会被统计进load_avg？答案是不会。</p>
<p>系统使用了一个技巧来处理这种情况，调用__update_load_avg()函数时，第三个参数weight = se-&gt;on_rq * scale_load_down(se-&gt;load.weight)。运行状态时se-&gt;on_rq=1，weight&gt;0，老负载被老化，新负载被累加；在进程从睡眠状态被唤醒时，se-&gt;on_rq=0，weight=0，只有老负载被老化，睡眠时间不会被统计；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">enqueue_task_fair() </span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">enqueue_entity(struct cfs_rq *cfs_rq, struct sched_entity *se, int flags)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    /* (1) 在调用负载更新时，se-&gt;on_rq = 0 */</span><br><span class="line">    enqueue_entity_load_avg(cfs_rq, se);</span><br><span class="line">    </span><br><span class="line">    se-&gt;on_rq = 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">||→</span><br><span class="line"></span><br><span class="line">static inline void</span><br><span class="line">enqueue_entity_load_avg(struct cfs_rq *cfs_rq, struct sched_entity *se)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	if (!migrated) &#123;</span><br><span class="line">	    </span><br><span class="line">	    /* (1.1) 传入weight=0，只老化旧负载，不统计新负载 */</span><br><span class="line">		__update_load_avg(now, cpu_of(rq_of(cfs_rq)), sa,</span><br><span class="line">			se-&gt;on_rq * scale_load_down(se-&gt;load.weight),</span><br><span class="line">			cfs_rq-&gt;curr == se, NULL);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相同的技巧是在更新cfs_rq负载时，调用__update_load_avg()函数时，第三个参数weight = scale_load_down(cfs_rq-&gt;load.weight)。如果cfs_rq没有任何进程时cfs_rq-&gt;load.weight=0，如果cfs_rq有进程时cfs_rq-&gt;load.weight=进程weight的累加值，这样在cfs没有进程idle时，就不会统计负载。但是如果被RT进程抢占，还是会统计(相当于cfs_rq的runnable状态)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static inline int update_cfs_rq_load_avg(u64 now, struct cfs_rq *cfs_rq)</span><br><span class="line">&#123;</span><br><span class="line">	struct sched_avg *sa = &amp;cfs_rq-&gt;avg;</span><br><span class="line">	int decayed, removed = 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	decayed = __update_load_avg(now, cpu_of(rq_of(cfs_rq)), sa,</span><br><span class="line">		scale_load_down(cfs_rq-&gt;load.weight), cfs_rq-&gt;curr != NULL, cfs_rq);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><em>7、LOAD_AVG_MAX；</em></strong></li>
</ul>
<p>从上面的计算过程解析可以看到，负载计算就是一个等比队列的求和。对于负载其实我们不关心他的绝对值，而是关心他和最大负载对比的相对值。所谓最大负载就是时间轴上一直都在，且能力值也都是最大的1(1024)。</p>
<p>我们从上面等比队列的求和公式:Sn = a1(1-q^n)/(1-q) = 1024(1 - 0.978520621^n)/(1-0.978520621)。我们来看这个求和函数的曲线。</p>
<p><img src="/images/scheduler/schedule_geometric_series_sum.png" alt="schedule_geometric_series_sum"></p>
<p>从曲线上分析，当x到达一定值后y趋于稳定，不再增长。</p>
<p>利用这个原理linux定义出了负载最大值LOAD_AVG_MAX。含义是经过了LOAD_AVG_MAX_N(345)个周期以后，等比队列求和达到最大值LOAD_AVG_MAX(47742)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * We choose a half-life close to 1 scheduling period.</span><br><span class="line"> * Note: The tables runnable_avg_yN_inv and runnable_avg_yN_sum are</span><br><span class="line"> * dependent on this value.</span><br><span class="line"> */</span><br><span class="line">#define LOAD_AVG_PERIOD 32</span><br><span class="line">#define LOAD_AVG_MAX 47742 /* maximum possible load avg */</span><br><span class="line">#define LOAD_AVG_MAX_N 345 /* number of full periods to produce LOAD_AVG_MAX */</span><br></pre></td></tr></table></figure>
<p>平均负载都是负载和最大负载之间的比值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static __always_inline int</span><br><span class="line">__update_load_avg(u64 now, int cpu, struct sched_avg *sa,</span><br><span class="line">		  unsigned long weight, int running, struct cfs_rq *cfs_rq)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	if (decayed) &#123;</span><br><span class="line">		sa-&gt;load_avg = div_u64(sa-&gt;load_sum, LOAD_AVG_MAX);</span><br><span class="line">		sa-&gt;loadwop_avg = div_u64(sa-&gt;loadwop_sum, LOAD_AVG_MAX);</span><br><span class="line"></span><br><span class="line">		if (cfs_rq) &#123;</span><br><span class="line">			cfs_rq-&gt;runnable_load_avg =</span><br><span class="line">				div_u64(cfs_rq-&gt;runnable_load_sum, LOAD_AVG_MAX);</span><br><span class="line">			cfs_rq-&gt;avg.loadwop_avg =</span><br><span class="line">				div_u64(cfs_rq-&gt;avg.loadwop_sum, LOAD_AVG_MAX);</span><br><span class="line">		&#125;</span><br><span class="line">		sa-&gt;util_avg = sa-&gt;util_sum / LOAD_AVG_MAX;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><em>8、struct sched_avg数据成员的含义；</em></strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">struct sched_avg &#123;</span><br><span class="line">	u64 last_update_time;</span><br><span class="line">	u32 period_contrib;</span><br><span class="line">	</span><br><span class="line">	/* (1) runnable状态负载，带weight */</span><br><span class="line">	u64 load_sum; // runnable状态负载总和，(weight*time*scale_freq)几个分量相乘</span><br><span class="line">	unsigned long load_avg; // runnable状态平均负载，(weight*time*scale_freq)几个分量相乘</span><br><span class="line">	                        // 因为weight的值会大于1024，所以load_avg的值会大于1024</span><br><span class="line"></span><br><span class="line">    /* (2) runnable状态负载，不带weight  */</span><br><span class="line">	unsigned long loadwop_sum;  // runnable状态负载总和，(time*scale_freq)几个分量相乘</span><br><span class="line">	unsigned long loadwop_avg;  // runnable状态平均负载，(time*scale_freq)几个分量相乘</span><br><span class="line">	                            // loadwop_avg的最大值为1024</span><br><span class="line"></span><br><span class="line">    /* (3) running状态负载 */</span><br><span class="line">	u32 util_sum; // running状态负载总和，(time*scale_freq*scale_cpu)几个分量相乘</span><br><span class="line">	unsigned long util_avg; // running状态平均负载，(time*scale_freq*scale_cpu)几个分量相乘</span><br><span class="line">	                        // util_avg的最大值为1024</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_SCHED_HMP</span><br><span class="line">	unsigned long pending_load;</span><br><span class="line">	u32 nr_pending;</span><br><span class="line">#ifdef CONFIG_SCHED_HMP_PRIO_FILTER</span><br><span class="line">	u32 nr_dequeuing_low_prio;</span><br><span class="line">	u32 nr_normal_prio;</span><br><span class="line">#endif</span><br><span class="line">	u64 hmp_last_up_migration;</span><br><span class="line">	u64 hmp_last_down_migration;</span><br><span class="line">#endif /* CONFIG_SCHED_HMP */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>8.1、loadwop_avg：</li>
</ul>
<p><img src="/images/scheduler/schedule_update_load_avg_loadwop_avg.png" alt="schedule_update_load_avg_loadwop_avg"></p>
<ul>
<li>8.2、load_avg：</li>
</ul>
<p><img src="/images/scheduler/schedule_update_load_avg_load_avg.png" alt="schedule_update_load_avg_load_avg"></p>
<ul>
<li>8.3、util_avg：</li>
</ul>
<p><img src="/images/scheduler/schedule_update_load_avg_util_avg.png" alt="schedule_update_load_avg_util_avg"></p>
<ul>
<li>8.4、scale_freq：</li>
</ul>
<p>需要特别强调的是loadwop_avg、load_avg、util_avg在他们的时间分量中都乘以了scale_freq，所以上面几图都是他们在max_freq下的表现，实际的负载还受当前freq的影响：</p>
<p><img src="/images/scheduler/schedule_update_load_avg_scale_freq.png" alt="schedule_update_load_avg_scale_freq"></p>
<ul>
<li>8.5、capacity/scale_cpu</li>
</ul>
<p><img src="/images/scheduler/schedule_update_load_avg_scale_cpu.png" alt="schedule_update_load_avg_scale_cpu"></p>
<p>capacity是在smp负载均衡时更新：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">run_rebalance_domains() -&gt; rebalance_domains() -&gt; load_balance() -&gt; find_busiest_group() -&gt; update_sd_lb_stats() -&gt; update_group_capacity() -&gt; update_cpu_capacity()</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static void update_cpu_capacity(struct sched_domain *sd, int cpu)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned long capacity = arch_scale_cpu_capacity(sd, cpu);</span><br><span class="line">	struct sched_group *sdg = sd-&gt;groups;</span><br><span class="line">	struct max_cpu_capacity *mcc;</span><br><span class="line">	unsigned long max_capacity;</span><br><span class="line">	int max_cap_cpu;</span><br><span class="line">	unsigned long flags;</span><br><span class="line"></span><br><span class="line">    /* (1) cpu_capacity_orig = cpu最大频率时的最大capacity */</span><br><span class="line">	cpu_rq(cpu)-&gt;cpu_capacity_orig = capacity;</span><br><span class="line"></span><br><span class="line">	mcc = &amp;cpu_rq(cpu)-&gt;rd-&gt;max_cpu_capacity;</span><br><span class="line"></span><br><span class="line">	raw_spin_lock_irqsave(&amp;mcc-&gt;lock, flags);</span><br><span class="line">	max_capacity = mcc-&gt;val;</span><br><span class="line">	max_cap_cpu = mcc-&gt;cpu;</span><br><span class="line"></span><br><span class="line">	if ((max_capacity &gt; capacity &amp;&amp; max_cap_cpu == cpu) ||</span><br><span class="line">	    (max_capacity &lt; capacity)) &#123;</span><br><span class="line">		mcc-&gt;val = capacity;</span><br><span class="line">		mcc-&gt;cpu = cpu;</span><br><span class="line">#ifdef CONFIG_SCHED_DEBUG</span><br><span class="line">		raw_spin_unlock_irqrestore(&amp;mcc-&gt;lock, flags);</span><br><span class="line">		/* pr_info(&quot;CPU%d: update max cpu_capacity %lu\n&quot;, cpu, capacity); */</span><br><span class="line">		goto skip_unlock;</span><br><span class="line">#endif</span><br><span class="line">	&#125;</span><br><span class="line">	raw_spin_unlock_irqrestore(&amp;mcc-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">skip_unlock: __attribute__ ((unused));</span><br><span class="line">	capacity *= scale_rt_capacity(cpu);</span><br><span class="line">	capacity &gt;&gt;= SCHED_CAPACITY_SHIFT;</span><br><span class="line"></span><br><span class="line">	if (!capacity)</span><br><span class="line">		capacity = 1;</span><br><span class="line"></span><br><span class="line">    /* (2) cpu_capacity = 最大capacity减去rt进程占用的比例 */</span><br><span class="line">	cpu_rq(cpu)-&gt;cpu_capacity = capacity;</span><br><span class="line">	sdg-&gt;sgc-&gt;capacity = capacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取capacity的函数有几种：capacity_orig_of()返回最大capacity，capacity_of()返回减去rt占用的capacity，capacity_curr_of()返回当前频率下的最大capacity。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static inline unsigned long capacity_of(int cpu)</span><br><span class="line">&#123;</span><br><span class="line">	return cpu_rq(cpu)-&gt;cpu_capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline unsigned long capacity_orig_of(int cpu)</span><br><span class="line">&#123;</span><br><span class="line">	return cpu_rq(cpu)-&gt;cpu_capacity_orig;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline unsigned long capacity_curr_of(int cpu)</span><br><span class="line">&#123;</span><br><span class="line">	return cpu_rq(cpu)-&gt;cpu_capacity_orig *</span><br><span class="line">	       arch_scale_freq_capacity(NULL, cpu)</span><br><span class="line">	       &gt;&gt; SCHED_CAPACITY_SHIFT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><em>9、__update_load_avg()函数完整的计算过程：</em></strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * We can represent the historical contribution to runnable average as the</span><br><span class="line"> * coefficients of a geometric series.  To do this we sub-divide our runnable</span><br><span class="line"> * history into segments of approximately 1ms (1024us); label the segment that</span><br><span class="line"> * occurred N-ms ago p_N, with p_0 corresponding to the current period, e.g.</span><br><span class="line"> *</span><br><span class="line"> * [&lt;- 1024us -&gt;|&lt;- 1024us -&gt;|&lt;- 1024us -&gt;| ...</span><br><span class="line"> *      p0            p1           p2</span><br><span class="line"> *     (now)       (~1ms ago)  (~2ms ago)</span><br><span class="line"> *</span><br><span class="line"> * Let u_i denote the fraction of p_i that the entity was runnable.</span><br><span class="line"> *</span><br><span class="line"> * We then designate the fractions u_i as our co-efficients, yielding the</span><br><span class="line"> * following representation of historical load:</span><br><span class="line"> *   u_0 + u_1*y + u_2*y^2 + u_3*y^3 + ...</span><br><span class="line"> *</span><br><span class="line"> * We choose y based on the with of a reasonably scheduling period, fixing:</span><br><span class="line"> *   y^32 = 0.5</span><br><span class="line"> *</span><br><span class="line"> * This means that the contribution to load ~32ms ago (u_32) will be weighted</span><br><span class="line"> * approximately half as much as the contribution to load within the last ms</span><br><span class="line"> * (u_0).</span><br><span class="line"> *</span><br><span class="line"> * When a period &quot;rolls over&quot; and we have new u_0`, multiplying the previous</span><br><span class="line"> * sum again by y is sufficient to update:</span><br><span class="line"> *   load_avg = u_0` + y*(u_0 + u_1*y + u_2*y^2 + ... )</span><br><span class="line"> *            = u_0 + u_1*y + u_2*y^2 + ... [re-labeling u_i --&gt; u_&#123;i+1&#125;]</span><br><span class="line"> */</span><br><span class="line">static __always_inline int</span><br><span class="line">__update_load_avg(u64 now, int cpu, struct sched_avg *sa,</span><br><span class="line">		  unsigned long weight, int running, struct cfs_rq *cfs_rq)</span><br><span class="line">&#123;</span><br><span class="line">	u64 delta, scaled_delta, periods;</span><br><span class="line">	u32 contrib;</span><br><span class="line">	unsigned int delta_w, scaled_delta_w, decayed = 0;</span><br><span class="line">	unsigned long scale_freq, scale_cpu;</span><br><span class="line"></span><br><span class="line">	delta = now - sa-&gt;last_update_time;</span><br><span class="line">	/*</span><br><span class="line">	 * This should only happen when time goes backwards, which it</span><br><span class="line">	 * unfortunately does during sched clock init when we swap over to TSC.</span><br><span class="line">	 */</span><br><span class="line">	if ((s64)delta &lt; 0) &#123;</span><br><span class="line">		sa-&gt;last_update_time = now;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Use 1024ns as the unit of measurement since it&apos;s a reasonable</span><br><span class="line">	 * approximation of 1us and fast to compute.</span><br><span class="line">	 */</span><br><span class="line">	/* (1) 把时间单位从ns，收缩成us */</span><br><span class="line">	delta &gt;&gt;= 10;</span><br><span class="line">	if (!delta)</span><br><span class="line">		return 0;</span><br><span class="line">	sa-&gt;last_update_time = now;</span><br><span class="line"></span><br><span class="line">    /* (2) scale_freq = (curr_freq/cpu_max)*1024 */</span><br><span class="line">	scale_freq = arch_scale_freq_capacity(NULL, cpu);</span><br><span class="line">	</span><br><span class="line">	/* (3) scale_cpu = (curr_cpu_perf/max_perf)*1024 */</span><br><span class="line">	scale_cpu = arch_scale_cpu_capacity(NULL, cpu);</span><br><span class="line"></span><br><span class="line">	/* delta_w is the amount already accumulated against our next period */</span><br><span class="line">	/* (4) 上次计算，没有凑成1024us整周期的余数 */</span><br><span class="line">	delta_w = sa-&gt;period_contrib;</span><br><span class="line">	if (delta + delta_w &gt;= 1024) &#123;</span><br><span class="line">		decayed = 1;</span><br><span class="line"></span><br><span class="line">		/* how much left for next period will start over, we don&apos;t know yet */</span><br><span class="line">		sa-&gt;period_contrib = 0;</span><br><span class="line"></span><br><span class="line">		/*</span><br><span class="line">		 * Now that we know we&apos;re crossing a period boundary, figure</span><br><span class="line">		 * out how much from delta we need to complete the current</span><br><span class="line">		 * period and accrue it.</span><br><span class="line">		 */</span><br><span class="line">		/* (5) 计算时间段A的负载 */</span><br><span class="line">		delta_w = 1024 - delta_w;</span><br><span class="line">		/* scaled_delta_w = (time*scale_freq)/1024 */</span><br><span class="line">		scaled_delta_w = cap_scale(delta_w, scale_freq);</span><br><span class="line">		if (weight) &#123;</span><br><span class="line">		    /* (5.1) load_sum = (weight*time*scale_freq)/1024 */</span><br><span class="line">			sa-&gt;load_sum += weight * scaled_delta_w;</span><br><span class="line">			</span><br><span class="line">			/* (5.2) loadwop_sum = (1024*time*scale_freq)/1024 </span><br><span class="line">			    = time*scale_freq</span><br><span class="line">			 */</span><br><span class="line">			sa-&gt;loadwop_sum += NICE_0_LOAD * scaled_delta_w;</span><br><span class="line">			</span><br><span class="line">			/* (5.3) 如果cfs_rq不为空，增加cfs_rq的统计 */</span><br><span class="line">			if (cfs_rq) &#123;</span><br><span class="line">				cfs_rq-&gt;runnable_load_sum +=</span><br><span class="line">						weight * scaled_delta_w;</span><br><span class="line">				</span><br><span class="line">				/* ooooo这里是一个bug：计算cfs_rq负载的时候，cfs_rq-&gt;avg会被计算两次</span><br><span class="line">				    看最新的代码中已经被修复</span><br><span class="line">				 */</span><br><span class="line">				cfs_rq-&gt;avg.loadwop_sum +=</span><br><span class="line">						NICE_0_LOAD * scaled_delta_w;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		/* (5.4) util_sum统计running状态的负载，不统计runnable负载 </span><br><span class="line">		    util_sum = (time*scale_freq*scale_cpu)/1024</span><br><span class="line">		 */</span><br><span class="line">		if (running)</span><br><span class="line">			sa-&gt;util_sum += scaled_delta_w * scale_cpu;</span><br><span class="line"></span><br><span class="line">		delta -= delta_w;</span><br><span class="line"></span><br><span class="line">		/* Figure out how many additional periods this update spans */</span><br><span class="line">		periods = delta / 1024;</span><br><span class="line">		delta %= 1024;</span><br><span class="line"></span><br><span class="line">        /* (5.5) 衰减时间段A的负载 */</span><br><span class="line">		sa-&gt;load_sum = decay_load(sa-&gt;load_sum, periods + 1);</span><br><span class="line">		sa-&gt;loadwop_sum = decay_load(sa-&gt;loadwop_sum, periods + 1);</span><br><span class="line">		if (cfs_rq) &#123;</span><br><span class="line">			cfs_rq-&gt;runnable_load_sum =</span><br><span class="line">				decay_load(cfs_rq-&gt;runnable_load_sum, periods + 1);</span><br><span class="line">			cfs_rq-&gt;avg.loadwop_sum =</span><br><span class="line">				decay_load(cfs_rq-&gt;avg.loadwop_sum, periods + 1);</span><br><span class="line">		&#125;</span><br><span class="line">		sa-&gt;util_sum = decay_load((u64)(sa-&gt;util_sum), periods + 1);</span><br><span class="line"></span><br><span class="line">		/* Efficiently calculate \sum (1..n_period) 1024*y^i */</span><br><span class="line">		/* (6) 计算时间段B的负载 */</span><br><span class="line">		contrib = __compute_runnable_contrib(periods);</span><br><span class="line">		contrib = cap_scale(contrib, scale_freq);</span><br><span class="line">		if (weight) &#123;</span><br><span class="line">			sa-&gt;load_sum += weight * contrib;</span><br><span class="line">			sa-&gt;loadwop_sum += NICE_0_LOAD * contrib;</span><br><span class="line">			if (cfs_rq) &#123;</span><br><span class="line">				cfs_rq-&gt;runnable_load_sum += weight * contrib;</span><br><span class="line">				cfs_rq-&gt;avg.loadwop_sum +=</span><br><span class="line">						NICE_0_LOAD * contrib;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (running)</span><br><span class="line">			sa-&gt;util_sum += contrib * scale_cpu;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* Remainder of delta accrued against u_0` */</span><br><span class="line">	/* (6) 计算时间段c的负载 */</span><br><span class="line">	scaled_delta = cap_scale(delta, scale_freq);</span><br><span class="line">	if (weight) &#123;</span><br><span class="line">		sa-&gt;load_sum += weight * scaled_delta;</span><br><span class="line">		sa-&gt;loadwop_sum += NICE_0_LOAD * scaled_delta;</span><br><span class="line">		if (cfs_rq) &#123;</span><br><span class="line">			cfs_rq-&gt;runnable_load_sum += weight * scaled_delta;</span><br><span class="line">			cfs_rq-&gt;avg.loadwop_sum +=</span><br><span class="line">				NICE_0_LOAD * scaled_delta;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if (running)</span><br><span class="line">		sa-&gt;util_sum += scaled_delta * scale_cpu;</span><br><span class="line"></span><br><span class="line">	sa-&gt;period_contrib += delta;</span><br><span class="line"></span><br><span class="line">    /* (7) 计算把负载转换成相对值 */</span><br><span class="line">	if (decayed) &#123;</span><br><span class="line">		sa-&gt;load_avg = div_u64(sa-&gt;load_sum, LOAD_AVG_MAX);</span><br><span class="line">		sa-&gt;loadwop_avg = div_u64(sa-&gt;loadwop_sum, LOAD_AVG_MAX);</span><br><span class="line"></span><br><span class="line">		if (cfs_rq) &#123;</span><br><span class="line">			cfs_rq-&gt;runnable_load_avg =</span><br><span class="line">				div_u64(cfs_rq-&gt;runnable_load_sum, LOAD_AVG_MAX);</span><br><span class="line">			cfs_rq-&gt;avg.loadwop_avg =</span><br><span class="line">				div_u64(cfs_rq-&gt;avg.loadwop_sum, LOAD_AVG_MAX);</span><br><span class="line">		&#125;</span><br><span class="line">		sa-&gt;util_avg = sa-&gt;util_sum / LOAD_AVG_MAX;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return decayed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-2、cpu级的负载计算update-cpu-load-active"><a href="#3-2、cpu级的负载计算update-cpu-load-active" class="headerlink" title="3.2、cpu级的负载计算update_cpu_load_active()"></a>3.2、cpu级的负载计算update_cpu_load_active()</h2><p>__update_load_avg()是计算se/cfs_rq级别的负载，在cpu级别linux使用update_cpu_load_active()来计算整个cpu-&gt;rq负载的变化趋势。计算也是周期性的，周期为1 tick。</p>
<blockquote>
<p>暂时我理解，这个rq load没有计入rt的负载。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">scheduler_tick() </span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">void update_cpu_load_active(struct rq *this_rq)</span><br><span class="line">&#123;</span><br><span class="line">    /* (1) 被累计的为：当前rqrunnable平均负载带weight分量(cpu-&gt;rq-&gt;cfs_rq-&gt;runnable_load_avg) */</span><br><span class="line">	unsigned long load = weighted_cpuload(cpu_of(this_rq));</span><br><span class="line">	/*</span><br><span class="line">	 * See the mess around update_idle_cpu_load() / update_cpu_load_nohz().</span><br><span class="line">	 */</span><br><span class="line">	this_rq-&gt;last_load_update_tick = jiffies;</span><br><span class="line">	/* (2)   */</span><br><span class="line">	__update_cpu_load(this_rq, load, 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Update rq-&gt;cpu_load[] statistics. This function is usually called every</span><br><span class="line"> * scheduler tick (TICK_NSEC). With tickless idle this will not be called</span><br><span class="line"> * every tick. We fix it up based on jiffies.</span><br><span class="line"> */</span><br><span class="line">static void __update_cpu_load(struct rq *this_rq, unsigned long this_load,</span><br><span class="line">			      unsigned long pending_updates)</span><br><span class="line">&#123;</span><br><span class="line">	int i, scale;</span><br><span class="line"></span><br><span class="line">	this_rq-&gt;nr_load_updates++;</span><br><span class="line"></span><br><span class="line">	/* Update our load: */</span><br><span class="line">	/* (2.1) 逐个计算cpu_load[]中5个时间等级的值 */</span><br><span class="line">	this_rq-&gt;cpu_load[0] = this_load; /* Fasttrack for idx 0 */</span><br><span class="line">	for (i = 1, scale = 2; i &lt; CPU_LOAD_IDX_MAX; i++, scale += scale) &#123;</span><br><span class="line">		unsigned long old_load, new_load;</span><br><span class="line"></span><br><span class="line">		/* scale is effectively 1 &lt;&lt; i now, and &gt;&gt; i divides by scale */</span><br><span class="line"></span><br><span class="line">		old_load = this_rq-&gt;cpu_load[i];</span><br><span class="line">		/* (2.2) 如果因为进入noHZ模式，有pending_updates个tick没有更新，</span><br><span class="line">		    先老化原有负载</span><br><span class="line">		 */</span><br><span class="line">		old_load = decay_load_missed(old_load, pending_updates - 1, i);</span><br><span class="line">		new_load = this_load;</span><br><span class="line">		/*</span><br><span class="line">		 * Round up the averaging division if load is increasing. This</span><br><span class="line">		 * prevents us from getting stuck on 9 if the load is 10, for</span><br><span class="line">		 * example.</span><br><span class="line">		 */</span><br><span class="line">		if (new_load &gt; old_load)</span><br><span class="line">			new_load += scale - 1;</span><br><span class="line"></span><br><span class="line">        /* (2.3) cpu_load的计算公式 */</span><br><span class="line">		this_rq-&gt;cpu_load[i] = (old_load * (scale - 1) + new_load) &gt;&gt; i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sched_avg_update(this_rq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码注释中详细解释了cpu_load的计算方法：</p>
<ul>
<li><p>1、每个tick计算不同idx时间等级的load，计算公式：load = (2^idx - 1) / 2^idx <em> load + 1 / 2^idx </em> cur_load</p>
</li>
<li><p>2、如果cpu因为noHZ错过了(n-1)个tick的更新，那么计算load要分两步：</p>
<p>  首先老化(decay)原有的load：load = ((2^idx - 1) / 2^idx)^(n-1) <em> load<br>  再按照一般公式计算load：load = (2^idx - 1) / 2^idx) </em> load + 1 / 2^idx * cur_load</p>
</li>
<li><p>3、为了decay的加速计算，设计了decay_load_missed()查表法计算：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * The exact cpuload at various idx values, calculated at every tick would be</span><br><span class="line"> * load = (2^idx - 1) / 2^idx * load + 1 / 2^idx * cur_load</span><br><span class="line"> *</span><br><span class="line"> * If a cpu misses updates for n-1 ticks (as it was idle) and update gets called</span><br><span class="line"> * on nth tick when cpu may be busy, then we have:</span><br><span class="line"> * load = ((2^idx - 1) / 2^idx)^(n-1) * load</span><br><span class="line"> * load = (2^idx - 1) / 2^idx) * load + 1 / 2^idx * cur_load</span><br><span class="line"> *</span><br><span class="line"> * decay_load_missed() below does efficient calculation of</span><br><span class="line"> * load = ((2^idx - 1) / 2^idx)^(n-1) * load</span><br><span class="line"> * avoiding 0..n-1 loop doing load = ((2^idx - 1) / 2^idx) * load</span><br><span class="line"> *</span><br><span class="line"> * The calculation is approximated on a 128 point scale.</span><br><span class="line"> * degrade_zero_ticks is the number of ticks after which load at any</span><br><span class="line"> * particular idx is approximated to be zero.</span><br><span class="line"> * degrade_factor is a precomputed table, a row for each load idx.</span><br><span class="line"> * Each column corresponds to degradation factor for a power of two ticks,</span><br><span class="line"> * based on 128 point scale.</span><br><span class="line"> * Example:</span><br><span class="line"> * row 2, col 3 (=12) says that the degradation at load idx 2 after</span><br><span class="line"> * 8 ticks is 12/128 (which is an approximation of exact factor 3^8/4^8).</span><br><span class="line"> *</span><br><span class="line"> * With this power of 2 load factors, we can degrade the load n times</span><br><span class="line"> * by looking at 1 bits in n and doing as many mult/shift instead of</span><br><span class="line"> * n mult/shifts needed by the exact degradation.</span><br><span class="line"> */</span><br><span class="line">#define DEGRADE_SHIFT		7</span><br><span class="line">static const unsigned char</span><br><span class="line">		degrade_zero_ticks[CPU_LOAD_IDX_MAX] = &#123;0, 8, 32, 64, 128&#125;;</span><br><span class="line">static const unsigned char</span><br><span class="line">		degrade_factor[CPU_LOAD_IDX_MAX][DEGRADE_SHIFT + 1] = &#123;</span><br><span class="line">					&#123;0, 0, 0, 0, 0, 0, 0, 0&#125;,</span><br><span class="line">					&#123;64, 32, 8, 0, 0, 0, 0, 0&#125;,</span><br><span class="line">					&#123;96, 72, 40, 12, 1, 0, 0&#125;,</span><br><span class="line">					&#123;112, 98, 75, 43, 15, 1, 0&#125;,</span><br><span class="line">					&#123;120, 112, 98, 76, 45, 16, 2&#125; &#125;;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Update cpu_load for any missed ticks, due to tickless idle. The backlog</span><br><span class="line"> * would be when CPU is idle and so we just decay the old load without</span><br><span class="line"> * adding any new load.</span><br><span class="line"> */</span><br><span class="line">static unsigned long</span><br><span class="line">decay_load_missed(unsigned long load, unsigned long missed_updates, int idx)</span><br><span class="line">&#123;</span><br><span class="line">	int j = 0;</span><br><span class="line"></span><br><span class="line">	if (!missed_updates)</span><br><span class="line">		return load;</span><br><span class="line"></span><br><span class="line">	if (missed_updates &gt;= degrade_zero_ticks[idx])</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">	if (idx == 1)</span><br><span class="line">		return load &gt;&gt; missed_updates;</span><br><span class="line"></span><br><span class="line">	while (missed_updates) &#123;</span><br><span class="line">		if (missed_updates % 2)</span><br><span class="line">			load = (load * degrade_factor[idx][j]) &gt;&gt; DEGRADE_SHIFT;</span><br><span class="line"></span><br><span class="line">		missed_updates &gt;&gt;= 1;</span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">	return load;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/scheduler/schedule_cpu_load.png" alt="schedule_cpu_load"></p>
<ul>
<li>1、cpu_load[]含5条均线，反应不同时间窗口长度下的负载情况；主要供load_balance()在不<br>同场景判断是否负载平衡的比较基准，常用为cpu_load[0]和cpu_load[1];</li>
<li>2、cpu_load[index]对应的时间长度为{0, 8, 32, 64, 128}，单位为tick;</li>
<li>3、移动均线的目的在于平滑样本的抖动，确定趋势的变化方向;</li>
</ul>
<h2 id="3-3、系统级的负载计算calc-global-load-tick"><a href="#3-3、系统级的负载计算calc-global-load-tick" class="headerlink" title="3.3、系统级的负载计算calc_global_load_tick()"></a>3.3、系统级的负载计算calc_global_load_tick()</h2><p>系统级的平均负载(load average)可以通过以下命令(uptime、top、cat /proc/loadavg)查看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ uptime</span><br><span class="line"> 16:48:24 up  4:11,  1 user,  load average: 25.25, 23.40, 23.46</span><br><span class="line"></span><br><span class="line">$ top - 16:48:42 up  4:12,  1 user,  load average: 25.25, 23.14, 23.37</span><br><span class="line"></span><br><span class="line">$ cat /proc/loadavg </span><br><span class="line">25.72 23.19 23.35 42/3411 43603</span><br></pre></td></tr></table></figure>
<p>“load average:”后面的3个数字分别表示1分钟、5分钟、15分钟的load average。可以从几方面去解析load average：</p>
<ul>
<li>If the averages are 0.0, then your system is idle.</li>
<li>If the 1 minute average is higher than the 5 or 15 minute averages, then load is increasing.</li>
<li>If the 1 minute average is lower than the 5 or 15 minute averages, then load is decreasing.</li>
<li>If they are higher than your CPU count, then you might have a performance problem (it depends).</li>
</ul>
<p><img src="/images/scheduler/schedule_sys_load_avg.png" alt="schedule_sys_load_avg"></p>
<blockquote>
<p>最早的系统级平均负载(load average)只会统计runnable状态。但是linux后面觉得这种统计方式代表不了系统的真实负载；举一个例子：系统换一个低速硬盘后，他的runnable负载还会小于高速硬盘时的值；linux认为睡眠状态(TASK_INTERRUPTIBLE/TASK_UNINTERRUPTIBLE)也是系统的一种负载，系统得不到服务是因为io/外设的负载过重；系统级负载统计函数calc_global_load_tick()中会把(this_rq-&gt;nr_running+this_rq-&gt;nr_uninterruptible)都计入负载；</p>
</blockquote>
<h3 id="3-3-1、calc-global-load-tick"><a href="#3-3-1、calc-global-load-tick" class="headerlink" title="3.3.1、calc_global_load_tick()"></a>3.3.1、calc_global_load_tick()</h3><p>我们来看详细的代码解析。</p>
<ul>
<li>1、每个cpu每隔5s更新本cpu rq的(nr_running+nr_uninterruptible)任务数量到系统全局变量calc_load_tasks，calc_load_tasks是整系统多个cpu(nr_running+nr_uninterruptible)任务数量的总和，多cpu在访问calc_load_tasks变量时使用原子操作来互斥。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">scheduler_tick()</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">void calc_global_load_tick(struct rq *this_rq)</span><br><span class="line">&#123;</span><br><span class="line">	long delta;</span><br><span class="line"></span><br><span class="line">    /* (1) 5S的更新周期 */</span><br><span class="line">	if (time_before(jiffies, this_rq-&gt;calc_load_update))</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">    /* (2) 计算本cpu的负载变化到全局变量calc_load_tasks中 */</span><br><span class="line">	delta  = calc_load_fold_active(this_rq);</span><br><span class="line">	if (delta)</span><br><span class="line">		atomic_long_add(delta, &amp;calc_load_tasks);</span><br><span class="line"></span><br><span class="line">	this_rq-&gt;calc_load_update += LOAD_FREQ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>2、多个cpu更新calc_load_tasks，但是计算load只由一个cpu来完成，这个cpu就是tick_do_timer_cpu。在linux time一文中，我们看到这个cpu就是专门来更新时间戳timer的(update_wall_time())。实际上它在更新时间戳的同时也会调用do_timer() -&gt; calc_global_load()来计算系统负载。</li>
</ul>
<p>核心算法calc_load()的思想也是：旧的load<em>老化系数 + 新load</em>系数</p>
<p>假设单位1为FIXED_1=2^11=2028，EXP_1=1884、EXP_5=2014、EXP_15=2037，load的计算：</p>
<p>load = old_load<em>(EXP_?/FIXED_1) + new_load</em>(FIXED_1-EXP_?)/FIXED_1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">do_timer() -&gt; calc_global_load()</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">void calc_global_load(unsigned long ticks)</span><br><span class="line">&#123;</span><br><span class="line">	long active, delta;</span><br><span class="line"></span><br><span class="line">    /* (1) 计算的间隔时间为5s + 10tick，</span><br><span class="line">        加10tick的目的就是让所有cpu都更新完calc_load_tasks，</span><br><span class="line">        tick_do_timer_cpu再来计算</span><br><span class="line">     */</span><br><span class="line">	if (time_before(jiffies, calc_load_update + 10))</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Fold the &apos;old&apos; idle-delta to include all NO_HZ cpus.</span><br><span class="line">	 */</span><br><span class="line">	delta = calc_load_fold_idle();</span><br><span class="line">	if (delta)</span><br><span class="line">		atomic_long_add(delta, &amp;calc_load_tasks);</span><br><span class="line"></span><br><span class="line">    /* (2) 读取全局统计变量 */</span><br><span class="line">	active = atomic_long_read(&amp;calc_load_tasks);</span><br><span class="line">	active = active &gt; 0 ? active * FIXED_1 : 0;</span><br><span class="line"></span><br><span class="line">    /* (3) 计算1分钟、5分钟、15分钟的负载 */</span><br><span class="line">	avenrun[0] = calc_load(avenrun[0], EXP_1, active);</span><br><span class="line">	avenrun[1] = calc_load(avenrun[1], EXP_5, active);</span><br><span class="line">	avenrun[2] = calc_load(avenrun[2], EXP_15, active);</span><br><span class="line"></span><br><span class="line">	calc_load_update += LOAD_FREQ;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * In case we idled for multiple LOAD_FREQ intervals, catch up in bulk.</span><br><span class="line">	 */</span><br><span class="line">	calc_global_nohz();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * a1 = a0 * e + a * (1 - e)</span><br><span class="line"> */</span><br><span class="line">static unsigned long</span><br><span class="line">calc_load(unsigned long load, unsigned long exp, unsigned long active)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned long newload;</span><br><span class="line"></span><br><span class="line">	newload = load * exp + active * (FIXED_1 - exp);</span><br><span class="line">	if (active &gt;= load)</span><br><span class="line">		newload += FIXED_1-1;</span><br><span class="line"></span><br><span class="line">	return newload / FIXED_1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#define FSHIFT		11		/* nr of bits of precision */</span><br><span class="line">#define FIXED_1		(1&lt;&lt;FSHIFT)	/* 1.0 as fixed-point */</span><br><span class="line">#define LOAD_FREQ	(5*HZ+1)	/* 5 sec intervals */</span><br><span class="line">#define EXP_1		1884		/* 1/exp(5sec/1min) as fixed-point */</span><br><span class="line">#define EXP_5		2014		/* 1/exp(5sec/5min) */</span><br><span class="line">#define EXP_15		2037		/* 1/exp(5sec/15min) */</span><br></pre></td></tr></table></figure>
<p>3、/proc/loadavg</p>
<p>代码实现在kernel/fs/proc/loadavg.c中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static int loadavg_proc_show(struct seq_file *m, void *v)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned long avnrun[3];</span><br><span class="line"></span><br><span class="line">	get_avenrun(avnrun, FIXED_1/200, 0);</span><br><span class="line"></span><br><span class="line">	seq_printf(m, &quot;%lu.%02lu %lu.%02lu %lu.%02lu %ld/%d %d\n&quot;,</span><br><span class="line">		LOAD_INT(avnrun[0]), LOAD_FRAC(avnrun[0]),</span><br><span class="line">		LOAD_INT(avnrun[1]), LOAD_FRAC(avnrun[1]),</span><br><span class="line">		LOAD_INT(avnrun[2]), LOAD_FRAC(avnrun[2]),</span><br><span class="line">		nr_running(), nr_threads,</span><br><span class="line">		task_active_pid_ns(current)-&gt;last_pid);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-4-占用率统计"><a href="#3-4-占用率统计" class="headerlink" title="3.4 占用率统计"></a>3.4 占用率统计</h2><h3 id="3-4-1、cputime-c"><a href="#3-4-1、cputime-c" class="headerlink" title="3.4.1、cputime.c"></a>3.4.1、cputime.c</h3><p>top命令利用“/proc/stat”、“/proc/stat”来做cpu占用率统计，可以在AOSP/system/core/toolbox/top.c中查看top代码实现。</p>
<p>读取/proc/stat可以查看系统各种状态的时间统计，代码实现在fs/proc/stat.c show_stat()。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># cat /proc/stat</span><br><span class="line"></span><br><span class="line">/* 系统时间的累加，格式 = </span><br><span class="line">&quot;cpu, user, nice, system, idle, iowait, irq, softirq, steal, guest, guest_nice&quot; </span><br><span class="line">*/</span><br><span class="line">cpu  4022747 54885 15739405 106716492 190413 0 38250 0 0 0   </span><br><span class="line">cpu0 2507238 44342 9881429 87084619 154904 0 32594 0 0 0</span><br><span class="line">intr 242500437 0 0 149757888 0 0 5 15529 0 0 0 0 0 0 0 0 18385 3111402 0 6862026 128 0 0 2 0 0 0 0 276502 2317633 4713710 0 0 0 3 2604 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1211 0 760467 0 0 27713 0 0 0 0 0 0 0 0 0 0 0 0 1789515 8333417 1369 3344 2399 389 0 23665294 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4068 0 0 0 0 13984 0 0 0 0 0 0 0 0 0 0 0 13585 169 13590 169 19300 169 0 0 0 0 0 45 0 9622 0 0 0 0 0 0 0 0 0 27026 1948 0 19475 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 242 0 0 0 0 0 0 0 2580 2595 0 0 0 873 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 17 0 0 0 0 1 7340 0 0 635 102644 167 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 292 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 58 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span><br><span class="line"></span><br><span class="line">/* 格式：</span><br><span class="line">nctxt: sum += cpu_rq(i)-&gt;nr_switches;</span><br><span class="line">btime：boottime.tv_sec</span><br><span class="line">processes：total_forks</span><br><span class="line">procs_running：sum += cpu_rq(i)-&gt;nr_running;</span><br><span class="line">procs_blocked：sum += atomic_read(&amp;cpu_rq(i)-&gt;nr_iowait);</span><br><span class="line">*/</span><br><span class="line">ctxt 384108244</span><br><span class="line">btime 1512114477</span><br><span class="line">processes 130269</span><br><span class="line">procs_running 1</span><br><span class="line">procs_blocked 0</span><br><span class="line"></span><br><span class="line">/* 软中断的次数统计，格式：</span><br><span class="line">softirq, 全局统计, HI_SOFTIRQ, TIMER_SOFTIRQ, NET_TX_SOFTIRQ, NET_RX_SOFTIRQ, BLOCK_SOFTIRQ, BLOCK_IOPOLL_SOFTIRQ, TASKLET_SOFTIRQ, SCHED_SOFTIRQ, HRTIMER_SOFTIRQ, RCU_SOFTIRQ</span><br><span class="line">*/</span><br><span class="line">softirq 207132697 736178 121273868 735555 9094 2134399 734917 746032 14491717 0 66270937</span><br></pre></td></tr></table></figure>
<p>读取/proc/pid/stat可以查看进程各种状态的时间统计，代码实现在fs/proc/array.c do_task_stat()。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># cat /proc/824/stat</span><br><span class="line">824 (ifaad) S 1 824 0 0 -1 4210944 600 0 2 0 1 1 0 0 20 0 1 0 2648 12922880 1066 18446744073709551615 416045604864 416045622068 548870218464 548870217760 500175854100 0 0 0 32768 1 0 0 17 6 0 0 0 0 0 416045629200 416045633544 416159543296 548870220457 548870220475 548870220475 548870221798 0</span><br></pre></td></tr></table></figure>
<p>相关的时间统计是在cputime.c中实现的，在每个tick任务中通过采样法计算系统和进程不同状态下的时间统计，这种方法精度是不高的：</p>
<ul>
<li>1、采样法只能在tick时采样，中间发生了任务调度不可统计；</li>
<li>2、系统统计了以下几种类型：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">enum cpu_usage_stat &#123;</span><br><span class="line">	CPUTIME_USER,</span><br><span class="line">	CPUTIME_NICE,</span><br><span class="line">	CPUTIME_SYSTEM,</span><br><span class="line">	CPUTIME_SOFTIRQ,</span><br><span class="line">	CPUTIME_IRQ,</span><br><span class="line">	CPUTIME_IDLE,</span><br><span class="line">	CPUTIME_IOWAIT,</span><br><span class="line">	CPUTIME_STEAL,</span><br><span class="line">	CPUTIME_GUEST,</span><br><span class="line">	CPUTIME_GUEST_NICE,</span><br><span class="line">	NR_STATS,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>3、在nohz模式时，退出nohz时会使用tick_nohz_idle_exit() -&gt; tick_nohz_account_idle_ticks() -&gt; account_idle_ticks()加上nohz损失的idle时间；</li>
</ul>
<p>tick统计的代码详细解析如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line">update_process_times() -&gt; account_process_tick()</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">void account_process_tick(struct task_struct *p, int user_tick)</span><br><span class="line">&#123;</span><br><span class="line">	cputime_t one_jiffy_scaled = cputime_to_scaled(cputime_one_jiffy);</span><br><span class="line">	struct rq *rq = this_rq();</span><br><span class="line"></span><br><span class="line">	if (vtime_accounting_enabled())</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	if (sched_clock_irqtime) &#123;</span><br><span class="line">	    /* (1) 如果irq的时间需要被统计，使用新的函数 */</span><br><span class="line">		irqtime_account_process_tick(p, user_tick, rq, 1);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (steal_account_process_tick())</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	if (user_tick)</span><br><span class="line">	    /* (2) 统计用户态时间 */</span><br><span class="line">		account_user_time(p, cputime_one_jiffy, one_jiffy_scaled);</span><br><span class="line">	else if ((p != rq-&gt;idle) || (irq_count() != HARDIRQ_OFFSET))</span><br><span class="line">	    /* (3) 统计用户态时间 */</span><br><span class="line">		account_system_time(p, HARDIRQ_OFFSET, cputime_one_jiffy,</span><br><span class="line">				    one_jiffy_scaled);</span><br><span class="line">	else</span><br><span class="line">	    /* (4) 统计idle时间 */</span><br><span class="line">		account_idle_time(cputime_one_jiffy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">static void irqtime_account_process_tick(struct task_struct *p, int user_tick,</span><br><span class="line">					 struct rq *rq, int ticks)</span><br><span class="line">&#123;</span><br><span class="line">    /* (1.1) 1 tick的时间 */</span><br><span class="line">	cputime_t scaled = cputime_to_scaled(cputime_one_jiffy);</span><br><span class="line">	u64 cputime = (__force u64) cputime_one_jiffy;</span><br><span class="line">	</span><br><span class="line">	/* (1.2) cpu级别的统计结构：kcpustat_this_cpu-&gt;cpustat */</span><br><span class="line">	u64 *cpustat = kcpustat_this_cpu-&gt;cpustat;</span><br><span class="line"></span><br><span class="line">	if (steal_account_process_tick())</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	cputime *= ticks;</span><br><span class="line">	scaled *= ticks;</span><br><span class="line"></span><br><span class="line">    /* (1.3) 如果irq时间已经增加，把本tick 时间加到IRQ时间，加入cpu级别统计 */</span><br><span class="line">	if (irqtime_account_hi_update()) &#123;</span><br><span class="line">		cpustat[CPUTIME_IRQ] += cputime;</span><br><span class="line">		</span><br><span class="line">	/* (1.4) 如果softirq时间已经增加，把本tick 时间加到SOFTIRQ时间，加入cpu级别统计 */</span><br><span class="line">	&#125; else if (irqtime_account_si_update()) &#123;</span><br><span class="line">		cpustat[CPUTIME_SOFTIRQ] += cputime;</span><br><span class="line">		</span><br><span class="line">	/* (1.5) 加入system内核态 CPUTIME_SOFTIRQ时间，加入cpu级别、进程级别统计 */</span><br><span class="line">	&#125; else if (this_cpu_ksoftirqd() == p) &#123;</span><br><span class="line">		/*</span><br><span class="line">		 * ksoftirqd time do not get accounted in cpu_softirq_time.</span><br><span class="line">		 * So, we have to handle it separately here.</span><br><span class="line">		 * Also, p-&gt;stime needs to be updated for ksoftirqd.</span><br><span class="line">		 */</span><br><span class="line">		__account_system_time(p, cputime, scaled, CPUTIME_SOFTIRQ);</span><br><span class="line">		</span><br><span class="line">	/* (1.6) 加入用户态时间，加入cpu级别、进程级别统计 */</span><br><span class="line">	&#125; else if (user_tick) &#123;</span><br><span class="line">		account_user_time(p, cputime, scaled);</span><br><span class="line">		</span><br><span class="line">	/* (1.7) 加入idle时间，加入cpu级别统计 */</span><br><span class="line">	&#125; else if (p == rq-&gt;idle) &#123;</span><br><span class="line">		account_idle_time(cputime);</span><br><span class="line">	</span><br><span class="line">	/* (1.8) 加入guest时间，把system时间转成user时间 */</span><br><span class="line">	&#125; else if (p-&gt;flags &amp; PF_VCPU) &#123; /* System time or guest time */</span><br><span class="line">		account_guest_time(p, cputime, scaled);</span><br><span class="line">		</span><br><span class="line">	/* (1.9) 加入system内核态 CPUTIME_SYSTEM时间，加入cpu级别、进程级别统计 */</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		__account_system_time(p, cputime, scaled,	CPUTIME_SYSTEM);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">||→</span><br><span class="line"></span><br><span class="line">static inline</span><br><span class="line">void __account_system_time(struct task_struct *p, cputime_t cputime,</span><br><span class="line">			cputime_t cputime_scaled, int index)</span><br><span class="line">&#123;</span><br><span class="line">	/* Add system time to process. */</span><br><span class="line">	/* (1.5.1) 增加进程级别的内核态时间p-&gt;stime */</span><br><span class="line">	p-&gt;stime += cputime;</span><br><span class="line">	p-&gt;stimescaled += cputime_scaled;</span><br><span class="line">	/* 统计task所在线程组(thread group)的运行时间：tsk-&gt;signal-&gt;cputimer-&gt;cputime_atomic.stime */</span><br><span class="line">	account_group_system_time(p, cputime);</span><br><span class="line"></span><br><span class="line">	/* Add system time to cpustat. */</span><br><span class="line">	/* (1.5.2) 更新CPU级别的cpustat统计：kernel_cpustat.cpustat[index]</span><br><span class="line">	    更新cpuacct的cpustat统计：ca-&gt;cpustat-&gt;cpustat[index]</span><br><span class="line">	 */</span><br><span class="line">	task_group_account_field(p, index, (__force u64) cputime);</span><br><span class="line"></span><br><span class="line">	/* Account for system time used */</span><br><span class="line">	/* (1.5.3) 更新tsk-&gt;acct_timexpd、tsk-&gt;acct_rss_mem1、tsk-&gt;acct_vm_mem1 */</span><br><span class="line">	acct_account_cputime(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">||→</span><br><span class="line"></span><br><span class="line">void account_user_time(struct task_struct *p, cputime_t cputime,</span><br><span class="line">		       cputime_t cputime_scaled)</span><br><span class="line">&#123;</span><br><span class="line">	int index;</span><br><span class="line"></span><br><span class="line">	/* Add user time to process. */</span><br><span class="line">	/* (1.6.1) 增加进程级别的用户态时间p-&gt;utime */</span><br><span class="line">	p-&gt;utime += cputime;</span><br><span class="line">	p-&gt;utimescaled += cputime_scaled;</span><br><span class="line">	/* 统计task所在线程组(thread group)的运行时间：tsk-&gt;signal-&gt;cputimer-&gt;cputime_atomic.utime */</span><br><span class="line">	account_group_user_time(p, cputime);</span><br><span class="line"></span><br><span class="line">	index = (task_nice(p) &gt; 0) ? CPUTIME_NICE : CPUTIME_USER;</span><br><span class="line"></span><br><span class="line">	/* Add user time to cpustat. */</span><br><span class="line">	/* (1.6.2) 更新CPU级别的cpustat统计：kernel_cpustat.cpustat[index]</span><br><span class="line">	    更新cpuacct的cpustat统计：ca-&gt;cpustat-&gt;cpustat[index]</span><br><span class="line">	 */</span><br><span class="line">	task_group_account_field(p, index, (__force u64) cputime);</span><br><span class="line"></span><br><span class="line">	/* Account for user time used */</span><br><span class="line">	/* (1.6.3) 更新tsk-&gt;acct_timexpd、tsk-&gt;acct_rss_mem1、tsk-&gt;acct_vm_mem1 */</span><br><span class="line">	acct_account_cputime(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">||→</span><br><span class="line"></span><br><span class="line">void account_idle_time(cputime_t cputime)</span><br><span class="line">&#123;</span><br><span class="line">	u64 *cpustat = kcpustat_this_cpu-&gt;cpustat;</span><br><span class="line">	struct rq *rq = this_rq();</span><br><span class="line"></span><br><span class="line">    /* (1.7.1) 把本tick 时间加到CPUTIME_IOWAIT时间，加入cpu级别统计 */</span><br><span class="line">	if (atomic_read(&amp;rq-&gt;nr_iowait) &gt; 0)</span><br><span class="line">		cpustat[CPUTIME_IOWAIT] += (__force u64) cputime;</span><br><span class="line">	</span><br><span class="line">	/* (1.7.1) 把本tick 时间加到CPUTIME_IDLE时间，加入cpu级别统计 */</span><br><span class="line">	else</span><br><span class="line">		cpustat[CPUTIME_IDLE] += (__force u64) cputime;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">||→</span><br><span class="line"></span><br><span class="line">static void account_guest_time(struct task_struct *p, cputime_t cputime,</span><br><span class="line">			       cputime_t cputime_scaled)</span><br><span class="line">&#123;</span><br><span class="line">	u64 *cpustat = kcpustat_this_cpu-&gt;cpustat;</span><br><span class="line"></span><br><span class="line">	/* Add guest time to process. */</span><br><span class="line">	p-&gt;utime += cputime;</span><br><span class="line">	p-&gt;utimescaled += cputime_scaled;</span><br><span class="line">	account_group_user_time(p, cputime);</span><br><span class="line">	p-&gt;gtime += cputime;</span><br><span class="line"></span><br><span class="line">	/* Add guest time to cpustat. */</span><br><span class="line">	if (task_nice(p) &gt; 0) &#123;</span><br><span class="line">		cpustat[CPUTIME_NICE] += (__force u64) cputime;</span><br><span class="line">		cpustat[CPUTIME_GUEST_NICE] += (__force u64) cputime;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		cpustat[CPUTIME_USER] += (__force u64) cputime;</span><br><span class="line">		cpustat[CPUTIME_GUEST] += (__force u64) cputime;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4、负载均衡"><a href="#4、负载均衡" class="headerlink" title="4、负载均衡"></a>4、负载均衡</h1><h2 id="4-1、SMP负载均衡"><a href="#4-1、SMP负载均衡" class="headerlink" title="4.1、SMP负载均衡"></a>4.1、SMP负载均衡</h2><h3 id="4-1-1、Scheduling-Domains"><a href="#4-1-1、Scheduling-Domains" class="headerlink" title="4.1.1、Scheduling Domains"></a>4.1.1、Scheduling Domains</h3><h4 id="4-1-1-1、Scheduling-Domains概念"><a href="#4-1-1-1、Scheduling-Domains概念" class="headerlink" title="4.1.1.1、Scheduling Domains概念"></a>4.1.1.1、Scheduling Domains概念</h4><p>借用<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-schldom/" target="_blank" rel="noopener">Linux Scheduling Domains</a>的描述，阐述Scheduling Domains的概念。</p>
<p>一个复杂的高端系统由上到下可以这样构成：</p>
<ul>
<li>1、它是一个 NUMA 架构的系统，系统中的每个 Node 访问系统中不同区域的内存有不同的速度。</li>
<li>2、同时它又是一个 SMP 系统。由多个物理 CPU(Physical Package) 构成。这些物理 CPU 共享系统中所有的内存。但都有自己独立的 Cache 。</li>
<li>3、每个物理 CPU 又由多个核 (Core) 构成，即 Multi-core 技术或者叫 Chip-level Multi processor(CMP) 。这些核都被集成在一块 die 里面。一般有自己独立的 L1 Cache，但可能共享 L2 Cache 。</li>
<li>4、每个核中又通过 SMT 之类的技术实现多个硬件线程，或者叫 Virtual CPU( 比如 Intel 的 Hyper-threading 技术 ) 。这些硬件线程，逻辑上看是就是一个 CPU 。它们之间几乎所有的东西都共享。包括 L1 Cache，甚至是逻辑运算单元 (ALU) 以及 Power 。</li>
</ul>
<p>可以看到cpu是有多个层级的，cpu和越近的层级之间共享的资源越多。所以进程在cpu之间迁移是有代价的，从性能的角度看，迁移跨越的层级越大性能损失越大。另外还需要从功耗的角度来考虑进程迁移的代价，这就是EAS考虑的。</p>
<h4 id="4-1-1-2、arm64-cpu-topology"><a href="#4-1-1-2、arm64-cpu-topology" class="headerlink" title="4.1.1.2、arm64 cpu_topology"></a>4.1.1.2、arm64 cpu_topology</h4><p>arm64架构的cpu拓扑结构存储在cpu_topology[]变量当中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * cpu topology table</span><br><span class="line"> */</span><br><span class="line">struct cpu_topology cpu_topology[NR_CPUS];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct cpu_topology &#123;</span><br><span class="line">	int thread_id;</span><br><span class="line">	int core_id;</span><br><span class="line">	int cluster_id;                 // 本cpu所在的cluster</span><br><span class="line">	unsigned int partno;</span><br><span class="line">	cpumask_t thread_sibling;</span><br><span class="line">	cpumask_t core_sibling;         // 在MutiCore层次(即同一个cluster中)，有哪些兄弟cpu</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>cpu_topology[]是parse_dt_cpu_capacity()函数解析dts中的信息建立的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line">kernel_init() -&gt; kernel_init_freeable() -&gt; smp_prepare_cpus() -&gt; init_cpu_topology() -&gt; parse_dt_topology()</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static int __init parse_dt_topology(void)</span><br><span class="line">&#123;</span><br><span class="line">	struct device_node *cn, *map;</span><br><span class="line">	int ret = 0;</span><br><span class="line">	int cpu;</span><br><span class="line"></span><br><span class="line">    /* (1) 找到dts中cpu topology的根节点&quot;/cpus&quot;&quot; */</span><br><span class="line">	cn = of_find_node_by_path(&quot;/cpus&quot;);</span><br><span class="line">	if (!cn) &#123;</span><br><span class="line">		pr_err(&quot;No CPU information found in DT\n&quot;);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * When topology is provided cpu-map is essentially a root</span><br><span class="line">	 * cluster with restricted subnodes.</span><br><span class="line">	 */</span><br><span class="line">	/* (2) 找到&quot;cpu-map&quot;节点 */</span><br><span class="line">	map = of_get_child_by_name(cn, &quot;cpu-map&quot;);</span><br><span class="line">	if (!map)</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">    /* (3) 解析&quot;cpu-map&quot;中的cluster */</span><br><span class="line">	ret = parse_cluster(map, 0);</span><br><span class="line">	if (ret != 0)</span><br><span class="line">		goto out_map;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Check that all cores are in the topology; the SMP code will</span><br><span class="line">	 * only mark cores described in the DT as possible.</span><br><span class="line">	 */</span><br><span class="line">	for_each_possible_cpu(cpu)</span><br><span class="line">		if (cpu_topology[cpu].cluster_id == -1)</span><br><span class="line">			ret = -EINVAL;</span><br><span class="line"></span><br><span class="line">out_map:</span><br><span class="line">	of_node_put(map);</span><br><span class="line">out:</span><br><span class="line">	of_node_put(cn);</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">static int __init parse_cluster(struct device_node *cluster, int depth)</span><br><span class="line">&#123;</span><br><span class="line">	char name[10];</span><br><span class="line">	bool leaf = true;</span><br><span class="line">	bool has_cores = false;</span><br><span class="line">	struct device_node *c;</span><br><span class="line">	static int cluster_id __initdata;</span><br><span class="line">	int core_id = 0;</span><br><span class="line">	int i, ret;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * First check for child clusters; we currently ignore any</span><br><span class="line">	 * information about the nesting of clusters and present the</span><br><span class="line">	 * scheduler with a flat list of them.</span><br><span class="line">	 */</span><br><span class="line">	i = 0;</span><br><span class="line">	/* (3.1) 如果有多级cluster，继续递归搜索 */</span><br><span class="line">	do &#123;</span><br><span class="line">		snprintf(name, sizeof(name), &quot;cluster%d&quot;, i);</span><br><span class="line">		c = of_get_child_by_name(cluster, name);</span><br><span class="line">		if (c) &#123;</span><br><span class="line">			leaf = false;</span><br><span class="line">			ret = parse_cluster(c, depth + 1);</span><br><span class="line">			of_node_put(c);</span><br><span class="line">			if (ret != 0)</span><br><span class="line">				return ret;</span><br><span class="line">		&#125;</span><br><span class="line">		i++;</span><br><span class="line">	&#125; while (c);</span><br><span class="line"></span><br><span class="line">	/* Now check for cores */</span><br><span class="line">	i = 0;</span><br><span class="line">	do &#123;</span><br><span class="line">	    /* (3.2) 或者core层次的节点 */</span><br><span class="line">		snprintf(name, sizeof(name), &quot;core%d&quot;, i);</span><br><span class="line">		c = of_get_child_by_name(cluster, name);</span><br><span class="line">		if (c) &#123;</span><br><span class="line">			has_cores = true;</span><br><span class="line"></span><br><span class="line">			if (depth == 0) &#123;</span><br><span class="line">				pr_err(&quot;%s: cpu-map children should be clusters\n&quot;,</span><br><span class="line">				       c-&gt;full_name);</span><br><span class="line">				of_node_put(c);</span><br><span class="line">				return -EINVAL;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			if (leaf) &#123;</span><br><span class="line">			    /* (3.3) 如果是叶子cluster节点，继续遍历core中的cpu节点 */</span><br><span class="line">				ret = parse_core(c, cluster_id, core_id++);</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				pr_err(&quot;%s: Non-leaf cluster with core %s\n&quot;,</span><br><span class="line">				       cluster-&gt;full_name, name);</span><br><span class="line">				ret = -EINVAL;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			of_node_put(c);</span><br><span class="line">			if (ret != 0)</span><br><span class="line">				return ret;</span><br><span class="line">		&#125;</span><br><span class="line">		i++;</span><br><span class="line">	&#125; while (c);</span><br><span class="line"></span><br><span class="line">	if (leaf &amp;&amp; !has_cores)</span><br><span class="line">		pr_warn(&quot;%s: empty cluster\n&quot;, cluster-&gt;full_name);</span><br><span class="line"></span><br><span class="line">	if (leaf)</span><br><span class="line">		cluster_id++;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">||→</span><br><span class="line"></span><br><span class="line">static int __init parse_core(struct device_node *core, int cluster_id,</span><br><span class="line">			     int core_id)</span><br><span class="line">&#123;</span><br><span class="line">	char name[10];</span><br><span class="line">	bool leaf = true;</span><br><span class="line">	int i = 0;</span><br><span class="line">	int cpu;</span><br><span class="line">	struct device_node *t;</span><br><span class="line"></span><br><span class="line">	do &#123;</span><br><span class="line">	    /* (3.3.1) 如果存在thread层级，解析thread和cpu层级 */</span><br><span class="line">		snprintf(name, sizeof(name), &quot;thread%d&quot;, i);</span><br><span class="line">		t = of_get_child_by_name(core, name);</span><br><span class="line">		if (t) &#123;</span><br><span class="line">			leaf = false;</span><br><span class="line">			cpu = get_cpu_for_node(t);</span><br><span class="line">			if (cpu &gt;= 0) &#123;</span><br><span class="line">				cpu_topology[cpu].cluster_id = cluster_id;</span><br><span class="line">				cpu_topology[cpu].core_id = core_id;</span><br><span class="line">				cpu_topology[cpu].thread_id = i;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				pr_err(&quot;%s: Can&apos;t get CPU for thread\n&quot;,</span><br><span class="line">				       t-&gt;full_name);</span><br><span class="line">				of_node_put(t);</span><br><span class="line">				return -EINVAL;</span><br><span class="line">			&#125;</span><br><span class="line">			of_node_put(t);</span><br><span class="line">		&#125;</span><br><span class="line">		i++;</span><br><span class="line">	&#125; while (t);</span><br><span class="line"></span><br><span class="line">    /* (3.3.2) 否则直接解析cpu层级 */</span><br><span class="line">	cpu = get_cpu_for_node(core);</span><br><span class="line">	if (cpu &gt;= 0) &#123;</span><br><span class="line">		if (!leaf) &#123;</span><br><span class="line">			pr_err(&quot;%s: Core has both threads and CPU\n&quot;,</span><br><span class="line">			       core-&gt;full_name);</span><br><span class="line">			return -EINVAL;</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">        /* (3.3.3) 得到了cpu的cluster_id/core_id */</span><br><span class="line">		cpu_topology[cpu].cluster_id = cluster_id;</span><br><span class="line">		cpu_topology[cpu].core_id = core_id;</span><br><span class="line">	&#125; else if (leaf) &#123;</span><br><span class="line">		pr_err(&quot;%s: Can&apos;t get CPU for leaf core\n&quot;, core-&gt;full_name);</span><br><span class="line">		return -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|||→</span><br><span class="line"></span><br><span class="line">static int __init get_cpu_for_node(struct device_node *node)</span><br><span class="line">&#123;</span><br><span class="line">	struct device_node *cpu_node;</span><br><span class="line">	int cpu;</span><br><span class="line"></span><br><span class="line">	cpu_node = of_parse_phandle(node, &quot;cpu&quot;, 0);</span><br><span class="line">	if (!cpu_node)</span><br><span class="line">		return -1;</span><br><span class="line"></span><br><span class="line">	for_each_possible_cpu(cpu) &#123;</span><br><span class="line">		if (of_get_cpu_node(cpu, NULL) == cpu_node) &#123;</span><br><span class="line">			of_node_put(cpu_node);</span><br><span class="line">			return cpu;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pr_crit(&quot;Unable to find CPU node for %s\n&quot;, cpu_node-&gt;full_name);</span><br><span class="line"></span><br><span class="line">	of_node_put(cpu_node);</span><br><span class="line">	return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>cpu同一层次的关系cpu_topology[cpu].core_sibling/thread_sibling会在update_siblings_masks()中更新：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">kernel_init() -&gt; kernel_init_freeable() -&gt; smp_prepare_cpus() -&gt; store_cpu_topology() -&gt; update_siblings_masks()</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static void update_siblings_masks(unsigned int cpuid)</span><br><span class="line">&#123;</span><br><span class="line">	struct cpu_topology *cpu_topo, *cpuid_topo = &amp;cpu_topology[cpuid];</span><br><span class="line">	int cpu;</span><br><span class="line"></span><br><span class="line">	/* update core and thread sibling masks */</span><br><span class="line">	for_each_possible_cpu(cpu) &#123;</span><br><span class="line">		cpu_topo = &amp;cpu_topology[cpu];</span><br><span class="line"></span><br><span class="line">		if (cpuid_topo-&gt;cluster_id != cpu_topo-&gt;cluster_id)</span><br><span class="line">			continue;</span><br><span class="line"></span><br><span class="line">		cpumask_set_cpu(cpuid, &amp;cpu_topo-&gt;core_sibling);</span><br><span class="line">		if (cpu != cpuid)</span><br><span class="line">			cpumask_set_cpu(cpu, &amp;cpuid_topo-&gt;core_sibling);</span><br><span class="line"></span><br><span class="line">		if (cpuid_topo-&gt;core_id != cpu_topo-&gt;core_id)</span><br><span class="line">			continue;</span><br><span class="line"></span><br><span class="line">		cpumask_set_cpu(cpuid, &amp;cpu_topo-&gt;thread_sibling);</span><br><span class="line">		if (cpu != cpuid)</span><br><span class="line">			cpumask_set_cpu(cpu, &amp;cpuid_topo-&gt;thread_sibling);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以mt6799为例，topology为”4<em>A35 + 4</em>A53 + 2*A73”，dts中定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line">mt6799.dtsi:</span><br><span class="line"></span><br><span class="line">cpus &#123;</span><br><span class="line">		#address-cells = &lt;1&gt;;</span><br><span class="line">		#size-cells = &lt;0&gt;;</span><br><span class="line"></span><br><span class="line">		cpu0: cpu@0 &#123;</span><br><span class="line">			device_type = &quot;cpu&quot;;</span><br><span class="line">			compatible = &quot;arm,cortex-a35&quot;;</span><br><span class="line">			reg = &lt;0x000&gt;;</span><br><span class="line">			enable-method = &quot;psci&quot;;</span><br><span class="line">			cpu-idle-states = &lt;&amp;LEGACY_MCDI &amp;LEGACY_SODI &amp;LEGACY_SODI3 &amp;LEGACY_DPIDLE&gt;,</span><br><span class="line">					  &lt;&amp;LEGACY_SUSPEND &amp;MCDI &amp;SODI &amp;SODI3 &amp;DPIDLE &amp;SUSPEND&gt;;</span><br><span class="line">			cpu-release-addr = &lt;0x0 0x40000200&gt;;</span><br><span class="line">			clock-frequency = &lt;1248000000&gt;;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		cpu1: cpu@001 &#123;</span><br><span class="line">			device_type = &quot;cpu&quot;;</span><br><span class="line">			compatible = &quot;arm,cortex-a35&quot;;</span><br><span class="line">			reg = &lt;0x001&gt;;</span><br><span class="line">			enable-method = &quot;psci&quot;;</span><br><span class="line">			cpu-idle-states = &lt;&amp;LEGACY_MCDI &amp;LEGACY_SODI &amp;LEGACY_SODI3 &amp;LEGACY_DPIDLE&gt;,</span><br><span class="line">					  &lt;&amp;LEGACY_SUSPEND &amp;MCDI &amp;SODI &amp;SODI3 &amp;DPIDLE &amp;SUSPEND&gt;;</span><br><span class="line">			cpu-release-addr = &lt;0x0 0x40000200&gt;;</span><br><span class="line">			clock-frequency = &lt;1248000000&gt;;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		cpu2: cpu@002 &#123;</span><br><span class="line">			device_type = &quot;cpu&quot;;</span><br><span class="line">			compatible = &quot;arm,cortex-a35&quot;;</span><br><span class="line">			reg = &lt;0x002&gt;;</span><br><span class="line">			enable-method = &quot;psci&quot;;</span><br><span class="line">			cpu-idle-states = &lt;&amp;LEGACY_MCDI &amp;LEGACY_SODI &amp;LEGACY_SODI3 &amp;LEGACY_DPIDLE&gt;,</span><br><span class="line">					  &lt;&amp;LEGACY_SUSPEND &amp;MCDI &amp;SODI &amp;SODI3 &amp;DPIDLE &amp;SUSPEND&gt;;</span><br><span class="line">			cpu-release-addr = &lt;0x0 0x40000200&gt;;</span><br><span class="line">			clock-frequency = &lt;1248000000&gt;;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		cpu3: cpu@003 &#123;</span><br><span class="line">			device_type = &quot;cpu&quot;;</span><br><span class="line">			compatible = &quot;arm,cortex-a35&quot;;</span><br><span class="line">			reg = &lt;0x003&gt;;</span><br><span class="line">			enable-method = &quot;psci&quot;;</span><br><span class="line">			cpu-idle-states = &lt;&amp;LEGACY_MCDI &amp;LEGACY_SODI &amp;LEGACY_SODI3 &amp;LEGACY_DPIDLE&gt;,</span><br><span class="line">					  &lt;&amp;LEGACY_SUSPEND &amp;MCDI &amp;SODI &amp;SODI3 &amp;DPIDLE &amp;SUSPEND&gt;;</span><br><span class="line">			cpu-release-addr = &lt;0x0 0x40000200&gt;;</span><br><span class="line">			clock-frequency = &lt;1248000000&gt;;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		cpu4: cpu@100 &#123;</span><br><span class="line">			device_type = &quot;cpu&quot;;</span><br><span class="line">			compatible = &quot;arm,cortex-a53&quot;;</span><br><span class="line">			reg = &lt;0x100&gt;;</span><br><span class="line">			enable-method = &quot;psci&quot;;</span><br><span class="line">			cpu-idle-states = &lt;&amp;LEGACY_MCDI &amp;LEGACY_SODI &amp;LEGACY_SODI3 &amp;LEGACY_DPIDLE&gt;,</span><br><span class="line">					  &lt;&amp;LEGACY_SUSPEND &amp;MCDI &amp;SODI &amp;SODI3 &amp;DPIDLE &amp;SUSPEND&gt;;</span><br><span class="line">			cpu-release-addr = &lt;0x0 0x40000200&gt;;</span><br><span class="line">			clock-frequency = &lt;1378000000&gt;;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		cpu5: cpu@101 &#123;</span><br><span class="line">			device_type = &quot;cpu&quot;;</span><br><span class="line">			compatible = &quot;arm,cortex-a53&quot;;</span><br><span class="line">			reg = &lt;0x101&gt;;</span><br><span class="line">			enable-method = &quot;psci&quot;;</span><br><span class="line">			cpu-idle-states = &lt;&amp;LEGACY_MCDI &amp;LEGACY_SODI &amp;LEGACY_SODI3 &amp;LEGACY_DPIDLE&gt;,</span><br><span class="line">					  &lt;&amp;LEGACY_SUSPEND &amp;MCDI &amp;SODI &amp;SODI3 &amp;DPIDLE &amp;SUSPEND&gt;;</span><br><span class="line">			cpu-release-addr = &lt;0x0 0x40000200&gt;;</span><br><span class="line">			clock-frequency = &lt;1378000000&gt;;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		cpu6: cpu@102 &#123;</span><br><span class="line">			device_type = &quot;cpu&quot;;</span><br><span class="line">			compatible = &quot;arm,cortex-a53&quot;;</span><br><span class="line">			reg = &lt;0x102&gt;;</span><br><span class="line">			enable-method = &quot;psci&quot;;</span><br><span class="line">			cpu-idle-states = &lt;&amp;LEGACY_MCDI &amp;LEGACY_SODI &amp;LEGACY_SODI3 &amp;LEGACY_DPIDLE&gt;,</span><br><span class="line">					  &lt;&amp;LEGACY_SUSPEND &amp;MCDI &amp;SODI &amp;SODI3 &amp;DPIDLE &amp;SUSPEND&gt;;</span><br><span class="line">			cpu-release-addr = &lt;0x0 0x40000200&gt;;</span><br><span class="line">			clock-frequency = &lt;1378000000&gt;;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		cpu7: cpu@103 &#123;</span><br><span class="line">			device_type = &quot;cpu&quot;;</span><br><span class="line">			compatible = &quot;arm,cortex-a53&quot;;</span><br><span class="line">			reg = &lt;0x103&gt;;</span><br><span class="line">			enable-method = &quot;psci&quot;;</span><br><span class="line">			cpu-idle-states = &lt;&amp;LEGACY_MCDI &amp;LEGACY_SODI &amp;LEGACY_SODI3 &amp;LEGACY_DPIDLE&gt;,</span><br><span class="line">					  &lt;&amp;LEGACY_SUSPEND &amp;MCDI &amp;SODI &amp;SODI3 &amp;DPIDLE &amp;SUSPEND&gt;;</span><br><span class="line">			cpu-release-addr = &lt;0x0 0x40000200&gt;;</span><br><span class="line">			clock-frequency = &lt;1378000000&gt;;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		cpu8: cpu@200 &#123;</span><br><span class="line">			device_type = &quot;cpu&quot;;</span><br><span class="line">			compatible = &quot;arm,cortex-a73&quot;;</span><br><span class="line">			reg = &lt;0x200&gt;;</span><br><span class="line">			enable-method = &quot;psci&quot;;</span><br><span class="line">			cpu-idle-states = &lt;&amp;LEGACY_MCDI &amp;LEGACY_SODI &amp;LEGACY_SODI3 &amp;LEGACY_DPIDLE&gt;,</span><br><span class="line">					  &lt;&amp;LEGACY_SUSPEND &amp;MCDI &amp;SODI &amp;SODI3 &amp;DPIDLE &amp;SUSPEND&gt;;</span><br><span class="line">			cpu-release-addr = &lt;0x0 0x40000200&gt;;</span><br><span class="line">			clock-frequency = &lt;1638000000&gt;;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		cpu9: cpu@201 &#123;</span><br><span class="line">			device_type = &quot;cpu&quot;;</span><br><span class="line">			compatible = &quot;arm,cortex-a73&quot;;</span><br><span class="line">			reg = &lt;0x201&gt;;</span><br><span class="line">			enable-method = &quot;psci&quot;;</span><br><span class="line">			cpu-idle-states = &lt;&amp;LEGACY_MCDI &amp;LEGACY_SODI &amp;LEGACY_SODI3 &amp;LEGACY_DPIDLE&gt;,</span><br><span class="line">					  &lt;&amp;LEGACY_SUSPEND &amp;MCDI &amp;SODI &amp;SODI3 &amp;DPIDLE &amp;SUSPEND&gt;;</span><br><span class="line">			cpu-release-addr = &lt;0x0 0x40000200&gt;;</span><br><span class="line">			clock-frequency = &lt;1638000000&gt;;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		cpu-map &#123;</span><br><span class="line">			cluster0 &#123;</span><br><span class="line">				core0 &#123;</span><br><span class="line">					cpu = &lt;&amp;cpu0&gt;;</span><br><span class="line">				&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">				core1 &#123;</span><br><span class="line">					cpu = &lt;&amp;cpu1&gt;;</span><br><span class="line">				&#125;;</span><br><span class="line"></span><br><span class="line">				core2 &#123;</span><br><span class="line">					cpu = &lt;&amp;cpu2&gt;;</span><br><span class="line">				&#125;;</span><br><span class="line"></span><br><span class="line">				core3 &#123;</span><br><span class="line">					cpu = &lt;&amp;cpu3&gt;;</span><br><span class="line">				&#125;;</span><br><span class="line"></span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			cluster1 &#123;</span><br><span class="line">				core0 &#123;</span><br><span class="line">					cpu = &lt;&amp;cpu4&gt;;</span><br><span class="line">				&#125;;</span><br><span class="line"></span><br><span class="line">				core1 &#123;</span><br><span class="line">					cpu = &lt;&amp;cpu5&gt;;</span><br><span class="line">				&#125;;</span><br><span class="line"></span><br><span class="line">				core2 &#123;</span><br><span class="line">					cpu = &lt;&amp;cpu6&gt;;</span><br><span class="line">				&#125;;</span><br><span class="line"></span><br><span class="line">				core3 &#123;</span><br><span class="line">					cpu = &lt;&amp;cpu7&gt;;</span><br><span class="line">				&#125;;</span><br><span class="line"></span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			cluster2 &#123;</span><br><span class="line">				core0 &#123;</span><br><span class="line">					cpu = &lt;&amp;cpu8&gt;;</span><br><span class="line">				&#125;;</span><br><span class="line"></span><br><span class="line">				core1 &#123;</span><br><span class="line">					cpu = &lt;&amp;cpu9&gt;;</span><br><span class="line">				&#125;;</span><br><span class="line"></span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><em>经过parse_dt_topology()、update_siblings_masks()解析后得到cpu_topology[}的值为：</em></strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cpu 0 cluster_id = 0, core_id = 0, core_sibling = 0xf</span><br><span class="line">cpu 1 cluster_id = 0, core_id = 1, core_sibling = 0xf</span><br><span class="line">cpu 2 cluster_id = 0, core_id = 2, core_sibling = 0xf</span><br><span class="line">cpu 3 cluster_id = 0, core_id = 3, core_sibling = 0xf</span><br><span class="line">cpu 4 cluster_id = 1, core_id = 0, core_sibling = 0xf0</span><br><span class="line">cpu 5 cluster_id = 1, core_id = 1, core_sibling = 0xf0</span><br><span class="line">cpu 6 cluster_id = 1, core_id = 2, core_sibling = 0xf0</span><br><span class="line">cpu 7 cluster_id = 1, core_id = 3, core_sibling = 0xf0</span><br><span class="line">cpu 8 cluster_id = 2, core_id = 0, core_sibling = 0x300</span><br><span class="line">cpu 9 cluster_id = 2, core_id = 1, core_sibling = 0x300</span><br></pre></td></tr></table></figure>
<h4 id="4-1-1-3、Scheduling-Domains的初始化"><a href="#4-1-1-3、Scheduling-Domains的初始化" class="headerlink" title="4.1.1.3、Scheduling Domains的初始化"></a>4.1.1.3、Scheduling Domains的初始化</h4><p>在kernel_init_freeable()中，调用smp_prepare_cpus()初始化完cpu的拓扑关系，再调用smp_init()唤醒cpu，紧接会调用sched_init_smp()初始化系统的Scheduling Domains。</p>
<p>关于拓扑的层次默认可选的有3层：SMT/MC/DIE。arm目前不支持多线程技术，所以现在只支持2层：MC/DIE。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Topology list, bottom-up.</span><br><span class="line"> */</span><br><span class="line">static struct sched_domain_topology_level default_topology[] = &#123;</span><br><span class="line">#ifdef CONFIG_SCHED_SMT</span><br><span class="line">	&#123; cpu_smt_mask, cpu_smt_flags, SD_INIT_NAME(SMT) &#125;,</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_SCHED_MC</span><br><span class="line">	&#123; cpu_coregroup_mask, cpu_core_flags, SD_INIT_NAME(MC) &#125;,</span><br><span class="line">#endif</span><br><span class="line">	&#123; cpu_cpu_mask, SD_INIT_NAME(DIE) &#125;,</span><br><span class="line">	&#123; NULL, &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>arm64使用的SDTL如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static struct sched_domain_topology_level arm64_topology[] = &#123;</span><br><span class="line">#ifdef CONFIG_SCHED_MC</span><br><span class="line">	&#123; cpu_coregroup_mask, cpu_corepower_flags, cpu_core_energy, SD_INIT_NAME(MC) &#125;,</span><br><span class="line">#endif</span><br><span class="line">	&#123; cpu_cpu_mask, NULL, cpu_cluster_energy, SD_INIT_NAME(DIE) &#125;,</span><br><span class="line">	&#123; NULL, &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>具体的Scheduling Domains的初始化代码分析如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br></pre></td><td class="code"><pre><span class="line">kernel_init() -&gt; kernel_init_freeable() -&gt; sched_init_smp() -&gt; init_sched_domains(cpu_active_mask):</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static int init_sched_domains(const struct cpumask *cpu_map)</span><br><span class="line">&#123;</span><br><span class="line">	int err;</span><br><span class="line"></span><br><span class="line">	arch_update_cpu_topology();</span><br><span class="line">	</span><br><span class="line">	/* (1) 当前只有一个schedule domain需要初始化 */</span><br><span class="line">	ndoms_cur = 1;</span><br><span class="line">	doms_cur = alloc_sched_domains(ndoms_cur);</span><br><span class="line">	if (!doms_cur)</span><br><span class="line">		doms_cur = &amp;fallback_doms;</span><br><span class="line">	</span><br><span class="line">	/* (2) 按照传入的cpu_active_mask，构造sched_domains */</span><br><span class="line">	cpumask_andnot(doms_cur[0], cpu_map, cpu_isolated_map);</span><br><span class="line">	err = build_sched_domains(doms_cur[0], NULL);</span><br><span class="line">	</span><br><span class="line">	/* (3) 注册“/proc/sys/kernel/sched_domain/” */</span><br><span class="line">	register_sched_domain_sysctl();</span><br><span class="line"></span><br><span class="line">	return err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">static int build_sched_domains(const struct cpumask *cpu_map,</span><br><span class="line">			       struct sched_domain_attr *attr)</span><br><span class="line">&#123;</span><br><span class="line">	enum s_alloc alloc_state;</span><br><span class="line">	struct sched_domain *sd;</span><br><span class="line">	struct s_data d;</span><br><span class="line">	struct rq *rq = NULL;</span><br><span class="line">	int i, ret = -ENOMEM;</span><br><span class="line"></span><br><span class="line">    /* (2.1) 在每个tl层次，给每个cpu分配sd、sg、sgc空间 */</span><br><span class="line">	alloc_state = __visit_domain_allocation_hell(&amp;d, cpu_map);</span><br><span class="line">	if (alloc_state != sa_rootdomain)</span><br><span class="line">		goto error;</span><br><span class="line"></span><br><span class="line">	/* Set up domains for cpus specified by the cpu_map. */</span><br><span class="line">	for_each_cpu(i, cpu_map) &#123;</span><br><span class="line">		struct sched_domain_topology_level *tl;</span><br><span class="line"></span><br><span class="line">		sd = NULL;</span><br><span class="line">		for_each_sd_topology(tl) &#123;</span><br><span class="line">		    /* (2.2) 初始化sd</span><br><span class="line">		        构造其不同tl之间的sd的parent、cild关系</span><br><span class="line">		        按照SDTL传入的tl-&gt;mask()函数，给sd-&gt;span[]赋值</span><br><span class="line">		     */</span><br><span class="line">			sd = build_sched_domain(tl, cpu_map, attr, sd, i);</span><br><span class="line">			</span><br><span class="line">			/* (2.2.1) 将最底层tl的sd赋值给d.sd */</span><br><span class="line">			if (tl == sched_domain_topology)</span><br><span class="line">				*per_cpu_ptr(d.sd, i) = sd;</span><br><span class="line">			if (tl-&gt;flags &amp; SDTL_OVERLAP || sched_feat(FORCE_SD_OVERLAP))</span><br><span class="line">				sd-&gt;flags |= SD_OVERLAP;</span><br><span class="line">			if (cpumask_equal(cpu_map, sched_domain_span(sd)))</span><br><span class="line">				break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* Build the groups for the domains */</span><br><span class="line">	for_each_cpu(i, cpu_map) &#123;</span><br><span class="line">		for (sd = *per_cpu_ptr(d.sd, i); sd; sd = sd-&gt;parent) &#123;</span><br><span class="line">		    /* (2.3) 给sd-&gt;span_weight赋值 */</span><br><span class="line">			sd-&gt;span_weight = cpumask_weight(sched_domain_span(sd));</span><br><span class="line">			if (sd-&gt;flags &amp; SD_OVERLAP) &#123;</span><br><span class="line">				if (build_overlap_sched_groups(sd, i))</span><br><span class="line">					goto error;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">			    /* (2.4) 按照span，构造每个tl层次中，sd、sg之间的关系 */</span><br><span class="line">				if (build_sched_groups(sd, i))</span><br><span class="line">					goto error;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* Calculate CPU capacity for physical packages and nodes */</span><br><span class="line">	for (i = nr_cpumask_bits-1; i &gt;= 0; i--) &#123;</span><br><span class="line">		struct sched_domain_topology_level *tl = sched_domain_topology;</span><br><span class="line"></span><br><span class="line">		if (!cpumask_test_cpu(i, cpu_map))</span><br><span class="line">			continue;</span><br><span class="line"></span><br><span class="line">		for (sd = *per_cpu_ptr(d.sd, i); sd; sd = sd-&gt;parent, tl++) &#123;</span><br><span class="line">		    /* (2.5) 初始化sg-&gt;sge对应的energy表 */</span><br><span class="line">			init_sched_energy(i, sd, tl-&gt;energy);</span><br><span class="line">			/* (2.6) 对有人引用的sd、sg、sgc进行标识，</span><br><span class="line">			    无人引用的sd、sg、sgc在__free_domain_allocs()中会被释放</span><br><span class="line">			 */</span><br><span class="line">			claim_allocations(i, sd);</span><br><span class="line">			/* (2.7) 初始化每个tl层级的sgc-&gt;capacity</span><br><span class="line">			 */</span><br><span class="line">			init_sched_groups_capacity(i, sd);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* Attach the domains */</span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	/* (2.8) 将d.rd赋值给rq-&gt;sd</span><br><span class="line">	    将d.rd赋值给rq-&gt;rd</span><br><span class="line">	 */</span><br><span class="line">	for_each_cpu(i, cpu_map) &#123;</span><br><span class="line">		rq = cpu_rq(i);</span><br><span class="line">		sd = *per_cpu_ptr(d.sd, i);</span><br><span class="line">		cpu_attach_domain(sd, d.rd, i);</span><br><span class="line">	&#125;</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">	ret = 0;</span><br><span class="line">error:</span><br><span class="line">    /* (2.9) free掉分配失败/分配成功多余的内存 */</span><br><span class="line">	__free_domain_allocs(&amp;d, alloc_state, cpu_map);</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">||→</span><br><span class="line"></span><br><span class="line">static enum s_alloc __visit_domain_allocation_hell(struct s_data *d,</span><br><span class="line">						   const struct cpumask *cpu_map)</span><br><span class="line">&#123;</span><br><span class="line">	memset(d, 0, sizeof(*d));</span><br><span class="line"></span><br><span class="line">    /* (2.1.1) 每个tl层次，给每个cpu都分配sd、sg、sgc，</span><br><span class="line">        tl-&gt;data-&gt;sd、l-&gt;data-&gt;sg、l-&gt;data-&gt;sgc</span><br><span class="line">     */</span><br><span class="line">	if (__sdt_alloc(cpu_map))</span><br><span class="line">		return sa_sd_storage;</span><br><span class="line">		</span><br><span class="line">	/* (2.1.2) 分配d-&gt;sd指针空间</span><br><span class="line">	    实际d-&gt;sd会指向最底层tl的tl-&gt;data-&gt;sd</span><br><span class="line">	 */</span><br><span class="line">	d-&gt;sd = alloc_percpu(struct sched_domain *);</span><br><span class="line">	if (!d-&gt;sd)</span><br><span class="line">		return sa_sd_storage;</span><br><span class="line">		</span><br><span class="line">	/* (2.1.3) 分配d-&gt;rd的指针空间和实际空间 </span><br><span class="line">	    rd = root_domain</span><br><span class="line">	 */</span><br><span class="line">	d-&gt;rd = alloc_rootdomain();</span><br><span class="line">	if (!d-&gt;rd)</span><br><span class="line">		return sa_sd;</span><br><span class="line">	return sa_rootdomain;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">||→</span><br><span class="line"></span><br><span class="line">struct sched_domain *build_sched_domain(struct sched_domain_topology_level *tl,</span><br><span class="line">		const struct cpumask *cpu_map, struct sched_domain_attr *attr,</span><br><span class="line">		struct sched_domain *child, int cpu)</span><br><span class="line">&#123;</span><br><span class="line">	struct sched_domain *sd = sd_init(tl, cpu);</span><br><span class="line">	if (!sd)</span><br><span class="line">		return child;</span><br><span class="line"></span><br><span class="line">    /* (2.2.1) 根据tl-&gt;mask()初始化sd-&gt;sapn[] */</span><br><span class="line">	cpumask_and(sched_domain_span(sd), cpu_map, tl-&gt;mask(cpu));</span><br><span class="line">	if (child) &#123;</span><br><span class="line">		sd-&gt;level = child-&gt;level + 1;</span><br><span class="line">		sched_domain_level_max = max(sched_domain_level_max, sd-&gt;level);</span><br><span class="line">		</span><br><span class="line">		/* (2.2.2) 如果有多层tl，建立起sd之间的parent/child关系，</span><br><span class="line">		    对arm来说：MC层tl-&gt;data-&gt;sd是child，DIE层tl-&gt;data-&gt;sd是parent</span><br><span class="line">		 */</span><br><span class="line">		child-&gt;parent = sd;</span><br><span class="line">		sd-&gt;child = child;</span><br><span class="line"></span><br><span class="line">		if (!cpumask_subset(sched_domain_span(child),</span><br><span class="line">				    sched_domain_span(sd))) &#123;</span><br><span class="line">			pr_err(&quot;BUG: arch topology borken\n&quot;);</span><br><span class="line">#ifdef CONFIG_SCHED_DEBUG</span><br><span class="line">			pr_err(&quot;     the %s domain not a subset of the %s domain\n&quot;,</span><br><span class="line">					child-&gt;name, sd-&gt;name);</span><br><span class="line">#endif</span><br><span class="line">			/* Fixup, ensure @sd has at least @child cpus. */</span><br><span class="line">			cpumask_or(sched_domain_span(sd),</span><br><span class="line">				   sched_domain_span(sd),</span><br><span class="line">				   sched_domain_span(child));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	set_domain_attribute(sd, attr);</span><br><span class="line"></span><br><span class="line">	return sd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">||→</span><br><span class="line"></span><br><span class="line">static int</span><br><span class="line">build_sched_groups(struct sched_domain *sd, int cpu)</span><br><span class="line">&#123;</span><br><span class="line">	struct sched_group *first = NULL, *last = NULL;</span><br><span class="line">	struct sd_data *sdd = sd-&gt;private;</span><br><span class="line">	const struct cpumask *span = sched_domain_span(sd);</span><br><span class="line">	struct cpumask *covered;</span><br><span class="line">	int i;</span><br><span class="line"></span><br><span class="line">    /* (2.4.1) 根据sd-&gt;span[]建立起sd、sg之间的关系 ，</span><br><span class="line">        如果sd没有child，每个cpu的sd、sg之间建立链接</span><br><span class="line">        如果sd有child，每个cpu的sd和span中第一个cpu的sg建立链接</span><br><span class="line">     */</span><br><span class="line">	get_group(cpu, sdd, &amp;sd-&gt;groups);</span><br><span class="line">	atomic_inc(&amp;sd-&gt;groups-&gt;ref);</span><br><span class="line"></span><br><span class="line">	if (cpu != cpumask_first(span))</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">	lockdep_assert_held(&amp;sched_domains_mutex);</span><br><span class="line">	covered = sched_domains_tmpmask;</span><br><span class="line"></span><br><span class="line">	cpumask_clear(covered);</span><br><span class="line"></span><br><span class="line">    /* (2.4.2) 挑选有sd链接的sg，给其中的sg-&gt;cpumask[]成员赋值 */</span><br><span class="line">	for_each_cpu(i, span) &#123;</span><br><span class="line">		struct sched_group *sg;</span><br><span class="line">		int group, j;</span><br><span class="line"></span><br><span class="line">		if (cpumask_test_cpu(i, covered))</span><br><span class="line">			continue;</span><br><span class="line"></span><br><span class="line">		group = get_group(i, sdd, &amp;sg);</span><br><span class="line">		cpumask_setall(sched_group_mask(sg));</span><br><span class="line"></span><br><span class="line">		for_each_cpu(j, span) &#123;</span><br><span class="line">			if (get_group(j, sdd, NULL) != group)</span><br><span class="line">				continue;</span><br><span class="line"></span><br><span class="line">			cpumask_set_cpu(j, covered);</span><br><span class="line">			cpumask_set_cpu(j, sched_group_cpus(sg));</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		/* (2.4.3) 挑选有sd链接的sg，将同一层级sg链接成链表， */</span><br><span class="line">		if (!first)</span><br><span class="line">			first = sg;</span><br><span class="line">		if (last)</span><br><span class="line">			last-&gt;next = sg;</span><br><span class="line">		last = sg;</span><br><span class="line">	&#125;</span><br><span class="line">	last-&gt;next = first;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">||→</span><br><span class="line"></span><br><span class="line">static void init_sched_energy(int cpu, struct sched_domain *sd,</span><br><span class="line">			      sched_domain_energy_f fn)</span><br><span class="line">&#123;</span><br><span class="line">	if (!(fn &amp;&amp; fn(cpu)))</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	if (cpu != group_balance_cpu(sd-&gt;groups))</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	if (sd-&gt;child &amp;&amp; !sd-&gt;child-&gt;groups-&gt;sge) &#123;</span><br><span class="line">		pr_err(&quot;BUG: EAS setup broken for CPU%d\n&quot;, cpu);</span><br><span class="line">#ifdef CONFIG_SCHED_DEBUG</span><br><span class="line">		pr_err(&quot;     energy data on %s but not on %s domain\n&quot;,</span><br><span class="line">			sd-&gt;name, sd-&gt;child-&gt;name);</span><br><span class="line">#endif</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	check_sched_energy_data(cpu, fn, sched_group_cpus(sd-&gt;groups));</span><br><span class="line"></span><br><span class="line">    /* (2.5.1) 不同层级tl，按照tl-&gt;energy()给sg-&gt;sge赋值 */</span><br><span class="line">	sd-&gt;groups-&gt;sge = fn(cpu);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">||→</span><br><span class="line"></span><br><span class="line">static void claim_allocations(int cpu, struct sched_domain *sd)</span><br><span class="line">&#123;</span><br><span class="line">	struct sd_data *sdd = sd-&gt;private;</span><br><span class="line">	</span><br><span class="line">	/* (2.6.1) 对有人使用的tl-&gt;data-&gt;sd、tl-&gt;data-&gt;sg、tl-&gt;data-&gt;sgc置空,</span><br><span class="line">	    无人使用的空间，将会在__free_domain_allocs()中被释放</span><br><span class="line">	 */</span><br><span class="line"></span><br><span class="line">	WARN_ON_ONCE(*per_cpu_ptr(sdd-&gt;sd, cpu) != sd);</span><br><span class="line">	*per_cpu_ptr(sdd-&gt;sd, cpu) = NULL;</span><br><span class="line"></span><br><span class="line">	if (atomic_read(&amp;(*per_cpu_ptr(sdd-&gt;sg, cpu))-&gt;ref))</span><br><span class="line">		*per_cpu_ptr(sdd-&gt;sg, cpu) = NULL;</span><br><span class="line"></span><br><span class="line">	if (atomic_read(&amp;(*per_cpu_ptr(sdd-&gt;sgc, cpu))-&gt;ref))</span><br><span class="line">		*per_cpu_ptr(sdd-&gt;sgc, cpu) = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">||→</span><br><span class="line"></span><br><span class="line">static void init_sched_groups_capacity(int cpu, struct sched_domain *sd)</span><br><span class="line">&#123;</span><br><span class="line">	struct sched_group *sg = sd-&gt;groups;</span><br><span class="line"></span><br><span class="line">	WARN_ON(!sg);</span><br><span class="line"></span><br><span class="line">	do &#123;</span><br><span class="line">	    /* (2.7.1) 更新sg-&gt;group_weight的值 */</span><br><span class="line">		sg-&gt;group_weight = cpumask_weight(sched_group_cpus(sg));</span><br><span class="line">		sg = sg-&gt;next;</span><br><span class="line">	&#125; while (sg != sd-&gt;groups);</span><br><span class="line"></span><br><span class="line">	if (cpu != group_balance_cpu(sg))</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">    /* (2.7.2) 更新sgc-&gt;capacity的值 */</span><br><span class="line">	update_group_capacity(sd, cpu);</span><br><span class="line">	</span><br><span class="line">	/* (2.7.3) 更新sgc-&gt;nr_busy_cpus的值 */</span><br><span class="line">	atomic_set(&amp;sg-&gt;sgc-&gt;nr_busy_cpus, sg-&gt;group_weight);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|||→</span><br><span class="line"></span><br><span class="line">void update_group_capacity(struct sched_domain *sd, int cpu)</span><br><span class="line">&#123;</span><br><span class="line">	struct sched_domain *child = sd-&gt;child;</span><br><span class="line">	struct sched_group *group, *sdg = sd-&gt;groups;</span><br><span class="line">	unsigned long capacity;</span><br><span class="line">	unsigned long interval;</span><br><span class="line"></span><br><span class="line">	interval = msecs_to_jiffies(sd-&gt;balance_interval);</span><br><span class="line">	interval = clamp(interval, 1UL, max_load_balance_interval);</span><br><span class="line">	sdg-&gt;sgc-&gt;next_update = jiffies + interval;</span><br><span class="line"></span><br><span class="line">	if (!child) &#123;</span><br><span class="line">	    /* (2.7.2.1) 如果sd没有child是最底层tl,</span><br><span class="line">	        则调用arch_scale_cpu_capacity()获取最大运算能力，并减去rt进程的消耗rq-&gt;rt_avg，</span><br><span class="line">	        得到本sd的sg-&gt;sgc-&gt;capacity</span><br><span class="line">	     */</span><br><span class="line">		update_cpu_capacity(sd, cpu);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	capacity = 0;</span><br><span class="line"></span><br><span class="line">	if (child-&gt;flags &amp; SD_OVERLAP) &#123;</span><br><span class="line">		/*</span><br><span class="line">		 * SD_OVERLAP domains cannot assume that child groups</span><br><span class="line">		 * span the current group.</span><br><span class="line">		 */</span><br><span class="line"></span><br><span class="line">		for_each_cpu(cpu, sched_group_cpus(sdg)) &#123;</span><br><span class="line">			struct sched_group_capacity *sgc;</span><br><span class="line">			struct rq *rq = cpu_rq(cpu);</span><br><span class="line"></span><br><span class="line">			/*</span><br><span class="line">			 * build_sched_domains() -&gt; init_sched_groups_capacity()</span><br><span class="line">			 * gets here before we&apos;ve attached the domains to the</span><br><span class="line">			 * runqueues.</span><br><span class="line">			 *</span><br><span class="line">			 * Use capacity_of(), which is set irrespective of domains</span><br><span class="line">			 * in update_cpu_capacity().</span><br><span class="line">			 *</span><br><span class="line">			 * This avoids capacity from being 0 and</span><br><span class="line">			 * causing divide-by-zero issues on boot.</span><br><span class="line">			 */</span><br><span class="line">			if (unlikely(!rq-&gt;sd)) &#123;</span><br><span class="line">				capacity += capacity_of(cpu);</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			sgc = rq-&gt;sd-&gt;groups-&gt;sgc;</span><br><span class="line">			capacity += sgc-&gt;capacity;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; else  &#123;</span><br><span class="line">		/*</span><br><span class="line">		 * !SD_OVERLAP domains can assume that child groups</span><br><span class="line">		 * span the current group.</span><br><span class="line">		 */ </span><br><span class="line"></span><br><span class="line">        /*  (2.7.2.2) 如果sd有child不是最底层tl,</span><br><span class="line">            则sgc-&gt;capacity等于所有child sg的group-&gt;sgc-&gt;capacity的和</span><br><span class="line">         */</span><br><span class="line">		group = child-&gt;groups;</span><br><span class="line">		do &#123;</span><br><span class="line">			capacity += group-&gt;sgc-&gt;capacity;</span><br><span class="line">			group = group-&gt;next;</span><br><span class="line">		&#125; while (group != child-&gt;groups);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sdg-&gt;sgc-&gt;capacity = capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">||||→</span><br><span class="line"></span><br><span class="line">static void update_cpu_capacity(struct sched_domain *sd, int cpu)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned long capacity = arch_scale_cpu_capacity(sd, cpu);</span><br><span class="line">	struct sched_group *sdg = sd-&gt;groups;</span><br><span class="line">	struct max_cpu_capacity *mcc;</span><br><span class="line">	unsigned long max_capacity;</span><br><span class="line">	int max_cap_cpu;</span><br><span class="line">	unsigned long flags;</span><br><span class="line"></span><br><span class="line">    /* (2.7.2.1.1) 根据arch_scale_cpu_capacity获取到本cpu最大/orig capacity</span><br><span class="line">     */</span><br><span class="line">	cpu_rq(cpu)-&gt;cpu_capacity_orig = capacity;</span><br><span class="line"></span><br><span class="line">	mcc = &amp;cpu_rq(cpu)-&gt;rd-&gt;max_cpu_capacity;</span><br><span class="line"></span><br><span class="line">	raw_spin_lock_irqsave(&amp;mcc-&gt;lock, flags);</span><br><span class="line">	max_capacity = mcc-&gt;val;</span><br><span class="line">	max_cap_cpu = mcc-&gt;cpu;</span><br><span class="line"></span><br><span class="line">	if ((max_capacity &gt; capacity &amp;&amp; max_cap_cpu == cpu) ||</span><br><span class="line">	    (max_capacity &lt; capacity)) &#123;</span><br><span class="line">		mcc-&gt;val = capacity;</span><br><span class="line">		mcc-&gt;cpu = cpu;</span><br><span class="line">#ifdef CONFIG_SCHED_DEBUG</span><br><span class="line">		raw_spin_unlock_irqrestore(&amp;mcc-&gt;lock, flags);</span><br><span class="line">		/* pr_info(&quot;CPU%d: update max cpu_capacity %lu\n&quot;, cpu, capacity); */</span><br><span class="line">		goto skip_unlock;</span><br><span class="line">#endif</span><br><span class="line">	&#125;</span><br><span class="line">	raw_spin_unlock_irqrestore(&amp;mcc-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">skip_unlock: __attribute__ ((unused));</span><br><span class="line">    /* (2.7.2.1.2) 减去rt消耗的capacity，</span><br><span class="line">        rq-&gt;rt_avg/(sched_avg_period() + delta)是rt进程占用cpu的比例，</span><br><span class="line">        剩下就为cfs可用的capacity</span><br><span class="line">     */</span><br><span class="line">	capacity *= scale_rt_capacity(cpu);</span><br><span class="line">	capacity &gt;&gt;= SCHED_CAPACITY_SHIFT;</span><br><span class="line"></span><br><span class="line">	if (!capacity)</span><br><span class="line">		capacity = 1;</span><br><span class="line"></span><br><span class="line">	cpu_rq(cpu)-&gt;cpu_capacity = capacity;</span><br><span class="line">	sdg-&gt;sgc-&gt;capacity = capacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>init_sched_domains()是在系统启动时创建sched_domain，如果发生cpu hotplug系统中online的cpu发生变化时，会调用partition_sched_domains重新构造系统的sched_domain。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">cpu_up() -&gt; _cpu_up() -&gt; __raw_notifier_call_chain() -&gt; cpuset_cpu_active() -&gt; cpuset_update_active_cpus() -&gt; partition_sched_domains() -&gt; build_sched_domains()；</span><br><span class="line"></span><br><span class="line">void __init sched_init_smp(void)</span><br><span class="line">&#123;</span><br><span class="line">	hotcpu_notifier(cpuset_cpu_active, CPU_PRI_CPUSET_ACTIVE);</span><br><span class="line">	hotcpu_notifier(cpuset_cpu_inactive, CPU_PRI_CPUSET_INACTIVE);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int cpuset_cpu_active(struct notifier_block *nfb, unsigned long action,</span><br><span class="line">			     void *hcpu)</span><br><span class="line">&#123;</span><br><span class="line">	switch (action) &#123;</span><br><span class="line">	case CPU_ONLINE_FROZEN:</span><br><span class="line">	case CPU_DOWN_FAILED_FROZEN:</span><br><span class="line"></span><br><span class="line">		/*</span><br><span class="line">		 * num_cpus_frozen tracks how many CPUs are involved in suspend</span><br><span class="line">		 * resume sequence. As long as this is not the last online</span><br><span class="line">		 * operation in the resume sequence, just build a single sched</span><br><span class="line">		 * domain, ignoring cpusets.</span><br><span class="line">		 */</span><br><span class="line">		num_cpus_frozen--;</span><br><span class="line">		if (likely(num_cpus_frozen)) &#123;</span><br><span class="line">			partition_sched_domains(1, NULL, NULL);</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		/*</span><br><span class="line">		 * This is the last CPU online operation. So fall through and</span><br><span class="line">		 * restore the original sched domains by considering the</span><br><span class="line">		 * cpuset configurations.</span><br><span class="line">		 */</span><br><span class="line"></span><br><span class="line">	case CPU_ONLINE:</span><br><span class="line">		cpuset_update_active_cpus(true);</span><br><span class="line">		break;</span><br><span class="line">	default:</span><br><span class="line">		return NOTIFY_DONE;</span><br><span class="line">	&#125;</span><br><span class="line">	return NOTIFY_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int cpuset_cpu_inactive(struct notifier_block *nfb, unsigned long action,</span><br><span class="line">			       void *hcpu)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned long flags;</span><br><span class="line">	long cpu = (long)hcpu;</span><br><span class="line">	struct dl_bw *dl_b;</span><br><span class="line">	bool overflow;</span><br><span class="line">	int cpus;</span><br><span class="line"></span><br><span class="line">	switch (action) &#123;</span><br><span class="line">	case CPU_DOWN_PREPARE:</span><br><span class="line">		rcu_read_lock_sched();</span><br><span class="line">		dl_b = dl_bw_of(cpu);</span><br><span class="line"></span><br><span class="line">		raw_spin_lock_irqsave(&amp;dl_b-&gt;lock, flags);</span><br><span class="line">		cpus = dl_bw_cpus(cpu);</span><br><span class="line">		overflow = __dl_overflow(dl_b, cpus, 0, 0);</span><br><span class="line">		raw_spin_unlock_irqrestore(&amp;dl_b-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">		rcu_read_unlock_sched();</span><br><span class="line"></span><br><span class="line">		if (overflow)</span><br><span class="line">			return notifier_from_errno(-EBUSY);</span><br><span class="line">		cpuset_update_active_cpus(false);</span><br><span class="line">		break;</span><br><span class="line">	case CPU_DOWN_PREPARE_FROZEN:</span><br><span class="line">		num_cpus_frozen++;</span><br><span class="line">		partition_sched_domains(1, NULL, NULL);</span><br><span class="line">		break;</span><br><span class="line">	default:</span><br><span class="line">		return NOTIFY_DONE;</span><br><span class="line">	&#125;</span><br><span class="line">	return NOTIFY_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-1-1-4、mt6799的Scheduling-Domains"><a href="#4-1-1-4、mt6799的Scheduling-Domains" class="headerlink" title="4.1.1.4、mt6799的Scheduling Domains"></a>4.1.1.4、mt6799的Scheduling Domains</h4><p>在系统初始化时，因为cmdline中传入了“maxcpus=8”所以setup_max_cpus=8，smp只是启动了8个核，mt6799的另外2个大核是在后面才启动的。我们看看在系统启动8个核的时候，Scheduling Domains是什么样的。</p>
<p>在启动的时候每个层次的tl对每个cpu都会分配sd、sg、sgc的内存空间，但是建立起有效链接后有些sg、sgc空间是没有用上的。没有使用的内存后面会在claim_allocations()中标识出来，build_sched_domains()函数返回之前调用__free_domain_allocs()释放掉。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">kernel_init() -&gt; kernel_init_freeable() -&gt; sched_init_smp() -&gt; init_sched_domains() -&gt; build_sched_domains() -&gt;  __visit_domain_allocation_hell() -&gt; __sdt_alloc():</span><br><span class="line"></span><br><span class="line">[__sdt_alloc][tl MC] cpu0, &amp;sd = 0xffffffc15663c600, &amp;sg = 0xffffffc156062600, &amp;sgc = 0xffffffc156062780 </span><br><span class="line">[__sdt_alloc][tl MC] cpu1, &amp;sd = 0xffffffc15608f000, &amp;sg = 0xffffffc156056780, &amp;sgc = 0xffffffc156090000 </span><br><span class="line">[__sdt_alloc][tl MC] cpu2, &amp;sd = 0xffffffc15608fc00, &amp;sg = 0xffffffc156090d80, &amp;sgc = 0xffffffc156090180 </span><br><span class="line">[__sdt_alloc][tl MC] cpu3, &amp;sd = 0xffffffc15608f300, &amp;sg = 0xffffffc156090c00, &amp;sgc = 0xffffffc156090300 </span><br><span class="line">[__sdt_alloc][tl MC] cpu4, &amp;sd = 0xffffffc15608f900, &amp;sg = 0xffffffc156090a80, &amp;sgc = 0xffffffc156090480 </span><br><span class="line">[__sdt_alloc][tl MC] cpu5, &amp;sd = 0xffffffc15608f600, &amp;sg = 0xffffffc156090900, &amp;sgc = 0xffffffc156090600 </span><br><span class="line">[__sdt_alloc][tl MC] cpu6, &amp;sd = 0xffffffc156091000, &amp;sg = 0xffffffc156090780, &amp;sgc = 0xffffffc156092000 </span><br><span class="line">[__sdt_alloc][tl MC] cpu7, &amp;sd = 0xffffffc156091c00, &amp;sg = 0xffffffc156092d80, &amp;sgc = 0xffffffc156092180 </span><br><span class="line"></span><br><span class="line">[__sdt_alloc][tl DIE] cpu0, &amp;sd = 0xffffffc156091300, &amp;sg = 0xffffffc156092c00, &amp;sgc = 0xffffffc156092300 </span><br><span class="line">[__sdt_alloc][tl DIE] cpu1, &amp;sd = 0xffffffc156091900, &amp;sg = 0xffffffc156092a80, &amp;sgc = 0xffffffc156092480 </span><br><span class="line">[__sdt_alloc][tl DIE] cpu2, &amp;sd = 0xffffffc156091600, &amp;sg = 0xffffffc156092900, &amp;sgc = 0xffffffc156092600 </span><br><span class="line">[__sdt_alloc][tl DIE] cpu3, &amp;sd = 0xffffffc156093000, &amp;sg = 0xffffffc156092780, &amp;sgc = 0xffffffc156094000 </span><br><span class="line">[__sdt_alloc][tl DIE] cpu4, &amp;sd = 0xffffffc156093c00, &amp;sg = 0xffffffc156094d80, &amp;sgc = 0xffffffc156094180 </span><br><span class="line">[__sdt_alloc][tl DIE] cpu5, &amp;sd = 0xffffffc156093300, &amp;sg = 0xffffffc156094c00, &amp;sgc = 0xffffffc156094300 </span><br><span class="line">[__sdt_alloc][tl DIE] cpu6, &amp;sd = 0xffffffc156093900, &amp;sg = 0xffffffc156094a80, &amp;sgc = 0xffffffc156094480 </span><br><span class="line">[__sdt_alloc][tl DIE] cpu7, &amp;sd = 0xffffffc156093600, &amp;sg = 0xffffffc156094900, &amp;sgc = 0xffffffc156094600</span><br></pre></td></tr></table></figure>
<p>建立链接以后每个层次tl的sd、sg之间的关系：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">kernel_init() -&gt; kernel_init_freeable() -&gt; sched_init_smp() -&gt; init_sched_domains() -&gt; build_sched_domains() -&gt; build_sched_groups():</span><br><span class="line"></span><br><span class="line">[build_sched_domains][tl MC] cpu0, sd-&gt;groups=0xffffffc156062600, sd-&gt;span_weight=4, sd-&gt;balance_interval=4, sd-&gt;span[]=0xf</span><br><span class="line">[build_sched_domains][tl MC] cpu0, sg-&gt;sgc=0xffffffc156062780, sg-&gt;next=0xffffffc156056780, sg-&gt;group_weight=0, sg-&gt;cpumask[]=0x1</span><br><span class="line">[build_sched_domains][tl MC] cpu0, sgc-&gt;capacity=0, sgc-&gt;next_update=0, sgc-&gt;nr_busy_cpus=0, sgc-&gt;cpumask[]=0x3ff</span><br><span class="line">[build_sched_domains][tl MC] cpu0, sd-&gt;min_interval=4, sd-&gt;max_interval=8, sd-&gt;busy_factor=32, sd-&gt;imbalance_pct=117, sd-&gt;cache_nice_tries=1, sd-&gt;busy_idx=2, sd-&gt;idle_idx=0, sd-&gt;newidle_idx=0, sd-&gt;wake_idx=0,  sd-&gt;forkexec_idx=0, sd-&gt;span_weight=4, sd-&gt;balance_interval=4, sd-&gt;level=0 </span><br><span class="line">[build_sched_domains][tl MC] cpu0, sd-&gt;flags=0x832f: SD_LOAD_BALANCE|SD_BALANCE_NEWIDLE|SD_BALANCE_EXEC|SD_BALANCE_FORK|SD_WAKE_AFFINE|SD_SHARE_POWERDOMAIN|SD_SHARE_PKG_RESOURCES|SD_SHARE_CAP_STATES|</span><br><span class="line">[build_sched_domains][tl MC] cpu1, sd-&gt;groups=0xffffffc156056780, sd-&gt;span_weight=4, sd-&gt;balance_interval=4, sd-&gt;span[]=0xf</span><br><span class="line">[build_sched_domains][tl MC] cpu1, sg-&gt;sgc=0xffffffc156090000, sg-&gt;next=0xffffffc156090d80, sg-&gt;group_weight=0, sg-&gt;cpumask[]=0x2</span><br><span class="line">[build_sched_domains][tl MC] cpu1, sgc-&gt;capacity=0, sgc-&gt;next_update=0, sgc-&gt;nr_busy_cpus=0, sgc-&gt;cpumask[]=0x3ff</span><br><span class="line">[build_sched_domains][tl MC] cpu1, sd-&gt;min_interval=4, sd-&gt;max_interval=8, sd-&gt;busy_factor=32, sd-&gt;imbalance_pct=117, sd-&gt;cache_nice_tries=1, sd-&gt;busy_idx=2, sd-&gt;idle_idx=0, sd-&gt;newidle_idx=0, sd-&gt;wake_idx=0,  sd-&gt;forkexec_idx=0, sd-&gt;span_weight=4, sd-&gt;balance_interval=4, sd-&gt;level=0 </span><br><span class="line">[build_sched_domains][tl MC] cpu1, sd-&gt;flags=0x832f: SD_LOAD_BALANCE|SD_BALANCE_NEWIDLE|SD_BALANCE_EXEC|SD_BALANCE_FORK|SD_WAKE_AFFINE|SD_SHARE_POWERDOMAIN|SD_SHARE_PKG_RESOURCES|SD_SHARE_CAP_STATES|</span><br><span class="line">[build_sched_domains][tl MC] cpu2, sd-&gt;groups=0xffffffc156090d80, sd-&gt;span_weight=4, sd-&gt;balance_interval=4, sd-&gt;span[]=0xf</span><br><span class="line">[build_sched_domains][tl MC] cpu2, sg-&gt;sgc=0xffffffc156090180, sg-&gt;next=0xffffffc156090c00, sg-&gt;group_weight=0, sg-&gt;cpumask[]=0x4</span><br><span class="line">[build_sched_domains][tl MC] cpu2, sgc-&gt;capacity=0, sgc-&gt;next_update=0, sgc-&gt;nr_busy_cpus=0, sgc-&gt;cpumask[]=0x3ff</span><br><span class="line">[build_sched_domains][tl MC] cpu2, sd-&gt;min_interval=4, sd-&gt;max_interval=8, sd-&gt;busy_factor=32, sd-&gt;imbalance_pct=117, sd-&gt;cache_nice_tries=1, sd-&gt;busy_idx=2, sd-&gt;idle_idx=0, sd-&gt;newidle_idx=0, sd-&gt;wake_idx=0,  sd-&gt;forkexec_idx=0, sd-&gt;span_weight=4, sd-&gt;balance_interval=4, sd-&gt;level=0 </span><br><span class="line">[build_sched_domains][tl MC] cpu2, sd-&gt;flags=0x832f: SD_LOAD_BALANCE|SD_BALANCE_NEWIDLE|SD_BALANCE_EXEC|SD_BALANCE_FORK|SD_WAKE_AFFINE|SD_SHARE_POWERDOMAIN|SD_SHARE_PKG_RESOURCES|SD_SHARE_CAP_STATES|</span><br><span class="line">[build_sched_domains][tl MC] cpu3, sd-&gt;groups=0xffffffc156090c00, sd-&gt;span_weight=4, sd-&gt;balance_interval=4, sd-&gt;span[]=0xf</span><br><span class="line">[build_sched_domains][tl MC] cpu3, sg-&gt;sgc=0xffffffc156090300, sg-&gt;next=0xffffffc156062600, sg-&gt;group_weight=0, sg-&gt;cpumask[]=0x8</span><br><span class="line">[build_sched_domains][tl MC] cpu3, sgc-&gt;capacity=0, sgc-&gt;next_update=0, sgc-&gt;nr_busy_cpus=0, sgc-&gt;cpumask[]=0x3ff</span><br><span class="line">[build_sched_domains][tl MC] cpu3, sd-&gt;min_interval=4, sd-&gt;max_interval=8, sd-&gt;busy_factor=32, sd-&gt;imbalance_pct=117, sd-&gt;cache_nice_tries=1, sd-&gt;busy_idx=2, sd-&gt;idle_idx=0, sd-&gt;newidle_idx=0, sd-&gt;wake_idx=0,  sd-&gt;forkexec_idx=0, sd-&gt;span_weight=4, sd-&gt;balance_interval=4, sd-&gt;level=0 </span><br><span class="line">[build_sched_domains][tl MC] cpu3, sd-&gt;flags=0x832f: SD_LOAD_BALANCE|SD_BALANCE_NEWIDLE|SD_BALANCE_EXEC|SD_BALANCE_FORK|SD_WAKE_AFFINE|SD_SHARE_POWERDOMAIN|SD_SHARE_PKG_RESOURCES|SD_SHARE_CAP_STATES|</span><br><span class="line">[build_sched_domains][tl MC] cpu4, sd-&gt;groups=0xffffffc156090a80, sd-&gt;span_weight=4, sd-&gt;balance_interval=4, sd-&gt;span[]=0xf0</span><br><span class="line">[build_sched_domains][tl MC] cpu4, sg-&gt;sgc=0xffffffc156090480, sg-&gt;next=0xffffffc156090900, sg-&gt;group_weight=0, sg-&gt;cpumask[]=0x10</span><br><span class="line">[build_sched_domains][tl MC] cpu4, sgc-&gt;capacity=0, sgc-&gt;next_update=0, sgc-&gt;nr_busy_cpus=0, sgc-&gt;cpumask[]=0x3ff</span><br><span class="line">[build_sched_domains][tl MC] cpu4, sd-&gt;min_interval=4, sd-&gt;max_interval=8, sd-&gt;busy_factor=32, sd-&gt;imbalance_pct=117, sd-&gt;cache_nice_tries=1, sd-&gt;busy_idx=2, sd-&gt;idle_idx=0, sd-&gt;newidle_idx=0, sd-&gt;wake_idx=0,  sd-&gt;forkexec_idx=0, sd-&gt;span_weight=4, sd-&gt;balance_interval=4, sd-&gt;level=0 </span><br><span class="line">[build_sched_domains][tl MC] cpu4, sd-&gt;flags=0x832f: SD_LOAD_BALANCE|SD_BALANCE_NEWIDLE|SD_BALANCE_EXEC|SD_BALANCE_FORK|SD_WAKE_AFFINE|SD_SHARE_POWERDOMAIN|SD_SHARE_PKG_RESOURCES|SD_SHARE_CAP_STATES|</span><br><span class="line">[build_sched_domains][tl MC] cpu5, sd-&gt;groups=0xffffffc156090900, sd-&gt;span_weight=4, sd-&gt;balance_interval=4, sd-&gt;span[]=0xf0</span><br><span class="line">[build_sched_domains][tl MC] cpu5, sg-&gt;sgc=0xffffffc156090600, sg-&gt;next=0xffffffc156090780, sg-&gt;group_weight=0, sg-&gt;cpumask[]=0x20</span><br><span class="line">[build_sched_domains][tl MC] cpu5, sgc-&gt;capacity=0, sgc-&gt;next_update=0, sgc-&gt;nr_busy_cpus=0, sgc-&gt;cpumask[]=0x3ff</span><br><span class="line">[build_sched_domains][tl MC] cpu5, sd-&gt;min_interval=4, sd-&gt;max_interval=8, sd-&gt;busy_factor=32, sd-&gt;imbalance_pct=117, sd-&gt;cache_nice_tries=1, sd-&gt;busy_idx=2, sd-&gt;idle_idx=0, sd-&gt;newidle_idx=0, sd-&gt;wake_idx=0,  sd-&gt;forkexec_idx=0, sd-&gt;span_weight=4, sd-&gt;balance_interval=4, sd-&gt;level=0 </span><br><span class="line">[build_sched_domains][tl MC] cpu5, sd-&gt;flags=0x832f: SD_LOAD_BALANCE|SD_BALANCE_NEWIDLE|SD_BALANCE_EXEC|SD_BALANCE_FORK|SD_WAKE_AFFINE|SD_SHARE_POWERDOMAIN|SD_SHARE_PKG_RESOURCES|SD_SHARE_CAP_STATES|</span><br><span class="line">[build_sched_domains][tl MC] cpu6, sd-&gt;groups=0xffffffc156090780, sd-&gt;span_weight=4, sd-&gt;balance_interval=4, sd-&gt;span[]=0xf0</span><br><span class="line">[build_sched_domains][tl MC] cpu6, sg-&gt;sgc=0xffffffc156092000, sg-&gt;next=0xffffffc156092d80, sg-&gt;group_weight=0, sg-&gt;cpumask[]=0x40</span><br><span class="line">[build_sched_domains][tl MC] cpu6, sgc-&gt;capacity=0, sgc-&gt;next_update=0, sgc-&gt;nr_busy_cpus=0, sgc-&gt;cpumask[]=0x3ff</span><br><span class="line">[build_sched_domains][tl MC] cpu6, sd-&gt;min_interval=4, sd-&gt;max_interval=8, sd-&gt;busy_factor=32, sd-&gt;imbalance_pct=117, sd-&gt;cache_nice_tries=1, sd-&gt;busy_idx=2, sd-&gt;idle_idx=0, sd-&gt;newidle_idx=0, sd-&gt;wake_idx=0,  sd-&gt;forkexec_idx=0, sd-&gt;span_weight=4, sd-&gt;balance_interval=4, sd-&gt;level=0 </span><br><span class="line">[build_sched_domains][tl MC] cpu6, sd-&gt;flags=0x832f: SD_LOAD_BALANCE|SD_BALANCE_NEWIDLE|SD_BALANCE_EXEC|SD_BALANCE_FORK|SD_WAKE_AFFINE|SD_SHARE_POWERDOMAIN|SD_SHARE_PKG_RESOURCES|SD_SHARE_CAP_STATES|</span><br><span class="line">[build_sched_domains][tl MC] cpu7, sd-&gt;groups=0xffffffc156092d80, sd-&gt;span_weight=4, sd-&gt;balance_interval=4, sd-&gt;span[]=0xf0</span><br><span class="line">[build_sched_domains][tl MC] cpu7, sg-&gt;sgc=0xffffffc156092180, sg-&gt;next=0xffffffc156090a80, sg-&gt;group_weight=0, sg-&gt;cpumask[]=0x80</span><br><span class="line">[build_sched_domains][tl MC] cpu7, sgc-&gt;capacity=0, sgc-&gt;next_update=0, sgc-&gt;nr_busy_cpus=0, sgc-&gt;cpumask[]=0x3ff</span><br><span class="line">[build_sched_domains][tl MC] cpu7, sd-&gt;min_interval=4, sd-&gt;max_interval=8, sd-&gt;busy_factor=32, sd-&gt;imbalance_pct=117, sd-&gt;cache_nice_tries=1, sd-&gt;busy_idx=2, sd-&gt;idle_idx=0, sd-&gt;newidle_idx=0, sd-&gt;wake_idx=0,  sd-&gt;forkexec_idx=0, sd-&gt;span_weight=4, sd-&gt;balance_interval=4, sd-&gt;level=0 </span><br><span class="line">[build_sched_domains][tl MC] cpu7, sd-&gt;flags=0x832f: SD_LOAD_BALANCE|SD_BALANCE_NEWIDLE|SD_BALANCE_EXEC|SD_BALANCE_FORK|SD_WAKE_AFFINE|SD_SHARE_POWERDOMAIN|SD_SHARE_PKG_RESOURCES|SD_SHARE_CAP_STATES|</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[build_sched_domains][tl DIE] cpu0, sd-&gt;groups=0xffffffc156092c00, sd-&gt;span_weight=8, sd-&gt;balance_interval=8, sd-&gt;span[]=0xff</span><br><span class="line">[build_sched_domains][tl DIE] cpu0, sg-&gt;sgc=0xffffffc156092300, sg-&gt;next=0xffffffc156094d80, sg-&gt;group_weight=0, sg-&gt;cpumask[]=0xf</span><br><span class="line">[build_sched_domains][tl DIE] cpu0, sgc-&gt;capacity=0, sgc-&gt;next_update=0, sgc-&gt;nr_busy_cpus=0, sgc-&gt;cpumask[]=0x3ff</span><br><span class="line">[build_sched_domains][tl DIE] cpu0, sd-&gt;min_interval=8, sd-&gt;max_interval=16, sd-&gt;busy_factor=32, sd-&gt;imbalance_pct=125, sd-&gt;cache_nice_tries=1, sd-&gt;busy_idx=2, sd-&gt;idle_idx=1, sd-&gt;newidle_idx=0, sd-&gt;wake_idx=0,  sd-&gt;forkexec_idx=0, sd-&gt;span_weight=8, sd-&gt;balance_interval=8, sd-&gt;level=1 </span><br><span class="line">[build_sched_domains][tl DIE] cpu0, sd-&gt;flags=0x102f: SD_LOAD_BALANCE|SD_BALANCE_NEWIDLE|SD_BALANCE_EXEC|SD_BALANCE_FORK|SD_WAKE_AFFINE|SD_PREFER_SIBLING|</span><br><span class="line">[build_sched_domains][tl DIE] cpu1, sd-&gt;groups=0xffffffc156092c00, sd-&gt;span_weight=8, sd-&gt;balance_interval=8, sd-&gt;span[]=0xff</span><br><span class="line">[build_sched_domains][tl DIE] cpu1, sg-&gt;sgc=0x0, sg-&gt;next=0xffffffc156092a80, sg-&gt;group_weight=0, sg-&gt;cpumask[]=0x0</span><br><span class="line">[build_sched_domains][tl DIE] cpu1, sgc-&gt;capacity=0, sgc-&gt;next_update=0, sgc-&gt;nr_busy_cpus=0, sgc-&gt;cpumask[]=0x0</span><br><span class="line">[build_sched_domains][tl DIE] cpu1, sd-&gt;min_interval=8, sd-&gt;max_interval=16, sd-&gt;busy_factor=32, sd-&gt;imbalance_pct=125, sd-&gt;cache_nice_tries=1, sd-&gt;busy_idx=2, sd-&gt;idle_idx=1, sd-&gt;newidle_idx=0, sd-&gt;wake_idx=0,  sd-&gt;forkexec_idx=0, sd-&gt;span_weight=8, sd-&gt;balance_interval=8, sd-&gt;level=1 </span><br><span class="line">[build_sched_domains][tl DIE] cpu1, sd-&gt;flags=0x102f: SD_LOAD_BALANCE|SD_BALANCE_NEWIDLE|SD_BALANCE_EXEC|SD_BALANCE_FORK|SD_WAKE_AFFINE|SD_PREFER_SIBLING|</span><br><span class="line">[build_sched_domains][tl DIE] cpu2, sd-&gt;groups=0xffffffc156092c00, sd-&gt;span_weight=8, sd-&gt;balance_interval=8, sd-&gt;span[]=0xff</span><br><span class="line">[build_sched_domains][tl DIE] cpu2, sg-&gt;sgc=0x0, sg-&gt;next=0xffffffc156092900, sg-&gt;group_weight=0, sg-&gt;cpumask[]=0x0</span><br><span class="line">[build_sched_domains][tl DIE] cpu2, sgc-&gt;capacity=0, sgc-&gt;next_update=0, sgc-&gt;nr_busy_cpus=0, sgc-&gt;cpumask[]=0x0</span><br><span class="line">[build_sched_domains][tl DIE] cpu2, sd-&gt;min_interval=8, sd-&gt;max_interval=16, sd-&gt;busy_factor=32, sd-&gt;imbalance_pct=125, sd-&gt;cache_nice_tries=1, sd-&gt;busy_idx=2, sd-&gt;idle_idx=1, sd-&gt;newidle_idx=0, sd-&gt;wake_idx=0,  sd-&gt;forkexec_idx=0, sd-&gt;span_weight=8, sd-&gt;balance_interval=8, sd-&gt;level=1 </span><br><span class="line">[build_sched_domains][tl DIE] cpu2, sd-&gt;flags=0x102f: SD_LOAD_BALANCE|SD_BALANCE_NEWIDLE|SD_BALANCE_EXEC|SD_BALANCE_FORK|SD_WAKE_AFFINE|SD_PREFER_SIBLING|</span><br><span class="line">[build_sched_domains][tl DIE] cpu3, sd-&gt;groups=0xffffffc156092c00, sd-&gt;span_weight=8, sd-&gt;balance_interval=8, sd-&gt;span[]=0xff</span><br><span class="line">[build_sched_domains][tl DIE] cpu3, sg-&gt;sgc=0x0, sg-&gt;next=0xffffffc156092780, sg-&gt;group_weight=0, sg-&gt;cpumask[]=0x0</span><br><span class="line">[build_sched_domains][tl DIE] cpu3, sgc-&gt;capacity=0, sgc-&gt;next_update=0, sgc-&gt;nr_busy_cpus=0, sgc-&gt;cpumask[]=0x0</span><br><span class="line">[build_sched_domains][tl DIE] cpu3, sd-&gt;min_interval=8, sd-&gt;max_interval=16, sd-&gt;busy_factor=32, sd-&gt;imbalance_pct=125, sd-&gt;cache_nice_tries=1, sd-&gt;busy_idx=2, sd-&gt;idle_idx=1, sd-&gt;newidle_idx=0, sd-&gt;wake_idx=0,  sd-&gt;forkexec_idx=0, sd-&gt;span_weight=8, sd-&gt;balance_interval=8, sd-&gt;level=1 </span><br><span class="line">[build_sched_domains][tl DIE] cpu3, sd-&gt;flags=0x102f: SD_LOAD_BALANCE|SD_BALANCE_NEWIDLE|SD_BALANCE_EXEC|SD_BALANCE_FORK|SD_WAKE_AFFINE|SD_PREFER_SIBLING|</span><br><span class="line">[build_sched_domains][tl DIE] cpu4, sd-&gt;groups=0xffffffc156094d80, sd-&gt;span_weight=8, sd-&gt;balance_interval=8, sd-&gt;span[]=0xff</span><br><span class="line">[build_sched_domains][tl DIE] cpu4, sg-&gt;sgc=0xffffffc156094180, sg-&gt;next=0xffffffc156092c00, sg-&gt;group_weight=0, sg-&gt;cpumask[]=0xf0</span><br><span class="line">[build_sched_domains][tl DIE] cpu4, sgc-&gt;capacity=0, sgc-&gt;next_update=0, sgc-&gt;nr_busy_cpus=0, sgc-&gt;cpumask[]=0x3ff</span><br><span class="line">[build_sched_domains][tl DIE] cpu4, sd-&gt;min_interval=8, sd-&gt;max_interval=16, sd-&gt;busy_factor=32, sd-&gt;imbalance_pct=125, sd-&gt;cache_nice_tries=1, sd-&gt;busy_idx=2, sd-&gt;idle_idx=1, sd-&gt;newidle_idx=0, sd-&gt;wake_idx=0,  sd-&gt;forkexec_idx=0, sd-&gt;span_weight=8, sd-&gt;balance_interval=8, sd-&gt;level=1 </span><br><span class="line">[build_sched_domains][tl DIE] cpu4, sd-&gt;flags=0x102f: SD_LOAD_BALANCE|SD_BALANCE_NEWIDLE|SD_BALANCE_EXEC|SD_BALANCE_FORK|SD_WAKE_AFFINE|SD_PREFER_SIBLING|</span><br><span class="line">[build_sched_domains][tl DIE] cpu5, sd-&gt;groups=0xffffffc156094d80, sd-&gt;span_weight=8, sd-&gt;balance_interval=8, sd-&gt;span[]=0xff</span><br><span class="line">[build_sched_domains][tl DIE] cpu5, sg-&gt;sgc=0x0, sg-&gt;next=0xffffffc156094c00, sg-&gt;group_weight=0, sg-&gt;cpumask[]=0x0</span><br><span class="line">[build_sched_domains][tl DIE] cpu5, sgc-&gt;capacity=0, sgc-&gt;next_update=0, sgc-&gt;nr_busy_cpus=0, sgc-&gt;cpumask[]=0x0</span><br><span class="line">[build_sched_domains][tl DIE] cpu5, sd-&gt;min_interval=8, sd-&gt;max_interval=16, sd-&gt;busy_factor=32, sd-&gt;imbalance_pct=125, sd-&gt;cache_nice_tries=1, sd-&gt;busy_idx=2, sd-&gt;idle_idx=1, sd-&gt;newidle_idx=0, sd-&gt;wake_idx=0,  sd-&gt;forkexec_idx=0, sd-&gt;span_weight=8, sd-&gt;balance_interval=8, sd-&gt;level=1 </span><br><span class="line">[build_sched_domains][tl DIE] cpu5, sd-&gt;flags=0x102f: SD_LOAD_BALANCE|SD_BALANCE_NEWIDLE|SD_BALANCE_EXEC|SD_BALANCE_FORK|SD_WAKE_AFFINE|SD_PREFER_SIBLING|</span><br><span class="line">[build_sched_domains][tl DIE] cpu6, sd-&gt;groups=0xffffffc156094d80, sd-&gt;span_weight=8, sd-&gt;balance_interval=8, sd-&gt;span[]=0xff</span><br><span class="line">[build_sched_domains][tl DIE] cpu6, sg-&gt;sgc=0x0, sg-&gt;next=0xffffffc156094a80, sg-&gt;group_weight=0, sg-&gt;cpumask[]=0x0</span><br><span class="line">[build_sched_domains][tl DIE] cpu6, sgc-&gt;capacity=0, sgc-&gt;next_update=0, sgc-&gt;nr_busy_cpus=0, sgc-&gt;cpumask[]=0x0</span><br><span class="line">[build_sched_domains][tl DIE] cpu6, sd-&gt;min_interval=8, sd-&gt;max_interval=16, sd-&gt;busy_factor=32, sd-&gt;imbalance_pct=125, sd-&gt;cache_nice_tries=1, sd-&gt;busy_idx=2, sd-&gt;idle_idx=1, sd-&gt;newidle_idx=0, sd-&gt;wake_idx=0,  sd-&gt;forkexec_idx=0, sd-&gt;span_weight=8, sd-&gt;balance_interval=8, sd-&gt;level=1 </span><br><span class="line">[build_sched_domains][tl DIE] cpu6, sd-&gt;flags=0x102f: SD_LOAD_BALANCE|SD_BALANCE_NEWIDLE|SD_BALANCE_EXEC|SD_BALANCE_FORK|SD_WAKE_AFFINE|SD_PREFER_SIBLING|</span><br><span class="line">[build_sched_domains][tl DIE] cpu7, sd-&gt;groups=0xffffffc156094d80, sd-&gt;span_weight=8, sd-&gt;balance_interval=8, sd-&gt;span[]=0xff</span><br><span class="line">[build_sched_domains][tl DIE] cpu7, sg-&gt;sgc=0x0, sg-&gt;next=0xffffffc156094900, sg-&gt;group_weight=0, sg-&gt;cpumask[]=0x0</span><br><span class="line">[build_sched_domains][tl DIE] cpu7, sgc-&gt;capacity=0, sgc-&gt;next_update=0, sgc-&gt;nr_busy_cpus=0, sgc-&gt;cpumask[]=0x0</span><br><span class="line">[build_sched_domains][tl DIE] cpu7, sd-&gt;min_interval=8, sd-&gt;max_interval=16, sd-&gt;busy_factor=32, sd-&gt;imbalance_pct=125, sd-&gt;cache_nice_tries=1, sd-&gt;busy_idx=2, sd-&gt;idle_idx=1, sd-&gt;newidle_idx=0, sd-&gt;wake_idx=0,  sd-&gt;forkexec_idx=0, sd-&gt;span_weight=8, sd-&gt;balance_interval=8, sd-&gt;level=1 </span><br><span class="line">[build_sched_domains][tl DIE] cpu7, sd-&gt;flags=0x102f: SD_LOAD_BALANCE|SD_BALANCE_NEWIDLE|SD_BALANCE_EXEC|SD_BALANCE_FORK|SD_WAKE_AFFINE|SD_PREFER_SIBLING|</span><br></pre></td></tr></table></figure>
<p>用图形表达的关系如下：</p>
<p><img src="/images/scheduler/schedule_sched_domain_mt6799_8cpus.png" alt="schedule_sched_domain_mt6799_8cpus"></p>
<p>每个sched_domain中的参数也非常重要，在函数sd_init()中初始化，在smp负载均衡时会频繁的使用这些参数和标志：</p>
<html><br><table><br>    <tr><br>        <td style="width: 200px;"> sd 参数 </td><br>        <td style="width: 300px;"> tl MC 层级 </td><br>        <td style="width: 300px;"> tl DIE 层级 </td><br>    </tr><br>    <tr><br>        <td> sd-&gt;min_interval </td><br>        <td> 4 </td><br>        <td> 8 </td><br>    </tr><br>    <tr><br>        <td> sd-&gt;max_interval </td><br>        <td> 8 </td><br>        <td> 16 </td><br>    </tr><br>    <tr><br>        <td> sd-&gt;busy_factor </td><br>        <td> 32 </td><br>        <td> 32 </td><br>    </tr><br>    <tr><br>        <td> sd-&gt;imbalance_pct </td><br>        <td> 117 </td><br>        <td> 125 </td><br>    </tr><br>    <tr><br>        <td> sd-&gt;cache_nice_tries </td><br>        <td> 1 </td><br>        <td> 1 </td><br>    </tr><br>    <tr><br>        <td> sd-&gt;busy_idx </td><br>        <td> 2 </td><br>        <td> 2 </td><br>    </tr><br>    <tr><br>        <td> sd-&gt;idle_idx </td><br>        <td> 0 </td><br>        <td> 1 </td><br>    </tr><br>    <tr><br>        <td> sd-&gt;newidle_idx </td><br>        <td> 0 </td><br>        <td> 0 </td><br>    </tr><br>    <tr><br>        <td> sd-&gt;wake_idx </td><br>        <td> 0 </td><br>        <td> 0 </td><br>    </tr><br>    <tr><br>        <td> sd-&gt;forkexec_idx </td><br>        <td> 0 </td><br>        <td> 0 </td><br>    </tr><br>    <tr><br>        <td> sd-&gt;span_weight </td><br>        <td> 4 </td><br>        <td> 8 </td><br>    </tr><br>    <tr><br>        <td> sd-&gt;balance_interval</td><br>        <td> 4 </td><br>        <td> 8 </td><br>    </tr><br>    <tr><br>        <td> sd-&gt;level </td><br>        <td> 0 </td><br>        <td> 1 </td><br>    </tr><br>    <tr><br>        <td> sd-&gt;flags </td><br>        <td> 0x832f: SD_LOAD_BALANCE|SD_BALANCE_NEWIDLE|SD_BALANCE_EXEC|SD_BALANCE_FORK|SD_WAKE_AFFINE|SD_SHARE_POWERDOMAIN|SD_SHARE_PKG_RESOURCES|SD_SHARE_CAP_STATES<br>        </td><td> 0x102f: SD_LOAD_BALANCE|SD_BALANCE_NEWIDLE|SD_BALANCE_EXEC|SD_BALANCE_FORK|SD_WAKE_AFFINE|SD_PREFER_SIBLING </td><br>        <br>    </tr><br></table><br></html>


<p>update_top_cache_domain()函数中还把常用的一些sd进行了cache，我们通过打印得出每个cache实际对应的层次sd：</p>
<html><br><table><br>    <tr><br>        <td style="width: 200px;"> cache sd </td><br>        <td style="width: 300px;"> 说明 </td><br>        <td style="width: 300px;"> 赋值 </td><br>    </tr><br>    <tr><br>        <td> sd_busy </td><br>        <td> per_cpu(sd_busy, cpu), </td><br>        <td> 本cpu的tl DIE层级sd </td><br>    </tr><br>    <tr><br>        <td> sd_llc </td><br>        <td> per_cpu(sd_llc, cpu), </td><br>        <td> 本cpu的tl MC层级sd </td><br>    </tr><br>    <tr><br>        <td> sd_llc_size </td><br>        <td> per_cpu(sd_llc_size, cpu), </td><br>        <td> 4 </td><br>    </tr><br>    <tr><br>        <td> sd_llc_id </td><br>        <td> per_cpu(sd_llc_id, cpu), </td><br>        <td> 0/4 </td><br>    </tr><br>    <tr><br>        <td> sd_numa </td><br>        <td> per_cpu(sd_numa, cpu), </td><br>        <td> 0 </td><br>    </tr><br>    <tr><br>        <td> sd_asym </td><br>        <td> per_cpu(sd_asym, cpu), </td><br>        <td> 0 </td><br>    </tr><br>    <tr><br>        <td> sd_ea </td><br>        <td> per_cpu(sd_ea, cpu), </td><br>        <td> 本cpu的tl DIE层级sd </td><br>    </tr><br>    <tr><br>        <td> sd_scs </td><br>        <td> per_cpu(sd_scs, cpu), </td><br>        <td> 本cpu的tl MC层级sd </td><br>    </tr><br></table><br></html>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">static void update_top_cache_domain(int cpu)</span><br><span class="line">&#123;</span><br><span class="line">	struct sched_domain *sd;</span><br><span class="line">	struct sched_domain *busy_sd = NULL, *ea_sd = NULL;</span><br><span class="line">	int id = cpu;</span><br><span class="line">	int size = 1;</span><br><span class="line"></span><br><span class="line">	sd = highest_flag_domain(cpu, SD_SHARE_PKG_RESOURCES);</span><br><span class="line">	if (sd) &#123;</span><br><span class="line">		id = cpumask_first(sched_domain_span(sd));</span><br><span class="line">		size = cpumask_weight(sched_domain_span(sd));</span><br><span class="line">		busy_sd = sd-&gt;parent; /* sd_busy */</span><br><span class="line">	&#125;</span><br><span class="line">	rcu_assign_pointer(per_cpu(sd_busy, cpu), busy_sd);</span><br><span class="line"></span><br><span class="line">	rcu_assign_pointer(per_cpu(sd_llc, cpu), sd);</span><br><span class="line">	per_cpu(sd_llc_size, cpu) = size;</span><br><span class="line">	per_cpu(sd_llc_id, cpu) = id;</span><br><span class="line"></span><br><span class="line">	sd = lowest_flag_domain(cpu, SD_NUMA);</span><br><span class="line">	rcu_assign_pointer(per_cpu(sd_numa, cpu), sd);</span><br><span class="line"></span><br><span class="line">	sd = highest_flag_domain(cpu, SD_ASYM_PACKING);</span><br><span class="line">	rcu_assign_pointer(per_cpu(sd_asym, cpu), sd);</span><br><span class="line"></span><br><span class="line">	for_each_domain(cpu, sd) &#123;</span><br><span class="line">		if (sd-&gt;groups-&gt;sge)</span><br><span class="line">			ea_sd = sd;</span><br><span class="line">		else</span><br><span class="line">			break;</span><br><span class="line">	&#125;</span><br><span class="line">	rcu_assign_pointer(per_cpu(sd_ea, cpu), ea_sd);</span><br><span class="line"></span><br><span class="line">	sd = highest_flag_domain(cpu, SD_SHARE_CAP_STATES);</span><br><span class="line">	rcu_assign_pointer(per_cpu(sd_scs, cpu), sd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[update_top_cache_domain] cpu0, sd_busy=0xffffffc156091300, sd_llc=0xffffffc15663c600, sd_llc_size=4, sd_llc_id=0, sd_numa=0x0, sd_asym=0x0, sd_ea=0xffffffc156091300, sd_scs=0xffffffc15663c600</span><br><span class="line">[update_top_cache_domain] cpu1, sd_busy=0xffffffc156091900, sd_llc=0xffffffc15608f000, sd_llc_size=4, sd_llc_id=0, sd_numa=0x0, sd_asym=0x0, sd_ea=0xffffffc156091900, sd_scs=0xffffffc15608f000</span><br><span class="line">[update_top_cache_domain] cpu2, sd_busy=0xffffffc156091600, sd_llc=0xffffffc15608fc00, sd_llc_size=4, sd_llc_id=0, sd_numa=0x0, sd_asym=0x0, sd_ea=0xffffffc156091600, sd_scs=0xffffffc15608fc00</span><br><span class="line">[update_top_cache_domain] cpu3, sd_busy=0xffffffc156093000, sd_llc=0xffffffc15608f300, sd_llc_size=4, sd_llc_id=0, sd_numa=0x0, sd_asym=0x0, sd_ea=0xffffffc156093000, sd_scs=0xffffffc15608f300</span><br><span class="line">[update_top_cache_domain] cpu4, sd_busy=0xffffffc156093c00, sd_llc=0xffffffc15608f900, sd_llc_size=4, sd_llc_id=4, sd_numa=0x0, sd_asym=0x0, sd_ea=0xffffffc156093c00, sd_scs=0xffffffc15608f900</span><br><span class="line">[update_top_cache_domain] cpu5, sd_busy=0xffffffc156093300, sd_llc=0xffffffc15608f600, sd_llc_size=4, sd_llc_id=4, sd_numa=0x0, sd_asym=0x0, sd_ea=0xffffffc156093300, sd_scs=0xffffffc15608f600</span><br><span class="line">[update_top_cache_domain] cpu6, sd_busy=0xffffffc156093900, sd_llc=0xffffffc156091000, sd_llc_size=4, sd_llc_id=4, sd_numa=0x0, sd_asym=0x0, sd_ea=0xffffffc156093900, sd_scs=0xffffffc156091000</span><br><span class="line">[update_top_cache_domain] cpu7, sd_busy=0xffffffc156093600, sd_llc=0xffffffc156091c00, sd_llc_size=4, sd_llc_id=4, sd_numa=0x0, sd_asym=0x0, sd_ea=0xffffffc156093600, sd_scs=0xffffffc156091c00</span><br><span class="line"></span><br><span class="line">[__sdt_alloc][tl MC] cpu0, &amp;sd = 0xffffffc15663c600, &amp;sg = 0xffffffc156062600, &amp;sgc = 0xffffffc156062780 </span><br><span class="line">[__sdt_alloc][tl MC] cpu1, &amp;sd = 0xffffffc15608f000, &amp;sg = 0xffffffc156056780, &amp;sgc = 0xffffffc156090000 </span><br><span class="line">[__sdt_alloc][tl MC] cpu2, &amp;sd = 0xffffffc15608fc00, &amp;sg = 0xffffffc156090d80, &amp;sgc = 0xffffffc156090180 </span><br><span class="line">[__sdt_alloc][tl MC] cpu3, &amp;sd = 0xffffffc15608f300, &amp;sg = 0xffffffc156090c00, &amp;sgc = 0xffffffc156090300 </span><br><span class="line">[__sdt_alloc][tl MC] cpu4, &amp;sd = 0xffffffc15608f900, &amp;sg = 0xffffffc156090a80, &amp;sgc = 0xffffffc156090480 </span><br><span class="line">[__sdt_alloc][tl MC] cpu5, &amp;sd = 0xffffffc15608f600, &amp;sg = 0xffffffc156090900, &amp;sgc = 0xffffffc156090600 </span><br><span class="line">[__sdt_alloc][tl MC] cpu6, &amp;sd = 0xffffffc156091000, &amp;sg = 0xffffffc156090780, &amp;sgc = 0xffffffc156092000 </span><br><span class="line">[__sdt_alloc][tl MC] cpu7, &amp;sd = 0xffffffc156091c00, &amp;sg = 0xffffffc156092d80, &amp;sgc = 0xffffffc156092180 </span><br><span class="line"></span><br><span class="line">[__sdt_alloc][tl DIE] cpu0, &amp;sd = 0xffffffc156091300, &amp;sg = 0xffffffc156092c00, &amp;sgc = 0xffffffc156092300 </span><br><span class="line">[__sdt_alloc][tl DIE] cpu1, &amp;sd = 0xffffffc156091900, &amp;sg = 0xffffffc156092a80, &amp;sgc = 0xffffffc156092480 </span><br><span class="line">[__sdt_alloc][tl DIE] cpu2, &amp;sd = 0xffffffc156091600, &amp;sg = 0xffffffc156092900, &amp;sgc = 0xffffffc156092600 </span><br><span class="line">[__sdt_alloc][tl DIE] cpu3, &amp;sd = 0xffffffc156093000, &amp;sg = 0xffffffc156092780, &amp;sgc = 0xffffffc156094000 </span><br><span class="line">[__sdt_alloc][tl DIE] cpu4, &amp;sd = 0xffffffc156093c00, &amp;sg = 0xffffffc156094d80, &amp;sgc = 0xffffffc156094180 </span><br><span class="line">[__sdt_alloc][tl DIE] cpu5, &amp;sd = 0xffffffc156093300, &amp;sg = 0xffffffc156094c00, &amp;sgc = 0xffffffc156094300 </span><br><span class="line">[__sdt_alloc][tl DIE] cpu6, &amp;sd = 0xffffffc156093900, &amp;sg = 0xffffffc156094a80, &amp;sgc = 0xffffffc156094480 </span><br><span class="line">[__sdt_alloc][tl DIE] cpu7, &amp;sd = 0xffffffc156093600, &amp;sg = 0xffffffc156094900, &amp;sgc = 0xffffffc156094600</span><br></pre></td></tr></table></figure>
<p>mt6799在计算功耗(energy)和运算能力(capacity)时使用的表项如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br></pre></td><td class="code"><pre><span class="line">kernel_init() -&gt; kernel_init_freeable() -&gt; sched_init_smp() -&gt; init_sched_domains() -&gt; build_sched_domains() -&gt; init_sched_energy()/init_sched_groups_capacity()；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* v1 FY */</span><br><span class="line">struct upower_tbl_info upower_tbl_infos_FY[NR_UPOWER_BANK] = &#123;</span><br><span class="line">	INIT_UPOWER_TBL_INFOS(UPOWER_BANK_LL, upower_tbl_ll_1_FY),</span><br><span class="line">	INIT_UPOWER_TBL_INFOS(UPOWER_BANK_L, upower_tbl_l_1_FY),</span><br><span class="line">	INIT_UPOWER_TBL_INFOS(UPOWER_BANK_B, upower_tbl_b_1_FY),</span><br><span class="line">	INIT_UPOWER_TBL_INFOS(UPOWER_BANK_CLS_LL, upower_tbl_cluster_ll_1_FY),</span><br><span class="line">	INIT_UPOWER_TBL_INFOS(UPOWER_BANK_CLS_L, upower_tbl_cluster_l_1_FY),</span><br><span class="line">	INIT_UPOWER_TBL_INFOS(UPOWER_BANK_CLS_B, upower_tbl_cluster_b_1_FY),</span><br><span class="line">	INIT_UPOWER_TBL_INFOS(UPOWER_BANK_CCI, upower_tbl_cci_1_FY),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/* ver1 */</span><br><span class="line">/* FY table */</span><br><span class="line">struct upower_tbl upower_tbl_ll_1_FY = &#123;</span><br><span class="line">	.row = &#123;</span><br><span class="line">		&#123;.cap = 100, .volt = 75000, .dyn_pwr = 9994, .lkg_pwr = &#123;13681, 13681, 13681, 13681, 13681, 13681&#125; &#125;,</span><br><span class="line">		&#123;.cap = 126, .volt = 75000, .dyn_pwr = 12585, .lkg_pwr = &#123;13681, 13681, 13681, 13681, 13681, 13681&#125; &#125;,</span><br><span class="line">		&#123;.cap = 148, .volt = 75000, .dyn_pwr = 14806, .lkg_pwr = &#123;13681, 13681, 13681, 13681, 13681, 13681&#125; &#125;,</span><br><span class="line">		&#123;.cap = 167, .volt = 75000, .dyn_pwr = 16656, .lkg_pwr = &#123;13681, 13681, 13681, 13681, 13681, 13681&#125; &#125;,</span><br><span class="line">		&#123;.cap = 189, .volt = 75000, .dyn_pwr = 18877, .lkg_pwr = &#123;13681, 13681, 13681, 13681, 13681, 13681&#125; &#125;,</span><br><span class="line">		&#123;.cap = 212, .volt = 75000, .dyn_pwr = 21098, .lkg_pwr = &#123;13681, 13681, 13681, 13681, 13681, 13681&#125; &#125;,</span><br><span class="line">		&#123;.cap = 230, .volt = 75700, .dyn_pwr = 23379, .lkg_pwr = &#123;13936, 13936, 13936, 13936, 13936, 13936&#125; &#125;,</span><br><span class="line">		&#123;.cap = 245, .volt = 78100, .dyn_pwr = 26490, .lkg_pwr = &#123;14811, 14811, 14811, 14811, 14811, 14811&#125; &#125;,</span><br><span class="line">		&#123;.cap = 263, .volt = 81100, .dyn_pwr = 30729, .lkg_pwr = &#123;15958, 15958, 15958, 15958, 15958, 15958&#125; &#125;,</span><br><span class="line">		&#123;.cap = 278, .volt = 83500, .dyn_pwr = 34409, .lkg_pwr = &#123;16949, 16949, 16949, 16949, 16949, 16949&#125; &#125;,</span><br><span class="line">		&#123;.cap = 293, .volt = 86000, .dyn_pwr = 38447, .lkg_pwr = &#123;18036, 18036, 18036, 18036, 18036, 18036&#125; &#125;,</span><br><span class="line">		&#123;.cap = 304, .volt = 88400, .dyn_pwr = 42166, .lkg_pwr = &#123;19159, 19159, 19159, 19159, 19159, 19159&#125; &#125;,</span><br><span class="line">		&#123;.cap = 319, .volt = 90800, .dyn_pwr = 46657, .lkg_pwr = &#123;20333, 20333, 20333, 20333, 20333, 20333&#125; &#125;,</span><br><span class="line">		&#123;.cap = 334, .volt = 93200, .dyn_pwr = 51442, .lkg_pwr = &#123;21605, 21605, 21605, 21605, 21605, 21605&#125; &#125;,</span><br><span class="line">		&#123;.cap = 345, .volt = 95000, .dyn_pwr = 55230, .lkg_pwr = &#123;22560, 22560, 22560, 22560, 22560, 22560&#125; &#125;,</span><br><span class="line">		&#123;.cap = 356, .volt = 97400, .dyn_pwr = 59928, .lkg_pwr = &#123;24002, 24002, 24002, 24002, 24002, 24002&#125; &#125;,</span><br><span class="line">	&#125;,</span><br><span class="line">	.lkg_idx = DEFAULT_LKG_IDX,</span><br><span class="line">	.row_num = UPOWER_OPP_NUM,</span><br><span class="line">	.nr_idle_states = NR_UPOWER_CSTATES,</span><br><span class="line">	.idle_states = &#123;</span><br><span class="line">		&#123;&#123;0&#125;, &#123;7321&#125; &#125;,</span><br><span class="line">		&#123;&#123;0&#125;, &#123;7321&#125; &#125;,</span><br><span class="line">		&#123;&#123;0&#125;, &#123;7321&#125; &#125;,</span><br><span class="line">		&#123;&#123;0&#125;, &#123;7321&#125; &#125;,</span><br><span class="line">		&#123;&#123;0&#125;, &#123;7321&#125; &#125;,</span><br><span class="line">		&#123;&#123;0&#125;, &#123;7321&#125; &#125;,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct upower_tbl upower_tbl_cluster_ll_1_FY = &#123;</span><br><span class="line">	.row = &#123;</span><br><span class="line">		&#123;.cap = 100, .volt = 75000, .dyn_pwr = 3656, .lkg_pwr = &#123;21729, 21729, 21729, 21729, 21729, 21729&#125; &#125;,</span><br><span class="line">		&#123;.cap = 126, .volt = 75000, .dyn_pwr = 4604, .lkg_pwr = &#123;21729, 21729, 21729, 21729, 21729, 21729&#125; &#125;,</span><br><span class="line">		&#123;.cap = 148, .volt = 75000, .dyn_pwr = 5417, .lkg_pwr = &#123;21729, 21729, 21729, 21729, 21729, 21729&#125; &#125;,</span><br><span class="line">		&#123;.cap = 167, .volt = 75000, .dyn_pwr = 6094, .lkg_pwr = &#123;21729, 21729, 21729, 21729, 21729, 21729&#125; &#125;,</span><br><span class="line">		&#123;.cap = 189, .volt = 75000, .dyn_pwr = 6906, .lkg_pwr = &#123;21729, 21729, 21729, 21729, 21729, 21729&#125; &#125;,</span><br><span class="line">		&#123;.cap = 212, .volt = 75000, .dyn_pwr = 7719, .lkg_pwr = &#123;21729, 21729, 21729, 21729, 21729, 21729&#125; &#125;,</span><br><span class="line">		&#123;.cap = 230, .volt = 75700, .dyn_pwr = 8553, .lkg_pwr = &#123;22134, 22134, 22134, 22134, 22134, 22134&#125; &#125;,</span><br><span class="line">		&#123;.cap = 245, .volt = 78100, .dyn_pwr = 9692, .lkg_pwr = &#123;23523, 23523, 23523, 23523, 23523, 23523&#125; &#125;,</span><br><span class="line">		&#123;.cap = 263, .volt = 81100, .dyn_pwr = 11242, .lkg_pwr = &#123;25344, 25344, 25344, 25344, 25344, 25344&#125; &#125;,</span><br><span class="line">		&#123;.cap = 278, .volt = 83500, .dyn_pwr = 12589, .lkg_pwr = &#123;26919, 26919, 26919, 26919, 26919, 26919&#125; &#125;,</span><br><span class="line">		&#123;.cap = 293, .volt = 86000, .dyn_pwr = 14066, .lkg_pwr = &#123;28646, 28646, 28646, 28646, 28646, 28646&#125; &#125;,</span><br><span class="line">		&#123;.cap = 304, .volt = 88400, .dyn_pwr = 15427, .lkg_pwr = &#123;30430, 30430, 30430, 30430, 30430, 30430&#125; &#125;,</span><br><span class="line">		&#123;.cap = 319, .volt = 90800, .dyn_pwr = 17069, .lkg_pwr = &#123;32293, 32293, 32293, 32293, 32293, 32293&#125; &#125;,</span><br><span class="line">		&#123;.cap = 334, .volt = 93200, .dyn_pwr = 18820, .lkg_pwr = &#123;34314, 34314, 34314, 34314, 34314, 34314&#125; &#125;,</span><br><span class="line">		&#123;.cap = 345, .volt = 95000, .dyn_pwr = 20206, .lkg_pwr = &#123;35830, 35830, 35830, 35830, 35830, 35830&#125; &#125;,</span><br><span class="line">		&#123;.cap = 356, .volt = 97400, .dyn_pwr = 21925, .lkg_pwr = &#123;38121, 38121, 38121, 38121, 38121, 38121&#125; &#125;,</span><br><span class="line">	&#125;,</span><br><span class="line">	.lkg_idx = DEFAULT_LKG_IDX,</span><br><span class="line">	.row_num = UPOWER_OPP_NUM,</span><br><span class="line">	.nr_idle_states = NR_UPOWER_CSTATES,</span><br><span class="line">	.idle_states = &#123;</span><br><span class="line">		&#123;&#123;0&#125;, &#123;11628&#125; &#125;,</span><br><span class="line">		&#123;&#123;0&#125;, &#123;11628&#125; &#125;,</span><br><span class="line">		&#123;&#123;0&#125;, &#123;11628&#125; &#125;,</span><br><span class="line">		&#123;&#123;0&#125;, &#123;11628&#125; &#125;,</span><br><span class="line">		&#123;&#123;0&#125;, &#123;11628&#125; &#125;,</span><br><span class="line">		&#123;&#123;0&#125;, &#123;11628&#125; &#125;,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct upower_tbl upower_tbl_l_1_FY = &#123;</span><br><span class="line">	.row = &#123;</span><br><span class="line">		&#123;.cap = 116, .volt = 75000, .dyn_pwr = 16431, .lkg_pwr = &#123;22973, 22973, 22973, 22973, 22973, 22973&#125; &#125;,</span><br><span class="line">		&#123;.cap = 152, .volt = 75000, .dyn_pwr = 21486, .lkg_pwr = &#123;22973, 22973, 22973, 22973, 22973, 22973&#125; &#125;,</span><br><span class="line">		&#123;.cap = 179, .volt = 75000, .dyn_pwr = 25278, .lkg_pwr = &#123;22973, 22973, 22973, 22973, 22973, 22973&#125; &#125;,</span><br><span class="line">		&#123;.cap = 201, .volt = 75000, .dyn_pwr = 28437, .lkg_pwr = &#123;22973, 22973, 22973, 22973, 22973, 22973&#125; &#125;,</span><br><span class="line">		&#123;.cap = 228, .volt = 75000, .dyn_pwr = 32229, .lkg_pwr = &#123;22973, 22973, 22973, 22973, 22973, 22973&#125; &#125;,</span><br><span class="line">		&#123;.cap = 255, .volt = 75000, .dyn_pwr = 36021, .lkg_pwr = &#123;22973, 22973, 22973, 22973, 22973, 22973&#125; &#125;,</span><br><span class="line">		&#123;.cap = 282, .volt = 75700, .dyn_pwr = 40559, .lkg_pwr = &#123;23423, 23423, 23423, 23423, 23423, 23423&#125; &#125;,</span><br><span class="line">		&#123;.cap = 304, .volt = 78100, .dyn_pwr = 46598, .lkg_pwr = &#123;24968, 24968, 24968, 24968, 24968, 24968&#125; &#125;,</span><br><span class="line">		&#123;.cap = 331, .volt = 81100, .dyn_pwr = 54680, .lkg_pwr = &#123;26999, 26999, 26999, 26999, 26999, 26999&#125; &#125;,</span><br><span class="line">		&#123;.cap = 349, .volt = 83500, .dyn_pwr = 61098, .lkg_pwr = &#123;28760, 28760, 28760, 28760, 28760, 28760&#125; &#125;,</span><br><span class="line">		&#123;.cap = 371, .volt = 86000, .dyn_pwr = 68965, .lkg_pwr = &#123;30698, 30698, 30698, 30698, 30698, 30698&#125; &#125;,</span><br><span class="line">		&#123;.cap = 393, .volt = 88400, .dyn_pwr = 77258, .lkg_pwr = &#123;32706, 32706, 32706, 32706, 32706, 32706&#125; &#125;,</span><br><span class="line">		&#123;.cap = 416, .volt = 90800, .dyn_pwr = 86141, .lkg_pwr = &#123;34808, 34808, 34808, 34808, 34808, 34808&#125; &#125;,</span><br><span class="line">		&#123;.cap = 438, .volt = 93200, .dyn_pwr = 95634, .lkg_pwr = &#123;37097, 37097, 37097, 37097, 37097, 37097&#125; &#125;,</span><br><span class="line">		&#123;.cap = 452, .volt = 95000, .dyn_pwr = 102406, .lkg_pwr = &#123;38814, 38814, 38814, 38814, 38814, 38814&#125; &#125;,</span><br><span class="line">		&#123;.cap = 474, .volt = 97400, .dyn_pwr = 112974, .lkg_pwr = &#123;41424, 41424, 41424, 41424, 41424, 41424&#125; &#125;,</span><br><span class="line">	&#125;,</span><br><span class="line">	.lkg_idx = DEFAULT_LKG_IDX,</span><br><span class="line">	.row_num = UPOWER_OPP_NUM,</span><br><span class="line">	.nr_idle_states = NR_UPOWER_CSTATES,</span><br><span class="line">	.idle_states = &#123;</span><br><span class="line">		&#123;&#123;0&#125;, &#123;11926&#125; &#125;,</span><br><span class="line">		&#123;&#123;0&#125;, &#123;11926&#125; &#125;,</span><br><span class="line">		&#123;&#123;0&#125;, &#123;11926&#125; &#125;,</span><br><span class="line">		&#123;&#123;0&#125;, &#123;11926&#125; &#125;,</span><br><span class="line">		&#123;&#123;0&#125;, &#123;11926&#125; &#125;,</span><br><span class="line">		&#123;&#123;0&#125;, &#123;11926&#125; &#125;,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct upower_tbl upower_tbl_cluster_l_1_FY = &#123;</span><br><span class="line">	.row = &#123;</span><br><span class="line">		&#123;.cap = 116, .volt = 75000, .dyn_pwr = 2778, .lkg_pwr = &#123;26537, 26537, 26537, 26537, 26537, 26537&#125; &#125;,</span><br><span class="line">		&#123;.cap = 152, .volt = 75000, .dyn_pwr = 3633, .lkg_pwr = &#123;26537, 26537, 26537, 26537, 26537, 26537&#125; &#125;,</span><br><span class="line">		&#123;.cap = 179, .volt = 75000, .dyn_pwr = 4274, .lkg_pwr = &#123;26537, 26537, 26537, 26537, 26537, 26537&#125; &#125;,</span><br><span class="line">		&#123;.cap = 201, .volt = 75000, .dyn_pwr = 4808, .lkg_pwr = &#123;26537, 26537, 26537, 26537, 26537, 26537&#125; &#125;,</span><br><span class="line">		&#123;.cap = 228, .volt = 75000, .dyn_pwr = 5449, .lkg_pwr = &#123;26537, 26537, 26537, 26537, 26537, 26537&#125; &#125;,</span><br><span class="line">		&#123;.cap = 255, .volt = 75000, .dyn_pwr = 6090, .lkg_pwr = &#123;26537, 26537, 26537, 26537, 26537, 26537&#125; &#125;,</span><br><span class="line">		&#123;.cap = 282, .volt = 75700, .dyn_pwr = 6857, .lkg_pwr = &#123;27058, 27058, 27058, 27058, 27058, 27058&#125; &#125;,</span><br><span class="line">		&#123;.cap = 304, .volt = 78100, .dyn_pwr = 7878, .lkg_pwr = &#123;28843, 28843, 28843, 28843, 28843, 28843&#125; &#125;,</span><br><span class="line">		&#123;.cap = 331, .volt = 81100, .dyn_pwr = 9245, .lkg_pwr = &#123;31188, 31188, 31188, 31188, 31188, 31188&#125; &#125;,</span><br><span class="line">		&#123;.cap = 349, .volt = 83500, .dyn_pwr = 10330, .lkg_pwr = &#123;33223, 33223, 33223, 33223, 33223, 33223&#125; &#125;,</span><br><span class="line">		&#123;.cap = 371, .volt = 86000, .dyn_pwr = 11660, .lkg_pwr = &#123;35461, 35461, 35461, 35461, 35461, 35461&#125; &#125;,</span><br><span class="line">		&#123;.cap = 393, .volt = 88400, .dyn_pwr = 13062, .lkg_pwr = &#123;37781, 37781, 37781, 37781, 37781, 37781&#125; &#125;,</span><br><span class="line">		&#123;.cap = 416, .volt = 90800, .dyn_pwr = 14564, .lkg_pwr = &#123;40209, 40209, 40209, 40209, 40209, 40209&#125; &#125;,</span><br><span class="line">		&#123;.cap = 438, .volt = 93200, .dyn_pwr = 16169, .lkg_pwr = &#123;42854, 42854, 42854, 42854, 42854, 42854&#125; &#125;,</span><br><span class="line">		&#123;.cap = 452, .volt = 95000, .dyn_pwr = 17314, .lkg_pwr = &#123;44837, 44837, 44837, 44837, 44837, 44837&#125; &#125;,</span><br><span class="line">		&#123;.cap = 474, .volt = 97400, .dyn_pwr = 19101, .lkg_pwr = &#123;47852, 47852, 47852, 47852, 47852, 47852&#125; &#125;,</span><br><span class="line">	&#125;,</span><br><span class="line">	.lkg_idx = DEFAULT_LKG_IDX,</span><br><span class="line">	.row_num = UPOWER_OPP_NUM,</span><br><span class="line">	.nr_idle_states = NR_UPOWER_CSTATES,</span><br><span class="line">	.idle_states = &#123;</span><br><span class="line">		&#123;&#123;0&#125;, &#123;13776&#125; &#125;,</span><br><span class="line">		&#123;&#123;0&#125;, &#123;13776&#125; &#125;,</span><br><span class="line">		&#123;&#123;0&#125;, &#123;13776&#125; &#125;,</span><br><span class="line">		&#123;&#123;0&#125;, &#123;13776&#125; &#125;,</span><br><span class="line">		&#123;&#123;0&#125;, &#123;13776&#125; &#125;,</span><br><span class="line">		&#123;&#123;0&#125;, &#123;13776&#125; &#125;,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct upower_tbl upower_tbl_b_1_FY = &#123;</span><br><span class="line">	.row = &#123;</span><br><span class="line">		&#123;.cap = 211, .volt = 75000, .dyn_pwr = 61732, .lkg_pwr = &#123;71164, 71164, 71164, 71164, 71164, 71164&#125; &#125;,</span><br><span class="line">		&#123;.cap = 268, .volt = 75000, .dyn_pwr = 78352, .lkg_pwr = &#123;71164, 71164, 71164, 71164, 71164, 71164&#125; &#125;,</span><br><span class="line">		&#123;.cap = 317, .volt = 75000, .dyn_pwr = 92598, .lkg_pwr = &#123;71164, 71164, 71164, 71164, 71164, 71164&#125; &#125;,</span><br><span class="line">		&#123;.cap = 358, .volt = 75000, .dyn_pwr = 104469, .lkg_pwr = &#123;71164, 71164, 71164, 71164, 71164, 71164&#125; &#125;,</span><br><span class="line">		&#123;.cap = 406, .volt = 75000, .dyn_pwr = 118715, .lkg_pwr = &#123;71164, 71164, 71164, 71164, 71164, 71164&#125; &#125;,</span><br><span class="line">		&#123;.cap = 447, .volt = 75000, .dyn_pwr = 130587, .lkg_pwr = &#123;71164, 71164, 71164, 71164, 71164, 71164&#125; &#125;,</span><br><span class="line">		&#123;.cap = 504, .volt = 75700, .dyn_pwr = 149968, .lkg_pwr = &#123;72438, 72438, 72438, 72438, 72438, 72438&#125; &#125;,</span><br><span class="line">		&#123;.cap = 561, .volt = 78100, .dyn_pwr = 177650, .lkg_pwr = &#123;76806, 76806, 76806, 76806, 76806, 76806&#125; &#125;,</span><br><span class="line">		&#123;.cap = 634, .volt = 81100, .dyn_pwr = 216546, .lkg_pwr = &#123;82521, 82521, 82521, 82521, 82521, 82521&#125; &#125;,</span><br><span class="line">		&#123;.cap = 691, .volt = 83500, .dyn_pwr = 250153, .lkg_pwr = &#123;87447, 87447, 87447, 87447, 87447, 87447&#125; &#125;,</span><br><span class="line">		&#123;.cap = 748, .volt = 86000, .dyn_pwr = 287210, .lkg_pwr = &#123;92841, 92841, 92841, 92841, 92841, 92841&#125; &#125;,</span><br><span class="line">		&#123;.cap = 805, .volt = 88400, .dyn_pwr = 326553, .lkg_pwr = &#123;98397, 98397, 98397, 98397, 98397, 98397&#125; &#125;,</span><br><span class="line">	&#123;.cap = 861, .volt = 90800, .dyn_pwr = 368886, .lkg_pwr = &#123;104190, 104190, 104190, 104190, 104190, 104190&#125; &#125;,</span><br><span class="line">	&#123;.cap = 918, .volt = 93200, .dyn_pwr = 414309, .lkg_pwr = &#123;110456, 110456, 110456, 110456, 110456, 110456&#125; &#125;,</span><br><span class="line">	&#123;.cap = 959, .volt = 95000, .dyn_pwr = 449514, .lkg_pwr = &#123;115156, 115156, 115156, 115156, 115156, 115156&#125; &#125;,</span><br><span class="line">	&#123;.cap = 1024, .volt = 97400, .dyn_pwr = 504548, .lkg_pwr = &#123;122224, 122224, 122224, 122224, 122224, 122224&#125; &#125;,</span><br><span class="line">	&#125;,</span><br><span class="line">	.lkg_idx = DEFAULT_LKG_IDX,</span><br><span class="line">	.row_num = UPOWER_OPP_NUM,</span><br><span class="line">	.nr_idle_states = NR_UPOWER_CSTATES,</span><br><span class="line">	.idle_states = &#123;</span><br><span class="line">		&#123;&#123;0&#125;, &#123;38992&#125; &#125;,</span><br><span class="line">		&#123;&#123;0&#125;, &#123;38992&#125; &#125;,</span><br><span class="line">		&#123;&#123;0&#125;, &#123;38992&#125; &#125;,</span><br><span class="line">		&#123;&#123;0&#125;, &#123;38992&#125; &#125;,</span><br><span class="line">		&#123;&#123;0&#125;, &#123;38992&#125; &#125;,</span><br><span class="line">		&#123;&#123;0&#125;, &#123;38992&#125; &#125;,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct upower_tbl upower_tbl_cluster_b_1_FY = &#123;</span><br><span class="line">	.row = &#123;</span><br><span class="line">		&#123;.cap = 211, .volt = 75000, .dyn_pwr = 6408, .lkg_pwr = &#123;27561, 27561, 27561, 27561, 27561, 27561&#125; &#125;,</span><br><span class="line">		&#123;.cap = 268, .volt = 75000, .dyn_pwr = 8133, .lkg_pwr = &#123;27561, 27561, 27561, 27561, 27561, 27561&#125; &#125;,</span><br><span class="line">		&#123;.cap = 317, .volt = 75000, .dyn_pwr = 9612, .lkg_pwr = &#123;27561, 27561, 27561, 27561, 27561, 27561&#125; &#125;,</span><br><span class="line">		&#123;.cap = 358, .volt = 75000, .dyn_pwr = 10844, .lkg_pwr = &#123;27561, 27561, 27561, 27561, 27561, 27561&#125; &#125;,</span><br><span class="line">		&#123;.cap = 406, .volt = 75000, .dyn_pwr = 12323, .lkg_pwr = &#123;27561, 27561, 27561, 27561, 27561, 27561&#125; &#125;,</span><br><span class="line">		&#123;.cap = 447, .volt = 75000, .dyn_pwr = 13555, .lkg_pwr = &#123;27561, 27561, 27561, 27561, 27561, 27561&#125; &#125;,</span><br><span class="line">		&#123;.cap = 504, .volt = 75700, .dyn_pwr = 15567, .lkg_pwr = &#123;28054, 28054, 28054, 28054, 28054, 28054&#125; &#125;,</span><br><span class="line">		&#123;.cap = 561, .volt = 78100, .dyn_pwr = 18440, .lkg_pwr = &#123;29746, 29746, 29746, 29746, 29746, 29746&#125; &#125;,</span><br><span class="line">		&#123;.cap = 634, .volt = 81100, .dyn_pwr = 22478, .lkg_pwr = &#123;31959, 31959, 31959, 31959, 31959, 31959&#125; &#125;,</span><br><span class="line">		&#123;.cap = 691, .volt = 83500, .dyn_pwr = 25966, .lkg_pwr = &#123;33867, 33867, 33867, 33867, 33867, 33867&#125; &#125;,</span><br><span class="line">		&#123;.cap = 748, .volt = 86000, .dyn_pwr = 29813, .lkg_pwr = &#123;35956, 35956, 35956, 35956, 35956, 35956&#125; &#125;,</span><br><span class="line">		&#123;.cap = 805, .volt = 88400, .dyn_pwr = 33897, .lkg_pwr = &#123;38108, 38108, 38108, 38108, 38108, 38108&#125; &#125;,</span><br><span class="line">		&#123;.cap = 861, .volt = 90800, .dyn_pwr = 38291, .lkg_pwr = &#123;40351, 40351, 40351, 40351, 40351, 40351&#125; &#125;,</span><br><span class="line">		&#123;.cap = 918, .volt = 93200, .dyn_pwr = 43006, .lkg_pwr = &#123;42778, 42778, 42778, 42778, 42778, 42778&#125; &#125;,</span><br><span class="line">		&#123;.cap = 959, .volt = 95000, .dyn_pwr = 46661, .lkg_pwr = &#123;44598, 44598, 44598, 44598, 44598, 44598&#125; &#125;,</span><br><span class="line">		&#123;.cap = 1024, .volt = 97400, .dyn_pwr = 52373, .lkg_pwr = &#123;47335, 47335, 47335, 47335, 47335, 47335&#125; &#125;,</span><br><span class="line">	&#125;,</span><br><span class="line">	.lkg_idx = DEFAULT_LKG_IDX,</span><br><span class="line">	.row_num = UPOWER_OPP_NUM,</span><br><span class="line">	.nr_idle_states = NR_UPOWER_CSTATES,</span><br><span class="line">	.idle_states = &#123;</span><br><span class="line">		&#123;&#123;0&#125;, &#123;15101&#125; &#125;,</span><br><span class="line">		&#123;&#123;0&#125;, &#123;15101&#125; &#125;,</span><br><span class="line">		&#123;&#123;0&#125;, &#123;15101&#125; &#125;,</span><br><span class="line">		&#123;&#123;0&#125;, &#123;15101&#125; &#125;,</span><br><span class="line">		&#123;&#123;0&#125;, &#123;15101&#125; &#125;,</span><br><span class="line">		&#123;&#123;0&#125;, &#123;15101&#125; &#125;,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct upower_tbl upower_tbl_cci_1_FY = &#123;</span><br><span class="line">	.row = &#123;</span><br><span class="line">		&#123;.cap = 0, .volt = 75000, .dyn_pwr = 2708, .lkg_pwr = &#123;16248, 16248, 16248, 16248, 16248, 16248&#125; &#125;,</span><br><span class="line">		&#123;.cap = 0, .volt = 75000, .dyn_pwr = 3611, .lkg_pwr = &#123;16248, 16248, 16248, 16248, 16248, 16248&#125; &#125;,</span><br><span class="line">		&#123;.cap = 0, .volt = 75000, .dyn_pwr = 4288, .lkg_pwr = &#123;16248, 16248, 16248, 16248, 16248, 16248&#125; &#125;,</span><br><span class="line">		&#123;.cap = 0, .volt = 75000, .dyn_pwr = 5191, .lkg_pwr = &#123;16248, 16248, 16248, 16248, 16248, 16248&#125; &#125;,</span><br><span class="line">		&#123;.cap = 0, .volt = 75000, .dyn_pwr = 5868, .lkg_pwr = &#123;16248, 16248, 16248, 16248, 16248, 16248&#125; &#125;,</span><br><span class="line">		&#123;.cap = 0, .volt = 75000, .dyn_pwr = 6771, .lkg_pwr = &#123;16248, 16248, 16248, 16248, 16248, 16248&#125; &#125;,</span><br><span class="line">		&#123;.cap = 0, .volt = 75700, .dyn_pwr = 7588, .lkg_pwr = &#123;16537, 16537, 16537, 16537, 16537, 16537&#125; &#125;,</span><br><span class="line">		&#123;.cap = 0, .volt = 78100, .dyn_pwr = 8811, .lkg_pwr = &#123;17527, 17527, 17527, 17527, 17527, 17527&#125; &#125;,</span><br><span class="line">		&#123;.cap = 0, .volt = 81100, .dyn_pwr = 10292, .lkg_pwr = &#123;18822, 18822, 18822, 18822, 18822, 18822&#125; &#125;,</span><br><span class="line">		&#123;.cap = 0, .volt = 83500, .dyn_pwr = 11750, .lkg_pwr = &#123;19938, 19938, 19938, 19938, 19938, 19938&#125; &#125;,</span><br><span class="line">		&#123;.cap = 0, .volt = 86000, .dyn_pwr = 13354, .lkg_pwr = &#123;21159, 21159, 21159, 21159, 21159, 21159&#125; &#125;,</span><br><span class="line">		&#123;.cap = 0, .volt = 88400, .dyn_pwr = 14737, .lkg_pwr = &#123;22417, 22417, 22417, 22417, 22417, 22417&#125; &#125;,</span><br><span class="line">		&#123;.cap = 0, .volt = 90800, .dyn_pwr = 16540, .lkg_pwr = &#123;23728, 23728, 23728, 23728, 23728, 23728&#125; &#125;,</span><br><span class="line">		&#123;.cap = 0, .volt = 93200, .dyn_pwr = 18472, .lkg_pwr = &#123;25145, 25145, 25145, 25145, 25145, 25145&#125; &#125;,</span><br><span class="line">		&#123;.cap = 0, .volt = 95000, .dyn_pwr = 19916, .lkg_pwr = &#123;26208, 26208, 26208, 26208, 26208, 26208&#125; &#125;,</span><br><span class="line">		&#123;.cap = 0, .volt = 97400, .dyn_pwr = 22077, .lkg_pwr = &#123;27805, 27805, 27805, 27805, 27805, 27805&#125; &#125;,</span><br><span class="line">	&#125;,</span><br><span class="line">	.lkg_idx = DEFAULT_LKG_IDX,</span><br><span class="line">	.row_num = UPOWER_OPP_NUM,</span><br><span class="line">	.nr_idle_states = NR_UPOWER_CSTATES,</span><br><span class="line">	.idle_states = &#123;</span><br><span class="line">		&#123;&#123;0&#125;, &#123;8938&#125; &#125;,</span><br><span class="line">		&#123;&#123;0&#125;, &#123;8938&#125; &#125;,</span><br><span class="line">		&#123;&#123;0&#125;, &#123;8938&#125; &#125;,</span><br><span class="line">		&#123;&#123;0&#125;, &#123;8938&#125; &#125;,</span><br><span class="line">		&#123;&#123;0&#125;, &#123;8938&#125; &#125;,</span><br><span class="line">		&#123;&#123;0&#125;, &#123;8938&#125; &#125;,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="4-1-2、smp负载均衡的实现"><a href="#4-1-2、smp负载均衡的实现" class="headerlink" title="4.1.2、smp负载均衡的实现"></a>4.1.2、smp负载均衡的实现</h3><p>负载均衡和很多参数相关，下面列出了其中最重要的一些参数：</p>
<html><br><table><br>    <tr><br>        <td style="width: 100px;"> 成员 </td><br>        <td style="width: 100px;"> 所属结构 </td><br>        <td style="width: 100px;"> 含义 </td><br>        <td style="width: 200px;"> 更新/获取函数 </td><br>        <td style="width: 200px;"> 计算方法 </td><br>    </tr><br>    <tr><br>        <td> rq-&gt;cpu_capacity_orig </td><br>        <td> rq </td><br>        <td> 本cpu总的计算能力 </td><br>        <td> init_sched_groups_capacity()/update_sd_lb_stats() -&gt; update_group_capacity() -&gt; update_cpu_capacity() </td><br>        <td> capacity = arch_scale_cpu_capacity(sd, cpu) </td><br>    </tr><br>    <tr><br>        <td> rq-&gt;cpu_capacity </td><br>        <td> rq </td><br>        <td> 本cpu cfs的计算能力 = 总capacity - rt占用的capacity </td><br>        <td> init_sched_groups_capacity()/update_sd_lb_stats() -&gt; update_group_capacity() -&gt; update_cpu_capacity() </td><br>        <td> capacity <em>= scale_rt_capacity(cpu); </em></td><br>    </tr><br>    <tr><br>        <td> rq-&gt;rd-&gt;max_cpu_capacity </td><br>        <td> rq-&gt;rd </td><br>        <td> root_domain中最大的cpu计算能力 </td><br>        <td> init_sched_groups_capacity()/update_sd_lb_stats() -&gt; update_group_capacity() -&gt; update_cpu_capacity() </td><br>        <td>  </td><br>    </tr><br>    <tr><br>        <td> rq-&gt;rd-&gt;overutilized </td><br>        <td> rq-&gt;rd </td><br>        <td>  </td><br>        <td> update_sd_lb_stats() </td><br>        <td>  </td><br>    </tr><br>    <tr><br>        <td> rq-&gt;rd-&gt;overload </td><br>        <td> rq-&gt;rd </td><br>        <td>  </td><br>        <td> update_sd_lb_stats() </td><br>        <td>  </td><br>    </tr><br>    <tr><br>        <td> rq-&gt;rt_avg </td><br>        <td> rq </td><br>        <td> 本cpu的rt平均负载 </td><br>        <td> weighted_cpuload() -&gt; cfs_rq_runnable_load_avg() </td><br>        <td>  </td><br>    </tr><br>    <tr><br>        <td> rq-&gt;cfs.runnable_load_avg </td><br>        <td> rq-&gt;cfs(cfs_rq) </td><br>        <td> 本cpu cfs_rq的runable平均负载 </td><br>        <td> __update_load_avg()、cfs_rq_load_avg() </td><br>        <td> (runnable时间freq<em>weight)/LOAD_AVG_MAX </em></td><br>    </tr><br>    <tr><br>        <td> rq-&gt;cfs.avg.load_avg </td><br>        <td> rq-&gt;cfs.avg </td><br>        <td> 本cpu cfs_rq的runnable平均负载 </td><br>        <td> __update_load_avg() </td><br>        <td> (runnable时间freq<em>weight)/LOAD_AVG_MAX </em></td><br>    </tr><br>    <tr><br>        <td> rq-&gt;cfs.avg.loadwop_avg </td><br>        <td> rq-&gt;cfs.avg </td><br>        <td> 本cpu cfs_rq的runnable平均负载，不含weight </td><br>        <td> __update_load_avg() </td><br>        <td> (runnable时间freq)/LOAD_AVG_MAX </td><br>    </tr><br>    <tr><br>        <td> rq-&gt;cfs.avg.util_avg </td><br>        <td> rq-&gt;cfs.avg </td><br>        <td> 本cpu cfs_rq的running负载 </td><br>        <td> <strong>update_load_avg()、cpu_util() -&gt; </strong>cpu_util() </td><br>        <td> (running时间<em>freq</em>capacity)/LOAD_AVG_MAX </td><br>    </tr><br>    <tr><br>        <td> cfs_rq-&gt;nr_running </td><br>        <td> cfs_rq </td><br>        <td> 本cfs_rq这个层次runnable的se的数量 </td><br>        <td> enqueue_entity()/dequeue_entity() -&gt; account_entity_enqueue() </td><br>        <td>  </td><br>    </tr><br>    <tr><br>        <td> cfs_rq-&gt;h_nr_running </td><br>        <td> cfs_rq </td><br>        <td> 本cfs_rq包含所有子cfs_rq nr_running的总和 </td><br>        <td> enqueue_task_fair()/dequeue_task_fair </td><br>        <td>  </td><br>    </tr><br>    <tr><br>        <td> rq-&gt;nr_running </td><br>        <td> rq </td><br>        <td> 本cpu rq所有runnable的se的数量，包含所有子cfs_rq </td><br>        <td> enqueue_task_fair()/dequeue_task_fair -&gt; add_nr_running() </td><br>        <td>  </td><br>    </tr><br>    <tr><br>        <td>  </td><br>        <td>  </td><br>        <td>  </td><br>        <td>  </td><br>        <td>  </td><br>    </tr><br>    <tr><br>        <td>  </td><br>        <td>  </td><br>        <td>  </td><br>        <td>  </td><br>        <td>  </td><br>    </tr><br>    <tr><br>        <td>  </td><br>        <td>  </td><br>        <td>  </td><br>        <td>  </td><br>        <td>  </td><br>    </tr><br></table><br></html>

<h4 id="4-1-2-1、rebalance-domains"><a href="#4-1-2-1、rebalance-domains" class="headerlink" title="4.1.2.1、rebalance_domains()"></a>4.1.2.1、rebalance_domains()</h4><blockquote>
<p>mtk对定义了3种power模式来兼容EAS的：EAS模式(energy_aware())、HMP模式(sched_feat(SCHED_HMP))、hybrid_support(EAS、HMP同时共存)；</p>
</blockquote>
<blockquote>
<p>hybrid_support()模式下：一般负载均衡交给EAS；如果cpu_rq(cpu)-&gt;rd-&gt;overutilized负载已经严重不均衡，交给HMP；</p>
</blockquote>
<p>系统在scheduler_tick()中会定期的检测smp负载均衡的时间是否已到，如果到时触发SCHED_SOFTIRQ软中断：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">void scheduler_tick(void)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_SMP</span><br><span class="line">	rq-&gt;idle_balance = idle_cpu(cpu);</span><br><span class="line">	trigger_load_balance(rq);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Trigger the SCHED_SOFTIRQ if it is time to do periodic load balancing.</span><br><span class="line"> */</span><br><span class="line">void trigger_load_balance(struct rq *rq)</span><br><span class="line">&#123;</span><br><span class="line">	/* Don&apos;t need to rebalance while attached to NULL domain */</span><br><span class="line">	if (unlikely(on_null_domain(rq)))</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	if (time_after_eq(jiffies, rq-&gt;next_balance))</span><br><span class="line">		raise_softirq(SCHED_SOFTIRQ);</span><br><span class="line">#ifdef CONFIG_NO_HZ_COMMON</span><br><span class="line">	if (nohz_kick_needed(rq))</span><br><span class="line">		nohz_balancer_kick();</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SCHED_SOFTIRQ软中断的执行主体为run_rebalance_domains：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">__init void init_sched_fair_class(void)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	open_softirq(SCHED_SOFTIRQ, run_rebalance_domains);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * run_rebalance_domains is triggered when needed from the scheduler tick.</span><br><span class="line"> * Also triggered for nohz idle balancing (with nohz_balancing_kick set).</span><br><span class="line"> */</span><br><span class="line">static void run_rebalance_domains(struct softirq_action *h)</span><br><span class="line">&#123;</span><br><span class="line">	struct rq *this_rq = this_rq();</span><br><span class="line">	enum cpu_idle_type idle = this_rq-&gt;idle_balance ?</span><br><span class="line">						CPU_IDLE : CPU_NOT_IDLE;</span><br><span class="line">	int this_cpu = smp_processor_id();</span><br><span class="line"></span><br><span class="line">	/* bypass load balance of HMP if EAS consideration */</span><br><span class="line">	if ((!energy_aware() &amp;&amp; sched_feat(SCHED_HMP)) ||</span><br><span class="line">			(hybrid_support() &amp;&amp; cpu_rq(this_cpu)-&gt;rd-&gt;overutilized))</span><br><span class="line">		hmp_force_up_migration(this_cpu);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * If this cpu has a pending nohz_balance_kick, then do the</span><br><span class="line">	 * balancing on behalf of the other idle cpus whose ticks are</span><br><span class="line">	 * stopped. Do nohz_idle_balance *before* rebalance_domains to</span><br><span class="line">	 * give the idle cpus a chance to load balance. Else we may</span><br><span class="line">	 * load balance only within the local sched_domain hierarchy</span><br><span class="line">	 * and abort nohz_idle_balance altogether if we pull some load.</span><br><span class="line">	 */</span><br><span class="line">	nohz_idle_balance(this_rq, idle);</span><br><span class="line">	rebalance_domains(this_rq, idle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们分析最核心的函数rebalance_domains()：</p>
<p><strong><em>需要重点提一下的是</em></strong>：负载计算计算了3种负载(load_avg、loadwop_avg、util_avg)，rebalance_domains主要使用其中的<strong><em>load_avg</em></strong>，乘(SCHED_CAPACITY_SCALE/capacity)加以转换。</p>
<ul>
<li>1、逐级轮询本cpu的sd，判断本sd的时间间隔是否到期，如果到期做load_balance()；</li>
</ul>
<table>
<thead>
<tr>
<th>tl层级</th>
<th>cpu_busy?</th>
<th>sd-&gt;balance_interval</th>
<th>sd-&gt;busy_factor</th>
<th>sd balance interval</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>MC层级 | idle | 4 |1 | 4ms<br>MC层级 | busy | 4 | 32 | 128ms<br>DIE层级 | idle | 8 |1 | 8ms<br>DIE层级 | busy | 8 | 32 | 256ms<br>| | |  |  | rq-&gt;next_balance = min(上述值)</p>
<ul>
<li><p>2、在load_balance()中判断在本层级sd本cpu的当前情况是否适合充当dst_cpu，在should_we_balance()做各种判断，做dst_cpu的条件有：要么是本sg的第一个idle cpu，要么是本sg的第一个cpu。dst_cpu是作为目的cpu让负载高的cpu迁移进程过来，如果本cpu不符合条件中断操作；</p>
</li>
<li><p>3、继续find_busiest_group()，在sg链表中找出负载最重的sg。核心计算在update_sd_lb_stats()、update_sg_lb_stats()中。如果dst_cpu所在的local_group负载大于busiest sg，或者大于sds平均负载，中断操作；如果成功计算需要迁移的负载env-&gt;imbalance，为min((sds-&gt;avg - local), (busiest - sds-&gt;avg))；</p>
</li>
</ul>
<p><img src="/images/scheduler/schedule_rebalance_domains_find_busiest_group.png" alt="schedule_rebalance_domains_find_busiest_group"></p>
<ul>
<li>3.1、根据当前cpu的idle状态计算cpu load(rq-&gt;cpu_load[])时选用的index值：</li>
</ul>
<table>
<thead>
<tr>
<th>tl层级</th>
<th>busy_idx</th>
<th>idle_idx</th>
<th>newidle_idx</th>
</tr>
</thead>
<tbody>
<tr>
<td>MC层级</td>
<td>2</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>DIE层级</td>
<td>2</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<ul>
<li>3.2、计算sg负载sgs，选择sgs-&gt;avg_load最大的sg作为busiest_group。其中几个关键值的计算如下：</li>
</ul>
<table>
<thead>
<tr>
<th>负载值</th>
<th>计算方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>sgs-&gt;group_load</td>
<td>+= cpu_rq(cpu)-&gt;cpu_load[index-1]</td>
<td>累加cpu的load值，相对值(每个cpu的最大值都是1024)，且带weight分量</td>
<td></td>
</tr>
<tr>
<td>sgs-&gt;group_util</td>
<td>+= cpu_rq(cpu)-&gt;cfs.avg.util_avg</td>
<td>累加cpu cfs running值，绝对值(不同cluster，只有最大capacity能力的cpu最大值为1024)</td>
<td></td>
</tr>
<tr>
<td>sgs-&gt;group_capacity</td>
<td>+= (arch_scale_cpu_capacity(sd, cpu)*(1-rt_capacity))</td>
<td>累加cpu的capacity，绝对值(不同cluster，只有最大capacity能力的cpu最大值为1024)</td>
<td></td>
</tr>
<tr>
<td>sgs-&gt;avg_load</td>
<td>= (sgs-&gt;group_load*SCHED_CAPACITY_SCALE) / sgs-&gt;group_capacity</td>
<td>group_load做了转换，和group_capacity成反比</td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>3.3、在计算sg负载时，几个关键状态的计算如下：</li>
</ul>
<table>
<thead>
<tr>
<th>状态值</th>
<th>计算方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>sgs-&gt;group_no_capacity</td>
<td>(sgs-&gt;group_capacity <em> 100) &lt; (sgs-&gt;group_util </em> env-&gt;sd-&gt;imbalance_pct)</td>
<td>预留一定空间(比例为imbalance_pct)，sg运算能力已经不够了，sgs-&gt;group_type=group_overloaded</td>
<td></td>
</tr>
<tr>
<td>dst_rq-&gt;rd-&gt;overutilized</td>
<td>(capacity_of(cpu) <em> 1024) &lt; (cpu_util(cpu) </em> capacity_margin)</td>
<td>预留一定空间(比例为capacity_margin)，sg运算能力已经不够了</td>
<td></td>
</tr>
<tr>
<td>dst_rq-&gt;rd-&gt;overload</td>
<td>rq-&gt;nr_running &gt; 1</td>
<td>sg中任何一个cpu的runnable进程大于1</td>
<td></td>
</tr>
</tbody>
</table>
<p>比例参数imbalance_pct、capacity_margin的值为：</p>
<table>
<thead>
<tr>
<th>tl层级</th>
<th>sd-&gt;imbalance_pct (/100)</th>
<th>capacity_margin (/1024)</th>
</tr>
</thead>
<tbody>
<tr>
<td>MC层级</td>
<td>117</td>
<td>1280</td>
<td></td>
</tr>
<tr>
<td>DIE层级</td>
<td>125</td>
<td>1280</td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>3.4、计算env-&gt;imbalance，这个是rebalance需要迁移的负载量：</li>
</ul>
<table>
<thead>
<tr>
<th>负载值</th>
<th>计算方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>sds-&gt;total_load</td>
<td>+= sgs-&gt;group_load</td>
<td>—</td>
<td></td>
</tr>
<tr>
<td>sds-&gt;total_capacity</td>
<td>+= sgs-&gt;group_capacity</td>
<td>—</td>
<td></td>
</tr>
<tr>
<td>sds.avg_load</td>
<td>(SCHED_CAPACITY_SCALE * sds.total_load)/ sds.total_capacity</td>
<td>—</td>
<td></td>
</tr>
<tr>
<td>env-&gt;imbalance</td>
<td>min((busiest-&gt;avg_load - sds-&gt;avg_load)<em>busiest-&gt;group_capacity, (sds-&gt;avg_load - local-&gt;avg_load)</em>local-&gt;group_capacity) / SCHED_CAPACITY_SCALE)</td>
<td>感觉这里计算有bug啊，前面是1024/capcity，后面是capacity/1024，很混乱</td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>4、继续find_busiest_queue()，查找busiest sg中负载最重的cpu。</li>
</ul>
<p><img src="/images/scheduler/schedule_rebalance_domains_find_busiest_queue.png" alt="schedule_rebalance_domains_find_busiest_queue"></p>
<ul>
<li>4.1、找出sg中weighted_cpuload*capacity_of值最大的cpu：</li>
</ul>
<table>
<thead>
<tr>
<th>负载值</th>
<th>计算方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>weighted_cpuload(cpu)</td>
<td>cpu_rq(cpu)-&gt;cfs-&gt;runnable_load_avg</td>
<td>cpu的load值，相对值(每个cpu的最大值都是1024)，且带weight分量</td>
<td></td>
</tr>
<tr>
<td>capacity_of(cpu)</td>
<td>arch_scale_cpu_capacity(sd, cpu)*(1-rt_capacity)</td>
<td>cpu cfs running值，绝对值(不同cluster，只有最大capacity能力的cpu最大值为1024)</td>
<td></td>
</tr>
<tr>
<td>weighted_cpuload(cpu)*capacity_of(cpu)</td>
<td>—</td>
<td>最大值为busiest sg中busiest cpu rq</td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>5、迁移busiest cpu的负载到本地dst cpu上，迁移的负载额度为env-&gt;imbalance：detach_tasks() -&gt; attach_tasks()；</li>
</ul>
<ul>
<li>6、处理几种因为进程亲和力问题，busiest cpu不能迁移走足够的进程：LBF_DST_PINNED尝试更改dst_cpu为本地cpu相同sg的其他cpu；LBF_SOME_PINNED当前不能均衡尝试让父sd均衡；LBF_ALL_PINNED一个进程都不能迁移尝试去掉dst_cpu重新进行load_balance()；</li>
</ul>
<ul>
<li>7、如果经过各种尝试后还是没有一个进程迁移成功，最后尝试一次active_balance;</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br><span class="line">1093</span><br><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br><span class="line">1097</span><br><span class="line">1098</span><br><span class="line">1099</span><br><span class="line">1100</span><br><span class="line">1101</span><br><span class="line">1102</span><br><span class="line">1103</span><br><span class="line">1104</span><br><span class="line">1105</span><br><span class="line">1106</span><br><span class="line">1107</span><br><span class="line">1108</span><br><span class="line">1109</span><br><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">1112</span><br><span class="line">1113</span><br><span class="line">1114</span><br><span class="line">1115</span><br><span class="line">1116</span><br><span class="line">1117</span><br><span class="line">1118</span><br><span class="line">1119</span><br><span class="line">1120</span><br><span class="line">1121</span><br><span class="line">1122</span><br><span class="line">1123</span><br><span class="line">1124</span><br><span class="line">1125</span><br><span class="line">1126</span><br><span class="line">1127</span><br><span class="line">1128</span><br><span class="line">1129</span><br><span class="line">1130</span><br><span class="line">1131</span><br><span class="line">1132</span><br><span class="line">1133</span><br><span class="line">1134</span><br><span class="line">1135</span><br><span class="line">1136</span><br><span class="line">1137</span><br><span class="line">1138</span><br><span class="line">1139</span><br><span class="line">1140</span><br><span class="line">1141</span><br><span class="line">1142</span><br><span class="line">1143</span><br><span class="line">1144</span><br><span class="line">1145</span><br><span class="line">1146</span><br><span class="line">1147</span><br><span class="line">1148</span><br><span class="line">1149</span><br><span class="line">1150</span><br><span class="line">1151</span><br><span class="line">1152</span><br><span class="line">1153</span><br><span class="line">1154</span><br><span class="line">1155</span><br><span class="line">1156</span><br><span class="line">1157</span><br><span class="line">1158</span><br><span class="line">1159</span><br><span class="line">1160</span><br><span class="line">1161</span><br><span class="line">1162</span><br><span class="line">1163</span><br><span class="line">1164</span><br><span class="line">1165</span><br><span class="line">1166</span><br><span class="line">1167</span><br><span class="line">1168</span><br><span class="line">1169</span><br><span class="line">1170</span><br><span class="line">1171</span><br><span class="line">1172</span><br><span class="line">1173</span><br><span class="line">1174</span><br><span class="line">1175</span><br><span class="line">1176</span><br><span class="line">1177</span><br><span class="line">1178</span><br><span class="line">1179</span><br><span class="line">1180</span><br><span class="line">1181</span><br><span class="line">1182</span><br><span class="line">1183</span><br><span class="line">1184</span><br><span class="line">1185</span><br><span class="line">1186</span><br><span class="line">1187</span><br><span class="line">1188</span><br><span class="line">1189</span><br><span class="line">1190</span><br><span class="line">1191</span><br><span class="line">1192</span><br><span class="line">1193</span><br><span class="line">1194</span><br><span class="line">1195</span><br><span class="line">1196</span><br><span class="line">1197</span><br><span class="line">1198</span><br><span class="line">1199</span><br><span class="line">1200</span><br><span class="line">1201</span><br><span class="line">1202</span><br><span class="line">1203</span><br><span class="line">1204</span><br><span class="line">1205</span><br><span class="line">1206</span><br><span class="line">1207</span><br><span class="line">1208</span><br><span class="line">1209</span><br><span class="line">1210</span><br><span class="line">1211</span><br><span class="line">1212</span><br><span class="line">1213</span><br><span class="line">1214</span><br><span class="line">1215</span><br><span class="line">1216</span><br><span class="line">1217</span><br><span class="line">1218</span><br><span class="line">1219</span><br><span class="line">1220</span><br><span class="line">1221</span><br><span class="line">1222</span><br><span class="line">1223</span><br><span class="line">1224</span><br><span class="line">1225</span><br><span class="line">1226</span><br><span class="line">1227</span><br><span class="line">1228</span><br><span class="line">1229</span><br><span class="line">1230</span><br><span class="line">1231</span><br><span class="line">1232</span><br><span class="line">1233</span><br><span class="line">1234</span><br><span class="line">1235</span><br><span class="line">1236</span><br><span class="line">1237</span><br><span class="line">1238</span><br><span class="line">1239</span><br><span class="line">1240</span><br><span class="line">1241</span><br><span class="line">1242</span><br><span class="line">1243</span><br><span class="line">1244</span><br><span class="line">1245</span><br><span class="line">1246</span><br><span class="line">1247</span><br><span class="line">1248</span><br><span class="line">1249</span><br><span class="line">1250</span><br><span class="line">1251</span><br><span class="line">1252</span><br><span class="line">1253</span><br><span class="line">1254</span><br><span class="line">1255</span><br><span class="line">1256</span><br><span class="line">1257</span><br><span class="line">1258</span><br><span class="line">1259</span><br><span class="line">1260</span><br><span class="line">1261</span><br><span class="line">1262</span><br><span class="line">1263</span><br><span class="line">1264</span><br><span class="line">1265</span><br><span class="line">1266</span><br><span class="line">1267</span><br><span class="line">1268</span><br><span class="line">1269</span><br><span class="line">1270</span><br><span class="line">1271</span><br><span class="line">1272</span><br><span class="line">1273</span><br><span class="line">1274</span><br><span class="line">1275</span><br><span class="line">1276</span><br><span class="line">1277</span><br><span class="line">1278</span><br><span class="line">1279</span><br><span class="line">1280</span><br><span class="line">1281</span><br><span class="line">1282</span><br><span class="line">1283</span><br><span class="line">1284</span><br><span class="line">1285</span><br><span class="line">1286</span><br><span class="line">1287</span><br><span class="line">1288</span><br><span class="line">1289</span><br><span class="line">1290</span><br><span class="line">1291</span><br><span class="line">1292</span><br><span class="line">1293</span><br><span class="line">1294</span><br><span class="line">1295</span><br><span class="line">1296</span><br><span class="line">1297</span><br><span class="line">1298</span><br><span class="line">1299</span><br><span class="line">1300</span><br><span class="line">1301</span><br><span class="line">1302</span><br><span class="line">1303</span><br><span class="line">1304</span><br><span class="line">1305</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * It checks each scheduling domain to see if it is due to be balanced,</span><br><span class="line"> * and initiates a balancing operation if so.</span><br><span class="line"> *</span><br><span class="line"> * Balancing parameters are set up in init_sched_domains.</span><br><span class="line"> * Balance的参数是在sched_domains初始化时设置的</span><br><span class="line"> */</span><br><span class="line">static void rebalance_domains(struct rq *rq, enum cpu_idle_type idle)</span><br><span class="line">&#123;</span><br><span class="line">	int continue_balancing = 1;</span><br><span class="line">	int cpu = rq-&gt;cpu;</span><br><span class="line">	unsigned long interval;</span><br><span class="line">	struct sched_domain *sd;</span><br><span class="line">	/* 默认本cpu rq下一次的balance时间为60s以后 */</span><br><span class="line">	/* Earliest time when we have to do rebalance again */</span><br><span class="line">	unsigned long next_balance = jiffies + 60*HZ;</span><br><span class="line">	int update_next_balance = 0;</span><br><span class="line">	int need_serialize, need_decay = 0;</span><br><span class="line">	u64 max_cost = 0;</span><br><span class="line"></span><br><span class="line">    /* (1) 更新cpu rq中所有cfs_rq的最新负载 */</span><br><span class="line">	update_blocked_averages(cpu);</span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	/* (2) 对本cpu每个层次的schedule_domain进行扫描 */</span><br><span class="line">	for_each_domain(cpu, sd) &#123;</span><br><span class="line">	</span><br><span class="line">	    /* (3) 以1HZ的频率对sd-&gt;max_newidle_lb_cost进行老化，</span><br><span class="line">		    老化公式： new = old * (253/256)</span><br><span class="line">		 */</span><br><span class="line">		/*</span><br><span class="line">		 * Decay the newidle max times here because this is a regular</span><br><span class="line">		 * visit to all the domains. Decay ~1% per second.</span><br><span class="line">		 */</span><br><span class="line">		if (time_after(jiffies, sd-&gt;next_decay_max_lb_cost)) &#123;</span><br><span class="line">			sd-&gt;max_newidle_lb_cost =</span><br><span class="line">				(sd-&gt;max_newidle_lb_cost * 253) / 256;</span><br><span class="line">			sd-&gt;next_decay_max_lb_cost = jiffies + HZ;</span><br><span class="line">			need_decay = 1;</span><br><span class="line">		&#125;</span><br><span class="line">		max_cost += sd-&gt;max_newidle_lb_cost;</span><br><span class="line"></span><br><span class="line">		if (!(sd-&gt;flags &amp; SD_LOAD_BALANCE))</span><br><span class="line">			continue;</span><br><span class="line"></span><br><span class="line">#ifndef CONFIG_MTK_LOAD_BALANCE_ENHANCEMENT</span><br><span class="line">		/* nohz CPU need GTS balance to migrate tasks for more than 2 clusters*/</span><br><span class="line">		/* Don&apos;t consider GTS balance if hybrid support */</span><br><span class="line">		if (hybrid_support()) &#123;</span><br><span class="line">			if (sd-&gt;child || (!sd-&gt;child &amp;&amp;</span><br><span class="line">				(rcu_dereference(per_cpu(sd_scs, cpu)) == NULL)))</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">        /* (4) 如果continue_balancing = 0，指示停止当前层级的load balance</span><br><span class="line">            因为shed_group中其他的cpu正在这个层次做load_balance</span><br><span class="line">         */</span><br><span class="line">		/*</span><br><span class="line">		 * Stop the load balance at this level. There is another</span><br><span class="line">		 * CPU in our sched group which is doing load balancing more</span><br><span class="line">		 * actively.</span><br><span class="line">		 */</span><br><span class="line">		if (!continue_balancing) &#123;</span><br><span class="line">			if (need_decay)</span><br><span class="line">				continue;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        /* (5) 计算当前层次schedule_domain的balance间隔时间 */</span><br><span class="line">		interval = get_sd_balance_interval(sd, idle != CPU_IDLE);</span><br><span class="line"></span><br><span class="line">        /* (6) 如果需要串行化(SD_SERIALIZE)，做balance之前需要持锁 */</span><br><span class="line">		need_serialize = sd-&gt;flags &amp; SD_SERIALIZE;</span><br><span class="line">		if (need_serialize) &#123;</span><br><span class="line">			if (!spin_trylock(&amp;balancing))</span><br><span class="line">				goto out;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        /* (7) 如果本sd的balance间隔时间已到，进行实际的load_balance() */</span><br><span class="line">		if (time_after_eq(jiffies, sd-&gt;last_balance + interval)) &#123;</span><br><span class="line">			if (load_balance(cpu, rq, sd, idle, &amp;continue_balancing)) &#123;</span><br><span class="line">				/*</span><br><span class="line">				 * The LBF_DST_PINNED logic could have changed</span><br><span class="line">				 * env-&gt;dst_cpu, so we can&apos;t know our idle</span><br><span class="line">				 * state even if we migrated tasks. Update it.</span><br><span class="line">				 */</span><br><span class="line">				idle = idle_cpu(cpu) ? CPU_IDLE : CPU_NOT_IDLE;</span><br><span class="line">			&#125;</span><br><span class="line">			sd-&gt;last_balance = jiffies;</span><br><span class="line">			interval = get_sd_balance_interval(sd, idle != CPU_IDLE);</span><br><span class="line">		&#125;</span><br><span class="line">		if (need_serialize)</span><br><span class="line">			spin_unlock(&amp;balancing);</span><br><span class="line">out:</span><br><span class="line">        /* (8) 如果sd下一次balance时间在，rq的balance时间之前，需要更新rq的balance时间</span><br><span class="line">            rq的下一次balance时间：next_balance  (默认是60s后)</span><br><span class="line">            本sd的下一次balance时间：sd-&gt;last_balance + interval</span><br><span class="line">            rq的下一次balance时间需要选取多个sd中时间最近的一个</span><br><span class="line">         */</span><br><span class="line">		if (time_after(next_balance, sd-&gt;last_balance + interval)) &#123;</span><br><span class="line">			next_balance = sd-&gt;last_balance + interval;</span><br><span class="line">			update_next_balance = 1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if (need_decay) &#123;</span><br><span class="line">		/*</span><br><span class="line">		 * Ensure the rq-wide value also decays but keep it at a</span><br><span class="line">		 * reasonable floor to avoid funnies with rq-&gt;avg_idle.</span><br><span class="line">		 */</span><br><span class="line">		rq-&gt;max_idle_balance_cost =</span><br><span class="line">			max((u64)sysctl_sched_migration_cost, max_cost);</span><br><span class="line">	&#125;</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">    /* (8.1) 更新rq的balance时间 */</span><br><span class="line">	/*</span><br><span class="line">	 * next_balance will be updated only when there is a need.</span><br><span class="line">	 * When the cpu is attached to null domain for ex, it will not be</span><br><span class="line">	 * updated.</span><br><span class="line">	 */</span><br><span class="line">	if (likely(update_next_balance)) &#123;</span><br><span class="line">		rq-&gt;next_balance = next_balance;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_NO_HZ_COMMON</span><br><span class="line">		/*</span><br><span class="line">		 * If this CPU has been elected to perform the nohz idle</span><br><span class="line">		 * balance. Other idle CPUs have already rebalanced with</span><br><span class="line">		 * nohz_idle_balance() and nohz.next_balance has been</span><br><span class="line">		 * updated accordingly. This CPU is now running the idle load</span><br><span class="line">		 * balance for itself and we need to update the</span><br><span class="line">		 * nohz.next_balance accordingly.</span><br><span class="line">		 */</span><br><span class="line">		if ((idle == CPU_IDLE) &amp;&amp; time_after(nohz.next_balance, rq-&gt;next_balance))</span><br><span class="line">			nohz.next_balance = rq-&gt;next_balance;</span><br><span class="line">#endif</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">static int load_balance(int this_cpu, struct rq *this_rq,</span><br><span class="line">			struct sched_domain *sd, enum cpu_idle_type idle,</span><br><span class="line">			int *continue_balancing)</span><br><span class="line">&#123;</span><br><span class="line">	int ld_moved, cur_ld_moved, active_balance = 0;</span><br><span class="line">	struct sched_domain *sd_parent = sd-&gt;parent;</span><br><span class="line">	struct sched_group *group;</span><br><span class="line">	struct rq *busiest;</span><br><span class="line">	unsigned long flags;</span><br><span class="line">	struct cpumask *cpus = this_cpu_cpumask_var_ptr(load_balance_mask);</span><br><span class="line"></span><br><span class="line">    /* (7.1) 构造Load_balance需要的数据结构：</span><br><span class="line">        .sd		= sd,   //本cpu在本tl层次的sd</span><br><span class="line">        .dst_cpu	= this_cpu,   // 目的cpu是本cpu</span><br><span class="line">		.dst_rq		= this_rq,    // 目的rq是本cpu的rq</span><br><span class="line">		</span><br><span class="line">		// load_balance的目的是找出负载最重的cpu，并将一部分负载迁移到本cpu上</span><br><span class="line">     */</span><br><span class="line">	struct lb_env env = &#123;</span><br><span class="line">		.sd		= sd,</span><br><span class="line">		.dst_cpu	= this_cpu,</span><br><span class="line">		.dst_rq		= this_rq,</span><br><span class="line">		.dst_grpmask    = sched_group_cpus(sd-&gt;groups),</span><br><span class="line">		.idle		= idle,</span><br><span class="line">		.loop_break	= sched_nr_migrate_break,</span><br><span class="line">		.cpus		= cpus,</span><br><span class="line">		.fbq_type	= all,</span><br><span class="line">		.tasks		= LIST_HEAD_INIT(env.tasks),</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * For NEWLY_IDLE load_balancing, we don&apos;t need to consider</span><br><span class="line">	 * other cpus in our group</span><br><span class="line">	 */</span><br><span class="line">	if (idle == CPU_NEWLY_IDLE)</span><br><span class="line">		env.dst_grpmask = NULL;</span><br><span class="line"></span><br><span class="line">	cpumask_copy(cpus, cpu_active_mask);</span><br><span class="line"></span><br><span class="line">	schedstat_inc(sd, lb_count[idle]);</span><br><span class="line"></span><br><span class="line">redo:</span><br><span class="line">    /* (7.2) check当前cpu是否适合作为dst_cpu(即light cpu，需要分担其他cpu的负载) */</span><br><span class="line">	if (!should_we_balance(&amp;env)) &#123;</span><br><span class="line">		*continue_balancing = 0;</span><br><span class="line">		goto out_balanced;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (7.3) 找出本层级sched_group链表中，负载最重的(busiest)的sched_group */</span><br><span class="line">	group = find_busiest_group(&amp;env);</span><br><span class="line">	if (!group) &#123;</span><br><span class="line">		schedstat_inc(sd, lb_nobusyg[idle]);</span><br><span class="line">		goto out_balanced;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (7.4) 找出busiest sched_group中sched_group的rq，即负载最重cpu对应的rq */</span><br><span class="line">	busiest = find_busiest_queue(&amp;env, group);</span><br><span class="line">	if (!busiest) &#123;</span><br><span class="line">		schedstat_inc(sd, lb_nobusyq[idle]);</span><br><span class="line">		goto out_balanced;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	BUG_ON(busiest == env.dst_rq);</span><br><span class="line"></span><br><span class="line">	schedstat_add(sd, lb_imbalance[idle], env.imbalance);</span><br><span class="line"></span><br><span class="line">	env.src_cpu = busiest-&gt;cpu;</span><br><span class="line">	env.src_rq = busiest;</span><br><span class="line"></span><br><span class="line">	ld_moved = 0;</span><br><span class="line">	/* (7.5) 判断busiest cpu rq中的runnable进程数 &gt; 1？</span><br><span class="line">	    至少有进程可以迁移走</span><br><span class="line">	 */</span><br><span class="line">	if (busiest-&gt;nr_running &gt; 1) &#123;</span><br><span class="line">		/*</span><br><span class="line">		 * Attempt to move tasks. If find_busiest_group has found</span><br><span class="line">		 * an imbalance but busiest-&gt;nr_running &lt;= 1, the group is</span><br><span class="line">		 * still unbalanced. ld_moved simply stays zero, so it is</span><br><span class="line">		 * correctly treated as an imbalance.</span><br><span class="line">		 */</span><br><span class="line">		env.flags |= LBF_ALL_PINNED;</span><br><span class="line">		env.loop_max  = min(sysctl_sched_nr_migrate, busiest-&gt;nr_running);</span><br><span class="line"></span><br><span class="line">more_balance:</span><br><span class="line">		raw_spin_lock_irqsave(&amp;busiest-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">        /* (7.6) 从busiest rq中detach进程， </span><br><span class="line">            env-&gt;imbalance：需要迁移的负载大小</span><br><span class="line">            cur_ld_moved：实际迁移的进程数</span><br><span class="line">         */</span><br><span class="line">		/*</span><br><span class="line">		 * cur_ld_moved - load moved in current iteration</span><br><span class="line">		 * ld_moved     - cumulative load moved across iterations</span><br><span class="line">		 */</span><br><span class="line">		cur_ld_moved = detach_tasks(&amp;env);</span><br><span class="line">		</span><br><span class="line">		/* (7.7) busiest cpu负载减轻后，</span><br><span class="line">		    在sched_freq中判断cpu频率是否可以调低</span><br><span class="line">		 */</span><br><span class="line">		/*</span><br><span class="line">		 * We want to potentially lower env.src_cpu&apos;s OPP.</span><br><span class="line">		 */</span><br><span class="line">		if (cur_ld_moved)</span><br><span class="line">			update_capacity_of(env.src_cpu, SCHE_ONESHOT);</span><br><span class="line"></span><br><span class="line">		/*</span><br><span class="line">		 * We&apos;ve detached some tasks from busiest_rq. Every</span><br><span class="line">		 * task is masked &quot;TASK_ON_RQ_MIGRATING&quot;, so we can safely</span><br><span class="line">		 * unlock busiest-&gt;lock, and we are able to be sure</span><br><span class="line">		 * that nobody can manipulate the tasks in parallel.</span><br><span class="line">		 * See task_rq_lock() family for the details.</span><br><span class="line">		 */</span><br><span class="line"></span><br><span class="line">		raw_spin_unlock(&amp;busiest-&gt;lock);</span><br><span class="line"></span><br><span class="line">        /* (7.8) 把迁移过来的任务attack到dest_cpu上 */</span><br><span class="line">		if (cur_ld_moved) &#123;</span><br><span class="line">			attach_tasks(&amp;env);</span><br><span class="line">			ld_moved += cur_ld_moved;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		local_irq_restore(flags);</span><br><span class="line"></span><br><span class="line">        /* (7.9) LBF_NEED_BREAK设置，说明balance还没有完成，循环只是出来休息一下，</span><br><span class="line">            继续重新balance</span><br><span class="line">         */</span><br><span class="line">		if (env.flags &amp; LBF_NEED_BREAK) &#123;</span><br><span class="line">			env.flags &amp;= ~LBF_NEED_BREAK;</span><br><span class="line">			goto more_balance;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        /* (7.10) 设置了LBF_DST_PINNED标志，并且env.imbalance &gt; 0</span><br><span class="line">            说明src_cpu上有些进程因为affinity的原因不能迁移到dst_cpu但是能迁移到同sg的new_dst_cpu上</span><br><span class="line">            把dst_cpu更改为new_dst_cpu，重新开始balance流程</span><br><span class="line">         */</span><br><span class="line">		/*</span><br><span class="line">		 * Revisit (affine) tasks on src_cpu that couldn&apos;t be moved to</span><br><span class="line">		 * us and move them to an alternate dst_cpu in our sched_group</span><br><span class="line">		 * where they can run. The upper limit on how many times we</span><br><span class="line">		 * iterate on same src_cpu is dependent on number of cpus in our</span><br><span class="line">		 * sched_group.</span><br><span class="line">		 *</span><br><span class="line">		 * This changes load balance semantics a bit on who can move</span><br><span class="line">		 * load to a given_cpu. In addition to the given_cpu itself</span><br><span class="line">		 * (or a ilb_cpu acting on its behalf where given_cpu is</span><br><span class="line">		 * nohz-idle), we now have balance_cpu in a position to move</span><br><span class="line">		 * load to given_cpu. In rare situations, this may cause</span><br><span class="line">		 * conflicts (balance_cpu and given_cpu/ilb_cpu deciding</span><br><span class="line">		 * _independently_ and at _same_ time to move some load to</span><br><span class="line">		 * given_cpu) causing exceess load to be moved to given_cpu.</span><br><span class="line">		 * This however should not happen so much in practice and</span><br><span class="line">		 * moreover subsequent load balance cycles should correct the</span><br><span class="line">		 * excess load moved.</span><br><span class="line">		 */</span><br><span class="line">		if ((env.flags &amp; LBF_DST_PINNED) &amp;&amp; env.imbalance &gt; 0) &#123;</span><br><span class="line"></span><br><span class="line">			/* Prevent to re-select dst_cpu via env&apos;s cpus */</span><br><span class="line">			cpumask_clear_cpu(env.dst_cpu, env.cpus);</span><br><span class="line"></span><br><span class="line">			env.dst_rq	 = cpu_rq(env.new_dst_cpu);</span><br><span class="line">			env.dst_cpu	 = env.new_dst_cpu;</span><br><span class="line">			env.flags	&amp;= ~LBF_DST_PINNED;</span><br><span class="line">			env.loop	 = 0;</span><br><span class="line">			env.loop_break	 = sched_nr_migrate_break;</span><br><span class="line"></span><br><span class="line">			/*</span><br><span class="line">			 * Go back to &quot;more_balance&quot; rather than &quot;redo&quot; since we</span><br><span class="line">			 * need to continue with same src_cpu.</span><br><span class="line">			 */</span><br><span class="line">			goto more_balance;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        /* (7.11) 设置了LBF_SOME_PINNED标志，说明有些进程因为affinity迁移失败，  </span><br><span class="line">            设置当前sd的parent sd的 sgc-&gt;imbalance，让parent sd做rebalance的概率增高</span><br><span class="line">         */</span><br><span class="line">		/*</span><br><span class="line">		 * We failed to reach balance because of affinity.</span><br><span class="line">		 */</span><br><span class="line">		if (sd_parent) &#123;</span><br><span class="line">			int *group_imbalance = &amp;sd_parent-&gt;groups-&gt;sgc-&gt;imbalance;</span><br><span class="line"></span><br><span class="line">			if ((env.flags &amp; LBF_SOME_PINNED) &amp;&amp; env.imbalance &gt; 0)</span><br><span class="line">				*group_imbalance = 1;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        /* (7.12) 如果LBF_ALL_PINNED标志一直被置位，</span><br><span class="line">            说明busiest_cpu因为affinity没有一个进程迁移成功，哪怕迁移到dst_cpu同sg的其他cpu也没有一个成功</span><br><span class="line">            将busiest cpu从全局cpu mask去掉，重新做整个流程：find_busiest_group -&gt; find_busiest_queue -&gt; detach_tasks -&gt; attach_tasks</span><br><span class="line">         */</span><br><span class="line">		/* All tasks on this runqueue were pinned by CPU affinity */</span><br><span class="line">		if (unlikely(env.flags &amp; LBF_ALL_PINNED)) &#123;</span><br><span class="line">			cpumask_clear_cpu(cpu_of(busiest), cpus);</span><br><span class="line">			if (!cpumask_empty(cpus)) &#123;</span><br><span class="line">				env.loop = 0;</span><br><span class="line">				env.loop_break = sched_nr_migrate_break;</span><br><span class="line">				goto redo;</span><br><span class="line">			&#125;</span><br><span class="line">			goto out_all_pinned;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (7.13) 经过几轮的努力尝试，最终迁移的进程数ld_moved还是0，说明balance失败 */</span><br><span class="line">	if (!ld_moved) &#123;</span><br><span class="line">		schedstat_inc(sd, lb_failed[idle]);</span><br><span class="line">		/*</span><br><span class="line">		 * Increment the failure counter only on periodic balance.</span><br><span class="line">		 * We do not want newidle balance, which can be very</span><br><span class="line">		 * frequent, pollute the failure counter causing</span><br><span class="line">		 * excessive cache_hot migrations and active balances.</span><br><span class="line">		 */</span><br><span class="line">		if (idle != CPU_NEWLY_IDLE)</span><br><span class="line">			if (env.src_grp_nr_running &gt; 1)</span><br><span class="line">				sd-&gt;nr_balance_failed++;</span><br><span class="line"></span><br><span class="line">        /* (7.14) 最后一次尝试迁移一个进程 */</span><br><span class="line">		if (need_active_balance(&amp;env)) &#123;</span><br><span class="line">			raw_spin_lock_irqsave(&amp;busiest-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">            /* (7.15) 如果当前cpu不在busiest-&gt;curr进程的affinity之内，返回失败 */</span><br><span class="line">			/* don&apos;t kick the active_load_balance_cpu_stop,</span><br><span class="line">			 * if the curr task on busiest cpu can&apos;t be</span><br><span class="line">			 * moved to this_cpu</span><br><span class="line">			 */</span><br><span class="line">			if (!cpumask_test_cpu(this_cpu,</span><br><span class="line">					tsk_cpus_allowed(busiest-&gt;curr))) &#123;</span><br><span class="line">				raw_spin_unlock_irqrestore(&amp;busiest-&gt;lock,</span><br><span class="line">							    flags);</span><br><span class="line">				env.flags |= LBF_ALL_PINNED;</span><br><span class="line">				goto out_one_pinned;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			/*</span><br><span class="line">			 * -&gt;active_balance synchronizes accesses to</span><br><span class="line">			 * -&gt;active_balance_work.  Once set, it&apos;s cleared</span><br><span class="line">			 * only after active load balance is finished.</span><br><span class="line">			 */</span><br><span class="line">			if (!busiest-&gt;active_balance &amp;&amp; !cpu_park(cpu_of(busiest))) &#123;</span><br><span class="line">				busiest-&gt;active_balance = 1; /* load_balance */</span><br><span class="line">				busiest-&gt;push_cpu = this_cpu;</span><br><span class="line">				active_balance = 1;</span><br><span class="line">			&#125;</span><br><span class="line">			raw_spin_unlock_irqrestore(&amp;busiest-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">            /* (7.16) 迁移busiest-&gt;curr进程当前期cpu */</span><br><span class="line">			if (active_balance) &#123;</span><br><span class="line">				if (stop_one_cpu_dispatch(cpu_of(busiest),</span><br><span class="line">					active_load_balance_cpu_stop, busiest,</span><br><span class="line">					&amp;busiest-&gt;active_balance_work)) &#123;</span><br><span class="line">					raw_spin_lock_irqsave(&amp;busiest-&gt;lock, flags);</span><br><span class="line">					busiest-&gt;active_balance = 0;</span><br><span class="line">					active_balance = 0;</span><br><span class="line">					raw_spin_unlock_irqrestore(&amp;busiest-&gt;lock, flags);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			/*</span><br><span class="line">			 * We&apos;ve kicked active balancing, reset the failure</span><br><span class="line">			 * counter.</span><br><span class="line">			 */</span><br><span class="line">			sd-&gt;nr_balance_failed = sd-&gt;cache_nice_tries+1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; else</span><br><span class="line">		sd-&gt;nr_balance_failed = 0;</span><br><span class="line"></span><br><span class="line">	if (likely(!active_balance)) &#123;</span><br><span class="line">		/* We were unbalanced, so reset the balancing interval */</span><br><span class="line">		sd-&gt;balance_interval = sd-&gt;min_interval;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		/*</span><br><span class="line">		 * If we&apos;ve begun active balancing, start to back off. This</span><br><span class="line">		 * case may not be covered by the all_pinned logic if there</span><br><span class="line">		 * is only 1 task on the busy runqueue (because we don&apos;t call</span><br><span class="line">		 * detach_tasks).</span><br><span class="line">		 */</span><br><span class="line">		if (sd-&gt;balance_interval &lt; sd-&gt;max_interval)</span><br><span class="line">			sd-&gt;balance_interval *= 2;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	goto out;</span><br><span class="line"></span><br><span class="line">out_balanced:</span><br><span class="line">	/*</span><br><span class="line">	 * We reach balance although we may have faced some affinity</span><br><span class="line">	 * constraints. Clear the imbalance flag if it was set.</span><br><span class="line">	 */</span><br><span class="line">	if (sd_parent) &#123;</span><br><span class="line">		int *group_imbalance = &amp;sd_parent-&gt;groups-&gt;sgc-&gt;imbalance;</span><br><span class="line"></span><br><span class="line">		if (*group_imbalance)</span><br><span class="line">			*group_imbalance = 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">out_all_pinned:</span><br><span class="line">	/*</span><br><span class="line">	 * We reach balance because all tasks are pinned at this level so</span><br><span class="line">	 * we can&apos;t migrate them. Let the imbalance flag set so parent level</span><br><span class="line">	 * can try to migrate them.</span><br><span class="line">	 */</span><br><span class="line">	schedstat_inc(sd, lb_balanced[idle]);</span><br><span class="line"></span><br><span class="line">	sd-&gt;nr_balance_failed = 0;</span><br><span class="line"></span><br><span class="line">out_one_pinned:</span><br><span class="line">	/* tune up the balancing interval */</span><br><span class="line">	if (((env.flags &amp; LBF_ALL_PINNED) &amp;&amp;</span><br><span class="line">			sd-&gt;balance_interval &lt; MAX_PINNED_INTERVAL) ||</span><br><span class="line">			(sd-&gt;balance_interval &lt; sd-&gt;max_interval))</span><br><span class="line">		sd-&gt;balance_interval *= 2;</span><br><span class="line"></span><br><span class="line">	ld_moved = 0;</span><br><span class="line">out:</span><br><span class="line">	return ld_moved;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">||→</span><br><span class="line"></span><br><span class="line">static int should_we_balance(struct lb_env *env)</span><br><span class="line">&#123;</span><br><span class="line">	struct sched_group *sg = env-&gt;sd-&gt;groups;</span><br><span class="line">	struct cpumask *sg_cpus, *sg_mask;</span><br><span class="line">	int cpu, balance_cpu = -1;</span><br><span class="line"></span><br><span class="line">    /* (7.2.1) 如果本cpu为CPU_NEWLY_IDLE，直接符合迁移条件 */</span><br><span class="line">	/*</span><br><span class="line">	 * In the newly idle case, we will allow all the cpu&apos;s</span><br><span class="line">	 * to do the newly idle load balance.</span><br><span class="line">	 */</span><br><span class="line">	if (env-&gt;idle == CPU_NEWLY_IDLE)</span><br><span class="line">		return 1;</span><br><span class="line"></span><br><span class="line">	sg_cpus = sched_group_cpus(sg);</span><br><span class="line">	sg_mask = sched_group_mask(sg);</span><br><span class="line">	/* (7.2.2) 本sched_group的第一个idle cpu适合做load_balance */</span><br><span class="line">	/* Try to find first idle cpu */</span><br><span class="line">	for_each_cpu_and(cpu, sg_cpus, env-&gt;cpus) &#123;</span><br><span class="line">		if (!cpumask_test_cpu(cpu, sg_mask) || !idle_cpu(cpu))</span><br><span class="line">			continue;</span><br><span class="line"></span><br><span class="line">		balance_cpu = cpu;</span><br><span class="line">		break;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (7.2.3) 没有idle cpu，则选取本sched_group的第一个cpu做load_balance */</span><br><span class="line">	if (balance_cpu == -1)</span><br><span class="line">		balance_cpu = group_balance_cpu(sg);</span><br><span class="line"></span><br><span class="line">    /* (7.2.4) 不满足上述条件的cpu，不适合来启动load_balance */</span><br><span class="line">	/*</span><br><span class="line">	 * First idle cpu or the first cpu(busiest) in this sched group</span><br><span class="line">	 * is eligible for doing load balancing at this and above domains.</span><br><span class="line">	 */</span><br><span class="line">	return balance_cpu == env-&gt;dst_cpu;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">||→</span><br><span class="line"></span><br><span class="line">static struct sched_group *find_busiest_group(struct lb_env *env)</span><br><span class="line">&#123;</span><br><span class="line">	struct sg_lb_stats *local, *busiest;</span><br><span class="line">	struct sd_lb_stats sds;</span><br><span class="line">	int local_cpu = 0, busiest_cpu = 0;</span><br><span class="line">	struct cpumask *busiest_cpumask;</span><br><span class="line">	int same_clus = 0;</span><br><span class="line"></span><br><span class="line">	init_sd_lb_stats(&amp;sds);</span><br><span class="line"></span><br><span class="line">    /* (7.3.1) 更新本层级sched_group链表中，每个sched_group的负载,</span><br><span class="line">        并选出busiest的一个sched_group</span><br><span class="line">     */</span><br><span class="line">	/*</span><br><span class="line">	 * Compute the various statistics relavent for load balancing at</span><br><span class="line">	 * this level.</span><br><span class="line">	 */</span><br><span class="line">	update_sd_lb_stats(env, &amp;sds);</span><br><span class="line"></span><br><span class="line">	local = &amp;sds.local_stat;</span><br><span class="line">	busiest = &amp;sds.busiest_stat;</span><br><span class="line"></span><br><span class="line">	if (sds.busiest) &#123;</span><br><span class="line">		busiest_cpumask = sched_group_cpus(sds.busiest);</span><br><span class="line">		local_cpu = env-&gt;dst_cpu;</span><br><span class="line">		busiest_cpu = group_first_cpu(sds.busiest);</span><br><span class="line"></span><br><span class="line">		same_clus = is_the_same_domain(local_cpu, busiest_cpu);</span><br><span class="line">		mt_sched_printf(sched_lb, &quot;%s: local_cpu=%d, busiest_cpu=%d, busiest_mask=%lu, same_cluster=%d&quot;,</span><br><span class="line">				__func__, local_cpu, busiest_cpu, busiest_cpumask-&gt;bits[0], same_clus);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    /* (7.3.2) 如果EAS使能，跨cluster的任务迁移使用EAS来做 */</span><br><span class="line">	if (energy_aware() &amp;&amp; !env-&gt;dst_rq-&gt;rd-&gt;overutilized &amp;&amp; !same_clus)</span><br><span class="line">		goto out_balanced;</span><br><span class="line"></span><br><span class="line">    /* (7.3.3) */</span><br><span class="line">	/* ASYM feature bypasses nice load balance check */</span><br><span class="line">	if ((env-&gt;idle == CPU_IDLE || env-&gt;idle == CPU_NEWLY_IDLE) &amp;&amp;</span><br><span class="line">	    check_asym_packing(env, &amp;sds))</span><br><span class="line">		return sds.busiest;</span><br><span class="line"></span><br><span class="line">    /* (7.3.4) busiest sg上没有负载，返回空 */</span><br><span class="line">	/* There is no busy sibling group to pull tasks from */</span><br><span class="line">	if (!sds.busiest || busiest-&gt;sum_nr_running == 0) &#123;</span><br><span class="line">		if (!sds.busiest)</span><br><span class="line">			mt_sched_printf(sched_lb, &quot;[%s] %d: fail no busiest &quot;, __func__, env-&gt;src_cpu);</span><br><span class="line">		else</span><br><span class="line">			mt_sched_printf(sched_lb, &quot;[%s] %d: fail busiest no task &quot;, __func__, env-&gt;src_cpu);</span><br><span class="line">		goto out_balanced;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (7.3.5) sg链表里的平均负载 */</span><br><span class="line">	sds.avg_load = (SCHED_CAPACITY_SCALE * sds.total_load)</span><br><span class="line">						/ sds.total_capacity;</span><br><span class="line"></span><br><span class="line">    /* (7.3.6) 如果busiest sg低一级别的因为cpu affinity没有balance成功，设置了group_imbalanced标志 </span><br><span class="line">        强制在当前级别上进行balance</span><br><span class="line">     */</span><br><span class="line">	/*</span><br><span class="line">	 * If the busiest group is imbalanced the below checks don&apos;t</span><br><span class="line">	 * work because they assume all things are equal, which typically</span><br><span class="line">	 * isn&apos;t true due to cpus_allowed constraints and the like.</span><br><span class="line">	 */</span><br><span class="line">	if (busiest-&gt;group_type == group_imbalanced)</span><br><span class="line">		goto force_balance;</span><br><span class="line"></span><br><span class="line">    /* (7.3.7) 如果dest cpu/group很闲，busiest负载很重，  </span><br><span class="line">        强制开展balance</span><br><span class="line">     */</span><br><span class="line">	/* SD_BALANCE_NEWIDLE trumps SMP nice when underutilized */</span><br><span class="line">	if (env-&gt;idle == CPU_NEWLY_IDLE &amp;&amp; group_has_capacity(env, local) &amp;&amp;</span><br><span class="line">	    busiest-&gt;group_no_capacity)</span><br><span class="line">		goto force_balance;</span><br><span class="line"></span><br><span class="line">    /* (7.3.8)  如果dest_cpu所在sg的负载都大于busiest sg的负载，</span><br><span class="line">        放弃balance</span><br><span class="line">     */</span><br><span class="line">	/*</span><br><span class="line">	 * If the local group is busier than the selected busiest group</span><br><span class="line">	 * don&apos;t try and pull any tasks.</span><br><span class="line">	 */</span><br><span class="line">	if (local-&gt;avg_load &gt;= busiest-&gt;avg_load)</span><br><span class="line">		goto out_balanced;</span><br><span class="line"></span><br><span class="line">    /* (7.3.9)  如果dest_cpu所在sg的负载都大于sg链表的平均负载，</span><br><span class="line">        放弃balance</span><br><span class="line">     */</span><br><span class="line">	/*</span><br><span class="line">	 * Don&apos;t pull any tasks if this group is already above the domain</span><br><span class="line">	 * average load.</span><br><span class="line">	 */</span><br><span class="line">	if (local-&gt;avg_load &gt;= sds.avg_load)</span><br><span class="line">		goto out_balanced;</span><br><span class="line"></span><br><span class="line">    /* (7.3.10)  如果dest_cpu为idle，但是dest_cpu所在的sg idle cpu数量小于busiest sg的idle cpu数量</span><br><span class="line">        放弃balance</span><br><span class="line">     */</span><br><span class="line">#ifdef CONFIG_MTK_LOAD_BALANCE_ENHANCEMENT</span><br><span class="line">	if ((env-&gt;idle == CPU_IDLE) || (env-&gt;idle == CPU_NEWLY_IDLE)) &#123;</span><br><span class="line">		int i = (env-&gt;idle == CPU_IDLE) ? 1:0;</span><br><span class="line">#else</span><br><span class="line">	if (env-&gt;idle == CPU_IDLE) &#123;</span><br><span class="line">#endif</span><br><span class="line">		/*</span><br><span class="line">		 * This cpu is idle. If the busiest group is not overloaded</span><br><span class="line">		 * and there is no imbalance between this and busiest group</span><br><span class="line">		 * wrt idle cpus, it is balanced. The imbalance becomes</span><br><span class="line">		 * significant if the diff is greater than 1 otherwise we</span><br><span class="line">		 * might end up to just move the imbalance on another group</span><br><span class="line">		 */</span><br><span class="line">#ifdef CONFIG_MTK_LOAD_BALANCE_ENHANCEMENT</span><br><span class="line">		if ((busiest-&gt;group_type != group_overloaded) &amp;&amp;</span><br><span class="line">			(local-&gt;idle_cpus &lt; (busiest-&gt;idle_cpus + i)))</span><br><span class="line">#else</span><br><span class="line">		if ((busiest-&gt;group_type != group_overloaded) &amp;&amp;</span><br><span class="line">				(local-&gt;idle_cpus &lt;= (busiest-&gt;idle_cpus + 1)))</span><br><span class="line">#endif</span><br><span class="line">			goto out_balanced;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">	</span><br><span class="line">	    /* (7.3.11)  busiest-&gt;avg_load大于local-&gt;avg_load的比例没有超过env-&gt;sd-&gt;imbalance_pct</span><br><span class="line">            放弃balance</span><br><span class="line">        */</span><br><span class="line">		/*</span><br><span class="line">		 * In the CPU_NEWLY_IDLE, CPU_NOT_IDLE cases, use</span><br><span class="line">		 * imbalance_pct to be conservative.</span><br><span class="line">		 */</span><br><span class="line">		if (100 * busiest-&gt;avg_load &lt;=</span><br><span class="line">				env-&gt;sd-&gt;imbalance_pct * local-&gt;avg_load)</span><br><span class="line">			goto out_balanced;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">force_balance:</span><br><span class="line">	/* Looks like there is an imbalance. Compute it */</span><br><span class="line">	/* (7.3.12) 计算需要迁移的负载值env-&gt;imbalance */</span><br><span class="line">	calculate_imbalance(env, &amp;sds);</span><br><span class="line">#ifdef CONFIG_MTK_LOAD_BALANCE_ENHANCEMENT</span><br><span class="line">	env-&gt;imbalance = env-&gt;imbalance * SCHED_CAPACITY_SCALE</span><br><span class="line">		/ (sds.busiest-&gt;sgc-&gt;capacity / cpumask_weight(sched_group_cpus(sds.busiest)));</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	return sds.busiest;</span><br><span class="line"></span><br><span class="line">out_balanced:</span><br><span class="line">	env-&gt;imbalance = 0;</span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|||→</span><br><span class="line"></span><br><span class="line">static inline void update_sd_lb_stats(struct lb_env *env, struct sd_lb_stats *sds)</span><br><span class="line">&#123;</span><br><span class="line">	struct sched_domain *child = env-&gt;sd-&gt;child;</span><br><span class="line">	struct sched_group *sg = env-&gt;sd-&gt;groups;</span><br><span class="line">	struct sg_lb_stats tmp_sgs;</span><br><span class="line">	int load_idx, prefer_sibling = 0;</span><br><span class="line">	bool overload = false, overutilized = false;</span><br><span class="line"></span><br><span class="line">	if (child &amp;&amp; child-&gt;flags &amp; SD_PREFER_SIBLING)</span><br><span class="line">		prefer_sibling = 1;</span><br><span class="line"></span><br><span class="line">    /* (7.3.1.1) 根据idle情况，选择计算cpu负载时的idx，</span><br><span class="line">        idx：是CPU层级负载this_rq-&gt;cpu_load[i]数组的index值</span><br><span class="line">     */</span><br><span class="line">	load_idx = get_sd_load_idx(env-&gt;sd, env-&gt;idle);</span><br><span class="line"></span><br><span class="line">    /* (7.3.1.2) 逐个轮询本层级sched_group链表中的每个sched_group */</span><br><span class="line">	do &#123;</span><br><span class="line">		struct sg_lb_stats *sgs = &amp;tmp_sgs;</span><br><span class="line">		int local_group;</span><br><span class="line"></span><br><span class="line">        /* (7.3.1.3) 如果sg是当前cpu所在的sg，则本sg称为local_group </span><br><span class="line">            使用专门的数据结构来存储local_group的信息：</span><br><span class="line">            sds-&gt;local = sg;        // 使用sds-&gt;local来存储local_group</span><br><span class="line">            sgs = &amp;sds-&gt;local_stat; // 使用sds-&gt;local_stat来存储local_group的统计</span><br><span class="line">         */</span><br><span class="line">		local_group = cpumask_test_cpu(env-&gt;dst_cpu, sched_group_cpus(sg));</span><br><span class="line">		if (local_group) &#123;</span><br><span class="line">			sds-&gt;local = sg;</span><br><span class="line">			sgs = &amp;sds-&gt;local_stat;</span><br><span class="line"></span><br><span class="line">            /* (7.3.1.4) 更新local_group的capacity，更新的周期为sd-&gt;balance_interval </span><br><span class="line">                主要目的是动态减去RT进程消耗的capacity</span><br><span class="line">             */</span><br><span class="line">			if (env-&gt;idle != CPU_NEWLY_IDLE ||</span><br><span class="line">			    time_after_eq(jiffies, sg-&gt;sgc-&gt;next_update))</span><br><span class="line">				update_group_capacity(env-&gt;sd, env-&gt;dst_cpu);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        /* (7.3.1.5) 更新当前sched_group的负载统计 </span><br><span class="line">            sgs：sg统计数据放到sgs当中</span><br><span class="line">            overload：rq中runnable的进程&gt;1，那么肯定有进程在等待</span><br><span class="line">            overutilized：cpu的capacity &lt; util，运算能力不足</span><br><span class="line">         */</span><br><span class="line">		update_sg_lb_stats(env, sg, load_idx, local_group, sgs,</span><br><span class="line">						&amp;overload, &amp;overutilized);</span><br><span class="line"></span><br><span class="line">        /* (7.3.1.6) local_group不参与busiest sg的计算 */</span><br><span class="line">		if (local_group)</span><br><span class="line">			goto next_group;</span><br><span class="line"></span><br><span class="line">        /* (7.3.1.7) 如果设置了SD_PREFER_SIBLING标志，说明local_group希望其他人迁移任务到它身上，</span><br><span class="line">            提高其他sg的迁移优先级</span><br><span class="line">         */</span><br><span class="line">		/*</span><br><span class="line">		 * In case the child domain prefers tasks go to siblings</span><br><span class="line">		 * first, lower the sg capacity so that we&apos;ll try</span><br><span class="line">		 * and move all the excess tasks away. We lower the capacity</span><br><span class="line">		 * of a group only if the local group has the capacity to fit</span><br><span class="line">		 * these excess tasks. The extra check prevents the case where</span><br><span class="line">		 * you always pull from the heaviest group when it is already</span><br><span class="line">		 * under-utilized (possible with a large weight task outweighs</span><br><span class="line">		 * the tasks on the system).</span><br><span class="line">		 */</span><br><span class="line">		if (prefer_sibling &amp;&amp; sds-&gt;local &amp;&amp;</span><br><span class="line">		    group_has_capacity(env, &amp;sds-&gt;local_stat) &amp;&amp;</span><br><span class="line">		    (sgs-&gt;sum_nr_running &gt; 1)) &#123;</span><br><span class="line">			sgs-&gt;group_no_capacity = 1;</span><br><span class="line">			sgs-&gt;group_type = group_classify(sg, sgs);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        /* (7.3.1.8) 根据计算的sgs统计数据，找出busiest sg */</span><br><span class="line">		if (update_sd_pick_busiest(env, sds, sg, sgs)) &#123;</span><br><span class="line">			sds-&gt;busiest = sg;</span><br><span class="line">			sds-&gt;busiest_stat = *sgs;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">next_group:</span><br><span class="line">        /* (7.3.1.9) 更新sds中的负载、capacity统计 */</span><br><span class="line">		/* Now, start updating sd_lb_stats */</span><br><span class="line">		sds-&gt;total_load += sgs-&gt;group_load;</span><br><span class="line">		sds-&gt;total_capacity += sgs-&gt;group_capacity;</span><br><span class="line"></span><br><span class="line">		sg = sg-&gt;next;</span><br><span class="line">	&#125; while (sg != env-&gt;sd-&gt;groups);</span><br><span class="line"></span><br><span class="line">	if (env-&gt;sd-&gt;flags &amp; SD_NUMA)</span><br><span class="line">		env-&gt;fbq_type = fbq_classify_group(&amp;sds-&gt;busiest_stat);</span><br><span class="line"></span><br><span class="line">	env-&gt;src_grp_nr_running = sds-&gt;busiest_stat.sum_nr_running;</span><br><span class="line"></span><br><span class="line">    /* (7.3.1.10) 根据最后一个sg的overload、overutilized值</span><br><span class="line">        来更新dst_cpu rq-&gt;rd中的对应值 。</span><br><span class="line">        ooooo这里是怎么想的？不是local_group，也不是busiest_group，而是最后一个计算的sg!!!</span><br><span class="line">     */</span><br><span class="line">	if (!env-&gt;sd-&gt;parent) &#123;</span><br><span class="line">		/* update overload indicator if we are at root domain */</span><br><span class="line">		if (env-&gt;dst_rq-&gt;rd-&gt;overload != overload)</span><br><span class="line">			env-&gt;dst_rq-&gt;rd-&gt;overload = overload;</span><br><span class="line"></span><br><span class="line">		/* Update over-utilization (tipping point, U &gt;= 0) indicator */</span><br><span class="line">		if (env-&gt;dst_rq-&gt;rd-&gt;overutilized != overutilized)</span><br><span class="line">			env-&gt;dst_rq-&gt;rd-&gt;overutilized = overutilized;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		if (!env-&gt;dst_rq-&gt;rd-&gt;overutilized &amp;&amp; overutilized)</span><br><span class="line">			env-&gt;dst_rq-&gt;rd-&gt;overutilized = true;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">||||→</span><br><span class="line"></span><br><span class="line">static inline void update_sg_lb_stats(struct lb_env *env,</span><br><span class="line">			struct sched_group *group, int load_idx,</span><br><span class="line">			int local_group, struct sg_lb_stats *sgs,</span><br><span class="line">			bool *overload, bool *overutilized)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned long load;</span><br><span class="line">	int i;</span><br><span class="line"></span><br><span class="line">	memset(sgs, 0, sizeof(*sgs));</span><br><span class="line"></span><br><span class="line">    /*  (7.3.1.5.1) 遍历sched_group中的每个cpu */</span><br><span class="line">	for_each_cpu_and(i, sched_group_cpus(group), env-&gt;cpus) &#123;</span><br><span class="line">		struct rq *rq = cpu_rq(i);</span><br><span class="line"></span><br><span class="line">        /* (7.3.1.5.2) 获取本cpu的负载rq-&gt;cpu_load[load_idx-1] */</span><br><span class="line">		/* Bias balancing toward cpus of our domain */</span><br><span class="line">		if (local_group)</span><br><span class="line">		    /* 如果是local_group，负载往小的取：min(rq-&gt;cpu_load[load_idx-1], weighted_cpuload(cpu)) */</span><br><span class="line">			load = target_load(i, load_idx);</span><br><span class="line">		else</span><br><span class="line">		    /* 如果不是local_group，负载往大的取：max(rq-&gt;cpu_load[load_idx-1], weighted_cpuload(cpu)) */</span><br><span class="line">			load = source_load(i, load_idx);</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_MTK_SCHED_INTEROP</span><br><span class="line">        /* (7.3.1.5.3) 因为rq-&gt;cpu_load[]只包含cfs的负载，mtk尝试加上rt部分的负载</span><br><span class="line">            ooooo但是rq-&gt;cpu_capacity中已经减去了rt的部分，这里是否还需要？？</span><br><span class="line">         */</span><br><span class="line">		load += mt_rt_load(i);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">        /* (7.3.1.5.4) 累加sgs各项值：</span><br><span class="line">            sgs-&gt;group_load   // runnable负载带weight分量(cpu_rq(cpu)-&gt;cfs.avg.util_avg)，经过rq-&gt;cpu_load[]计算</span><br><span class="line">            sgs-&gt;group_util   // running负载(cpu_rq(cpu)-&gt;cfs.avg.load_avg/cpu_rq(cpu)-&gt;cfs.runnable_load_avg)</span><br><span class="line">            sgs-&gt;sum_nr_running // rq中所有se的总和</span><br><span class="line">            sgs-&gt;sum_weighted_load // runnable负载带weight分量(cpu_rq(cpu)-&gt;cfs.avg.util_avg)</span><br><span class="line">            sgs-&gt;idle_cpus      // idle状态的cpu计数</span><br><span class="line">         */</span><br><span class="line">#ifdef CONFIG_MTK_LOAD_BALANCE_ENHANCEMENT</span><br><span class="line">		sgs-&gt;group_load += (load * capacity_orig_of(i)) &gt;&gt; SCHED_CAPACITY_SHIFT;</span><br><span class="line">#else</span><br><span class="line">		sgs-&gt;group_load += load;</span><br><span class="line">#endif</span><br><span class="line">		sgs-&gt;group_util += cpu_util(i);</span><br><span class="line">		sgs-&gt;sum_nr_running += rq-&gt;cfs.h_nr_running;</span><br><span class="line"></span><br><span class="line">        /* (7.3.1.5.5) 如果rq中进程数量&gt;1，则就会有进程处于runnable状态，</span><br><span class="line">            overload = true</span><br><span class="line">         */</span><br><span class="line">		if (rq-&gt;nr_running &gt; 1)</span><br><span class="line">			*overload = true;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_NUMA_BALANCING</span><br><span class="line">		sgs-&gt;nr_numa_running += rq-&gt;nr_numa_running;</span><br><span class="line">		sgs-&gt;nr_preferred_running += rq-&gt;nr_preferred_running;</span><br><span class="line">#endif</span><br><span class="line">		sgs-&gt;sum_weighted_load += weighted_cpuload(i);</span><br><span class="line">		if (idle_cpu(i))</span><br><span class="line">			sgs-&gt;idle_cpus++;</span><br><span class="line"></span><br><span class="line">        /* (7.3.1.5.6) cpu的capacity小于cpu的running状态负载，</span><br><span class="line">            overutilized = true</span><br><span class="line">         */</span><br><span class="line">		if (cpu_overutilized(i))</span><br><span class="line">			*overutilized = true;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (7.3.1.5.7) 更新汇总后sgs的统计数据：</span><br><span class="line">        sgs-&gt;group_capacity     // sgs所有cpu capacity的累加</span><br><span class="line">        sgs-&gt;avg_load           // 按照group_capacity，等比例放大group_load负载，capacity越小avg_load越大</span><br><span class="line">        sgs-&gt;load_per_task      // sgs的平均每个进程的weight负载</span><br><span class="line">        sgs-&gt;group_weight       // sgs的online cpu个数</span><br><span class="line">        sgs-&gt;group_no_capacity  // sgs的capacity已经不够用，赶不上util</span><br><span class="line">        sgs-&gt;group_type         // 严重级别 group_overloaded &gt; group_imbalanced &gt; group_other</span><br><span class="line">                                // group_imbalanced: 下一等级的load_balance因为cpu_affinity的原因没有完成</span><br><span class="line">     */</span><br><span class="line">	/* Adjust by relative CPU capacity of the group */</span><br><span class="line">	sgs-&gt;group_capacity = group-&gt;sgc-&gt;capacity;</span><br><span class="line">	sgs-&gt;avg_load = (sgs-&gt;group_load*SCHED_CAPACITY_SCALE) / sgs-&gt;group_capacity;</span><br><span class="line"></span><br><span class="line">	if (sgs-&gt;sum_nr_running)</span><br><span class="line">		sgs-&gt;load_per_task = sgs-&gt;sum_weighted_load / sgs-&gt;sum_nr_running;</span><br><span class="line"></span><br><span class="line">	sgs-&gt;group_weight = group-&gt;group_weight;</span><br><span class="line"></span><br><span class="line">	sgs-&gt;group_no_capacity = group_is_overloaded(env, sgs);</span><br><span class="line">	sgs-&gt;group_type = group_classify(group, sgs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">||||→</span><br><span class="line"></span><br><span class="line">static bool update_sd_pick_busiest(struct lb_env *env,</span><br><span class="line">				   struct sd_lb_stats *sds,</span><br><span class="line">				   struct sched_group *sg,</span><br><span class="line">				   struct sg_lb_stats *sgs)</span><br><span class="line">&#123;</span><br><span class="line">	struct sg_lb_stats *busiest = &amp;sds-&gt;busiest_stat;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_MTK_LOAD_BALANCE_ENHANCEMENT</span><br><span class="line">	if (sgs-&gt;sum_nr_running == 0) &#123;</span><br><span class="line">		mt_sched_printf(sched_lb_info, &quot;[%s] sgs-&gt;sum_nr_running=%d&quot;,</span><br><span class="line">			__func__, sgs-&gt;sum_nr_running);</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    /* (7.3.1.9.1) 如果新的sgs group_type大于旧的busiest sgs，</span><br><span class="line">        新的sgs更busy</span><br><span class="line">     */</span><br><span class="line">	if (sgs-&gt;group_type &gt; busiest-&gt;group_type)</span><br><span class="line">		return true;</span><br><span class="line"></span><br><span class="line">    /* (7.3.1.9.2) 如果新的sgs group_type小于旧的busiest sgs，</span><br><span class="line">        旧的sgs更busy</span><br><span class="line">     */</span><br><span class="line">	if (sgs-&gt;group_type &lt; busiest-&gt;group_type)</span><br><span class="line">		return false;</span><br><span class="line"></span><br><span class="line">    /* (7.3.1.9.3) 在group_type相同的情况下，比较sgs-&gt;avg_load </span><br><span class="line">        sgs-&gt;avg_load = rq-&gt;cpu_load[load_idx-1] * (group_load*SCHED_CAPACITY_SCALE / sgs-&gt;group_capacity)</span><br><span class="line">     */</span><br><span class="line">	if (sgs-&gt;avg_load &lt;= busiest-&gt;avg_load)</span><br><span class="line">		return false;</span><br><span class="line"></span><br><span class="line">    /* (7.3.1.9.4) 如果SD_ASYM_PACKING标志没有置位,</span><br><span class="line">        在group_type相同的情况下，sgs-&gt;avg_load值较大的为busiest sg</span><br><span class="line">     */</span><br><span class="line">	/* This is the busiest node in its class. */</span><br><span class="line">	if (!(env-&gt;sd-&gt;flags &amp; SD_ASYM_PACKING))</span><br><span class="line">		return true;</span><br><span class="line"></span><br><span class="line">    /* (7.3.1.9.5) ASYM_PACKING的意思是会把负载移到最低序号的cpu上，</span><br><span class="line">        如果sg的frist cpu序号 &gt; dst_cpu，则busiest</span><br><span class="line">        对个sg的frist cpu序号 &gt; dst_cpu，选择序号小的sg</span><br><span class="line">     */</span><br><span class="line">	/*</span><br><span class="line">	 * ASYM_PACKING needs to move all the work to the lowest</span><br><span class="line">	 * numbered CPUs in the group, therefore mark all groups</span><br><span class="line">	 * higher than ourself as busy.</span><br><span class="line">	 */</span><br><span class="line">	if (sgs-&gt;sum_nr_running &amp;&amp; env-&gt;dst_cpu &lt; group_first_cpu(sg)) &#123;</span><br><span class="line">		if (!sds-&gt;busiest)</span><br><span class="line">			return true;</span><br><span class="line"></span><br><span class="line">		if (group_first_cpu(sds-&gt;busiest) &gt; group_first_cpu(sg))</span><br><span class="line">			return true;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (7.3.1.9.6) 设置了ASYM_PACKING，且如果sg的frist cpu序号 &lt;= dst_cpu，</span><br><span class="line">        返回false</span><br><span class="line">     */</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|||→</span><br><span class="line"></span><br><span class="line">static inline void calculate_imbalance(struct lb_env *env, struct sd_lb_stats *sds)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned long max_pull, load_above_capacity = ~0UL;</span><br><span class="line">	struct sg_lb_stats *local, *busiest;</span><br><span class="line"></span><br><span class="line">    /* (7.3.12.1) local sgs和busiest sgs */</span><br><span class="line">	local = &amp;sds-&gt;local_stat;</span><br><span class="line">	busiest = &amp;sds-&gt;busiest_stat;</span><br><span class="line"></span><br><span class="line">	if (busiest-&gt;group_type == group_imbalanced) &#123;</span><br><span class="line">		/*</span><br><span class="line">		 * In the group_imb case we cannot rely on group-wide averages</span><br><span class="line">		 * to ensure cpu-load equilibrium, look at wider averages. XXX</span><br><span class="line">		 */</span><br><span class="line">		busiest-&gt;load_per_task =</span><br><span class="line">			min(busiest-&gt;load_per_task, sds-&gt;avg_load);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (7.3.12.2) */</span><br><span class="line">	/*</span><br><span class="line">	 * In the presence of smp nice balancing, certain scenarios can have</span><br><span class="line">	 * max load less than avg load(as we skip the groups at or below</span><br><span class="line">	 * its cpu_capacity, while calculating max_load..)</span><br><span class="line">	 */</span><br><span class="line">	if (busiest-&gt;avg_load &lt;= sds-&gt;avg_load ||</span><br><span class="line">	    local-&gt;avg_load &gt;= sds-&gt;avg_load) &#123;</span><br><span class="line">		env-&gt;imbalance = 0;</span><br><span class="line">		return fix_small_imbalance(env, sds);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (7.3.12.3) */</span><br><span class="line">	/*</span><br><span class="line">	 * If there aren&apos;t any idle cpus, avoid creating some.</span><br><span class="line">	 */</span><br><span class="line">	if (busiest-&gt;group_type == group_overloaded &amp;&amp;</span><br><span class="line">	    local-&gt;group_type   == group_overloaded) &#123;</span><br><span class="line">		load_above_capacity = busiest-&gt;sum_nr_running *</span><br><span class="line">					SCHED_LOAD_SCALE;</span><br><span class="line">		if (load_above_capacity &gt; busiest-&gt;group_capacity)</span><br><span class="line">			load_above_capacity -= busiest-&gt;group_capacity;</span><br><span class="line">		else</span><br><span class="line">			load_above_capacity = ~0UL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (7.3.12.4) env-&gt;imbalance的值等于min((sds-&gt;avg - local), (busiest - sds-&gt;avg))</span><br><span class="line">        在local和sds平均值，busiest和sds平均值，两个差值之间选择最小值</span><br><span class="line">     */</span><br><span class="line">	/*</span><br><span class="line">	 * We&apos;re trying to get all the cpus to the average_load, so we don&apos;t</span><br><span class="line">	 * want to push ourselves above the average load, nor do we wish to</span><br><span class="line">	 * reduce the max loaded cpu below the average load. At the same time,</span><br><span class="line">	 * we also don&apos;t want to reduce the group load below the group capacity</span><br><span class="line">	 * (so that we can implement power-savings policies etc). Thus we look</span><br><span class="line">	 * for the minimum possible imbalance.</span><br><span class="line">	 */</span><br><span class="line">	max_pull = min(busiest-&gt;avg_load - sds-&gt;avg_load, load_above_capacity);</span><br><span class="line"></span><br><span class="line">	/* How much load to actually move to equalise the imbalance */</span><br><span class="line">	env-&gt;imbalance = min(</span><br><span class="line">		max_pull * busiest-&gt;group_capacity,</span><br><span class="line">		(sds-&gt;avg_load - local-&gt;avg_load) * local-&gt;group_capacity</span><br><span class="line">	) / SCHED_CAPACITY_SCALE;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * if *imbalance is less than the average load per runnable task</span><br><span class="line">	 * there is no guarantee that any tasks will be moved so we&apos;ll have</span><br><span class="line">	 * a think about bumping its value to force at least one task to be</span><br><span class="line">	 * moved</span><br><span class="line">	 */</span><br><span class="line">	if (env-&gt;imbalance &lt; busiest-&gt;load_per_task)</span><br><span class="line">		return fix_small_imbalance(env, sds);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">||→</span><br><span class="line"></span><br><span class="line">static struct rq *find_busiest_queue(struct lb_env *env,</span><br><span class="line">				     struct sched_group *group)</span><br><span class="line">&#123;</span><br><span class="line">	struct rq *busiest = NULL, *rq;</span><br><span class="line">	unsigned long busiest_load = 0, busiest_capacity = 1;</span><br><span class="line">	int i;</span><br><span class="line"></span><br><span class="line">    /* (7.4.1) 逐个遍历sg中的cpu */</span><br><span class="line">	for_each_cpu_and(i, sched_group_cpus(group), env-&gt;cpus) &#123;</span><br><span class="line">		unsigned long capacity, wl;</span><br><span class="line">		enum fbq_type rt;</span><br><span class="line"></span><br><span class="line">		rq = cpu_rq(i);</span><br><span class="line">		rt = fbq_classify_rq(rq);</span><br><span class="line"></span><br><span class="line">		/*</span><br><span class="line">		 * We classify groups/runqueues into three groups:</span><br><span class="line">		 *  - regular: there are !numa tasks</span><br><span class="line">		 *  - remote:  there are numa tasks that run on the &apos;wrong&apos; node</span><br><span class="line">		 *  - all:     there is no distinction</span><br><span class="line">		 *</span><br><span class="line">		 * In order to avoid migrating ideally placed numa tasks,</span><br><span class="line">		 * ignore those when there&apos;s better options.</span><br><span class="line">		 *</span><br><span class="line">		 * If we ignore the actual busiest queue to migrate another</span><br><span class="line">		 * task, the next balance pass can still reduce the busiest</span><br><span class="line">		 * queue by moving tasks around inside the node.</span><br><span class="line">		 *</span><br><span class="line">		 * If we cannot move enough load due to this classification</span><br><span class="line">		 * the next pass will adjust the group classification and</span><br><span class="line">		 * allow migration of more tasks.</span><br><span class="line">		 *</span><br><span class="line">		 * Both cases only affect the total convergence complexity.</span><br><span class="line">		 */</span><br><span class="line">		if (rt &gt; env-&gt;fbq_type)</span><br><span class="line">			continue;</span><br><span class="line"></span><br><span class="line">        /* (7.4.2) 计算出cpu的capacity和weight_load */</span><br><span class="line">		capacity = capacity_of(i);</span><br><span class="line"></span><br><span class="line">		wl = weighted_cpuload(i);</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_MTK_SCHED_INTEROP</span><br><span class="line">		wl += mt_rt_load(i);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">		/*</span><br><span class="line">		 * When comparing with imbalance, use weighted_cpuload()</span><br><span class="line">		 * which is not scaled with the cpu capacity.</span><br><span class="line">		 */</span><br><span class="line"></span><br><span class="line">		if (rq-&gt;nr_running == 1 &amp;&amp; wl &gt; env-&gt;imbalance &amp;&amp;</span><br><span class="line">		    !check_cpu_capacity(rq, env-&gt;sd))</span><br><span class="line">			continue;</span><br><span class="line"></span><br><span class="line">        /* (7.4.3) 选出相对负载最重的cpu */</span><br><span class="line">		/*</span><br><span class="line">		 * For the load comparisons with the other cpu&apos;s, consider</span><br><span class="line">		 * the weighted_cpuload() scaled with the cpu capacity, so</span><br><span class="line">		 * that the load can be moved away from the cpu that is</span><br><span class="line">		 * potentially running at a lower capacity.</span><br><span class="line">		 *</span><br><span class="line">		 * Thus we&apos;re looking for max(wl_i / capacity_i), crosswise</span><br><span class="line">		 * multiplication to rid ourselves of the division works out</span><br><span class="line">		 * to: wl_i * capacity_j &gt; wl_j * capacity_i;  where j is</span><br><span class="line">		 * our previous maximum.</span><br><span class="line">		 */</span><br><span class="line">		if (wl * busiest_capacity &gt; busiest_load * capacity) &#123;</span><br><span class="line">			busiest_load = wl;</span><br><span class="line">			busiest_capacity = capacity;</span><br><span class="line">			busiest = rq;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return busiest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">||→</span><br><span class="line"></span><br><span class="line">static int detach_tasks(struct lb_env *env)</span><br><span class="line">&#123;</span><br><span class="line">	struct list_head *tasks = &amp;env-&gt;src_rq-&gt;cfs_tasks;</span><br><span class="line">	struct task_struct *p;</span><br><span class="line">	unsigned long load;</span><br><span class="line">	int detached = 0;</span><br><span class="line"></span><br><span class="line">	lockdep_assert_held(&amp;env-&gt;src_rq-&gt;lock);</span><br><span class="line"></span><br><span class="line">	if (env-&gt;imbalance &lt;= 0)</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">    /* (7.6.1) 遍历busiest rq中的进程 */</span><br><span class="line">	while (!list_empty(tasks)) &#123;</span><br><span class="line">	</span><br><span class="line">	    /* (7.6.2) 如果dest cpu不是idle，不能将busiest cpu迁移到idle状态 */    </span><br><span class="line">		/*</span><br><span class="line">		 * We don&apos;t want to steal all, otherwise we may be treated likewise,</span><br><span class="line">		 * which could at worst lead to a livelock crash.</span><br><span class="line">		 */</span><br><span class="line">		if (env-&gt;idle != CPU_NOT_IDLE &amp;&amp; env-&gt;src_rq-&gt;nr_running &lt;= 1)</span><br><span class="line">			break;</span><br><span class="line"></span><br><span class="line">		p = list_first_entry(tasks, struct task_struct, se.group_node);</span><br><span class="line"></span><br><span class="line">        /* (7.6.3) 遍历任务最多不超过sysctl_sched_nr_migrate(32) */</span><br><span class="line">		env-&gt;loop++;</span><br><span class="line">		/* We&apos;ve more or less seen every task there is, call it quits */</span><br><span class="line">		if (env-&gt;loop &gt; env-&gt;loop_max)</span><br><span class="line">			break;</span><br><span class="line"></span><br><span class="line">        /* (7.6.4) 每sched_nr_migrate_break个任务遍历需要跳出休息一下，</span><br><span class="line">            如果没有达到env-&gt;loop_max，后面会重来</span><br><span class="line">         */</span><br><span class="line">		/* take a breather every nr_migrate tasks */</span><br><span class="line">		if (env-&gt;loop &gt; env-&gt;loop_break) &#123;</span><br><span class="line">			env-&gt;loop_break += sched_nr_migrate_break;</span><br><span class="line">			env-&gt;flags |= LBF_NEED_BREAK;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        /* (7.6.5) 判断任务是否支持迁移？ */</span><br><span class="line">		if (!can_migrate_task(p, env))</span><br><span class="line">			goto next;</span><br><span class="line"></span><br><span class="line">        /* (7.6.6) 获取p进程相对顶层cfs_rq的负载， </span><br><span class="line">            根据负载判断进程是否适合迁移</span><br><span class="line">         */</span><br><span class="line">		load = task_h_load(p);</span><br><span class="line"></span><br><span class="line">		if (sched_feat(LB_MIN) &amp;&amp; load &lt; 16 &amp;&amp; !env-&gt;sd-&gt;nr_balance_failed)</span><br><span class="line">			goto next;</span><br><span class="line"></span><br><span class="line">		if ((load / 2) &gt; env-&gt;imbalance)</span><br><span class="line">			goto next;</span><br><span class="line"></span><br><span class="line">        /* (7.6.7) detach 进程 */</span><br><span class="line">		detach_task(p, env);</span><br><span class="line">		list_add(&amp;p-&gt;se.group_node, &amp;env-&gt;tasks);</span><br><span class="line"></span><br><span class="line">		detached++;</span><br><span class="line">		env-&gt;imbalance -= load;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_PREEMPT</span><br><span class="line">		/*</span><br><span class="line">		 * NEWIDLE balancing is a source of latency, so preemptible</span><br><span class="line">		 * kernels will stop after the first task is detached to minimize</span><br><span class="line">		 * the critical section.</span><br><span class="line">		 */</span><br><span class="line">		if (env-&gt;idle == CPU_NEWLY_IDLE)</span><br><span class="line">			break;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">		/*</span><br><span class="line">		 * We only want to steal up to the prescribed amount of</span><br><span class="line">		 * weighted load.</span><br><span class="line">		 */</span><br><span class="line">		if (env-&gt;imbalance &lt;= 0)</span><br><span class="line">			break;</span><br><span class="line"></span><br><span class="line">		continue;</span><br><span class="line">next:</span><br><span class="line">		list_move_tail(&amp;p-&gt;se.group_node, tasks);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Right now, this is one of only two places we collect this stat</span><br><span class="line">	 * so we can safely collect detach_one_task() stats here rather</span><br><span class="line">	 * than inside detach_one_task().</span><br><span class="line">	 */</span><br><span class="line">	schedstat_add(env-&gt;sd, lb_gained[env-&gt;idle], detached);</span><br><span class="line"></span><br><span class="line">	return detached;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|||→</span><br><span class="line"></span><br><span class="line">static</span><br><span class="line">int can_migrate_task(struct task_struct *p, struct lb_env *env)</span><br><span class="line">&#123;</span><br><span class="line">	int tsk_cache_hot;</span><br><span class="line"></span><br><span class="line">	lockdep_assert_held(&amp;env-&gt;src_rq-&gt;lock);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * We do not migrate tasks that are:</span><br><span class="line">	 * 1) throttled_lb_pair, or</span><br><span class="line">	 * 2) cannot be migrated to this CPU due to cpus_allowed, or</span><br><span class="line">	 * 3) running (obviously), or</span><br><span class="line">	 * 4) are cache-hot on their current CPU.</span><br><span class="line">	 */</span><br><span class="line">	/* (7.6.5.1) 如果达到bandwith限制，返回失败 */</span><br><span class="line">	if (throttled_lb_pair(task_group(p), env-&gt;src_cpu, env-&gt;dst_cpu))</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">    /* (7.6.5.2) 如果p进程的cpu affinity不允许迁移到dst_cpu，进一步处理 */</span><br><span class="line">	if (!cpumask_test_cpu(env-&gt;dst_cpu, tsk_cpus_allowed(p))) &#123;</span><br><span class="line">		int cpu;</span><br><span class="line"></span><br><span class="line">		schedstat_inc(p, se.statistics.nr_failed_migrations_affine);</span><br><span class="line"></span><br><span class="line">        /* (7.6.5.3) LBF_SOME_PINNED标志，记录有些进程迁移失败 */</span><br><span class="line">		env-&gt;flags |= LBF_SOME_PINNED;</span><br><span class="line"></span><br><span class="line">        /* (7.6.5.5) 如果已经有其他的LBF_DST_PINNED动作，直接返回失败 */</span><br><span class="line">		/*</span><br><span class="line">		 * Remember if this task can be migrated to any other cpu in</span><br><span class="line">		 * our sched_group. We may want to revisit it if we couldn&apos;t</span><br><span class="line">		 * meet load balance goals by pulling other tasks on src_cpu.</span><br><span class="line">		 *</span><br><span class="line">		 * Also avoid computing new_dst_cpu if we have already computed</span><br><span class="line">		 * one in current iteration.</span><br><span class="line">		 */</span><br><span class="line">		if (!env-&gt;dst_grpmask || (env-&gt;flags &amp; LBF_DST_PINNED))</span><br><span class="line">			return 0;</span><br><span class="line"></span><br><span class="line">        /* (7.6.5.4) 如果dst_cpu同一sched_group中的其他cpu符合p的affinity，尝试更改dst_cpu，</span><br><span class="line">            设置LBF_DST_PINNED标志</span><br><span class="line">         */</span><br><span class="line">		/* Prevent to re-select dst_cpu via env&apos;s cpus */</span><br><span class="line">		for_each_cpu_and(cpu, env-&gt;dst_grpmask, env-&gt;cpus) &#123;</span><br><span class="line">			if (cpumask_test_cpu(cpu, tsk_cpus_allowed(p))) &#123;</span><br><span class="line">				env-&gt;flags |= LBF_DST_PINNED;</span><br><span class="line">				env-&gt;new_dst_cpu = cpu;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (7.6.5.6) 有任何符合affinity条件的p，清除LBF_ALL_PINNED标志 */</span><br><span class="line">	/* Record that we found atleast one task that could run on dst_cpu */</span><br><span class="line">	env-&gt;flags &amp;= ~LBF_ALL_PINNED;</span><br><span class="line"></span><br><span class="line">    /* (7.6.5.7) 如果p在running状态，返回失败 */</span><br><span class="line">	if (task_running(env-&gt;src_rq, p)) &#123;</span><br><span class="line">		schedstat_inc(p, se.statistics.nr_failed_migrations_running);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (7.6.5.8) NUMA 相关的一些判断  */</span><br><span class="line">	/*</span><br><span class="line">	 * Aggressive migration if:</span><br><span class="line">	 * 1) destination numa is preferred</span><br><span class="line">	 * 2) task is cache cold, or</span><br><span class="line">	 * 3) too many balance attempts have failed.</span><br><span class="line">	 */</span><br><span class="line">	tsk_cache_hot = migrate_degrades_locality(p, env);</span><br><span class="line">	if (tsk_cache_hot == -1)</span><br><span class="line">		tsk_cache_hot = task_hot(p, env);</span><br><span class="line"></span><br><span class="line">	if (tsk_cache_hot &lt;= 0 ||</span><br><span class="line">	    env-&gt;sd-&gt;nr_balance_failed &gt; env-&gt;sd-&gt;cache_nice_tries) &#123;</span><br><span class="line">		if (tsk_cache_hot == 1) &#123;</span><br><span class="line">			schedstat_inc(env-&gt;sd, lb_hot_gained[env-&gt;idle]);</span><br><span class="line">			schedstat_inc(p, se.statistics.nr_forced_migrations);</span><br><span class="line">		&#125;</span><br><span class="line">		return 1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	schedstat_inc(p, se.statistics.nr_failed_migrations_hot);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|||→</span><br><span class="line"></span><br><span class="line">static unsigned long task_h_load(struct task_struct *p)</span><br><span class="line">&#123;</span><br><span class="line">	struct cfs_rq *cfs_rq = task_cfs_rq(p);</span><br><span class="line"></span><br><span class="line">	update_cfs_rq_h_load(cfs_rq);</span><br><span class="line">	/* (7.6.6.1) task_h_load的目的是在task_group使能时，rq中有多个层次的cfs_rq </span><br><span class="line">	    如果进程p挂载在底层的cfs_rq中，把p的负载转换成顶层cfs_rq的相对负载</span><br><span class="line">	 */</span><br><span class="line">	return div64_ul(p-&gt;se.avg.load_avg * cfs_rq-&gt;h_load,</span><br><span class="line">			cfs_rq_load_avg(cfs_rq) + 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void update_cfs_rq_h_load(struct cfs_rq *cfs_rq)</span><br><span class="line">&#123;</span><br><span class="line">	struct rq *rq = rq_of(cfs_rq);</span><br><span class="line">	struct sched_entity *se = cfs_rq-&gt;tg-&gt;se[cpu_of(rq)];</span><br><span class="line">	u64 now = sched_clock_cpu(cpu_of(rq));</span><br><span class="line">	unsigned long load;</span><br><span class="line"></span><br><span class="line">	/* sched: change to jiffies */</span><br><span class="line">	now = now * HZ &gt;&gt; 30;</span><br><span class="line"></span><br><span class="line">	if (cfs_rq-&gt;last_h_load_update == now)</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">    /* 从底层cfs_rq到顶层cfs_rq建立起层次关系 */</span><br><span class="line">	cfs_rq-&gt;h_load_next = NULL;</span><br><span class="line">	for_each_sched_entity(se) &#123;</span><br><span class="line">		cfs_rq = cfs_rq_of(se);</span><br><span class="line">		cfs_rq-&gt;h_load_next = se;</span><br><span class="line">		if (cfs_rq-&gt;last_h_load_update == now)</span><br><span class="line">			break;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (!se) &#123;</span><br><span class="line">		cfs_rq-&gt;h_load = cfs_rq_load_avg(cfs_rq);</span><br><span class="line">		cfs_rq-&gt;last_h_load_update = now;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* 使用建立的关系，从顶层cfs_rq开始计算每个层次cfs_rq的相对顶层负载h_load */</span><br><span class="line">	while ((se = cfs_rq-&gt;h_load_next) != NULL) &#123;</span><br><span class="line">		load = cfs_rq-&gt;h_load;</span><br><span class="line">		load = div64_ul(load * se-&gt;avg.load_avg,</span><br><span class="line">			cfs_rq_load_avg(cfs_rq) + 1);</span><br><span class="line">		cfs_rq = group_cfs_rq(se);</span><br><span class="line">		cfs_rq-&gt;h_load = load;</span><br><span class="line">		cfs_rq-&gt;last_h_load_update = now;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-1-2-2、nohz-idle-balance"><a href="#4-1-2-2、nohz-idle-balance" class="headerlink" title="4.1.2.2、nohz_idle_balance()"></a>4.1.2.2、nohz_idle_balance()</h4><p>每个cpu的负载均衡是在本cpu的tick任务scheduler_tick()中判断执行的，如果cpu进入了nohz模式scheduler_tick()被stop，那么本cpu没有机会去做rebalance_domains()。为了解决这个问题，系统设计了nohz_idle_balance()，在运行的cpu上判断进入nohz的cpu是否需要rebalance load，如果需要选择一个idle cpu来帮所有的nohz idle cpu做负载均衡。</p>
<p>在rebalance_domains()函数之前有一个nohz_idle_balance()，这是系统在条件满足的情况下让一个idle cpu做idle负载均衡。主要的原理如下：</p>
<ul>
<li>1、cpu在进入nohz idle状态时，设置标志：</li>
</ul>
<p><img src="/images/scheduler/schedule_nohz_balance_step1.png" alt="schedule_nohz_balance_step1"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">tick_nohz_idle_enter() -&gt; set_cpu_sd_state_idle():</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">void set_cpu_sd_state_idle(void)</span><br><span class="line">&#123;</span><br><span class="line">	struct sched_domain *sd;</span><br><span class="line">	int cpu = smp_processor_id();</span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	sd = rcu_dereference(per_cpu(sd_busy, cpu));</span><br><span class="line"></span><br><span class="line">	if (!sd || sd-&gt;nohz_idle)</span><br><span class="line">		goto unlock;</span><br><span class="line">	</span><br><span class="line">	/* (1.1) 进入nohz idle，设置sd-&gt;nohz_idle标志 */</span><br><span class="line">	sd-&gt;nohz_idle = 1;</span><br><span class="line"></span><br><span class="line">    /* (1.2) 减少sgc-&gt;nr_busy_cpus的计数 */</span><br><span class="line">	atomic_dec(&amp;sd-&gt;groups-&gt;sgc-&gt;nr_busy_cpus);</span><br><span class="line">unlock:</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tick_nohz_idle_enter() -&gt; __tick_nohz_idle_enter() -&gt; tick_nohz_stop_sched_tick() -&gt; nohz_balance_enter_idle():</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">void nohz_balance_enter_idle(int cpu)</span><br><span class="line">&#123;</span><br><span class="line">	/*</span><br><span class="line">	 * If this cpu is going down, then nothing needs to be done.</span><br><span class="line">	 */</span><br><span class="line">	if (!cpu_active(cpu))</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	if (test_bit(NOHZ_TICK_STOPPED, nohz_flags(cpu)))</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * If we&apos;re a completely isolated CPU, we don&apos;t play.</span><br><span class="line">	 */</span><br><span class="line">	if (on_null_domain(cpu_rq(cpu)))</span><br><span class="line">		return;</span><br><span class="line">    </span><br><span class="line">    /* (2.1) 进入idle状态，设置nohz.idle_cpus_mask中对应的bit */</span><br><span class="line">	cpumask_set_cpu(cpu, nohz.idle_cpus_mask);</span><br><span class="line">	</span><br><span class="line">	/* (2.2) 进入idle状态，增加nohz.nr_cpus计数 */</span><br><span class="line">	atomic_inc(&amp;nohz.nr_cpus);</span><br><span class="line">	</span><br><span class="line">	/* (2.3) 设置cpu_rq(cpu)-&gt;nohz_flags中的NOHZ_TICK_STOPPED标志 */</span><br><span class="line">	set_bit(NOHZ_TICK_STOPPED, nohz_flags(cpu));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>2、在trigger_load_balance()中判断，当前是否需要触发idle load balance：</li>
</ul>
<p><img src="/images/scheduler/schedule_nohz_balance_step2.png" alt="schedule_nohz_balance_step2"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line">void trigger_load_balance(struct rq *rq)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    /* (1) 判断当前是否需要idle load balance */</span><br><span class="line">	if (nohz_kick_needed(rq))</span><br><span class="line">	    </span><br><span class="line">	    /* (2) 选中一个idle cpu去做idle load balance */</span><br><span class="line">		nohz_balancer_kick();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Current heuristic for kicking the idle load balancer in the presence</span><br><span class="line"> * of an idle cpu in the system.</span><br><span class="line"> *   - This rq has more than one task.</span><br><span class="line"> *   - This rq has at least one CFS task and the capacity of the CPU is</span><br><span class="line"> *     significantly reduced because of RT tasks or IRQs.</span><br><span class="line"> *   - At parent of LLC scheduler domain level, this cpu&apos;s scheduler group has</span><br><span class="line"> *     multiple busy cpu.</span><br><span class="line"> *   - For SD_ASYM_PACKING, if the lower numbered cpu&apos;s in the scheduler</span><br><span class="line"> *     domain span are idle.</span><br><span class="line"> */</span><br><span class="line">static inline bool nohz_kick_needed(struct rq *rq)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned long now = jiffies;</span><br><span class="line">	struct sched_domain *sd;</span><br><span class="line">	struct sched_group_capacity *sgc;</span><br><span class="line">	int nr_busy, cpu = rq-&gt;cpu;</span><br><span class="line">	bool kick = false;</span><br><span class="line"></span><br><span class="line">    /* (1.1) 如果当前cpu为idle状态，失败退出 */</span><br><span class="line">	if (unlikely(rq-&gt;idle_balance))</span><br><span class="line">		return false;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /* (1.2) 退出nohz状态：set_cpu_sd_state_busy()、nohz_balance_exit_idle(cpu)</span><br><span class="line">        是set_cpu_sd_state_idle()、nohz_balance_enter_idle()的反向操作</span><br><span class="line">     */</span><br><span class="line">   /*</span><br><span class="line">	* We may be recently in ticked or tickless idle mode. At the first</span><br><span class="line">	* busy tick after returning from idle, we will update the busy stats.</span><br><span class="line">	*/</span><br><span class="line">	set_cpu_sd_state_busy();</span><br><span class="line">	nohz_balance_exit_idle(cpu);</span><br><span class="line"></span><br><span class="line">    /* (1.3) 如果进入nohz idle状态的cpu数量为0，失败退出 */</span><br><span class="line">	/*</span><br><span class="line">	 * None are in tickless mode and hence no need for NOHZ idle load</span><br><span class="line">	 * balancing.</span><br><span class="line">	 */</span><br><span class="line">	if (likely(!atomic_read(&amp;nohz.nr_cpus)))</span><br><span class="line">		return false;</span><br><span class="line"></span><br><span class="line">    /* (1.4) nohz balance时间未到，失败退出 */</span><br><span class="line">	if (time_before(now, nohz.next_balance))</span><br><span class="line">		return false;</span><br><span class="line"></span><br><span class="line">#if !defined(CONFIG_MTK_LOAD_BALANCE_ENHANCEMENT) &amp;&amp; defined(CONFIG_HMP)</span><br><span class="line">	/* for more than two clusters, still need wakup nohz CPUs and force balancing */</span><br><span class="line">	/*</span><br><span class="line">	 * Bail out if there are no nohz CPUs in our</span><br><span class="line">	 * HMP domain, since we will move tasks between</span><br><span class="line">	 * domains through wakeup and force balancing</span><br><span class="line">	 * as necessary based upon task load.</span><br><span class="line">	 */</span><br><span class="line">	if (sched_feat(SCHED_HMP) &amp;&amp; cpumask_first_and(nohz.idle_cpus_mask,</span><br><span class="line">				&amp;((struct hmp_domain *)hmp_cpu_domain(cpu))-&gt;cpus) &gt;= nr_cpu_ids)</span><br><span class="line">		return false;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    /* (1.5) 当前cpu的进程&gt;=2，返回成功 */</span><br><span class="line">	if (rq-&gt;nr_running &gt;= 2 &amp;&amp;</span><br><span class="line">	    (!energy_aware() || cpu_overutilized(cpu)))</span><br><span class="line">		return true;</span><br><span class="line"></span><br><span class="line">    /* (1.6) sd所在sg的nr_busy_cpus&gt;1，返回成功 */</span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	sd = rcu_dereference(per_cpu(sd_busy, cpu));</span><br><span class="line">	if (sd &amp;&amp; !energy_aware()) &#123;</span><br><span class="line">		sgc = sd-&gt;groups-&gt;sgc;</span><br><span class="line">		nr_busy = atomic_read(&amp;sgc-&gt;nr_busy_cpus);</span><br><span class="line"></span><br><span class="line">		if (nr_busy &gt; 1) &#123;</span><br><span class="line">			kick = true;</span><br><span class="line">			goto unlock;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (1.7) 如果所有层次的se个数&gt;=1，且capacity在减少，返回成功 */</span><br><span class="line">	sd = rcu_dereference(rq-&gt;sd);</span><br><span class="line">	if (sd) &#123;</span><br><span class="line">		if ((rq-&gt;cfs.h_nr_running &gt;= 1) &amp;&amp;</span><br><span class="line">				check_cpu_capacity(rq, sd)) &#123;</span><br><span class="line">			kick = true;</span><br><span class="line">			goto unlock;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (1.8) 如果本sd-&gt;span[]中第一个idle cpu &lt; sd_asym，返回成功 */</span><br><span class="line">	sd = rcu_dereference(per_cpu(sd_asym, cpu));</span><br><span class="line">	if (sd &amp;&amp; (cpumask_first_and(nohz.idle_cpus_mask,</span><br><span class="line">				  sched_domain_span(sd)) &lt; cpu)) &#123;</span><br><span class="line">		kick = true;</span><br><span class="line">		goto unlock;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">unlock:</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	return kick;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">static void nohz_balancer_kick(void)</span><br><span class="line">&#123;</span><br><span class="line">	int ilb_cpu;</span><br><span class="line"></span><br><span class="line">	nohz.next_balance++;</span><br><span class="line"></span><br><span class="line">    /* (2.1) 找到所有idle cpu中的第一个idle cpu */</span><br><span class="line">	ilb_cpu = find_new_ilb();</span><br><span class="line"></span><br><span class="line">	if (ilb_cpu &gt;= nr_cpu_ids)</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">    /* (2.2) 给ilb_cpu的cpu_rq(cpu)-&gt;nohz_flags设置NOHZ_BALANCE_KICK标志位 */</span><br><span class="line">	if (test_and_set_bit(NOHZ_BALANCE_KICK, nohz_flags(ilb_cpu)))</span><br><span class="line">		return;</span><br><span class="line">		</span><br><span class="line">	/* (2.3) 使用ipi中断来唤醒ilb_cpu执行idle load balance */</span><br><span class="line">	/*</span><br><span class="line">	 * Use smp_send_reschedule() instead of resched_cpu().</span><br><span class="line">	 * This way we generate a sched IPI on the target cpu which</span><br><span class="line">	 * is idle. And the softirq performing nohz idle load balance</span><br><span class="line">	 * will be run before returning from the IPI.</span><br><span class="line">	 */</span><br><span class="line">	smp_send_reschedule(ilb_cpu);</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* (2.3.1) ilb_cpu倍唤醒后处理IPI_RESCHEDULE，</span><br><span class="line">    会触发一个SCHED_SOFTIRQ软中断来启动run_rebalance_domains()</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">void handle_IPI(int ipinr, struct pt_regs *regs)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned int cpu = smp_processor_id();</span><br><span class="line">	struct pt_regs *old_regs = set_irq_regs(regs);</span><br><span class="line"></span><br><span class="line">	if ((unsigned)ipinr &lt; NR_IPI) &#123;</span><br><span class="line">		trace_ipi_entry_rcuidle(ipi_types[ipinr]);</span><br><span class="line">		__inc_irq_stat(cpu, ipi_irqs[ipinr]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	switch (ipinr) &#123;</span><br><span class="line">	case IPI_RESCHEDULE:</span><br><span class="line">		scheduler_ipi();</span><br><span class="line">		break;</span><br><span class="line">		</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">void scheduler_ipi(void)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">	 * Check if someone kicked us for doing the nohz idle load balance.</span><br><span class="line">	 */</span><br><span class="line">	if (unlikely(got_nohz_idle_kick())) &#123;</span><br><span class="line">		this_rq()-&gt;idle_balance = 1;</span><br><span class="line">		raise_softirq_irqoff(SCHED_SOFTIRQ);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>3、被选中的ilb_cpu被唤醒后，需要帮其他所有idle cpu完成rebalance_domains()工作：</li>
</ul>
<p><img src="/images/scheduler/schedule_nohz_balance_step3.png" alt="schedule_nohz_balance_step3"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">static void nohz_idle_balance(struct rq *this_rq, enum cpu_idle_type idle)</span><br><span class="line">&#123;</span><br><span class="line">	int this_cpu = this_rq-&gt;cpu;</span><br><span class="line">	struct rq *rq;</span><br><span class="line">	int balance_cpu;</span><br><span class="line">	/* Earliest time when we have to do rebalance again */</span><br><span class="line">	unsigned long next_balance = jiffies + 60*HZ;</span><br><span class="line">	int update_next_balance = 0;</span><br><span class="line"></span><br><span class="line">    /* (1) 判断当前cpu是不是被选中被唤醒的ilb_cpu */</span><br><span class="line">	if (idle != CPU_IDLE ||</span><br><span class="line">	    !test_bit(NOHZ_BALANCE_KICK, nohz_flags(this_cpu)))</span><br><span class="line">		goto end;</span><br><span class="line"></span><br><span class="line">    /* (2) 轮询所有进入onhz状态的cpu */</span><br><span class="line">	for_each_cpu(balance_cpu, nohz.idle_cpus_mask) &#123;</span><br><span class="line">	</span><br><span class="line">	    /* (3) 只服务非本cpu，且还是idle状态的cpu </span><br><span class="line">	        ooooo本cpu也是idle状态，不需对本cpu做idle负载均衡？</span><br><span class="line">	        ooooo给其他idle cpu的rq做了负载均衡后，什么时候唤醒其他idle cpu？</span><br><span class="line">	     */</span><br><span class="line">		if (balance_cpu == this_cpu || !idle_cpu(balance_cpu))</span><br><span class="line">			continue;</span><br><span class="line"></span><br><span class="line">        /* (4) 如果本cpu被设置了resched标志，说明有线程被唤醒，退出idle状态 */</span><br><span class="line">		/*</span><br><span class="line">		 * If this cpu gets work to do, stop the load balancing</span><br><span class="line">		 * work being done for other cpus. Next load</span><br><span class="line">		 * balancing owner will pick it up.</span><br><span class="line">		 */</span><br><span class="line">		if (need_resched())</span><br><span class="line">			break;</span><br><span class="line"></span><br><span class="line">        /* (5) 需要做负载均衡的idle进程balance_cpu */</span><br><span class="line">		rq = cpu_rq(balance_cpu);</span><br><span class="line"></span><br><span class="line">        /* (6) 如果balance_cpu的rq-&gt;next_balance时间已到，替其做rebalance_domains() */</span><br><span class="line">		/*</span><br><span class="line">		 * If time for next balance is due,</span><br><span class="line">		 * do the balance.</span><br><span class="line">		 */</span><br><span class="line">		if (time_after_eq(jiffies, rq-&gt;next_balance)) &#123;</span><br><span class="line">			raw_spin_lock_irq(&amp;rq-&gt;lock);</span><br><span class="line">			update_rq_clock(rq);</span><br><span class="line">			</span><br><span class="line">			/* (7) 更新idle cpu因为idle造成的负载衰减 */</span><br><span class="line">			update_idle_cpu_load(rq);</span><br><span class="line">			raw_spin_unlock_irq(&amp;rq-&gt;lock);</span><br><span class="line">			</span><br><span class="line">			/* (8) 对balance_cpu做负载均衡 </span><br><span class="line">			    ooooo做完负载均衡，什么时候唤醒balance_cpu？？</span><br><span class="line">			 */</span><br><span class="line">			rebalance_domains(rq, CPU_IDLE);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (time_after(next_balance, rq-&gt;next_balance)) &#123;</span><br><span class="line">			next_balance = rq-&gt;next_balance;</span><br><span class="line">			update_next_balance = 1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (9) 根据所有进入nohz idle cpu rq的最近的一次到期时间，更新nohz.next_balance */</span><br><span class="line">	/*</span><br><span class="line">	 * next_balance will be updated only when there is a need.</span><br><span class="line">	 * When the CPU is attached to null domain for ex, it will not be</span><br><span class="line">	 * updated.</span><br><span class="line">	 */</span><br><span class="line">	if (likely(update_next_balance))</span><br><span class="line">		nohz.next_balance = next_balance;</span><br><span class="line">end:</span><br><span class="line">	clear_bit(NOHZ_BALANCE_KICK, nohz_flags(this_cpu));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-1-2-3、select-task-rq-fair"><a href="#4-1-2-3、select-task-rq-fair" class="headerlink" title="4.1.2.3、select_task_rq_fair()"></a>4.1.2.3、select_task_rq_fair()</h4><p>除了scheduler_tick()的时候会做负载均衡，另外一个时刻也会做负载均衡。就是fork新进程、wakeup休眠进程时，系统会根据负载均衡挑选一个最合适的cpu给进程运行，其核心函数就是select_task_rq_fair()：</p>
<ul>
<li>1、首先是使用EAS的方法来select_cpu，在EAS使能且没有overutilized时使用EAS方法：</li>
</ul>
<p><strong><em>需要重点提一下的是</em></strong>：负载计算计算了3种负载(load_avg、loadwop_avg、util_avg)，EAS主要使用其中的<strong><em>util_avg</em></strong>，和capacity一起计算。</p>
<ul>
<li>1.1、EAS遍历cluster和cpu，找到一个既能满足进程p的affinity又能容纳下进程p的负载util，属于能用最小capacity满足的cluster其中剩余capacity最多的target_cpu；</li>
</ul>
<p>首先找到能容纳进程p的util且capacity最小的cluster：</p>
<p><img src="/images/scheduler/schedule_select_task_energy_aware_wake_find_cluaster.png" alt="schedule_select_task_energy_aware_wake_find_cluaster"></p>
<p>然后在目标cluster中找到加上进程p以后，剩余capacity最大的cpu：</p>
<p><img src="/images/scheduler/schedule_select_task_energy_aware_find_cpu.png" alt="schedule_select_task_energy_aware_find_cpu"></p>
<p>pre_cpu是进程p上一次运行的cpu作为src_cpu，上面选择的target_cpu作为dst_cpu，就是尝试计算进程p从pre_cpu迁移到target_cpu系统的功耗差异：</p>
<p><img src="/images/scheduler/schedule_select_task_energy_aware_migration_direct.png" alt="schedule_select_task_energy_aware_migration_direct"></p>
<ul>
<li>1.2、计算负载变化前后，target_cpu和prev_cpu带来的power变化。如果没有power增加则返回target_cpu，如果有power增加则返回prev_cpu；</li>
</ul>
<p>计算负载变化的函数energy_diff()循环很多比较复杂，仔细分析下来就是计算target_cpu/prev_cpu在“MC层次cpu所在sg链表”+“DIE层级cpu所在sg”，这两种范围在负载变化中的功耗差异：</p>
<p><img src="/images/scheduler/schedule_select_task_energy_aware_energy_diff.png" alt="schedule_select_task_energy_aware_energy_diff"></p>
<p>energy_diff()的计算方法如下：</p>
<table>
<thead>
<tr>
<th>负载值</th>
<th>计算方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>idle_idx</td>
<td>min(rq-&gt;idle_state_idx)</td>
<td>sg多个cpu中，idle_state_idx最小值</td>
<td></td>
</tr>
<tr>
<td>eenv-&gt;cap_idx</td>
<td>find_new_capacity()</td>
<td>在负载变化后，根据sg多个cpu中的最大util值，匹配的cpu freq档位sg-&gt;sge-&gt;cap_states[eenv-&gt;cap_idx].cap</td>
<td></td>
</tr>
<tr>
<td>group_util</td>
<td>+= (__cpu_util &lt;&lt; SCHED_CAPACITY_SHIFT)/sg-&gt;sge-&gt;cap_states[eenv-&gt;cap_idx].cap</td>
<td>累加sg中cpu的util值，并且把util转换成capacity的反比</td>
<td></td>
</tr>
<tr>
<td>sg_busy_energy</td>
<td>(group_util * sg-&gt;sge-&gt;busy_power(group_first_cpu(sg), eenv, (sd-&gt;child) ? 1 : 0)) &gt;&gt; SCHED_CAPACITY_SHIFT</td>
<td>使用group_util计算busy部分消耗的功耗</td>
<td></td>
</tr>
<tr>
<td>sg_idle_energy</td>
<td>((SCHED_LOAD_SCALE - group_util) * sg-&gt;sge-&gt;idle_power(idle_idx, group_first_cpu(sg), eenv, (sd-&gt;child) ? 1 : 0))  &gt;&gt; SCHED_CAPACITY_SHIFT</td>
<td>使用(SCHED_LOAD_SCALE - group_util)计算idle部分计算的功耗</td>
<td></td>
</tr>
<tr>
<td>total_energy</td>
<td>sg_busy_energy + sg_idle_energy</td>
<td>单个sg的功耗，累计所有相关sg的功耗，总的差异就是进程P迁移以后的功耗差异</td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>2、如果EAS不适应，使用传统的负载均衡方法来select_cpu：</li>
<li>2.1、find_idlest_group() -&gt; find_idlest_cpu() 找出最时候的target_cpu；</li>
<li>2.2、最差的方法使用select_idle_sibling()讲究找到一个idle cpu作为target_cpu；</li>
<li>2.3、确定target_cpu后，继续使用hmp_select_task_rq_fair()来判断是否需要进行hmp迁移；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br></pre></td><td class="code"><pre><span class="line">static int</span><br><span class="line">select_task_rq_fair(struct task_struct *p, int prev_cpu, int sd_flag, int wake_flags)</span><br><span class="line">&#123;</span><br><span class="line">	struct sched_domain *tmp, *affine_sd = NULL, *sd = NULL;</span><br><span class="line">	int cpu = smp_processor_id();</span><br><span class="line">	int new_cpu = prev_cpu;  /* 默认new_cpu为prev_cpu */</span><br><span class="line">	int want_affine = 0;</span><br><span class="line">	int sync = wake_flags &amp; WF_SYNC;</span><br><span class="line">	int policy = 0;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_MTK_SCHED_VIP_TASKS</span><br><span class="line">	/* mtk: If task is VIP task, prefer most efficiency idle cpu */</span><br><span class="line">	if (is_vip_task(p)) &#123;</span><br><span class="line">		int vip_idle_cpu;</span><br><span class="line"></span><br><span class="line">		vip_idle_cpu = find_idle_vip_cpu(p);</span><br><span class="line">		if (vip_idle_cpu &gt;= 0)</span><br><span class="line">			return vip_idle_cpu;</span><br><span class="line">	&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    /* (1) 优先使用EAS计算target cpu， </span><br><span class="line">        mtk 对EAS定义了3种模式：EAS模式(energy_aware())、HMP模式(sched_feat(SCHED_HMP))、hybrid_support(EAS、HMP同时共存)；</span><br><span class="line">        hybrid_support()模式下：一般负载均衡交给EAS；如果cpu_rq(cpu)-&gt;rd-&gt;overutilized负载已经严重不均衡，交给HMP；</span><br><span class="line">     */</span><br><span class="line">	/*</span><br><span class="line">	 *  Consider EAS if only EAS enabled, but HMP</span><br><span class="line">	 *  if hybrid enabled and system is over-utilized.</span><br><span class="line">	 */</span><br><span class="line">	if ((energy_aware() &amp;&amp; !hybrid_support()) ||</span><br><span class="line">			(hybrid_support() &amp;&amp; !cpu_rq(cpu)-&gt;rd-&gt;overutilized))</span><br><span class="line">		goto CONSIDER_EAS;</span><br><span class="line"></span><br><span class="line">    /* (2) 非EAS情况，fork使用hmp balance */</span><br><span class="line">	/* HMP fork balance:</span><br><span class="line">	 * always put non-kernel forking tasks on a big domain</span><br><span class="line">	 */</span><br><span class="line">	if (sched_feat(SCHED_HMP) &amp;&amp; p-&gt;mm &amp;&amp; (sd_flag &amp; SD_BALANCE_FORK)) &#123;</span><br><span class="line">		new_cpu = hmp_fork_balance(p, prev_cpu);</span><br><span class="line"></span><br><span class="line">		/* to recover new_cpu value if something wrong */</span><br><span class="line">		if (new_cpu &gt;= nr_cpu_ids)</span><br><span class="line">			new_cpu = prev_cpu;</span><br><span class="line">		else &#123;</span><br><span class="line">#ifdef CONFIG_MTK_SCHED_TRACERS</span><br><span class="line">			trace_sched_select_task_rq(p, (LB_FORK | new_cpu), prev_cpu, new_cpu);</span><br><span class="line">#endif</span><br><span class="line">			return new_cpu;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">CONSIDER_EAS:</span><br><span class="line"></span><br><span class="line">    /* (3) 如果唤醒flag中设置了SD_BALANCE_WAKE，优先使用唤醒cpu来运行进程p，</span><br><span class="line">        还需判断下面3个条件是否满足：</span><br><span class="line">        !wake_wide(p)           // 当前cpu的唤醒次数没有超标</span><br><span class="line">        task_fits_max(p, cpu)   // 当前cpu的capacity能容纳进程p的util</span><br><span class="line">        cpumask_test_cpu(cpu, tsk_cpus_allowed(p)) // 当前cpu在进程在P的affinity中</span><br><span class="line">        EAS利用了want_affine这个标志，只要EAS使能，want_affine =1</span><br><span class="line">     */</span><br><span class="line">	if (sd_flag &amp; SD_BALANCE_WAKE)</span><br><span class="line">		want_affine = (!wake_wide(p) &amp;&amp; task_fits_max(p, cpu) &amp;&amp;</span><br><span class="line">			      cpumask_test_cpu(cpu, tsk_cpus_allowed(p))) ||</span><br><span class="line">			      energy_aware();</span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	/* (4) 从下往上遍历当前cpu的sd，查询在哪个层次的sd进行负载均衡 */</span><br><span class="line">	for_each_domain(cpu, tmp) &#123;</span><br><span class="line">	</span><br><span class="line">	    /* (4.1 如果当前sd不支持负载均SD_LOAD_BALANCE，退出) */</span><br><span class="line">		if (!(tmp-&gt;flags &amp; SD_LOAD_BALANCE))</span><br><span class="line">			break;</span><br><span class="line"></span><br><span class="line">        /* (4.2) 优先找affine_sd，找到直接break；</span><br><span class="line">            需要符合以下3个条件：</span><br><span class="line">            want_affine                     //</span><br><span class="line">            (tmp-&gt;flags &amp; SD_WAKE_AFFINE)   // 当前sd支持SD_WAKE_AFFINE标志</span><br><span class="line">            cpumask_test_cpu(prev_cpu, sched_domain_span(tmp))  //当前sd-&gt;span[]中同时包含cpu、pre_cpu</span><br><span class="line">         */</span><br><span class="line">		/*</span><br><span class="line">		 * If both cpu and prev_cpu are part of this domain,</span><br><span class="line">		 * cpu is a valid SD_WAKE_AFFINE target.</span><br><span class="line">		 */</span><br><span class="line">		if (want_affine &amp;&amp; (tmp-&gt;flags &amp; SD_WAKE_AFFINE) &amp;&amp;</span><br><span class="line">		    cpumask_test_cpu(prev_cpu, sched_domain_span(tmp))) &#123;</span><br><span class="line">			affine_sd = tmp;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        /* (4.3) 其次找一个符合sd_flag的sd */</span><br><span class="line">		if (tmp-&gt;flags &amp; sd_flag)</span><br><span class="line">			sd = tmp;</span><br><span class="line">		/* (4.4) 如果以上都失败，直接跳出 */</span><br><span class="line">		else if (!want_affine)</span><br><span class="line">			break;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (5) 如果affine_sd成功找到</span><br><span class="line">     */</span><br><span class="line">	if (affine_sd) &#123;</span><br><span class="line">		sd = NULL; /* Prefer wake_affine over balance flags */</span><br><span class="line">		if (cpu != prev_cpu &amp;&amp; wake_affine(affine_sd, p, sync))</span><br><span class="line">			new_cpu = cpu;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (6) 没有找到符合sd_flag的sd */</span><br><span class="line">	if (!sd) &#123;</span><br><span class="line">	    /* (6.1) EAS使能，且本cpu没有overutilized， </span><br><span class="line">	        使用EAS负载均衡算法</span><br><span class="line">	     */</span><br><span class="line">		if (energy_aware() &amp;&amp; !cpu_rq(cpu)-&gt;rd-&gt;overutilized) &#123;</span><br><span class="line">			new_cpu = energy_aware_wake_cpu(p, prev_cpu);</span><br><span class="line">			policy |= LB_EAS;</span><br><span class="line">		&#125;</span><br><span class="line">		/* (6.2) 如果不能使用EAS，且sd_flag中设置SD_BALANCE_WAKE标志 </span><br><span class="line">		    尝试在唤醒的cpu上运行p进程,</span><br><span class="line">		    ooooo前面辛苦计算的affine_sd没有派上用场？</span><br><span class="line">		 */</span><br><span class="line">		else if (sd_flag &amp; SD_BALANCE_WAKE) &#123; /* XXX always ? */</span><br><span class="line">			if (true) &#123;</span><br><span class="line">#ifdef CONFIG_CGROUP_SCHEDTUNE</span><br><span class="line">				bool prefer_idle = schedtune_prefer_idle(p) &gt; 0;</span><br><span class="line">#else</span><br><span class="line">				bool prefer_idle = true;</span><br><span class="line">#endif</span><br><span class="line">				int idle_cpu;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">				idle_cpu = find_best_idle_cpu(p, prefer_idle);</span><br><span class="line">				if (idle_cpu &gt;= 0) &#123;</span><br><span class="line">					new_cpu = idle_cpu;</span><br><span class="line">					policy |= LB_IDLEST;</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					new_cpu = select_max_spare_capacity_cpu(p, new_cpu);</span><br><span class="line">					policy |= LB_SPARE;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; else</span><br><span class="line">			/* (6.3) 不符合上述条件下的默认处理，尝试找一个idle cpu */</span><br><span class="line">				new_cpu = select_idle_sibling(p, new_cpu);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; else while (sd) &#123;</span><br><span class="line">	/* (7) 找到符合sd_flag的sd */</span><br><span class="line">		struct sched_group *group;</span><br><span class="line">		int weight;</span><br><span class="line"></span><br><span class="line">		policy |= LB_SMP;</span><br><span class="line"></span><br><span class="line">        /* (7.1) */</span><br><span class="line">		if (!(sd-&gt;flags &amp; sd_flag)) &#123;</span><br><span class="line">			sd = sd-&gt;child;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        /* (7.2) */</span><br><span class="line">		group = find_idlest_group(sd, p, cpu, sd_flag);</span><br><span class="line">		if (!group) &#123;</span><br><span class="line">			sd = sd-&gt;child;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        /* (7.3) */</span><br><span class="line">		new_cpu = find_idlest_cpu(group, p, cpu);</span><br><span class="line">		if (new_cpu == -1 || new_cpu == cpu) &#123;</span><br><span class="line">			/* Now try balancing at a lower domain level of cpu */</span><br><span class="line">			sd = sd-&gt;child;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        /* (7.4) */</span><br><span class="line">		/* Now try balancing at a lower domain level of new_cpu */</span><br><span class="line">		cpu = new_cpu;</span><br><span class="line">		weight = sd-&gt;span_weight;</span><br><span class="line">		sd = NULL;</span><br><span class="line">		for_each_domain(cpu, tmp) &#123;</span><br><span class="line">			if (weight &lt;= tmp-&gt;span_weight)</span><br><span class="line">				break;</span><br><span class="line">			if (tmp-&gt;flags &amp; sd_flag)</span><br><span class="line">				sd = tmp;</span><br><span class="line">		&#125;</span><br><span class="line">		/* while loop will break here if sd == NULL */</span><br><span class="line">	&#125;</span><br><span class="line">#ifdef CONFIG_MTK_SCHED_TRACERS</span><br><span class="line">	policy |= (new_cpu &lt;&lt; LB_SMP_SHIFT);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    /* (8) 在EAS不能运行的情况下，在做一次HMP的select操作：</span><br><span class="line">        判断进程p是否符合hmp的迁移条件，如果符合一次迁移到位，避免后续hmp的操作</span><br><span class="line">     */</span><br><span class="line">	/*  Consider hmp if no EAS  or over-utiled in hybrid mode. */</span><br><span class="line">	if ((!energy_aware() &amp;&amp; sched_feat(SCHED_HMP)) ||</span><br><span class="line">		(hybrid_support() &amp;&amp; cpu_rq(cpu)-&gt;rd-&gt;overutilized)) &#123;</span><br><span class="line"></span><br><span class="line">		new_cpu = hmp_select_task_rq_fair(sd_flag, p, prev_cpu, new_cpu);</span><br><span class="line">#ifdef CONFIG_MTK_SCHED_TRACERS</span><br><span class="line">		policy |= (new_cpu &lt;&lt; LB_HMP_SHIFT);</span><br><span class="line">#endif</span><br><span class="line">		policy |= LB_HMP;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_MTK_SCHED_TRACERS</span><br><span class="line">	trace_sched_select_task_rq(p, policy, prev_cpu, new_cpu);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	return new_cpu;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">inline int hmp_fork_balance(struct task_struct *p, int prev_cpu)</span><br><span class="line">&#123;</span><br><span class="line">	int new_cpu = prev_cpu;</span><br><span class="line">	int cpu = smp_processor_id();</span><br><span class="line"></span><br><span class="line">    /* (2.1) prev_cpu所在cluster是最快(fastest)的  */</span><br><span class="line">	if (hmp_cpu_is_fastest(prev_cpu)) &#123;</span><br><span class="line">		/* prev_cpu is fastest domain */</span><br><span class="line">		struct hmp_domain *hmpdom;</span><br><span class="line">		__always_unused int lowest_ratio;</span><br><span class="line"></span><br><span class="line">		hmpdom = list_entry(</span><br><span class="line">				&amp;hmp_cpu_domain(prev_cpu)-&gt;hmp_domains,</span><br><span class="line">				struct hmp_domain, hmp_domains);</span><br><span class="line"></span><br><span class="line">        /* (2.2) 尝试选出负载最小的cpu */</span><br><span class="line">		lowest_ratio = hmp_domain_min_load(hmpdom, &amp;new_cpu);</span><br><span class="line"></span><br><span class="line">		if (new_cpu &lt; nr_cpu_ids &amp;&amp; cpumask_test_cpu(new_cpu, tsk_cpus_allowed(p)))</span><br><span class="line">			return new_cpu;</span><br><span class="line"></span><br><span class="line">		new_cpu = cpumask_any_and(&amp;hmp_faster_domain(cpu)-&gt;cpus,</span><br><span class="line">				tsk_cpus_allowed(p));</span><br><span class="line"></span><br><span class="line">		if (new_cpu &lt; nr_cpu_ids)</span><br><span class="line">			return new_cpu;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">	    /* (2.3) 尝试选出prev_cpu所在cluster中负载最小的cpu */</span><br><span class="line">		/* prev_cpu is not fastest domain */</span><br><span class="line">		new_cpu = hmp_select_faster_cpu(p, prev_cpu);</span><br><span class="line"></span><br><span class="line">		if (new_cpu &lt; nr_cpu_ids)</span><br><span class="line">			return new_cpu;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return new_cpu;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">static int wake_affine(struct sched_domain *sd, struct task_struct *p, int sync)</span><br><span class="line">&#123;</span><br><span class="line">	s64 this_load, load;</span><br><span class="line">	s64 this_eff_load, prev_eff_load;</span><br><span class="line">	int idx, this_cpu, prev_cpu;</span><br><span class="line">	struct task_group *tg;</span><br><span class="line">	unsigned long weight;</span><br><span class="line">	int balanced;</span><br><span class="line"></span><br><span class="line">	idx	  = sd-&gt;wake_idx;</span><br><span class="line">	this_cpu  = smp_processor_id();</span><br><span class="line">	prev_cpu  = task_cpu(p);</span><br><span class="line">	load	  = source_load(prev_cpu, idx);</span><br><span class="line">	this_load = target_load(this_cpu, idx);</span><br><span class="line"></span><br><span class="line">    /* (5.1) */</span><br><span class="line">	/*</span><br><span class="line">	 * If sync wakeup then subtract the (maximum possible)</span><br><span class="line">	 * effect of the currently running task from the load</span><br><span class="line">	 * of the current CPU:</span><br><span class="line">	 */</span><br><span class="line">	if (sync) &#123;</span><br><span class="line">		tg = task_group(current);</span><br><span class="line">		weight = current-&gt;se.avg.load_avg;</span><br><span class="line"></span><br><span class="line">		this_load += effective_load(tg, this_cpu, -weight, -weight);</span><br><span class="line">		load += effective_load(tg, prev_cpu, 0, -weight);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	tg = task_group(p);</span><br><span class="line">	weight = p-&gt;se.avg.load_avg;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * In low-load situations, where prev_cpu is idle and this_cpu is idle</span><br><span class="line">	 * due to the sync cause above having dropped this_load to 0, we&apos;ll</span><br><span class="line">	 * always have an imbalance, but there&apos;s really nothing you can do</span><br><span class="line">	 * about that, so that&apos;s good too.</span><br><span class="line">	 *</span><br><span class="line">	 * Otherwise check if either cpus are near enough in load to allow this</span><br><span class="line">	 * task to be woken on this_cpu.</span><br><span class="line">	 */</span><br><span class="line">	this_eff_load = 100;</span><br><span class="line">	this_eff_load *= capacity_of(prev_cpu);</span><br><span class="line"></span><br><span class="line">	prev_eff_load = 100 + (sd-&gt;imbalance_pct - 100) / 2;</span><br><span class="line">	prev_eff_load *= capacity_of(this_cpu);</span><br><span class="line"></span><br><span class="line">	if (this_load &gt; 0) &#123;</span><br><span class="line">		this_eff_load *= this_load +</span><br><span class="line">			effective_load(tg, this_cpu, weight, weight);</span><br><span class="line"></span><br><span class="line">		prev_eff_load *= load + effective_load(tg, prev_cpu, 0, weight);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	balanced = this_eff_load &lt;= prev_eff_load;</span><br><span class="line"></span><br><span class="line">	schedstat_inc(p, se.statistics.nr_wakeups_affine_attempts);</span><br><span class="line"></span><br><span class="line">	if (!balanced)</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">	schedstat_inc(sd, ttwu_move_affine);</span><br><span class="line">	schedstat_inc(p, se.statistics.nr_wakeups_affine);</span><br><span class="line"></span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">static int energy_aware_wake_cpu(struct task_struct *p, int target)</span><br><span class="line">&#123;</span><br><span class="line">	int target_max_cap = INT_MAX;</span><br><span class="line">	int target_cpu = task_cpu(p);</span><br><span class="line">	unsigned long min_util;</span><br><span class="line">	unsigned long new_util;</span><br><span class="line">	int i, cpu;</span><br><span class="line">	bool is_tiny = false;</span><br><span class="line">	int nrg_diff = 0;</span><br><span class="line">	int cluster_id = 0;</span><br><span class="line">	struct cpumask cluster_cpus;</span><br><span class="line">	int max_cap_cpu = 0;</span><br><span class="line">	int best_cpu = 0;</span><br><span class="line"></span><br><span class="line">    /* (6.1.1) 遍历cluster和cpu，找出一个capacity最小的cpu能容纳下util(p)为best_cpu */</span><br><span class="line">	/*</span><br><span class="line">	 * Find group with sufficient capacity. We only get here if no cpu is</span><br><span class="line">	 * overutilized. We may end up overutilizing a cpu by adding the task,</span><br><span class="line">	 * but that should not be any worse than select_idle_sibling().</span><br><span class="line">	 * load_balance() should sort it out later as we get above the tipping</span><br><span class="line">	 * point.</span><br><span class="line">	 */</span><br><span class="line">	cluster_id = arch_get_nr_clusters();</span><br><span class="line">	for (i = 0; i &lt; cluster_id; i++) &#123;</span><br><span class="line">		arch_get_cluster_cpus(&amp;cluster_cpus, i);</span><br><span class="line">		max_cap_cpu = cpumask_first(&amp;cluster_cpus);</span><br><span class="line"></span><br><span class="line">		/* Assuming all cpus are the same in group */</span><br><span class="line">		for_each_cpu(cpu, &amp;cluster_cpus) &#123;</span><br><span class="line"></span><br><span class="line">			if (!cpu_online(cpu))</span><br><span class="line">				continue;</span><br><span class="line"></span><br><span class="line">			if (capacity_of(max_cap_cpu) &lt; target_max_cap &amp;&amp;</span><br><span class="line">			task_fits_max(p, max_cap_cpu)) &#123;</span><br><span class="line">				best_cpu = cpu;</span><br><span class="line">				target_max_cap = capacity_of(max_cap_cpu);</span><br><span class="line">			&#125;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (task_util(p) &lt; TINY_TASK_THRESHOLD)</span><br><span class="line">		is_tiny = true;</span><br><span class="line"></span><br><span class="line">	/* Find cpu with sufficient capacity */</span><br><span class="line">	min_util = boosted_task_util(p);</span><br><span class="line">	if (!is_tiny)</span><br><span class="line">	    /* (6.1.2) 根据best_cpu所在的cluster和进程p的affinity，</span><br><span class="line">	        找出加上util(p)以后，剩余capacity最大的cpu：target_cpu</span><br><span class="line">	     */</span><br><span class="line">		target_cpu = select_max_spare_capacity_cpu(p, best_cpu);</span><br><span class="line">	else</span><br><span class="line">	    /* (6.1.3) 根据cluster和进程p的affinity，</span><br><span class="line">	        找出加上util(p)以后，当前freq的capacity能满足的第一个cpu：target_cpu</span><br><span class="line">	     */</span><br><span class="line">		for_each_cpu_and(i, tsk_cpus_allowed(p), &amp;cluster_cpus) &#123;</span><br><span class="line"></span><br><span class="line">			if (!cpu_online(i))</span><br><span class="line">				continue;</span><br><span class="line"></span><br><span class="line">			/*</span><br><span class="line">			 * p&apos;s blocked utilization is still accounted for on prev_cpu</span><br><span class="line">			 * so prev_cpu will receive a negative bias due to the double</span><br><span class="line">			 * accounting. However, the blocked utilization may be zero.</span><br><span class="line">			 */</span><br><span class="line">			new_util = cpu_util(i) + task_util(p);</span><br><span class="line"></span><br><span class="line">			/*</span><br><span class="line">			 * Ensure minimum capacity to grant the required boost.</span><br><span class="line">			 * The target CPU can be already at a capacity level higher</span><br><span class="line">			 * than the one required to boost the task.</span><br><span class="line">			 */</span><br><span class="line">			new_util = max(min_util, new_util);</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_MTK_SCHED_INTEROP</span><br><span class="line">			if (cpu_rq(i)-&gt;rt.rt_nr_running &amp;&amp; likely(!is_rt_throttle(i)))</span><br><span class="line">				continue;</span><br><span class="line">#endif</span><br><span class="line">			if (new_util &gt; capacity_orig_of(i))</span><br><span class="line">				continue;</span><br><span class="line"></span><br><span class="line">			if (new_util &lt; capacity_curr_of(i)) &#123;</span><br><span class="line">				target_cpu = i;</span><br><span class="line">				if (cpu_rq(i)-&gt;nr_running)</span><br><span class="line">					break;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			/* cpu has capacity at higher OPP, keep it as fallback */</span><br><span class="line">			if (target_cpu == task_cpu(p))</span><br><span class="line">				target_cpu = i;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">    /* (6.1.4) 如果pre_cpu和target_cpu是同一个cluster，直接成功返回 */</span><br><span class="line">	/* no need energy calculation if the same domain */</span><br><span class="line">	if (is_the_same_domain(task_cpu(p), target_cpu))</span><br><span class="line">		return target_cpu;</span><br><span class="line"></span><br><span class="line">	/* no energy comparison if the same cluster */</span><br><span class="line">	if (target_cpu != task_cpu(p)) &#123;</span><br><span class="line">	    </span><br><span class="line">	    /* (6.1.5) 构造需要迁移的环境变量  */</span><br><span class="line">		struct energy_env eenv = &#123;</span><br><span class="line">			.util_delta	= task_util(p),</span><br><span class="line">			.src_cpu	= task_cpu(p),</span><br><span class="line">			.dst_cpu	= target_cpu,</span><br><span class="line">			.task		= p,</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		/* Not enough spare capacity on previous cpu */</span><br><span class="line">		if (cpu_overutilized(task_cpu(p))) &#123;</span><br><span class="line">			trace_energy_aware_wake_cpu(p, task_cpu(p), target_cpu,</span><br><span class="line">					(int)task_util(p), nrg_diff, true, is_tiny);</span><br><span class="line">			return target_cpu;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        /* (6.1.6) 计算进程p从pre_cpu迁移到target_cpu后的功耗差值nrg_diff，</span><br><span class="line">            如果功耗增加，nrg_diff &gt;= 0，返回pre_cpu即task_cpu(p)，</span><br><span class="line">            如果功耗减少，返回新的target_cpu</span><br><span class="line">         */</span><br><span class="line">		nrg_diff = energy_diff(&amp;eenv);</span><br><span class="line">		if (nrg_diff &gt;= 0) &#123;</span><br><span class="line">			trace_energy_aware_wake_cpu(p, task_cpu(p), target_cpu,</span><br><span class="line">					(int)task_util(p), nrg_diff, false, is_tiny);</span><br><span class="line">			return task_cpu(p);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	trace_energy_aware_wake_cpu(p, task_cpu(p), target_cpu, (int)task_util(p), nrg_diff, false, is_tiny);</span><br><span class="line">	return target_cpu;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">||→</span><br><span class="line"></span><br><span class="line">static inline int</span><br><span class="line">energy_diff(struct energy_env *eenv)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned int boost;</span><br><span class="line">	int nrg_delta;</span><br><span class="line"></span><br><span class="line">	/* Conpute &quot;absolute&quot; energy diff */</span><br><span class="line">	__energy_diff(eenv);</span><br><span class="line"></span><br><span class="line">	/* Return energy diff when boost margin is 0 */</span><br><span class="line">#ifdef CONFIG_CGROUP_SCHEDTUNE</span><br><span class="line">	boost = schedtune_task_boost(eenv-&gt;task);</span><br><span class="line">#else</span><br><span class="line">	boost = get_sysctl_sched_cfs_boost();</span><br><span class="line">#endif</span><br><span class="line">	if (boost == 0)</span><br><span class="line">		return eenv-&gt;nrg.diff;</span><br><span class="line"></span><br><span class="line">	/* Compute normalized energy diff */</span><br><span class="line">	nrg_delta = normalize_energy(eenv-&gt;nrg.diff);</span><br><span class="line">	eenv-&gt;nrg.delta = nrg_delta;</span><br><span class="line"></span><br><span class="line">	eenv-&gt;payoff = schedtune_accept_deltas(</span><br><span class="line">			eenv-&gt;nrg.delta,</span><br><span class="line">			eenv-&gt;cap.delta,</span><br><span class="line">			eenv-&gt;task);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * When SchedTune is enabled, the energy_diff() function will return</span><br><span class="line">	 * the computed energy payoff value. Since the energy_diff() return</span><br><span class="line">	 * value is expected to be negative by its callers, this evaluation</span><br><span class="line">	 * function return a negative value each time the evaluation return a</span><br><span class="line">	 * positive payoff, which is the condition for the acceptance of</span><br><span class="line">	 * a scheduling decision</span><br><span class="line">	 */</span><br><span class="line">	return -eenv-&gt;payoff;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int __energy_diff(struct energy_env *eenv)</span><br><span class="line">&#123;</span><br><span class="line">	struct sched_domain *sd;</span><br><span class="line">	struct sched_group *sg;</span><br><span class="line">	int sd_cpu = -1, energy_before = 0, energy_after = 0;</span><br><span class="line">	</span><br><span class="line">	/* (6.1.6.1) 构造迁移前的环境变量  */</span><br><span class="line">	struct energy_env eenv_before = &#123;</span><br><span class="line">		.util_delta	= 0,</span><br><span class="line">		.src_cpu	= eenv-&gt;src_cpu,</span><br><span class="line">		.dst_cpu	= eenv-&gt;dst_cpu,</span><br><span class="line">		.nrg		= &#123; 0, 0, 0, 0&#125;,</span><br><span class="line">		.cap		= &#123; 0, 0, 0 &#125;,</span><br><span class="line">	&#125;;</span><br><span class="line">#ifdef CONFIG_MTK_SCHED_EAS_POWER_SUPPORT</span><br><span class="line">	int i;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	if (eenv-&gt;src_cpu == eenv-&gt;dst_cpu)</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_MTK_SCHED_EAS_POWER_SUPPORT</span><br><span class="line">	/* To get max opp index of every cluster for power estimation of share buck */</span><br><span class="line">	for (i = 0; i &lt; arch_get_nr_clusters(); i++) &#123;</span><br><span class="line">		/* for energy before */</span><br><span class="line">		eenv_before.opp_idx[i]  = mtk_cluster_capacity_idx(i, &amp;eenv_before);</span><br><span class="line"></span><br><span class="line">		/* for energy after */</span><br><span class="line">		eenv-&gt;opp_idx[i]  = mtk_cluster_capacity_idx(i, eenv);</span><br><span class="line"></span><br><span class="line">		mt_sched_printf(sched_eas_energy_calc, &quot;cid=%d, before max_opp:%d, after max_opp:%d\n&quot;,</span><br><span class="line">					i, eenv_before.opp_idx[i], eenv-&gt;opp_idx[i]);</span><br><span class="line">	&#125;</span><br><span class="line">#endif</span><br><span class="line">    </span><br><span class="line">    /* (6.1.6.2) sd来至于cache sd_ea，是cpu对应的顶层sd(tl DIE层) */</span><br><span class="line">	sd_cpu = (eenv-&gt;src_cpu != -1) ? eenv-&gt;src_cpu : eenv-&gt;dst_cpu;</span><br><span class="line">	sd = rcu_dereference(per_cpu(sd_ea, sd_cpu));</span><br><span class="line"></span><br><span class="line">	if (!sd)</span><br><span class="line">		return 0; /* Error */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	mt_sched_printf(sched_eas_energy_calc, &quot;0. %s: move task from src=%d to dst=%d util=%d&quot;,</span><br><span class="line">				__func__, eenv-&gt;src_cpu, eenv-&gt;dst_cpu, eenv-&gt;util_delta);</span><br><span class="line"></span><br><span class="line">	sg = sd-&gt;groups;</span><br><span class="line"></span><br><span class="line">    /* (6.1.6.3) 遍历sg所在sg链表，找到符合条件的sg， </span><br><span class="line">        累加计算eenv_before、eenv相关sg的功耗</span><br><span class="line">     */ </span><br><span class="line">	do &#123;</span><br><span class="line">	    /* (6.1.6.4) 如果当前sg包含src_cpu或者dst_cpu，计算 */</span><br><span class="line">		if (cpu_in_sg(sg, eenv-&gt;src_cpu) || cpu_in_sg(sg, eenv-&gt;dst_cpu)) &#123;</span><br><span class="line">		</span><br><span class="line">		    /* (6.1.6.5) 当前顶层sg为eenv的sg_top  */</span><br><span class="line">			eenv_before.sg_top = eenv-&gt;sg_top = sg;</span><br><span class="line"></span><br><span class="line">			mt_sched_printf(sched_eas_energy_calc, &quot;1. %s: src=%d dst=%d mask=0x%lx (before)&quot;,</span><br><span class="line">					__func__,  eenv_before.src_cpu, eenv_before.dst_cpu, sg-&gt;cpumask[0]);</span><br><span class="line">			</span><br><span class="line">			/* (6.1.6.6) 计算eenv_before负载下sg的power */</span><br><span class="line">			if (sched_group_energy(&amp;eenv_before))</span><br><span class="line">				return 0; /* Invalid result abort */</span><br><span class="line">			energy_before += eenv_before.energy;</span><br><span class="line"></span><br><span class="line">			/* Keep track of SRC cpu (before) capacity */</span><br><span class="line">			eenv-&gt;cap.before = eenv_before.cap.before;</span><br><span class="line">			eenv-&gt;cap.delta = eenv_before.cap.delta;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			mt_sched_printf(sched_eas_energy_calc, &quot;2. %s: src=%d dst=%d mask=0x%lx (after)&quot;,</span><br><span class="line">					__func__,  eenv-&gt;src_cpu, eenv-&gt;dst_cpu, sg-&gt;cpumask[0]);</span><br><span class="line">			/* (6.1.6.7) 计算eenv负载下sg的power */</span><br><span class="line">			if (sched_group_energy(eenv))</span><br><span class="line">				return 0; /* Invalid result abort */</span><br><span class="line">			energy_after += eenv-&gt;energy;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; while (sg = sg-&gt;next, sg != sd-&gt;groups);</span><br><span class="line"></span><br><span class="line">    /* (6.1.6.8) 计算energy_after - energy_before */</span><br><span class="line">	eenv-&gt;nrg.before = energy_before;</span><br><span class="line">	eenv-&gt;nrg.after = energy_after;</span><br><span class="line">	eenv-&gt;nrg.diff = eenv-&gt;nrg.after - eenv-&gt;nrg.before;</span><br><span class="line">	eenv-&gt;payoff = 0;</span><br><span class="line"></span><br><span class="line">	trace_sched_energy_diff(eenv-&gt;task,</span><br><span class="line">				eenv-&gt;src_cpu, eenv-&gt;dst_cpu, eenv-&gt;util_delta,</span><br><span class="line">				eenv-&gt;nrg.before, eenv-&gt;nrg.after, eenv-&gt;nrg.diff,</span><br><span class="line">				eenv-&gt;cap.before, eenv-&gt;cap.after, eenv-&gt;cap.delta,</span><br><span class="line">				eenv-&gt;nrg.delta, eenv-&gt;payoff);</span><br><span class="line"></span><br><span class="line">	mt_sched_printf(sched_eas_energy_calc, &quot;5. %s: nrg.diff=%d cap.delta=%d&quot;,</span><br><span class="line">				__func__, eenv-&gt;nrg.diff, eenv-&gt;cap.delta);</span><br><span class="line"></span><br><span class="line">	return eenv-&gt;nrg.diff;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|||→</span><br><span class="line"></span><br><span class="line">static int sched_group_energy(struct energy_env *eenv)</span><br><span class="line">&#123;</span><br><span class="line">	struct sched_domain *sd;</span><br><span class="line">	int cpu, total_energy = 0;</span><br><span class="line">	struct cpumask visit_cpus;</span><br><span class="line">	struct sched_group *sg;</span><br><span class="line">#ifdef CONFIG_MTK_SCHED_EAS_POWER_SUPPORT</span><br><span class="line">	int only_lv1_sd = 0;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	WARN_ON(!eenv-&gt;sg_top-&gt;sge);</span><br><span class="line"></span><br><span class="line">	cpumask_copy(&amp;visit_cpus, sched_group_cpus(eenv-&gt;sg_top));</span><br><span class="line"></span><br><span class="line">    /* (6.1.6.6.1) 根据sg_top顶层sd，找到需要计算的cpu集合visit_cpus，逐个遍历其中每一个cpu</span><br><span class="line">        ooooo这一套复杂的循环算法计算下来，其实就计算了几个power，以cpu0-cpu3为例：</span><br><span class="line">        4个底层sg的power + 1个顶层sg的power</span><br><span class="line">     */ </span><br><span class="line">	while (!cpumask_empty(&amp;visit_cpus)) &#123;</span><br><span class="line">		struct sched_group *sg_shared_cap = NULL;</span><br><span class="line"></span><br><span class="line">        /* (6.1.6.6.2) 选取visit_cpus中的第一个cpu */</span><br><span class="line">		cpu = cpumask_first(&amp;visit_cpus);</span><br><span class="line"></span><br><span class="line">		sd = rcu_dereference_check_sched_domain(cpu_rq(cpu)-&gt;sd);</span><br><span class="line">		if (!sd) &#123;</span><br><span class="line">			/* a corner racing with hotplug? sd doesn&apos;t exist in this cpu. */</span><br><span class="line"></span><br><span class="line">			return -EINVAL;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		/*</span><br><span class="line">		 * Is the group utilization affected by cpus outside this</span><br><span class="line">		 * sched_group?</span><br><span class="line">		 */</span><br><span class="line">		sd = rcu_dereference(per_cpu(sd_scs, cpu));</span><br><span class="line">#ifdef CONFIG_MTK_SCHED_EAS_POWER_SUPPORT</span><br><span class="line">		/* Try to handle one CPU in this cluster by hotplug.</span><br><span class="line">		 * In it there is only lv-1 sched_domain exist which having</span><br><span class="line">		 * no share_cap_states.</span><br><span class="line">		 */</span><br><span class="line">		if (!sd) &#123;</span><br><span class="line">			sd = rcu_dereference(per_cpu(sd_ea, cpu));</span><br><span class="line">			only_lv1_sd = 1;</span><br><span class="line">		&#125;</span><br><span class="line">#endif</span><br><span class="line">		if (!sd) &#123;</span><br><span class="line">			/*</span><br><span class="line">			 * We most probably raced with hotplug; returning a</span><br><span class="line">			 * wrong energy estimation is better than entering an</span><br><span class="line">			 * infinite loop.</span><br><span class="line">			 */</span><br><span class="line">			return -EINVAL;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (sd-&gt;parent)</span><br><span class="line">			sg_shared_cap = sd-&gt;parent-&gt;groups;</span><br><span class="line"></span><br><span class="line">        /* (6.1.6.6.3) 从底层到顶层逐个遍历cpu所在的sd */</span><br><span class="line">		for_each_domain(cpu, sd) &#123;</span><br><span class="line">			sg = sd-&gt;groups;</span><br><span class="line"></span><br><span class="line">            /* (6.1.6.6.4) 如果是顶层sd，只会计算一个sg */</span><br><span class="line">			/* Has this sched_domain already been visited? */</span><br><span class="line">			if (sd-&gt;child &amp;&amp; group_first_cpu(sg) != cpu)</span><br><span class="line">				break;</span><br><span class="line"></span><br><span class="line">            /* (6.1.6.6.5) 逐个遍历该层次sg链表所在sg */</span><br><span class="line">			do &#123;</span><br><span class="line">				unsigned long group_util;</span><br><span class="line">				int sg_busy_energy, sg_idle_energy;</span><br><span class="line">				int cap_idx, idle_idx;</span><br><span class="line"></span><br><span class="line">				if (sg_shared_cap &amp;&amp; sg_shared_cap-&gt;group_weight &gt;= sg-&gt;group_weight)</span><br><span class="line">					eenv-&gt;sg_cap = sg_shared_cap;</span><br><span class="line">				else</span><br><span class="line">					eenv-&gt;sg_cap = sg;</span><br><span class="line"></span><br><span class="line">                /* (6.1.6.6.6) 根据eenv指示的负载变化，找出满足该sg中最大负载cpu的capacity_index */</span><br><span class="line">				cap_idx = find_new_capacity(eenv, sg-&gt;sge);</span><br><span class="line"></span><br><span class="line">				if (sg-&gt;group_weight == 1) &#123;</span><br><span class="line">					/* Remove capacity of src CPU (before task move) */</span><br><span class="line">					if (eenv-&gt;util_delta == 0 &amp;&amp;</span><br><span class="line">					    cpumask_test_cpu(eenv-&gt;src_cpu, sched_group_cpus(sg))) &#123;</span><br><span class="line">						eenv-&gt;cap.before = sg-&gt;sge-&gt;cap_states[cap_idx].cap;</span><br><span class="line">						eenv-&gt;cap.delta -= eenv-&gt;cap.before;</span><br><span class="line">					&#125;</span><br><span class="line">					/* Add capacity of dst CPU  (after task move) */</span><br><span class="line">					if (eenv-&gt;util_delta != 0 &amp;&amp;</span><br><span class="line">					    cpumask_test_cpu(eenv-&gt;dst_cpu, sched_group_cpus(sg))) &#123;</span><br><span class="line">						eenv-&gt;cap.after = sg-&gt;sge-&gt;cap_states[cap_idx].cap;</span><br><span class="line">						eenv-&gt;cap.delta += eenv-&gt;cap.after;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">                /* (6.1.6.6.7) 找出sg所有cpu中最小的idle index */</span><br><span class="line">				idle_idx = group_idle_state(sg);</span><br><span class="line">				</span><br><span class="line">				/* (6.1.6.6.8) 累加sg中所有cpu的相对负载，</span><br><span class="line">				    最大负载为sg-&gt;sge-&gt;cap_states[eenv-&gt;cap_idx].cap</span><br><span class="line">				 */</span><br><span class="line">				group_util = group_norm_util(eenv, sg);</span><br><span class="line">				</span><br><span class="line">				/* (6.1.6.6.9) 计算power = busy_power + idle_power */</span><br><span class="line">#ifdef CONFIG_MTK_SCHED_EAS_POWER_SUPPORT</span><br><span class="line">				/*</span><br><span class="line">				 * To support power estimation for MTK soc.</span><br><span class="line">				 * Consider share buck for dynamic power and SPARK/MCDI for static power.</span><br><span class="line">				 */</span><br><span class="line">				sg_busy_energy = (group_util *</span><br><span class="line">					sg-&gt;sge-&gt;busy_power(group_first_cpu(sg), eenv, (sd-&gt;child) ? 1 : 0))</span><br><span class="line">								&gt;&gt; SCHED_CAPACITY_SHIFT;</span><br><span class="line">				sg_idle_energy = ((SCHED_LOAD_SCALE - group_util) *</span><br><span class="line">					sg-&gt;sge-&gt;idle_power(idle_idx, group_first_cpu(sg), eenv, (sd-&gt;child) ? 1 : 0))</span><br><span class="line">								&gt;&gt; SCHED_CAPACITY_SHIFT;</span><br><span class="line">#else</span><br><span class="line">				/* Power value had been separated to static + dynamic here */</span><br><span class="line">				sg_busy_energy = (group_util * (sg-&gt;sge-&gt;cap_states[cap_idx].dyn_pwr +</span><br><span class="line">						sg-&gt;sge-&gt;cap_states[cap_idx].lkg_pwr[sg-&gt;sge-&gt;lkg_idx]))</span><br><span class="line">								&gt;&gt; SCHED_CAPACITY_SHIFT;</span><br><span class="line">				sg_idle_energy = ((SCHED_LOAD_SCALE-group_util) *</span><br><span class="line">						sg-&gt;sge-&gt;idle_states[idle_idx].power)</span><br><span class="line">								&gt;&gt; SCHED_CAPACITY_SHIFT;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">				total_energy += sg_busy_energy + sg_idle_energy;</span><br><span class="line"></span><br><span class="line">				mt_sched_printf(sched_eas_energy_calc, &quot;busy_energy=%d idle_eneryg=%d (cost=%d)&quot;,</span><br><span class="line">							sg_busy_energy, sg_idle_energy, total_energy);</span><br><span class="line"></span><br><span class="line">                /* (6.1.6.6.10) 如果遍历了底层sd，从visit_cpus中去掉对应的sg cpu */</span><br><span class="line">				if (!sd-&gt;child)</span><br><span class="line">					cpumask_xor(&amp;visit_cpus, &amp;visit_cpus, sched_group_cpus(sg));</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_MTK_SCHED_EAS_POWER_SUPPORT</span><br><span class="line">				/*</span><br><span class="line">				 * We try to get correct energy estimation while racing with hotplug</span><br><span class="line">				 * and avoid entering a infinite loop.</span><br><span class="line">				 */</span><br><span class="line">				if (only_lv1_sd) &#123;</span><br><span class="line">					eenv-&gt;energy = total_energy;</span><br><span class="line">					return 0;</span><br><span class="line">				&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">				if (cpumask_equal(sched_group_cpus(sg), sched_group_cpus(eenv-&gt;sg_top)))</span><br><span class="line">					goto next_cpu;</span><br><span class="line"></span><br><span class="line">			&#125; while (sg = sg-&gt;next, sg != sd-&gt;groups);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		/* (6.1.6.6.11) 如果遍历了cpu的底层到顶层sd，从visit_cpus中去掉对应的cpu */</span><br><span class="line">next_cpu:</span><br><span class="line">		cpumask_clear_cpu(cpu, &amp;visit_cpus);</span><br><span class="line">		continue;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	eenv-&gt;energy = total_energy;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">static struct sched_group *</span><br><span class="line">find_idlest_group(struct sched_domain *sd, struct task_struct *p,</span><br><span class="line">		  int this_cpu, int sd_flag)</span><br><span class="line">&#123;</span><br><span class="line">	struct sched_group *idlest = NULL, *group = sd-&gt;groups;</span><br><span class="line">	struct sched_group *fit_group = NULL;</span><br><span class="line">	unsigned long min_load = ULONG_MAX, this_load = 0;</span><br><span class="line">	unsigned long fit_capacity = ULONG_MAX;</span><br><span class="line">	int load_idx = sd-&gt;forkexec_idx;</span><br><span class="line">	int imbalance = 100 + (sd-&gt;imbalance_pct-100)/2;</span><br><span class="line"></span><br><span class="line">    /* (7.2.1) 选择load_idx */</span><br><span class="line">	if (sd_flag &amp; SD_BALANCE_WAKE)</span><br><span class="line">		load_idx = sd-&gt;wake_idx;</span><br><span class="line"></span><br><span class="line">    /* (7.2.2) 当前cpu所在sd层次的sg，遍历sg所在的sg链表，选出负载最轻的idlest sg */</span><br><span class="line">	do &#123;</span><br><span class="line">		unsigned long load, avg_load;</span><br><span class="line">		int local_group;</span><br><span class="line">		int i;</span><br><span class="line"></span><br><span class="line">        /* (7.2.3) 略过不符合p进程affinity的sg */</span><br><span class="line">		/* Skip over this group if it has no CPUs allowed */</span><br><span class="line">		if (!cpumask_intersects(sched_group_cpus(group),</span><br><span class="line">					tsk_cpus_allowed(p)))</span><br><span class="line">			continue;</span><br><span class="line"></span><br><span class="line">        /* (7.2.4) local_group等于本cpu所在的sg */</span><br><span class="line">		local_group = cpumask_test_cpu(this_cpu,</span><br><span class="line">					       sched_group_cpus(group));</span><br><span class="line"></span><br><span class="line">		/* Tally up the load of all CPUs in the group */</span><br><span class="line">		avg_load = 0;</span><br><span class="line"></span><br><span class="line">        /* (7.2.5) 遍历sg中的所有cpu，累加负载 */</span><br><span class="line">		for_each_cpu(i, sched_group_cpus(group)) &#123;</span><br><span class="line">			/* Bias balancing toward cpus of our domain */</span><br><span class="line">			if (local_group)</span><br><span class="line">				load = source_load(i, load_idx);</span><br><span class="line">			else</span><br><span class="line">				load = target_load(i, load_idx);</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_MTK_SCHED_INTEROP</span><br><span class="line">			load += mt_rt_load(i);</span><br><span class="line">#endif</span><br><span class="line">			avg_load += load;</span><br><span class="line"></span><br><span class="line">            /* (7.2.6) 如果EAS使能，找到能最小满足进程p的capacity sg */</span><br><span class="line">			/*</span><br><span class="line">			 * Look for most energy-efficient group that can fit</span><br><span class="line">			 * that can fit the task.</span><br><span class="line">			 */</span><br><span class="line">			if (capacity_of(i) &lt; fit_capacity &amp;&amp; task_fits_spare(p, i)) &#123;</span><br><span class="line">				fit_capacity = capacity_of(i);</span><br><span class="line">				fit_group = group;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        /* (7.2.7) 用累计的负载计算相对负载 */</span><br><span class="line">		/* Adjust by relative CPU capacity of the group */</span><br><span class="line">		avg_load = (avg_load * SCHED_CAPACITY_SCALE) / group-&gt;sgc-&gt;capacity;</span><br><span class="line"></span><br><span class="line">        /* (7.2.8) 计算idlest sg */</span><br><span class="line">		if (local_group) &#123;</span><br><span class="line">			this_load = avg_load;</span><br><span class="line">		&#125; else if (avg_load &lt; min_load) &#123;</span><br><span class="line">			min_load = avg_load;</span><br><span class="line">			idlest = group;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; while (group = group-&gt;next, group != sd-&gt;groups);</span><br><span class="line"></span><br><span class="line">    /* (7.2.9) EAS使能，返回fit_group */</span><br><span class="line">	if (energy_aware() &amp;&amp; fit_group)</span><br><span class="line">		return fit_group;</span><br><span class="line"></span><br><span class="line">	if (!idlest || 100*this_load &lt; imbalance*min_load)</span><br><span class="line">		return NULL;</span><br><span class="line">	</span><br><span class="line">	/* (7.2.11) 否则，返回idlest */</span><br><span class="line">	return idlest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">static int</span><br><span class="line">find_idlest_cpu(struct sched_group *group, struct task_struct *p, int this_cpu)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned long load, min_load = ULONG_MAX;</span><br><span class="line">	unsigned int min_exit_latency = UINT_MAX;</span><br><span class="line">	u64 latest_idle_timestamp = 0;</span><br><span class="line">	int least_loaded_cpu = this_cpu;</span><br><span class="line">	int shallowest_idle_cpu = -1;</span><br><span class="line">	int i;</span><br><span class="line"></span><br><span class="line">    /* (7.3.1) 遍历sg中符合p进程affinity的cpu */</span><br><span class="line">	/* Traverse only the allowed CPUs */</span><br><span class="line">	for_each_cpu_and(i, sched_group_cpus(group), tsk_cpus_allowed(p)) &#123;</span><br><span class="line">	</span><br><span class="line">	    /* (7.3.2) 如果cpu的剩余capacity能容纳下p进程的load */</span><br><span class="line">		if (task_fits_spare(p, i)) &#123;</span><br><span class="line">			struct rq *rq = cpu_rq(i);</span><br><span class="line">			struct cpuidle_state *idle = idle_get_state(rq);</span><br><span class="line">			</span><br><span class="line">			/* (7.3.2.1) 优先选出idle状态，且退出idle开销最小的cpu */</span><br><span class="line">			if (idle &amp;&amp; idle-&gt;exit_latency &lt; min_exit_latency) &#123;</span><br><span class="line">				/*</span><br><span class="line">				 * We give priority to a CPU whose idle state</span><br><span class="line">				 * has the smallest exit latency irrespective</span><br><span class="line">				 * of any idle timestamp.</span><br><span class="line">				 */</span><br><span class="line">				min_exit_latency = idle-&gt;exit_latency;</span><br><span class="line">				latest_idle_timestamp = rq-&gt;idle_stamp;</span><br><span class="line">				shallowest_idle_cpu = i;</span><br><span class="line">			&#125; else if (idle_cpu(i) &amp;&amp;</span><br><span class="line">				   (!idle || idle-&gt;exit_latency == min_exit_latency) &amp;&amp;</span><br><span class="line">				   rq-&gt;idle_stamp &gt; latest_idle_timestamp) &#123;</span><br><span class="line">				/*</span><br><span class="line">				 * If equal or no active idle state, then</span><br><span class="line">				 * the most recently idled CPU might have</span><br><span class="line">				 * a warmer cache.</span><br><span class="line">				 */</span><br><span class="line">				latest_idle_timestamp = rq-&gt;idle_stamp;</span><br><span class="line">				shallowest_idle_cpu = i;</span><br><span class="line">			&#125; else if (shallowest_idle_cpu == -1) &#123;</span><br><span class="line">				/*</span><br><span class="line">				 * If we haven&apos;t found an idle CPU yet</span><br><span class="line">				 * pick a non-idle one that can fit the task as</span><br><span class="line">				 * fallback.</span><br><span class="line">				 */</span><br><span class="line">				shallowest_idle_cpu = i;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		/* (7.3.3) cpu的剩余capacity容纳不下进程p，选出负载最轻的cpu */</span><br><span class="line">		&#125; else if (shallowest_idle_cpu == -1) &#123;</span><br><span class="line">			load = weighted_cpuload(i);</span><br><span class="line">#ifdef CONFIG_MTK_SCHED_INTEROP</span><br><span class="line">			load += mt_rt_load(i);</span><br><span class="line">#endif</span><br><span class="line">			if (load &lt; min_load || (load == min_load &amp;&amp; i == this_cpu)) &#123;</span><br><span class="line">				min_load = load;</span><br><span class="line">				least_loaded_cpu = i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return shallowest_idle_cpu != -1 ? shallowest_idle_cpu : least_loaded_cpu;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">static int hmp_select_task_rq_fair(int sd_flag, struct task_struct *p,</span><br><span class="line">		int prev_cpu, int new_cpu)</span><br><span class="line">&#123;</span><br><span class="line">	struct list_head *pos;</span><br><span class="line">	struct sched_entity *se = &amp;p-&gt;se;</span><br><span class="line">	struct cpumask fast_cpu_mask, slow_cpu_mask;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_HMP_TRACER</span><br><span class="line">	int cpu = 0;</span><br><span class="line"></span><br><span class="line">	for_each_online_cpu(cpu)</span><br><span class="line">		trace_sched_cfs_runnable_load(cpu, cfs_load(cpu), cfs_length(cpu));</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	/* error handling */</span><br><span class="line">	if (prev_cpu &gt;= num_possible_cpus())</span><br><span class="line">		return new_cpu;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Skip all the checks if only one CPU is online.</span><br><span class="line">	 * Otherwise, select the most appropriate CPU from cluster.</span><br><span class="line">	 */</span><br><span class="line">	if (num_online_cpus() == 1)</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">    /* (8.1) 找出fastest hmp_domain，只有一个， </span><br><span class="line">        找出slow hmp_domain，有多个，</span><br><span class="line">        在一个fast_cpu_mask和多个slow_cpu_mask之间，逐个尝试hmp_select_task_migration()</span><br><span class="line">        p进程是否会满足hmp迁移</span><br><span class="line">     */</span><br><span class="line">	cpumask_clear(&amp;fast_cpu_mask);</span><br><span class="line">	cpumask_clear(&amp;slow_cpu_mask);</span><br><span class="line">	/* order: fast to slow hmp domain */</span><br><span class="line">	list_for_each(pos, &amp;hmp_domains) &#123;</span><br><span class="line">		struct hmp_domain *domain = list_entry(pos, struct hmp_domain, hmp_domains);</span><br><span class="line"></span><br><span class="line">		if (!cpumask_empty(&amp;domain-&gt;cpus)) &#123;</span><br><span class="line">			if (cpumask_empty(&amp;fast_cpu_mask)) &#123;</span><br><span class="line">				cpumask_copy(&amp;fast_cpu_mask, &amp;domain-&gt;possible_cpus);</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				cpumask_copy(&amp;slow_cpu_mask, &amp;domain-&gt;possible_cpus);</span><br><span class="line">				new_cpu = hmp_select_task_migration(sd_flag, p,</span><br><span class="line">					prev_cpu, new_cpu, &amp;fast_cpu_mask, &amp;slow_cpu_mask);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	/* it happens when num_online_cpus=1 */</span><br><span class="line">	if (new_cpu &gt;= nr_cpu_ids) &#123;</span><br><span class="line">		/* BUG_ON(1); */</span><br><span class="line">		new_cpu = prev_cpu;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cfs_nr_pending(new_cpu)++;</span><br><span class="line">	cfs_pending_load(new_cpu) += se_load(se);</span><br><span class="line"></span><br><span class="line">	return new_cpu;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">||→</span><br><span class="line"></span><br><span class="line">static int hmp_select_task_migration(int sd_flag, struct task_struct *p, int prev_cpu, int new_cpu,</span><br><span class="line">		struct cpumask *fast_cpu_mask, struct cpumask *slow_cpu_mask)</span><br><span class="line">&#123;</span><br><span class="line">	int step = 0;</span><br><span class="line">	struct sched_entity *se = &amp;p-&gt;se;</span><br><span class="line">	int B_target = num_possible_cpus();</span><br><span class="line">	int L_target = num_possible_cpus();</span><br><span class="line">	struct clb_env clbenv;</span><br><span class="line"></span><br><span class="line">    /* (8.1.1) 找出fast_cpu_mask中负载最轻的cpu B_target，且符合p进程的affinity */</span><br><span class="line">	B_target = hmp_select_cpu(HMP_SELECT_RQ, p, fast_cpu_mask, prev_cpu, 0);</span><br><span class="line">	</span><br><span class="line">	/* (8.1.2) 找出slow_cpu_mask中负载最轻的cpu L_target，且符合p进程的affinity */</span><br><span class="line">	L_target = hmp_select_cpu(HMP_SELECT_RQ, p, slow_cpu_mask, prev_cpu, 1);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Only one cluster exists or only one cluster is allowed for this task</span><br><span class="line">	 * Case 1: return the runqueue whose load is minimum</span><br><span class="line">	 * Case 2: return original CFS runqueue selection result</span><br><span class="line">	 */</span><br><span class="line">	if (B_target &gt;= num_possible_cpus() &amp;&amp; L_target &gt;= num_possible_cpus())</span><br><span class="line">		goto out;</span><br><span class="line">	if (B_target &gt;= num_possible_cpus())</span><br><span class="line">		goto select_slow;</span><br><span class="line">	if (L_target &gt;= num_possible_cpus())</span><br><span class="line">		goto select_fast;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Two clusters exist and both clusters are allowed for this task</span><br><span class="line">	 * Step 1: Move newly created task to the cpu where no tasks are running</span><br><span class="line">	 * Step 2: Migrate heavy-load task to big</span><br><span class="line">	 * Step 3: Migrate light-load task to LITTLE</span><br><span class="line">	 * Step 4: Make sure the task stays in its previous hmp domain</span><br><span class="line">	 */</span><br><span class="line">	step = 1;</span><br><span class="line">	if (task_created(sd_flag) &amp;&amp; !task_low_priority(p-&gt;prio)) &#123;</span><br><span class="line">		if (!rq_length(B_target))</span><br><span class="line">			goto select_fast;</span><br><span class="line">		if (!rq_length(L_target))</span><br><span class="line">			goto select_slow;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	/* (8.1.3) 计算如果L_target和B_target发生hmp迁移，各种负载和thershold的计算 */</span><br><span class="line">	memset(&amp;clbenv, 0, sizeof(clbenv));</span><br><span class="line">	clbenv.flags |= HMP_SELECT_RQ;</span><br><span class="line">	cpumask_copy(&amp;clbenv.lcpus, slow_cpu_mask);</span><br><span class="line">	cpumask_copy(&amp;clbenv.bcpus, fast_cpu_mask);</span><br><span class="line">	clbenv.ltarget = L_target;</span><br><span class="line">	clbenv.btarget = B_target;</span><br><span class="line">	sched_update_clbstats(&amp;clbenv);</span><br><span class="line">	</span><br><span class="line">	/* (8.1.4) 判断进程p从L_target up到 B_target的可行性 */</span><br><span class="line">	step = 2;</span><br><span class="line">	if (hmp_up_migration(L_target, &amp;B_target, se, &amp;clbenv))</span><br><span class="line">		goto select_fast;</span><br><span class="line">		</span><br><span class="line">	/* (8.1.5) 判断进程p从B_target down到 L_target的可行性 */</span><br><span class="line">	step = 3;</span><br><span class="line">	if (hmp_down_migration(B_target, &amp;L_target, se, &amp;clbenv))</span><br><span class="line">		goto select_slow;</span><br><span class="line">		</span><br><span class="line">	/* (8.1.6) 如果prev_cpu是slowest */</span><br><span class="line">	step = 4;</span><br><span class="line">	if (hmp_cpu_is_slowest(prev_cpu))</span><br><span class="line">		goto select_slow;</span><br><span class="line">	goto select_fast;</span><br><span class="line"></span><br><span class="line">    /* (8.1.7) 返回 B_target */</span><br><span class="line">select_fast:</span><br><span class="line">	new_cpu = B_target;</span><br><span class="line">	cpumask_clear(slow_cpu_mask);</span><br><span class="line">	goto out;</span><br><span class="line">	</span><br><span class="line">	/* (8.1.8) 返回 L_target */</span><br><span class="line">select_slow:</span><br><span class="line">	new_cpu = L_target;</span><br><span class="line">	cpumask_copy(fast_cpu_mask, slow_cpu_mask);</span><br><span class="line">	cpumask_clear(slow_cpu_mask);</span><br><span class="line">	goto out;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">#ifdef CONFIG_HMP_TRACER</span><br><span class="line">	trace_sched_hmp_load(clbenv.bstats.load_avg, clbenv.lstats.load_avg);</span><br><span class="line">#endif</span><br><span class="line">	return new_cpu;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-2、HMP负载均衡"><a href="#4-2、HMP负载均衡" class="headerlink" title="4.2、HMP负载均衡"></a>4.2、HMP负载均衡</h2><p>除了SMP load_balance()负载均衡以外，我们还希望在多个SMP cluster之间能遵守一种规则：heavy任务跑在big core上，light任务跑在little core上，这样能快速的达到一个合理的负载状态。这种算法就叫做HMP负载均衡，EAS会统一的考虑负载、性能、功耗，EAS使能后HMP就被禁用了。</p>
<p>HMP负载均衡的操作分两种：</p>
<ul>
<li>1、heavy task从little cpu迁移到big cpu。这种叫做up操作，对应的函数hmp_force_up_migration()；</li>
<li>2、light task从big cpu迁移到little cpu。这种叫做down操作，对应的函数hmp_force_down_migration()；</li>
</ul>
<h3 id="4-2-1、hmp-domain初始化"><a href="#4-2-1、hmp-domain初始化" class="headerlink" title="4.2.1、hmp domain初始化"></a>4.2.1、hmp domain初始化</h3><p><img src="/images/scheduler/schedule_hmp_domains_init.png" alt="schedule_hmp_domains_init"></p>
<p>hmp在初始化的时候会每个cluster分配一个hmp_domain，把所有hmp_domain加入到全局链表hmp_domains中。hmp_domains链表构建完成以后，离链表头hmp_domains最近的hmp_domain是速度最快的cluster，离hmp_domains越远hmp_domain对应的速度越慢。因为在构造链表时是按照cluster id来加入的，速度最快cluster的hmp_domain最后加入，所以离表头最近。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">static int __init hmp_cpu_mask_setup(void)</span><br><span class="line">&#123;</span><br><span class="line">	struct hmp_domain *domain;</span><br><span class="line">	struct list_head *pos;</span><br><span class="line">	int dc, cpu;</span><br><span class="line"></span><br><span class="line">	pr_warn(&quot;Initializing HMP scheduler:\n&quot;);</span><br><span class="line"></span><br><span class="line">	/* Initialize hmp_domains using platform code */</span><br><span class="line">	/* (1) 调用arch相关的hmp_domains初始化函数 */</span><br><span class="line">	arch_get_hmp_domains(&amp;hmp_domains);</span><br><span class="line">	if (list_empty(&amp;hmp_domains)) &#123;</span><br><span class="line">		pr_warn(&quot;HMP domain list is empty!\n&quot;);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* Print hmp_domains */</span><br><span class="line">	dc = 0;</span><br><span class="line">	list_for_each(pos, &amp;hmp_domains) &#123;</span><br><span class="line">		domain = list_entry(pos, struct hmp_domain, hmp_domains);</span><br><span class="line"></span><br><span class="line">		for_each_cpu(cpu, &amp;domain-&gt;possible_cpus) &#123;</span><br><span class="line">		    /* (2) 给per_cpu变量hmp_cpu_domain赋值 */</span><br><span class="line">			per_cpu(hmp_cpu_domain, cpu) = domain;</span><br><span class="line">		&#125;</span><br><span class="line">		dc++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">void __init arch_get_hmp_domains(struct list_head *hmp_domains_list)</span><br><span class="line">&#123;</span><br><span class="line">	struct hmp_domain *domain;</span><br><span class="line">	struct cpumask cpu_mask;</span><br><span class="line">	int id, maxid;</span><br><span class="line"></span><br><span class="line">	cpumask_clear(&amp;cpu_mask);</span><br><span class="line">	maxid = arch_get_nr_clusters();</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Initialize hmp_domains</span><br><span class="line">	 * Must be ordered with respect to compute capacity.</span><br><span class="line">	 * Fastest domain at head of list.</span><br><span class="line">	 */</span><br><span class="line">	/* (1.1) 按照cluster id初始化对应的hmp_domain */</span><br><span class="line">	for (id = 0; id &lt; maxid; id++) &#123;</span><br><span class="line">		arch_get_cluster_cpus(&amp;cpu_mask, id);</span><br><span class="line">		domain = (struct hmp_domain *)</span><br><span class="line">			kmalloc(sizeof(struct hmp_domain), GFP_KERNEL);</span><br><span class="line">		cpumask_copy(&amp;domain-&gt;possible_cpus, &amp;cpu_mask);</span><br><span class="line">		cpumask_and(&amp;domain-&gt;cpus, cpu_online_mask, &amp;domain-&gt;possible_cpus);</span><br><span class="line">		</span><br><span class="line">		/* (1.2) 将hmp_domain加入到全局链表hmp_domains_list即hmp_domains中 */</span><br><span class="line">		list_add(&amp;domain-&gt;hmp_domains, hmp_domains_list);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-2、hmp-force-up-migration"><a href="#4-2-2、hmp-force-up-migration" class="headerlink" title="4.2.2、hmp_force_up_migration()"></a>4.2.2、hmp_force_up_migration()</h3><p>hmp_force_up_migration()的操作主要有以下几个步骤：</p>
<p><strong><em>需要重点提一下的是</em></strong>：负载计算计算了3种负载(load_avg、loadwop_avg、util_avg)，rebalance_domains主要使用其中的<strong><em>loadwop_avg</em></strong>。</p>
<ul>
<li>1、根据当前cpu，选择fast_cpu_mask、slow_cpu_mask；</li>
</ul>
<p>hmp_force_up_migration尝试把slow cpu上的heavy进程迁移到fast cpu上，关于slow、fast的选择有以下几种场景：</p>
<p><img src="/images/scheduler/schedule_hmp_up_migration.png" alt="schedule_hmp_up_migration"></p>
<ul>
<li><p>2、选择当前cpu的heaviest进程作为迁移进程p；并不会遍历cpu上所有进程去选出heaviest进程，只会查询curr进程和cfs_rq中5个进程中的heaviest；</p>
</li>
<li><p>3、根据fast_cpu_mask，选择一个负载最少的target cpu；</p>
</li>
</ul>
<p><img src="/images/scheduler/schedule_hmp_force_up_migration_hmp_select_cpu.png" alt="schedule_hmp_force_up_migration_hmp_select_cpu"></p>
<ul>
<li>4、根据源cpu(curr_cpu)、目的cpu(target_cpu)，计算负载；</li>
</ul>
<p>重要的数据计算方法：</p>
<html><br><table><br>    <tr><br>        <td style="width: 100px;"> 重要数据 </td><br>        <td style="width: 100px;"> 所属结构 </td><br>        <td style="width: 100px;"> 含义 </td><br>        <td style="width: 100px;"> 更新/获取函数 </td><br>        <td style="width: 200px;"> 计算方法 </td><br>    </tr><br>    <tr><br>        <td> clbenv-&gt;bstats.cpu_power </td><br>        <td> clbenv-&gt;bstats </td><br>        <td> B族cpu的绝对计算能力 </td><br>        <td> sched_update_clbstats() </td><br>        <td> arch_scale_cpu_capacity(NULL, clbenv-&gt;btarget) </td><br>    </tr><br>    <tr><br>        <td> clbenv-&gt;lstats.cpu_power </td><br>        <td> clbenv-&gt;lstats </td><br>        <td> L族cpu的绝对计算能力 </td><br>        <td> sched_update_clbstats() </td><br>        <td> arch_scale_cpu_capacity(NULL, clbenv-&gt;ltarget) </td><br>    </tr><br>    <tr><br>        <td> clbenv-&gt;lstats.cpu_capacity </td><br>        <td> clbenv-&gt;lstats </td><br>        <td> B族cpu的相对计算能力，大于1024 </td><br>        <td> sched_update_clbstats() </td><br>        <td> SCHED_CAPACITY_SCALE <em> clbenv-&gt;bstats.cpu_power / (clbenv-&gt;lstats.cpu_power+1) </em></td><br>    </tr><br>    <tr><br>        <td> clbenv-&gt;bstats.cpu_capacity </td><br>        <td> clbenv-&gt;bstats </td><br>        <td> L族cpu的相对计算能力，等于1024 </td><br>        <td> sched_update_clbstats() </td><br>        <td> SCHED_CAPACITY_SCALE </td><br>    </tr><br>    <tr><br>        <td> clbs-&gt;ncpu </td><br>        <td> clbenv-&gt;bstats/clbenv-&gt;lstats </td><br>        <td> L族/B族online的cpu数量 </td><br>        <td> collect_cluster_stats() </td><br>        <td> if (cpu_online(cpu)) clbs-&gt;ncpu++; </td><br>    </tr><br>    <tr><br>        <td> clbs-&gt;ntask </td><br>        <td> clbenv-&gt;bstats/clbenv-&gt;lstats </td><br>        <td> L族/B族所有online cpu中所有层级se的总和 </td><br>        <td> collect_cluster_stats() </td><br>        <td> clbs-&gt;ntask += cpu_rq(cpu)-&gt;cfs.h_nr_running; </td><br>    </tr><br>    <tr><br>        <td> clbs-&gt;load_avg </td><br>        <td> clbenv-&gt;bstats/clbenv-&gt;lstats </td><br>        <td> L族/B族online cpu的平均runnable负载，不带weight </td><br>        <td> collect_cluster_stats() </td><br>        <td> sum(cpu_rq(cpu)-&gt;cfs.avg.loadwop_avg)/clbs-&gt;ncpu </td><br>    </tr><br>    <tr><br>        <td> clbs-&gt;scaled_acap </td><br>        <td> clbenv-&gt;bstats/clbenv-&gt;lstats </td><br>        <td> L族/B族target cpu计算能力的剩余值 </td><br>        <td> collect_cluster_stats() </td><br>        <td> hmp_scale_down(clbs-&gt;cpu_capacity - cpu_rq(target)-&gt;cfs.avg.loadwop_avg) </td><br>    </tr><br>    <tr><br>        <td> clbs-&gt;scaled_atask </td><br>        <td> clbenv-&gt;bstats/clbenv-&gt;lstats </td><br>        <td> L族/B族target cpu的task space的剩余值 </td><br>        <td> collect_cluster_stats() </td><br>        <td> hmp_scale_down(clbs-&gt;cpu_capacity - cpu_rq(target)-&gt;cfs.h_nr_running  cpu_rq(target)-&gt;cfs.avg.loadwop_avg) </td><br>    </tr><br>    <tr><br>        <td> clbenv-&gt;bstats.threshold </td><br>        <td> clbenv-&gt;bstats </td><br>        <td> 进程要up迁移到B族的负载门限值 </td><br>        <td> adj_threshold() </td><br>        <td> HMP_MAX_LOAD - HMP_MAX_LOAD <em> b_nacap </em> b_natask / ((b_nacap + l_nacap) <em> (b_natask + l_natask) + 1)；b_nacap、b_natask会乘以一个放大系数(b_cpu_power/l_cpu_power)，类似如cpu_capacity的计算 </em></td><br>    </tr><br>    <tr><br>        <td> clbenv-&gt;lstats.threshold  </td><br>        <td> clbenv-&gt;lstats </td><br>        <td> 进程要down迁移到L族的负载门限值 </td><br>        <td> adj_threshold() </td><br>        <td> HMP_MAX_LOAD  l_nacap <em> l_natask / ((b_nacap + l_nacap) </em> (b_natask + l_natask) + 1)；b_nacap、b_natask会乘以一个放大系数(b_cpu_power/l_cpu_power)，类似如cpu_capacity的计算 </td><br>    </tr><br></table><br></html>

<ul>
<li>5、根据计算的负载情况，判断进程p是否符合up迁移条件((se_load(se) &gt; B-&gt;threshold)，等其他条件)；</li>
</ul>
<p>up-migration条件列表(hmp_up_migration())：</p>
<html><br><table><br>    <tr><br>        <td style="width: 100px;"> 条件 </td><br>        <td style="width: 100px;"> 含义 </td><br>        <td style="width: 200px;"> 计算方法 </td><br>        <td style="width: 200px;"> 计算解析 </td><br>    </tr><br>    <tr><br>        <td> [1] Migration stabilizing </td><br>        <td> 如果target cpu刚做过up迁移，不适合再进行迁移 </td><br>        <td> if (!hmp_up_stable(<em>target_cpu)) check-&gt;result = 0; </em></td><br>        <td> (((now - hmp_last_up_migration(cpu)) &gt;&gt; 10) &lt; hmp_next_up_threshold) //间隔时间小于hmp_next_up_threshold </td><br>    </tr><br>    <tr><br>        <td> [2] Filter low-priority task </td><br>        <td> 低优先级进程(nice&gt;5)如果负载不够，不能进行up迁移 </td><br>        <td> if (hmp_low_prio_task_up_rejected(p, B, L)) check-&gt;result = 0; </td><br>        <td> (task_low_priority(p-&gt;prio) &amp;&amp; (B-&gt;ntask &gt;= B-&gt;ncpu || 0 != L-&gt;nr_normal_prio_task) &amp;&amp; (p-&gt;se.avg.loadwop_avg &lt; 800)) // (如果是低优先级(nice&gt;5)进程) &amp;&amp; (B组进程大于cpu数 || L正常优先级的进程不为0) &amp;&amp; (进程负载&lt;800)；满足上述条件不进行up迁移 </td><br>    </tr><br>    <tr><br>        <td> [2.5]if big is idle, just go to big </td><br>        <td> 如果目标B cpu处于idle状态，不需要判断其他条件，直接满足up迁移 </td><br>        <td> if (rq_length(target_cpu) == 0) check-&gt;result = 1; </td><br>        <td> (cpu_rq(cpu)-&gt;nr_running + cfs_nr_pending(cpu)) == 0 //  </td><br>    </tr><br>    <tr><br>        <td> [3] Check CPU capacity </td><br>        <td> 判断目标B cpu的capacity是否足够容纳迁移过去的进程se </td><br>        <td> if (!hmp_task_fast_cpu_afford(B, se, *target_cpu)) check-&gt;result = 0; </td><br>        <td> (se_load(se) + cfs_load(target_cpu)) &lt; (B-&gt;cpu_capacity - (B-&gt;cpu_capacity &gt;&gt; 2)) // se + target_cpu的负载，需要小于3/4 cpu_capacity  </td><br>    </tr><br>    <tr><br>        <td> [4] Check dynamic migration threshold </td><br>        <td> 如果进程的负载达到up迁移的门限值，则满足up迁移 </td><br>        <td> if (se_load(se) &gt; B-&gt;threshold) check-&gt;result = 1; </td><br>        <td>  </td><br>    </tr><br></table><br></html>

<ul>
<li>6、如果条件符合，进行实际的up迁移；</li>
</ul>
<p>hmp_force_up_migration()详细的代码解析：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br></pre></td><td class="code"><pre><span class="line">static void run_rebalance_domains(struct softirq_action *h)</span><br><span class="line">&#123;</span><br><span class="line">	struct rq *this_rq = this_rq();</span><br><span class="line">	enum cpu_idle_type idle = this_rq-&gt;idle_balance ?</span><br><span class="line">						CPU_IDLE : CPU_NOT_IDLE;</span><br><span class="line">	int this_cpu = smp_processor_id();</span><br><span class="line"></span><br><span class="line">	/* bypass load balance of HMP if EAS consideration */</span><br><span class="line">	/* (1) 在EAS不使能的情况下，尝试进行HMP负载均衡 */</span><br><span class="line">	if ((!energy_aware() &amp;&amp; sched_feat(SCHED_HMP)) ||</span><br><span class="line">			(hybrid_support() &amp;&amp; cpu_rq(this_cpu)-&gt;rd-&gt;overutilized))</span><br><span class="line">		hmp_force_up_migration(this_cpu);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * If this cpu has a pending nohz_balance_kick, then do the</span><br><span class="line">	 * balancing on behalf of the other idle cpus whose ticks are</span><br><span class="line">	 * stopped. Do nohz_idle_balance *before* rebalance_domains to</span><br><span class="line">	 * give the idle cpus a chance to load balance. Else we may</span><br><span class="line">	 * load balance only within the local sched_domain hierarchy</span><br><span class="line">	 * and abort nohz_idle_balance altogether if we pull some load.</span><br><span class="line">	 */</span><br><span class="line">	nohz_idle_balance(this_rq, idle);</span><br><span class="line">	rebalance_domains(this_rq, idle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">static void hmp_force_up_migration(int this_cpu)</span><br><span class="line">&#123;</span><br><span class="line">	int curr_cpu, target_cpu;a</span><br><span class="line">	struct sched_entity *se;</span><br><span class="line">	struct rq *target;</span><br><span class="line">	unsigned long flags;</span><br><span class="line">	unsigned int force = 0;</span><br><span class="line">	struct task_struct *p;</span><br><span class="line">	struct clb_env clbenv;</span><br><span class="line">#ifdef CONFIG_SCHED_HMP_PLUS</span><br><span class="line">	struct sched_entity *orig;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	if (!spin_trylock(&amp;hmp_force_migration))</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_HMP_TRACER</span><br><span class="line">	for_each_online_cpu(curr_cpu)</span><br><span class="line">		trace_sched_cfs_runnable_load(curr_cpu, cfs_load(curr_cpu), cfs_length(curr_cpu));</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	/* Migrate heavy task from LITTLE to big */</span><br><span class="line">	/* (1.1) 逐个online cpu尝试进行heavy task从little cpu到big cpu的迁移 */</span><br><span class="line">	for_each_online_cpu(curr_cpu) &#123;</span><br><span class="line">		struct hmp_domain *hmp_domain = NULL;</span><br><span class="line">		struct cpumask fast_cpu_mask, slow_cpu_mask;</span><br><span class="line"></span><br><span class="line">		cpumask_clear(&amp;fast_cpu_mask);</span><br><span class="line">		cpumask_clear(&amp;slow_cpu_mask);</span><br><span class="line">		/* (1.2) 如果当前cpu不属于速度最快(fastest)的domain,</span><br><span class="line">		    则尝试进行up操作</span><br><span class="line">		 */</span><br><span class="line">		if (!hmp_cpu_is_fastest(curr_cpu)) &#123;</span><br><span class="line">			/* current cpu is slow_cpu_mask*/</span><br><span class="line">			/* (1.2.1) 当前cpu所在的hmp_domain为slow_cpu_mask */</span><br><span class="line">			hmp_domain = hmp_cpu_domain(curr_cpu);</span><br><span class="line">			cpumask_copy(&amp;slow_cpu_mask, &amp;hmp_domain-&gt;possible_cpus);</span><br><span class="line"></span><br><span class="line">            /* (1.2.2) 最fastest且online的hmp_domain为fast_cpu_mask */</span><br><span class="line">			while (&amp;hmp_domain-&gt;hmp_domains != hmp_domains.next) &#123;</span><br><span class="line">				struct list_head *pos = &amp;hmp_domain-&gt;hmp_domains;</span><br><span class="line"></span><br><span class="line">				hmp_domain = list_entry(pos-&gt;prev, struct hmp_domain, hmp_domains);</span><br><span class="line">				if (!cpumask_empty(&amp;hmp_domain-&gt;cpus)) &#123;</span><br><span class="line">					cpumask_copy(&amp;fast_cpu_mask, &amp;hmp_domain-&gt;possible_cpus);</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">		/* (1.3) 如果当前cpu属于速度最快(fastest)的domain,</span><br><span class="line">		    则直接进行down操作</span><br><span class="line">		 */</span><br><span class="line">			hmp_force_down_migration(this_cpu);</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		if (!hmp_domain || hmp_domain == hmp_cpu_domain(curr_cpu))</span><br><span class="line">			continue;</span><br><span class="line"></span><br><span class="line">		if (cpumask_empty(&amp;fast_cpu_mask) || cpumask_empty(&amp;slow_cpu_mask))</span><br><span class="line">			continue;</span><br><span class="line"></span><br><span class="line">		force = 0;</span><br><span class="line">		/* (1.4) 取出当前cpu的当前cfs进程 */</span><br><span class="line">		target = cpu_rq(curr_cpu);</span><br><span class="line">		raw_spin_lock_irqsave(&amp;target-&gt;lock, flags);</span><br><span class="line">		se = target-&gt;cfs.curr;</span><br><span class="line">		if (!se) &#123;</span><br><span class="line">			raw_spin_unlock_irqrestore(&amp;target-&gt;lock, flags);</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		/* Find task entity */</span><br><span class="line">		if (!entity_is_task(se)) &#123;</span><br><span class="line">			struct cfs_rq *cfs_rq;</span><br><span class="line"></span><br><span class="line">			cfs_rq = group_cfs_rq(se);</span><br><span class="line">			while (cfs_rq) &#123;</span><br><span class="line">				se = cfs_rq-&gt;curr;</span><br><span class="line">				cfs_rq = group_cfs_rq(se);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">#ifdef CONFIG_SCHED_HMP_PLUS</span><br><span class="line">		orig = se;</span><br><span class="line">		/* (1.5) 或者取出当前cpu前5个cfs进程中，负载最重(heaviest)的进程 */</span><br><span class="line">		se = hmp_get_heaviest_task(se, -1);</span><br><span class="line">		if (!se) &#123;</span><br><span class="line">			raw_spin_unlock_irqrestore(&amp;target-&gt;lock, flags);</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		if (!entity_is_task(se))</span><br><span class="line">			p = task_of(orig);</span><br><span class="line">		else</span><br><span class="line">#endif</span><br><span class="line">			p = task_of(se);</span><br><span class="line"></span><br><span class="line">        /* (1.6) 选择fast_cpu_mask domain中，负载最少的cpu */</span><br><span class="line">		target_cpu = hmp_select_cpu(HMP_GB, p, &amp;fast_cpu_mask, -1, 0);</span><br><span class="line">		if (target_cpu &gt;= num_possible_cpus()) &#123;</span><br><span class="line">			raw_spin_unlock_irqrestore(&amp;target-&gt;lock, flags);</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		/* Collect cluster information */</span><br><span class="line">		/* (1.7) up操作的对象已经选择好：</span><br><span class="line">		    源little cpu：curr_cpu</span><br><span class="line">		    目的big cpu：target_cpu</span><br><span class="line">		 */</span><br><span class="line">		memset(&amp;clbenv, 0, sizeof(clbenv));</span><br><span class="line">		clbenv.flags |= HMP_GB;</span><br><span class="line">		clbenv.ltarget = curr_cpu;</span><br><span class="line">		clbenv.btarget = target_cpu;</span><br><span class="line">		cpumask_copy(&amp;clbenv.lcpus, &amp;slow_cpu_mask);</span><br><span class="line">		cpumask_copy(&amp;clbenv.bcpus, &amp;fast_cpu_mask);</span><br><span class="line">		/* (1.8) up操作前的数据计算 */</span><br><span class="line">		sched_update_clbstats(&amp;clbenv);</span><br><span class="line"></span><br><span class="line">		/* Check migration threshold */</span><br><span class="line">		/* (1.9) 根据计算的数据，判断up操作的可行性 */</span><br><span class="line">		if (!target-&gt;active_balance &amp;&amp;</span><br><span class="line">				hmp_up_migration(curr_cpu, &amp;target_cpu, se, &amp;clbenv) &amp;&amp;</span><br><span class="line">				!cpu_park(cpu_of(target))) &#123;</span><br><span class="line">			if (p-&gt;state != TASK_DEAD) &#123;</span><br><span class="line">			    /* 准备从target rq中迁移进程p到target_cpu，</span><br><span class="line">			        设置rq正在处理负载balance标志active_balance */</span><br><span class="line">				get_task_struct(p);</span><br><span class="line">				target-&gt;active_balance = 1; /* force up */</span><br><span class="line">				target-&gt;push_cpu = target_cpu;</span><br><span class="line">				target-&gt;migrate_task = p;</span><br><span class="line">				force = 1;</span><br><span class="line">				trace_sched_hmp_migrate(p, target-&gt;push_cpu, 1);</span><br><span class="line">				hmp_next_up_delay(&amp;p-&gt;se, target-&gt;push_cpu);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		raw_spin_unlock_irqrestore(&amp;target-&gt;lock, flags);</span><br><span class="line">		/* (1.10) 判断结果是可以进行up操作，</span><br><span class="line">		    则调用hmp_force_up_cpu_stop()进行实际的up操作 </span><br><span class="line">		 */</span><br><span class="line">		if (force) &#123;</span><br><span class="line">			if (stop_one_cpu_dispatch(cpu_of(target),</span><br><span class="line">						hmp_force_up_cpu_stop,</span><br><span class="line">						target, &amp;target-&gt;active_balance_work)) &#123;</span><br><span class="line">				/* 迁移完成，清除标志 */</span><br><span class="line">				put_task_struct(p); /* out of rq-&gt;lock */</span><br><span class="line">				raw_spin_lock_irqsave(&amp;target-&gt;lock, flags);</span><br><span class="line">				target-&gt;active_balance = 0;</span><br><span class="line">				force = 0;</span><br><span class="line">				raw_spin_unlock_irqrestore(&amp;target-&gt;lock, flags);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; else</span><br><span class="line">		/* (1.11) 否则，再尝试进行down操作 */</span><br><span class="line">			hmp_force_down_migration(this_cpu);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_HMP_TRACER</span><br><span class="line">	trace_sched_hmp_load(clbenv.bstats.load_avg, clbenv.lstats.load_avg);</span><br><span class="line">#endif</span><br><span class="line">	spin_unlock(&amp;hmp_force_migration);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">||→</span><br><span class="line"></span><br><span class="line">static const int hmp_max_tasks = 5;</span><br><span class="line">static struct sched_entity *hmp_get_heaviest_task(</span><br><span class="line">		struct sched_entity *se, int target_cpu)</span><br><span class="line">&#123;</span><br><span class="line">	int num_tasks = hmp_max_tasks;</span><br><span class="line">	struct sched_entity *max_se = se;</span><br><span class="line">	unsigned long int max_ratio = se-&gt;avg.loadwop_avg;</span><br><span class="line">	const struct cpumask *hmp_target_mask = NULL;</span><br><span class="line">	struct hmp_domain *hmp;</span><br><span class="line"></span><br><span class="line">    /* (1.5.1) 如果本cpu是fastest cpu，则不用查找直接返回，</span><br><span class="line">        因为本函数的目的是找little cpu中的heaviest进程</span><br><span class="line">     */</span><br><span class="line">	if (hmp_cpu_is_fastest(cpu_of(se-&gt;cfs_rq-&gt;rq)))</span><br><span class="line">		return max_se;</span><br><span class="line"></span><br><span class="line">    /* (1.5.2) 获取比本cpu fater一级cpu的hmp_domain，作为进程亲和力判断的mask */</span><br><span class="line">	hmp = hmp_faster_domain(cpu_of(se-&gt;cfs_rq-&gt;rq));</span><br><span class="line">	hmp_target_mask = &amp;hmp-&gt;cpus;</span><br><span class="line">	/* (1.5.3) 传入参数target_cpu = -1，</span><br><span class="line">	    所以hmp_target_mask使用的是源cpu hmp_domain的hmp-&gt;cpus </span><br><span class="line">	 */</span><br><span class="line">	if (target_cpu &gt;= 0) &#123;</span><br><span class="line">		/* idle_balance gets run on a CPU while</span><br><span class="line">		 * it is in the middle of being hotplugged</span><br><span class="line">		 * out. Bail early in that case.</span><br><span class="line">		 */</span><br><span class="line">		if (!cpumask_test_cpu(target_cpu, hmp_target_mask))</span><br><span class="line">			return NULL;</span><br><span class="line">		hmp_target_mask = cpumask_of(target_cpu);</span><br><span class="line">	&#125;</span><br><span class="line">	/* The currently running task is not on the runqueue */</span><br><span class="line">	/* (1.5.4) 从当前cpu的cfs红黑树中，连续5个进程和curr进程比较，选出heaviest进程 </span><br><span class="line">	    比较使用的负载为se-&gt;avg.loadwop_avg，不带weight分量</span><br><span class="line">	 */</span><br><span class="line">	se = __pick_first_entity(cfs_rq_of(se));</span><br><span class="line">	while (num_tasks &amp;&amp; se) &#123;</span><br><span class="line">		if (entity_is_task(se) &amp;&amp; se-&gt;avg.loadwop_avg &gt; max_ratio &amp;&amp;</span><br><span class="line">				cpumask_intersects(hmp_target_mask, tsk_cpus_allowed(task_of(se)))) &#123;</span><br><span class="line">			max_se = se;</span><br><span class="line">			max_ratio = se-&gt;avg.loadwop_avg;</span><br><span class="line">		&#125;</span><br><span class="line">		se = __pick_next_entity(se);</span><br><span class="line">		num_tasks--;</span><br><span class="line">	&#125;</span><br><span class="line">	return max_se;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">||→</span><br><span class="line"></span><br><span class="line">static unsigned int hmp_select_cpu(unsigned int caller, struct task_struct *p,</span><br><span class="line">		struct cpumask *mask, int prev, int up)</span><br><span class="line">&#123;</span><br><span class="line">	int curr = 0;</span><br><span class="line">	int target = num_possible_cpus();</span><br><span class="line">	unsigned long curr_wload = 0;</span><br><span class="line">	unsigned long target_wload = 0;</span><br><span class="line">	struct cpumask srcp;</span><br><span class="line"></span><br><span class="line">    /* (1.6.1) 综合fast_cpu_mask、cpu_online_mask、tsk_cpus_allowed(p)，</span><br><span class="line">        选取first cpu为target</span><br><span class="line">     */</span><br><span class="line">	cpumask_and(&amp;srcp, cpu_online_mask, mask);</span><br><span class="line">	target = cpumask_any_and(&amp;srcp, tsk_cpus_allowed(p));</span><br><span class="line">	if (target &gt;= num_possible_cpus())</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * RT class is taken into account because CPU load is multiplied</span><br><span class="line">	 * by the total number of CPU runnable tasks that includes RT tasks.</span><br><span class="line">	 */</span><br><span class="line">	/*  (1.6.2) 计算target cpu所对应的load，</span><br><span class="line">	    target_wload = (rq-&gt;cfs.avg.loadwop_avg + rq-&gt;cfs.avg.pending_load) * (rq-&gt;nr_running + rq-&gt;cfs.avg.nr_pending)</span><br><span class="line">	    该负载会受RT进程的影响，因为rq-&gt;nr_running会统计包括RT进程的数量</span><br><span class="line">	 */</span><br><span class="line">	target_wload = hmp_inc(cfs_load(target));</span><br><span class="line">	target_wload += cfs_pending_load(target);</span><br><span class="line">	target_wload *= rq_length(target);</span><br><span class="line">	for_each_cpu(curr, mask) &#123;</span><br><span class="line">		/* Check CPU status and task affinity */</span><br><span class="line">		if (!cpu_online(curr) || !cpumask_test_cpu(curr, tsk_cpus_allowed(p)))</span><br><span class="line">			continue;</span><br><span class="line"></span><br><span class="line">		/* For global load balancing, unstable CPU will be bypassed */</span><br><span class="line">		/* (1.6.3) 如果当前是up操作，如果cpu在短时间内进行了down操作，则不适合马上进行up操作 */</span><br><span class="line">		if (hmp_caller_is_gb(caller) &amp;&amp; !hmp_cpu_stable(curr, up))</span><br><span class="line">			continue;</span><br><span class="line"></span><br><span class="line">		curr_wload = hmp_inc(cfs_load(curr));</span><br><span class="line">		curr_wload += cfs_pending_load(curr);</span><br><span class="line">		curr_wload *= rq_length(curr);</span><br><span class="line">		/* (1.6.4) 选择load最小的作为target cpu */</span><br><span class="line">		if (curr_wload &lt; target_wload) &#123;</span><br><span class="line">			target_wload = curr_wload;</span><br><span class="line">			target = curr;</span><br><span class="line">		/* (1.6.5) 在load同样小的情况下，选择prev cpu */</span><br><span class="line">		&#125; else if (curr_wload == target_wload &amp;&amp; curr == prev) &#123;</span><br><span class="line">			target = curr;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	return target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">||→</span><br><span class="line"></span><br><span class="line">static void sched_update_clbstats(struct clb_env *clbenv)</span><br><span class="line">&#123;</span><br><span class="line">	/* init cpu power and capacity */</span><br><span class="line">	/* (1.8.1) L族和B族的绝对运行能力和相对运算能力，</span><br><span class="line">	    .cpu_power = 绝对运算能力</span><br><span class="line">	    .cpu_capacity = 相对运算能力</span><br><span class="line">	 */</span><br><span class="line">	clbenv-&gt;bstats.cpu_power = (int) arch_scale_cpu_capacity(NULL, clbenv-&gt;btarget);</span><br><span class="line">	clbenv-&gt;lstats.cpu_power = (int) arch_scale_cpu_capacity(NULL, clbenv-&gt;ltarget);</span><br><span class="line">	clbenv-&gt;lstats.cpu_capacity = SCHED_CAPACITY_SCALE;</span><br><span class="line">	clbenv-&gt;bstats.cpu_capacity = SCHED_CAPACITY_SCALE * clbenv-&gt;bstats.cpu_power / (clbenv-&gt;lstats.cpu_power+1);</span><br><span class="line"></span><br><span class="line">    /* (1.8.2) L族和B族的 */</span><br><span class="line">	collect_cluster_stats(&amp;clbenv-&gt;bstats, &amp;clbenv-&gt;bcpus, clbenv-&gt;btarget);</span><br><span class="line">	collect_cluster_stats(&amp;clbenv-&gt;lstats, &amp;clbenv-&gt;lcpus, clbenv-&gt;ltarget);</span><br><span class="line">	</span><br><span class="line">	/* (1.8.3) L族和B族的 */</span><br><span class="line">	adj_threshold(clbenv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|||→</span><br><span class="line"></span><br><span class="line">static void collect_cluster_stats(struct clb_stats *clbs, struct cpumask *cluster_cpus, int target)</span><br><span class="line">&#123;</span><br><span class="line">#define HMP_RESOLUTION_SCALING (4)</span><br><span class="line">#define hmp_scale_down(w) ((w) &gt;&gt; HMP_RESOLUTION_SCALING)</span><br><span class="line"></span><br><span class="line">	/* Update cluster informatics */</span><br><span class="line">	int cpu;</span><br><span class="line"></span><br><span class="line">    /* (1.8.2.1) 累加本族online cpu的值 */</span><br><span class="line">	for_each_cpu(cpu, cluster_cpus) &#123;</span><br><span class="line">		if (cpu_online(cpu)) &#123;</span><br><span class="line">			clbs-&gt;ncpu++;</span><br><span class="line">			clbs-&gt;ntask += cpu_rq(cpu)-&gt;cfs.h_nr_running;</span><br><span class="line">			clbs-&gt;load_avg += cpu_rq(cpu)-&gt;cfs.avg.loadwop_avg;</span><br><span class="line">#ifdef CONFIG_SCHED_HMP_PRIO_FILTER</span><br><span class="line">			clbs-&gt;nr_normal_prio_task += cfs_nr_normal_prio(cpu);</span><br><span class="line">			clbs-&gt;nr_dequeuing_low_prio += cfs_nr_dequeuing_low_prio(cpu);</span><br><span class="line">#endif</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (!clbs-&gt;ncpu || target &gt;= num_possible_cpus() || !cpumask_test_cpu(target, cluster_cpus))</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Calculate available CPU capacity</span><br><span class="line">	 * Calculate available task space</span><br><span class="line">	 *</span><br><span class="line">	 * Why load ratio should be multiplied by the number of task ?</span><br><span class="line">	 * The task is the entity of scheduling unit so that we should consider</span><br><span class="line">	 * it in scheduler. Only considering task load is not enough.</span><br><span class="line">	 * Thus, multiplying the number of tasks can adjust load ratio to a more</span><br><span class="line">	 * reasonable value.</span><br><span class="line">	 */</span><br><span class="line">	/* (1.8.2.2) 计算本族剩余的cpu计算能力 </span><br><span class="line">	    capacity = 相对计算能力(clbs-&gt;cpu_capacity) - 本cpu的负载(rq-&gt;cfs.avg.loadwop_avg)</span><br><span class="line">	    ：clbs-&gt;cpu_capacity是B族和L族相对的(L是1024，B大于1024)，而负载(rq-&gt;cfs.avg.loadwop_avg)是相对自己的B族和L族的最大值都是1024</span><br><span class="line">	 */</span><br><span class="line">	clbs-&gt;load_avg /= clbs-&gt;ncpu;</span><br><span class="line">	clbs-&gt;acap = clbs-&gt;cpu_capacity - cpu_rq(target)-&gt;cfs.avg.loadwop_avg;</span><br><span class="line">	clbs-&gt;scaled_acap = hmp_scale_down(clbs-&gt;acap);</span><br><span class="line">	</span><br><span class="line">	/* (1.8.2.3) 计算本族剩余的task空间</span><br><span class="line">	    scaled_atask = 相对计算能力(clbs-&gt;cpu_capacity) - 本cpu的负载(rq-&gt;cfs.avg.loadwop_avg)*本cpu所有的进程数量(rq-&gt;cfs.h_nr_running)</span><br><span class="line">	    ooooo这里的计算也不是在同一纬度上的</span><br><span class="line">	 */</span><br><span class="line">	clbs-&gt;scaled_atask = cpu_rq(target)-&gt;cfs.h_nr_running * cpu_rq(target)-&gt;cfs.avg.loadwop_avg;</span><br><span class="line">	clbs-&gt;scaled_atask = clbs-&gt;cpu_capacity - clbs-&gt;scaled_atask;</span><br><span class="line">	clbs-&gt;scaled_atask = hmp_scale_down(clbs-&gt;scaled_atask);</span><br><span class="line"></span><br><span class="line">	mt_sched_printf(sched_log, &quot;[%s] cpu/cluster:%d/%02lx load/len:%lu/%u stats:%d,%d,%d,%d,%d,%d,%d,%d\n&quot;,</span><br><span class="line">			__func__, target, *cpumask_bits(cluster_cpus),</span><br><span class="line">			cpu_rq(target)-&gt;cfs.avg.loadwop_avg,</span><br><span class="line">			cpu_rq(target)-&gt;cfs.h_nr_running,</span><br><span class="line">			clbs-&gt;ncpu, clbs-&gt;ntask, clbs-&gt;load_avg, clbs-&gt;cpu_capacity,</span><br><span class="line">			clbs-&gt;acap, clbs-&gt;scaled_acap, clbs-&gt;scaled_atask, clbs-&gt;threshold);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|||→</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Task Dynamic Migration Threshold Adjustment.</span><br><span class="line"> *</span><br><span class="line"> * If the workload between clusters is not balanced, adjust migration</span><br><span class="line"> * threshold in an attempt to move task precisely.</span><br><span class="line"> *</span><br><span class="line"> * Diff. = Max Threshold - Min Threshold</span><br><span class="line"> *</span><br><span class="line"> * Dynamic UP-Threshold =</span><br><span class="line"> *                               B_nacap               B_natask</span><br><span class="line"> * Max Threshold - Diff. x  -----------------  x  -------------------</span><br><span class="line"> *                          B_nacap + L_nacap     B_natask + L_natask</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> * Dynamic Down-Threshold =</span><br><span class="line"> *                               L_nacap               L_natask</span><br><span class="line"> * Min Threshold + Diff. x  -----------------  x  -------------------</span><br><span class="line"> *                          B_nacap + L_nacap     B_natask + L_natask</span><br><span class="line"> */</span><br><span class="line">static void adj_threshold(struct clb_env *clbenv)</span><br><span class="line">&#123;</span><br><span class="line">#define POSITIVE(x) ((int)(x) &lt; 0 ? 0 : (x))</span><br><span class="line"></span><br><span class="line">	unsigned long b_cap = 0, l_cap = 0;</span><br><span class="line">	int b_nacap, l_nacap, b_natask, l_natask;</span><br><span class="line"></span><br><span class="line">	b_cap = clbenv-&gt;bstats.cpu_power;</span><br><span class="line">	l_cap = clbenv-&gt;lstats.cpu_power;</span><br><span class="line">	</span><br><span class="line">	/* (1.8.3.1) 把B族剩余cpu计算能力和task空间，转换成L族的相对值 */</span><br><span class="line">	b_nacap = POSITIVE(clbenv-&gt;bstats.scaled_acap *</span><br><span class="line">			clbenv-&gt;bstats.cpu_power / (clbenv-&gt;lstats.cpu_power+1));</span><br><span class="line">	b_natask = POSITIVE(clbenv-&gt;bstats.scaled_atask *</span><br><span class="line">			clbenv-&gt;bstats.cpu_power / (clbenv-&gt;lstats.cpu_power+1));</span><br><span class="line">	</span><br><span class="line">	/* L族的值维持不变 */		</span><br><span class="line">	l_nacap = POSITIVE(clbenv-&gt;lstats.scaled_acap);</span><br><span class="line">	l_natask = POSITIVE(clbenv-&gt;lstats.scaled_atask);</span><br><span class="line"></span><br><span class="line">    /* (1.8.3.2) 计算up的threshold， </span><br><span class="line">        up-threshold = HMP_MAX_LOAD - HMP_MAX_LOAD*B族剩余</span><br><span class="line">     */</span><br><span class="line">	clbenv-&gt;bstats.threshold = HMP_MAX_LOAD - HMP_MAX_LOAD * b_nacap * b_natask /</span><br><span class="line">		((b_nacap + l_nacap) * (b_natask + l_natask) + 1);</span><br><span class="line">		</span><br><span class="line">	/* (1.8.3.3) 计算down的threshold， </span><br><span class="line">        down-threshold = HMP_MAX_LOAD*L族剩余</span><br><span class="line">     */</span><br><span class="line">	clbenv-&gt;lstats.threshold = HMP_MAX_LOAD * l_nacap * l_natask /</span><br><span class="line">		((b_nacap + l_nacap) * (b_natask + l_natask) + 1);</span><br><span class="line"></span><br><span class="line">	mt_sched_printf(sched_log, &quot;[%s]\tup/dl:%4d/%4d L(%d:%4lu) b(%d:%4lu)\n&quot;, __func__,</span><br><span class="line">			clbenv-&gt;bstats.threshold, clbenv-&gt;lstats.threshold,</span><br><span class="line">			clbenv-&gt;ltarget, l_cap, clbenv-&gt;btarget, b_cap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">||→</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Check whether this task should be migrated to big</span><br><span class="line"> * Briefly summarize the flow as below;</span><br><span class="line"> * 1) Migration stabilizing</span><br><span class="line"> * 2) Filter low-priority task</span><br><span class="line"> * 2.5) Keep all cpu busy</span><br><span class="line"> * 3) Check CPU capacity</span><br><span class="line"> * 4) Check dynamic migration threshold</span><br><span class="line"> */</span><br><span class="line">static unsigned int hmp_up_migration(int cpu, int *target_cpu, struct sched_entity *se,</span><br><span class="line">		struct clb_env *clbenv)</span><br><span class="line">&#123;</span><br><span class="line">	struct task_struct *p = task_of(se);</span><br><span class="line">	struct clb_stats *L, *B;</span><br><span class="line">	struct mcheck *check;</span><br><span class="line">	int curr_cpu = cpu;</span><br><span class="line">#ifdef CONFIG_HMP_TRACER</span><br><span class="line">	unsigned int caller = clbenv-&gt;flags;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	L = &amp;clbenv-&gt;lstats;</span><br><span class="line">	B = &amp;clbenv-&gt;bstats;</span><br><span class="line">	check = &amp;clbenv-&gt;mcheck;</span><br><span class="line"></span><br><span class="line">	check-&gt;status = clbenv-&gt;flags;</span><br><span class="line">	check-&gt;status |= HMP_TASK_UP_MIGRATION;</span><br><span class="line">	check-&gt;result = 0;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * No migration is needed if</span><br><span class="line">	 * 1) There is only one cluster</span><br><span class="line">	 * 2) Task is already in big cluster</span><br><span class="line">	 * 3) It violates task affinity</span><br><span class="line">	 */</span><br><span class="line">	if (!L-&gt;ncpu || !B-&gt;ncpu</span><br><span class="line">			|| cpumask_test_cpu(curr_cpu, &amp;clbenv-&gt;bcpus)</span><br><span class="line">			|| !cpumask_intersects(&amp;clbenv-&gt;bcpus, tsk_cpus_allowed(p)))</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">    /* (1.9.1) 如果目标cpu短时间内已经执行了up操作，则为up unstable状态，退出 */</span><br><span class="line">	/*</span><br><span class="line">	 * [1] Migration stabilizing</span><br><span class="line">	 * Let the task load settle before doing another up migration.</span><br><span class="line">	 * It can prevent a bunch of tasks from migrating to a unstable CPU.</span><br><span class="line">	 */</span><br><span class="line">	if (!hmp_up_stable(*target_cpu))</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">    /* (1.9.2) 过滤掉优先级较低的进程，不进行迁移操作。具体有3个条件：</span><br><span class="line">	    (task_low_priority(p-&gt;prio) &amp;&amp; \    // nice值大于5</span><br><span class="line">	    (B-&gt;ntask &gt;= B-&gt;ncpu || 0 != L-&gt;nr_normal_prio_task) &amp;&amp; \  // B组进程大于cou数 || 正常优先级的进程不为0</span><br><span class="line">	    (p-&gt;se.avg.loadwop_avg &lt; 800))  // 平均负载小于800</span><br><span class="line">	 */</span><br><span class="line">	/* [2] Filter low-priority task */</span><br><span class="line">#ifdef CONFIG_SCHED_HMP_PRIO_FILTER</span><br><span class="line">	if (hmp_low_prio_task_up_rejected(p, B, L)) &#123;</span><br><span class="line">		check-&gt;status |= HMP_LOW_PRIORITY_FILTER;</span><br><span class="line">		goto trace;</span><br><span class="line">	&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    /* (1.9.3) 如果B组的target cpu为idle，不用过多判断，直接准备迁移 */</span><br><span class="line">	/* [2.5]if big is idle, just go to big */</span><br><span class="line">	if (rq_length(*target_cpu) == 0) &#123;</span><br><span class="line">		check-&gt;status |= HMP_BIG_IDLE;</span><br><span class="line">		check-&gt;status |= HMP_MIGRATION_APPROVED;</span><br><span class="line">		check-&gt;result = 1;</span><br><span class="line">		goto trace;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (1.9.4) 判断B族target cpu的capacity是否足够，</span><br><span class="line">        (se_load(se) + cfs_load(cpu)) &lt; (B-&gt;cpu_capacity - (B-&gt;cpu_capacity &gt;&gt; 2))</span><br><span class="line">        // target cpu负载 + 要迁移的se负载 是否小于 3/4 B族cpu的capacity</span><br><span class="line">     */</span><br><span class="line">	/*</span><br><span class="line">	 * [3] Check CPU capacity</span><br><span class="line">	 * Forbid up-migration if big CPU can&apos;t handle this task</span><br><span class="line">	 */</span><br><span class="line">	if (!hmp_task_fast_cpu_afford(B, se, *target_cpu)) &#123;</span><br><span class="line">		check-&gt;status |= HMP_BIG_CAPACITY_INSUFFICIENT;</span><br><span class="line">		goto trace;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (1.9.5) 判断se的负载是否已经大于up-threshold(B-&gt;threshold) */</span><br><span class="line">	/*</span><br><span class="line">	 * [4] Check dynamic migration threshold</span><br><span class="line">	 * Migrate task from LITTLE to big if load is greater than up-threshold</span><br><span class="line">	 */</span><br><span class="line">	if (se_load(se) &gt; B-&gt;threshold) &#123;</span><br><span class="line">		check-&gt;status |= HMP_MIGRATION_APPROVED;</span><br><span class="line">		check-&gt;result = 1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">trace:</span><br><span class="line">#ifdef CONFIG_HMP_TRACER</span><br><span class="line">	if (check-&gt;result &amp;&amp; hmp_caller_is_gb(caller))</span><br><span class="line">		hmp_stats.nr_force_up++;</span><br><span class="line">	trace_sched_hmp_stats(&amp;hmp_stats);</span><br><span class="line">	trace_sched_dynamic_threshold(task_of(se), B-&gt;threshold, check-&gt;status,</span><br><span class="line">			curr_cpu, *target_cpu, se_load(se), B, L);</span><br><span class="line">	trace_sched_dynamic_threshold_draw(B-&gt;threshold, L-&gt;threshold);</span><br><span class="line">#endif</span><br><span class="line">out:</span><br><span class="line">	return check-&gt;result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">||→</span><br><span class="line"></span><br><span class="line">static int hmp_force_up_cpu_stop(void *data)</span><br><span class="line">&#123;</span><br><span class="line">    /* (1.10.1) 执行进程迁移 */</span><br><span class="line">	return hmp_active_task_migration_cpu_stop(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|||→</span><br><span class="line"></span><br><span class="line">static int hmp_active_task_migration_cpu_stop(void *data)</span><br><span class="line">&#123;</span><br><span class="line">	struct rq *busiest_rq = data;</span><br><span class="line">	struct task_struct *p = NULL;</span><br><span class="line">	int busiest_cpu = cpu_of(busiest_rq);</span><br><span class="line">	int target_cpu = busiest_rq-&gt;push_cpu;</span><br><span class="line">	struct rq *target_rq = cpu_rq(target_cpu);</span><br><span class="line">	struct sched_domain *sd;</span><br><span class="line"></span><br><span class="line">	raw_spin_lock_irq(&amp;busiest_rq-&gt;lock);</span><br><span class="line">	p = busiest_rq-&gt;migrate_task;</span><br><span class="line">	/* make sure the requested cpu hasn&apos;t gone down in the meantime */</span><br><span class="line">	if (unlikely(busiest_cpu != smp_processor_id() ||</span><br><span class="line">				!busiest_rq-&gt;active_balance)) &#123;</span><br><span class="line">		goto out_unlock;</span><br><span class="line">	&#125;</span><br><span class="line">	/* Is there any task to move? */</span><br><span class="line">	if (busiest_rq-&gt;nr_running &lt;= 1)</span><br><span class="line">		goto out_unlock;</span><br><span class="line">	/* Are both target and busiest cpu online */</span><br><span class="line">	if (!cpu_online(busiest_cpu) || !cpu_online(target_cpu))</span><br><span class="line">		goto out_unlock;</span><br><span class="line">	/* Task has migrated meanwhile, abort forced migration */</span><br><span class="line">	if ((!p) || (task_rq(p) != busiest_rq))</span><br><span class="line">		goto out_unlock;</span><br><span class="line">	/*</span><br><span class="line">	 * This condition is &quot;impossible&quot;, if it occurs</span><br><span class="line">	 * we need to fix it. Originally reported by</span><br><span class="line">	 * Bjorn Helgaas on a 128-cpu setup.</span><br><span class="line">	 */</span><br><span class="line">	WARN_ON(busiest_rq == target_rq);</span><br><span class="line"></span><br><span class="line">    /* (1.10.1.1) 将源、目的rq lock住 */</span><br><span class="line">	/* move a task from busiest_rq to target_rq */</span><br><span class="line">	double_lock_balance(busiest_rq, target_rq);</span><br><span class="line"></span><br><span class="line">    /* (1.10.1.2) 搜索target cpu所在的某一层次的sd，其sd-&gt;span[]即包含源cpu又包含目的cpu */</span><br><span class="line">	/* Search for an sd spanning us and the target CPU. */</span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	for_each_domain(target_cpu, sd) &#123;</span><br><span class="line">		if (cpumask_test_cpu(busiest_cpu, sched_domain_span(sd)))</span><br><span class="line">			break;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (1.10.1.3) 构造数据，在同一sd下进行迁移 */</span><br><span class="line">	if (likely(sd)) &#123;</span><br><span class="line">		struct lb_env env = &#123;</span><br><span class="line">			.sd             = sd,</span><br><span class="line">			.dst_cpu        = target_cpu,</span><br><span class="line">			.dst_rq         = target_rq,</span><br><span class="line">			.src_cpu        = busiest_rq-&gt;cpu,</span><br><span class="line">			.src_rq         = busiest_rq,</span><br><span class="line">			.idle           = CPU_IDLE,</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		schedstat_inc(sd, alb_count);</span><br><span class="line"></span><br><span class="line">        /* (1.10.1.4) 任务迁移 */</span><br><span class="line">		if (move_specific_task(&amp;env, p))</span><br><span class="line">			schedstat_inc(sd, alb_pushed);</span><br><span class="line">		else</span><br><span class="line">			schedstat_inc(sd, alb_failed);</span><br><span class="line">	&#125;</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	double_unlock_balance(busiest_rq, target_rq);</span><br><span class="line">out_unlock:</span><br><span class="line">	busiest_rq-&gt;active_balance = 0;</span><br><span class="line">	raw_spin_unlock_irq(&amp;busiest_rq-&gt;lock);</span><br><span class="line"></span><br><span class="line">	put_task_struct(p);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">||||→</span><br><span class="line"></span><br><span class="line">static int move_specific_task(struct lb_env *env, struct task_struct *pm)</span><br><span class="line">&#123;</span><br><span class="line">	struct task_struct *p, *n;</span><br><span class="line"></span><br><span class="line">    /* (1.10.1.4.1) 从源rq-&gt;cfs_tasks逐个取出任务，直到查到pm */</span><br><span class="line">	list_for_each_entry_safe(p, n, &amp;env-&gt;src_rq-&gt;cfs_tasks, se.group_node) &#123;</span><br><span class="line">	</span><br><span class="line">	    /* (1.10.1.4.2) task group的throttled判断 */</span><br><span class="line">		if (throttled_lb_pair(task_group(p), env-&gt;src_rq-&gt;cpu,</span><br><span class="line">					env-&gt;dst_cpu))</span><br><span class="line">			continue;</span><br><span class="line"></span><br><span class="line">        /* (1.10.1.4.3) 判断任务能否被迁移 */</span><br><span class="line">		if (!hmp_can_migrate_task(p, env))</span><br><span class="line">			continue;</span><br><span class="line">		/* Check if we found the right task */</span><br><span class="line">		if (p != pm)</span><br><span class="line">			continue;</span><br><span class="line"></span><br><span class="line">        /* (1.10.1.4.4) 迁移 */</span><br><span class="line">		move_task(p, env);</span><br><span class="line">		/*</span><br><span class="line">		 * Right now, this is only the third place move_task()</span><br><span class="line">		 * is called, so we can safely collect move_task()</span><br><span class="line">		 * stats here rather than inside move_task().</span><br><span class="line">		 */</span><br><span class="line">		schedstat_inc(env-&gt;sd, lb_gained[env-&gt;idle]);</span><br><span class="line">		return 1;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|||||→</span><br><span class="line"></span><br><span class="line">static void move_task(struct task_struct *p, struct lb_env *env)</span><br><span class="line">&#123;</span><br><span class="line">	deactivate_task(env-&gt;src_rq, p, 0);</span><br><span class="line">	set_task_cpu(p, env-&gt;dst_cpu);</span><br><span class="line">	activate_task(env-&gt;dst_rq, p, 0);</span><br><span class="line">	check_preempt_curr(env-&gt;dst_rq, p, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-3、hmp-force-down-migration"><a href="#4-2-3、hmp-force-down-migration" class="headerlink" title="4.2.3、hmp_force_down_migration()"></a>4.2.3、hmp_force_down_migration()</h3><p>hmp_force_down_migration()的操作主要有以下几个步骤：</p>
<ul>
<li>1、根据当前cpu，选择fast_cpu_mask、slow_cpu_mask；</li>
</ul>
<p>hmp_force_down_migration尝试把fast cpu上的light进程迁移到slow cpu上，关于fast、slow的选择有以下几种场景：</p>
<p><img src="/images/scheduler/schedule_hmp_down_migration.png" alt="schedule_hmp_down_migration"></p>
<ul>
<li><p>2、选择当前cpu的lightest进程作为迁移进程p；并不会遍历cpu上所有进程去选出lightest进程，只会查询curr进程和cfs_rq中5个进程中的lightest；</p>
</li>
<li><p>3、根据slow_cpu_mask，选择一个负载最少的target cpu；</p>
</li>
</ul>
<p><img src="/images/scheduler/schedule_hmp_force_down_migration_hmp_select_cpu.png" alt="schedule_hmp_force_down_migration_hmp_select_cpu"></p>
<ul>
<li>4、根据源cpu(curr_cpu)、目的cpu(target_cpu)，计算负载；</li>
</ul>
<p>重要的数据计算方法和hmp_force_up_migration()一致，参考上一节；</p>
<ul>
<li>5、根据计算的负载情况，判断进程p是否符合down迁移条件((L-&gt;threshold &gt;= se_load(se))，等其他条件)；</li>
</ul>
<p>down-migration条件列表(hmp_down_migration())：</p>
<html><br><table><br>    <tr><br>        <td style="width: 100px;"> 条件 </td><br>        <td style="width: 100px;"> 含义 </td><br>        <td style="width: 200px;"> 计算方法 </td><br>        <td style="width: 200px;"> 计算解析 </td><br>    </tr><br>    <tr><br>        <td> [1] Migration stabilizing </td><br>        <td> 如果target cpu刚做过down迁移，不适合再进行迁移 </td><br>        <td> if (!hmp_down_stable(<em>target_cpu)) check-&gt;result = 0; </em></td><br>        <td> (((now - hmp_last_down_migration(cpu)) &gt;&gt; 10) &lt; hmp_next_down_threshold) //间隔时间小于hmp_next_down_threshold </td><br>    </tr><br>    <tr><br>        <td> [1.5]if big is busy and little is idle, just go to little </td><br>        <td> 如果big cpu busy &amp;&amp; little cpu idle，则不用进行其他判断，直接满足up迁移 </td><br>        <td> if ((rq_length(target_cpu) == 0 &amp;&amp; caller == HMP_SELECT_RQ &amp;&amp; rq_length(curr_cpu) &gt; 0) &amp;&amp; (!(!is_heavy_task(curr_rq-&gt;curr) &amp;&amp; is_heavy_task(p)))) check-&gt;result = 1;</td><br>        <td> caller == HMP_SELECT_RQ // 只有select rq操作时有效； is_heavy_task() // p-&gt;se.avg.loadwop_avg &gt;= 650 </td><br>    </tr><br>    <tr><br>        <td> [2] Filter low-priority task </td><br>        <td> 低优先级进程(nice&gt;5)如果满足以下条件，准许迁移 </td><br>        <td> if (hmp_low_prio_task_down_allowed(p, B, L)) check-&gt;result = 1; </td><br>        <td> (task_low_priority(p-&gt;prio) &amp;&amp; !B-&gt;nr_dequeuing_low_prio &amp;&amp; B-&gt;ntask &gt;= B-&gt;ncpu &amp;&amp; 0 != L-&gt;nr_normal_prio_task &amp;&amp; (p-&gt;se.avg.loadwop_avg &lt; 800)) // (nice值大于5) &amp;&amp; (B和L都不是特别空闲) &amp;&amp; (进程负载&lt;800) </td><br>    </tr><br>    <tr><br>        <td> [3] Check CPU capacity，1) big cpu is not oversubscribed </td><br>        <td> 如果big cpu有足够的空闲周期，不需要强制把big cpu的light任务迁移到little cpu上 </td><br>        <td> if (!hmp_fast_cpu_oversubscribed(caller, B, se, curr_cpu)) check-&gt;result = 0; </td><br>        <td> cfs_load(curr_cpu) &lt; (B-&gt;cpu_capacity - (B-&gt;cpu_capacity &gt;&gt; 2)) // 当前cpu负载小于3/4 cpu_capacity </td><br>    </tr><br>    <tr><br>        <td> [3] Check CPU capacity，2) LITTLE cpu doesn’t have available capacity for this new task </td><br>        <td> 判断L族cpu的剩余capacity是否足够容纳需要迁移的进程 </td><br>        <td> if (!hmp_task_slow_cpu_afford(L, se)) check-&gt;result = 0; </td><br>        <td> (L-&gt;acap &gt; 0 &amp;&amp; L-&gt;acap &gt;= se_load(se)) // L族cpu的剩余能力大于se的负载，才能继续判断 </td><br>    </tr><br>    <tr><br>        <td> [4] Check dynamic migration threshold </td><br>        <td> 如果进程的负载低于down迁移的门限值，则满足down迁移 </td><br>        <td> if (L-&gt;threshold &gt;= se_load(se)) check-&gt;result = 1; </td><br>        <td>  </td><br>    </tr><br></table><br></html>

<ul>
<li>6、如果条件符合，进行实际的down迁移；</li>
</ul>
<p>hmp_force_down_migration()详细的代码解析：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br></pre></td><td class="code"><pre><span class="line">static void hmp_force_down_migration(int this_cpu)</span><br><span class="line">&#123;</span><br><span class="line">	int target_cpu;</span><br><span class="line">	struct sched_entity *se;</span><br><span class="line">	struct rq *target;</span><br><span class="line">	unsigned long flags;</span><br><span class="line">	unsigned int force = 0;</span><br><span class="line">	struct task_struct *p;</span><br><span class="line">	struct clb_env clbenv;</span><br><span class="line">#ifdef CONFIG_SCHED_HMP_PLUS</span><br><span class="line">	struct sched_entity *orig;</span><br><span class="line">	int B_cpu;</span><br><span class="line">#endif</span><br><span class="line">	struct hmp_domain *hmp_domain = NULL;</span><br><span class="line">	struct cpumask fast_cpu_mask, slow_cpu_mask;</span><br><span class="line"></span><br><span class="line">	cpumask_clear(&amp;fast_cpu_mask);</span><br><span class="line">	cpumask_clear(&amp;slow_cpu_mask);</span><br><span class="line"></span><br><span class="line">	/* Migrate light task from big to LITTLE */</span><br><span class="line">	/* (1) 如果当前cpu不是最慢的cpu(slowest)，则尝试down操作 */</span><br><span class="line">	if (!hmp_cpu_is_slowest(this_cpu)) &#123;</span><br><span class="line">	</span><br><span class="line">	    /* (2) 当前cpu所在的hmp_domain为fast_cpu_mask */</span><br><span class="line">		hmp_domain = hmp_cpu_domain(this_cpu);</span><br><span class="line">		cpumask_copy(&amp;fast_cpu_mask, &amp;hmp_domain-&gt;possible_cpus);</span><br><span class="line">		</span><br><span class="line">		/* (3) 查找相比当前最慢且online的hmp_domain作为slow_cpu_mask */</span><br><span class="line">		while (!list_is_last(&amp;hmp_domain-&gt;hmp_domains, &amp;hmp_domains)) &#123;</span><br><span class="line">			struct list_head *pos = &amp;hmp_domain-&gt;hmp_domains;</span><br><span class="line"></span><br><span class="line">			hmp_domain = list_entry(pos-&gt;next, struct hmp_domain, hmp_domains);</span><br><span class="line"></span><br><span class="line">			if (!cpumask_empty(&amp;hmp_domain-&gt;cpus)) &#123;</span><br><span class="line">				cpumask_copy(&amp;slow_cpu_mask, &amp;hmp_domain-&gt;possible_cpus);</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	if (!hmp_domain || hmp_domain == hmp_cpu_domain(this_cpu))</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">    /* (4) 找不到可操作的fast_cpu_mask、slow_cpu_mask直接返回 */</span><br><span class="line">	if (cpumask_empty(&amp;fast_cpu_mask) || cpumask_empty(&amp;slow_cpu_mask))</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">    /* (5) 源cpu = this_cpu，源rq = target */</span><br><span class="line">	force = 0;</span><br><span class="line">	target = cpu_rq(this_cpu);</span><br><span class="line">	raw_spin_lock_irqsave(&amp;target-&gt;lock, flags);</span><br><span class="line">	se = target-&gt;cfs.curr;</span><br><span class="line">	if (!se) &#123;</span><br><span class="line">		raw_spin_unlock_irqrestore(&amp;target-&gt;lock, flags);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (6) 首先尝试使用curr进程作为down迁移的进程 */</span><br><span class="line">	/* Find task entity */</span><br><span class="line">	if (!entity_is_task(se)) &#123;</span><br><span class="line">		struct cfs_rq *cfs_rq;</span><br><span class="line"></span><br><span class="line">		cfs_rq = group_cfs_rq(se);</span><br><span class="line">		while (cfs_rq) &#123;</span><br><span class="line">			se = cfs_rq-&gt;curr;</span><br><span class="line">			cfs_rq = group_cfs_rq(se);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">#ifdef CONFIG_SCHED_HMP_PLUS</span><br><span class="line">    /* (7) 在curr进程开始的5个进程中，挑负载最轻的进程作为down迁移进程 */</span><br><span class="line">	orig = se;</span><br><span class="line">	se = hmp_get_lightest_task(orig, 1);</span><br><span class="line">	if (!entity_is_task(se))</span><br><span class="line">		p = task_of(orig);</span><br><span class="line">	else</span><br><span class="line">#endif</span><br><span class="line">		p = task_of(se);</span><br><span class="line">#ifdef CONFIG_SCHED_HMP_PLUS</span><br><span class="line">    /* (8) 找出B族中负载最轻的cpu，如果其为idle状态，则放弃down操作 </span><br><span class="line">        因为load_balance中的idle_balance会重新把任务迁移回idle的big cpu，避免相互的乒乓操作</span><br><span class="line">     */</span><br><span class="line">	/* Don&apos;t offload to little if there is one idle big, let load balance to do it&apos;s work */</span><br><span class="line">	/* Also, to prevent idle_balance from leading to potential ping-pong */</span><br><span class="line">	B_cpu = hmp_select_cpu(HMP_GB, p, &amp;fast_cpu_mask, this_cpu, 0);</span><br><span class="line">	if (B_cpu &lt; nr_cpu_ids &amp;&amp; !rq_length(B_cpu)) &#123;</span><br><span class="line">		raw_spin_unlock_irqrestore(&amp;target-&gt;lock, flags);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    /* (9) 找出L族中负载最轻的cpu作为target_cpu */</span><br><span class="line">	target_cpu = hmp_select_cpu(HMP_GB, p, &amp;slow_cpu_mask, -1, 1);</span><br><span class="line">	if (target_cpu &gt;= num_possible_cpus()) &#123;</span><br><span class="line">		raw_spin_unlock_irqrestore(&amp;target-&gt;lock, flags);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (10) 迁移前对B族、L族负载和threshold的计算 */</span><br><span class="line">	/* Collect cluster information */</span><br><span class="line">	memset(&amp;clbenv, 0, sizeof(clbenv));</span><br><span class="line">	clbenv.flags |= HMP_GB;</span><br><span class="line">	clbenv.btarget = this_cpu;</span><br><span class="line">	clbenv.ltarget = target_cpu;</span><br><span class="line">	cpumask_copy(&amp;clbenv.lcpus, &amp;slow_cpu_mask);</span><br><span class="line">	cpumask_copy(&amp;clbenv.bcpus, &amp;fast_cpu_mask);</span><br><span class="line">	sched_update_clbstats(&amp;clbenv);</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_SCHED_HMP_PLUS</span><br><span class="line">	if (cpu_rq(this_cpu)-&gt;cfs.h_nr_running &lt; 2) &#123;</span><br><span class="line">		raw_spin_unlock_irqrestore(&amp;target-&gt;lock, flags);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    /* (11) 检查down操作的迁移条件是否成立,hmp_down_migration() */</span><br><span class="line">	/* Check migration threshold */</span><br><span class="line">	if (!target-&gt;active_balance &amp;&amp;</span><br><span class="line">			hmp_down_migration(this_cpu, &amp;target_cpu, se, &amp;clbenv) &amp;&amp;</span><br><span class="line">			!cpu_park(cpu_of(target))) &#123;</span><br><span class="line">		if (p-&gt;state != TASK_DEAD) &#123;</span><br><span class="line">			get_task_struct(p);</span><br><span class="line">			target-&gt;active_balance = 1; /* force down */</span><br><span class="line">			target-&gt;push_cpu = target_cpu;</span><br><span class="line">			target-&gt;migrate_task = p;</span><br><span class="line">			force = 1;</span><br><span class="line">			trace_sched_hmp_migrate(p, target-&gt;push_cpu, 1);</span><br><span class="line">			hmp_next_down_delay(&amp;p-&gt;se, target-&gt;push_cpu);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	raw_spin_unlock_irqrestore(&amp;target-&gt;lock, flags);</span><br><span class="line">	</span><br><span class="line">	/* (12) 条件成立进行实际的down迁移操作hmp_force_down_cpu_stop() */</span><br><span class="line">	if (force) &#123;</span><br><span class="line">		if (stop_one_cpu_dispatch(cpu_of(target),</span><br><span class="line">					hmp_force_down_cpu_stop,</span><br><span class="line">					target, &amp;target-&gt;active_balance_work)) &#123;</span><br><span class="line">			put_task_struct(p); /* out of rq-&gt;lock */</span><br><span class="line">			raw_spin_lock_irqsave(&amp;target-&gt;lock, flags);</span><br><span class="line">			target-&gt;active_balance = 0;</span><br><span class="line">			force = 0;</span><br><span class="line">			raw_spin_unlock_irqrestore(&amp;target-&gt;lock, flags);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">static struct sched_entity *hmp_get_lightest_task(</span><br><span class="line">		struct sched_entity *se, int migrate_down)</span><br><span class="line">&#123;</span><br><span class="line">	int num_tasks = hmp_max_tasks;</span><br><span class="line">	struct sched_entity *min_se = se;</span><br><span class="line">	unsigned long int min_ratio = se-&gt;avg.loadwop_avg;</span><br><span class="line">	const struct cpumask *hmp_target_mask = NULL;</span><br><span class="line"></span><br><span class="line">	if (migrate_down) &#123;</span><br><span class="line">		struct hmp_domain *hmp;</span><br><span class="line"></span><br><span class="line">        /* (7.1) 如果cpu是最慢cpu(slowest)则直接退出，</span><br><span class="line">            因为本函数的目的是找出faster cpu中lightest进程</span><br><span class="line">         */</span><br><span class="line">		if (hmp_cpu_is_slowest(cpu_of(se-&gt;cfs_rq-&gt;rq)))</span><br><span class="line">			return min_se;</span><br><span class="line">			</span><br><span class="line">		/* (7.2) 将更slow一级的hmp_domain作为进程cpu亲和力的mask */</span><br><span class="line">		hmp = hmp_slower_domain(cpu_of(se-&gt;cfs_rq-&gt;rq));</span><br><span class="line">		hmp_target_mask = &amp;hmp-&gt;cpus;</span><br><span class="line">	&#125;</span><br><span class="line">	/* The currently running task is not on the runqueue */</span><br><span class="line">	se = __pick_first_entity(cfs_rq_of(se));</span><br><span class="line"></span><br><span class="line">    /* (7.3) 从当前cpu的cfs红黑树中，连续5个进程和curr进程比较，选出lightest进程 </span><br><span class="line">	    比较使用的负载为se-&gt;avg.loadwop_avg，不带weight分量</span><br><span class="line">	 */</span><br><span class="line">	while (num_tasks &amp;&amp; se) &#123;</span><br><span class="line">		if (entity_is_task(se) &amp;&amp;</span><br><span class="line">				(se-&gt;avg.loadwop_avg &lt; min_ratio &amp;&amp; hmp_target_mask &amp;&amp;</span><br><span class="line">				 cpumask_intersects(hmp_target_mask, tsk_cpus_allowed(task_of(se))))) &#123;</span><br><span class="line">			min_se = se;</span><br><span class="line">			min_ratio = se-&gt;avg.loadwop_avg;</span><br><span class="line">		&#125;</span><br><span class="line">		se = __pick_next_entity(se);</span><br><span class="line">		num_tasks--;</span><br><span class="line">	&#125;</span><br><span class="line">	return min_se;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Check whether this task should be migrated to LITTLE</span><br><span class="line"> * Briefly summarize the flow as below;</span><br><span class="line"> * 1) Migration stabilizing</span><br><span class="line"> * 1.5) Keep all cpu busy</span><br><span class="line"> * 2) Filter low-priority task</span><br><span class="line"> * 3) Check CPU capacity</span><br><span class="line"> * 4) Check dynamic migration threshold</span><br><span class="line"> */</span><br><span class="line">static unsigned int hmp_down_migration(int cpu, int *target_cpu, struct sched_entity *se,</span><br><span class="line">		struct clb_env *clbenv)</span><br><span class="line">&#123;</span><br><span class="line">	struct task_struct *p = task_of(se);</span><br><span class="line">	struct clb_stats *L, *B;</span><br><span class="line">	struct mcheck *check;</span><br><span class="line">	int curr_cpu = cpu;</span><br><span class="line">	unsigned int caller = clbenv-&gt;flags;</span><br><span class="line"></span><br><span class="line">	L = &amp;clbenv-&gt;lstats;</span><br><span class="line">	B = &amp;clbenv-&gt;bstats;</span><br><span class="line">	check = &amp;clbenv-&gt;mcheck;</span><br><span class="line"></span><br><span class="line">	check-&gt;status = caller;</span><br><span class="line">	check-&gt;status |= HMP_TASK_DOWN_MIGRATION;</span><br><span class="line">	check-&gt;result = 0;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * No migration is needed if</span><br><span class="line">	 * 1) There is only one cluster</span><br><span class="line">	 * 2) Task is already in LITTLE cluster</span><br><span class="line">	 * 3) It violates task affinity</span><br><span class="line">	 */</span><br><span class="line">	if (!L-&gt;ncpu || !B-&gt;ncpu</span><br><span class="line">			|| cpumask_test_cpu(curr_cpu, &amp;clbenv-&gt;lcpus)</span><br><span class="line">			|| !cpumask_intersects(&amp;clbenv-&gt;lcpus, tsk_cpus_allowed(p)))</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">    /* (11.1) 目的little cpu target_cpu近期如果有做过down操作，不适合再做down迁移 */</span><br><span class="line">	/*</span><br><span class="line">	 * [1] Migration stabilizing</span><br><span class="line">	 * Let the task load settle before doing another down migration.</span><br><span class="line">	 * It can prevent a bunch of tasks from migrating to a unstable CPU.</span><br><span class="line">	 */</span><br><span class="line">	if (!hmp_down_stable(*target_cpu))</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">    /* (11.2) 如果big busy，little idle则不用进行threshold判断 */</span><br><span class="line">	/* [1.5]if big is busy and little is idle, just go to little */</span><br><span class="line">	if (rq_length(*target_cpu) == 0 &amp;&amp; caller == HMP_SELECT_RQ &amp;&amp; rq_length(curr_cpu) &gt; 0) &#123;</span><br><span class="line">		struct rq *curr_rq = cpu_rq(curr_cpu);</span><br><span class="line"></span><br><span class="line">        /* (11.2.1) 如果big cpu，curr进程不是heavy进程，但是p是heavy进程，直接准许down迁移 </span><br><span class="line">            heavy进程的判断标准为：负载&gt;=650</span><br><span class="line">         */</span><br><span class="line">		/* if current big core is not heavy task and wake up task is heavy task no go to little */</span><br><span class="line">		if (!(!is_heavy_task(curr_rq-&gt;curr) &amp;&amp; is_heavy_task(p))) &#123;</span><br><span class="line">			check-&gt;status |= HMP_BIG_BUSY_LITTLE_IDLE;</span><br><span class="line">			check-&gt;status |= HMP_MIGRATION_APPROVED;</span><br><span class="line">			check-&gt;result = 1;</span><br><span class="line">			goto trace;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (11.3) 低优先级进程，如果满足以下条件，准许迁移：</span><br><span class="line">        (task_low_priority(p-&gt;prio) &amp;&amp; !B-&gt;nr_dequeuing_low_prio &amp;&amp; \   // nice值大于5</span><br><span class="line">         B-&gt;ntask &gt;= B-&gt;ncpu &amp;&amp; 0 != L-&gt;nr_normal_prio_task &amp;&amp; \        // B和L都不是特别空闲</span><br><span class="line">         (p-&gt;se.avg.loadwop_avg &lt; 800))                                 // L上准备迁移的进程负载小于800</span><br><span class="line">	 */</span><br><span class="line">	/* [2] Filter low-priority task */</span><br><span class="line">#ifdef CONFIG_SCHED_HMP_PRIO_FILTER</span><br><span class="line">	if (hmp_low_prio_task_down_allowed(p, B, L)) &#123;</span><br><span class="line">		cfs_nr_dequeuing_low_prio(curr_cpu)++;</span><br><span class="line">		check-&gt;status |= HMP_LOW_PRIORITY_FILTER;</span><br><span class="line">		check-&gt;status |= HMP_MIGRATION_APPROVED;</span><br><span class="line">		check-&gt;result = 1;</span><br><span class="line">		goto trace;</span><br><span class="line">	&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * [3] Check CPU capacity</span><br><span class="line">	 * Forbid down-migration if either of the following conditions is true</span><br><span class="line">	 * 1) big cpu is not oversubscribed (if big CPU seems to have spare</span><br><span class="line">	 *    cycles, do not force this task to run on LITTLE CPU, but</span><br><span class="line">	 *    keep it staying in its previous cluster instead)</span><br><span class="line">	 * 2) LITTLE cpu doesn&apos;t have available capacity for this new task</span><br><span class="line">	 */</span><br><span class="line">	/* (11.4) 如果big cpu有足够的空闲周期，不需要强制把light任务迁移到little cpu上 </span><br><span class="line">	    cfs_load(cpu) &lt; (B-&gt;cpu_capacity - (B-&gt;cpu_capacity &gt;&gt; 2))</span><br><span class="line">	 */</span><br><span class="line">	if (!hmp_fast_cpu_oversubscribed(caller, B, se, curr_cpu)) &#123;</span><br><span class="line">		check-&gt;status |= HMP_BIG_NOT_OVERSUBSCRIBED;</span><br><span class="line">		goto trace;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (11.5) 判断L族cpu的capacity是否足够容纳需要迁移的进程，</span><br><span class="line">        (L-&gt;acap &gt; 0 &amp;&amp; L-&gt;acap &gt;= se_load(se))</span><br><span class="line">     */</span><br><span class="line">	if (!hmp_task_slow_cpu_afford(L, se)) &#123;</span><br><span class="line">		check-&gt;status |= HMP_LITTLE_CAPACITY_INSUFFICIENT;</span><br><span class="line">		goto trace;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /* (11.6) 判断se的负载是否已经小于down-threshold(L-&gt;threshold) */</span><br><span class="line">	/*</span><br><span class="line">	 * [4] Check dynamic migration threshold</span><br><span class="line">	 * Migrate task from big to LITTLE if load ratio is less than</span><br><span class="line">	 * or equal to down-threshold</span><br><span class="line">	 */</span><br><span class="line">	if (L-&gt;threshold &gt;= se_load(se)) &#123;</span><br><span class="line">		check-&gt;status |= HMP_MIGRATION_APPROVED;</span><br><span class="line">		check-&gt;result = 1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">trace:</span><br><span class="line">#ifdef CONFIG_HMP_TRACER</span><br><span class="line">	if (check-&gt;result &amp;&amp; hmp_caller_is_gb(caller))</span><br><span class="line">		hmp_stats.nr_force_down++;</span><br><span class="line">	trace_sched_hmp_stats(&amp;hmp_stats);</span><br><span class="line">	trace_sched_dynamic_threshold(task_of(se), L-&gt;threshold, check-&gt;status,</span><br><span class="line">			curr_cpu, *target_cpu, se_load(se), B, L);</span><br><span class="line">	trace_sched_dynamic_threshold_draw(B-&gt;threshold, L-&gt;threshold);</span><br><span class="line">#endif</span><br><span class="line">out:</span><br><span class="line">	return check-&gt;result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-4、hmp-select-task-rq-fair"><a href="#4-2-4、hmp-select-task-rq-fair" class="headerlink" title="4.2.4、hmp_select_task_rq_fair()"></a>4.2.4、hmp_select_task_rq_fair()</h3><h2 id="4-3、cpu-freq调整"><a href="#4-3、cpu-freq调整" class="headerlink" title="4.3、cpu freq调整"></a>4.3、cpu freq调整</h2><p>前面讲的负载均衡的手段都是负载迁移，把负载迁移到最idle或者最省power的cpu上。另外一种方式就是调整cpu的freq，从而改变cpu的curr_capacity，来满足性能和功耗的需求。</p>
<p>cpu的频率调整是基于3个层次的：cpufreq governor、cpufreq core、cpufreq driver。</p>
<ul>
<li>1、cpufreq governor决定cpu调频的算法，计算负载、根据负载的变化来动态调整频率；</li>
<li>2、cpufreq core对通用层进行了一些封装，比如cpufreq_policy的封装；</li>
<li>3、cpufreq driver是底层操作的实现，比如freq_table的初始化、cpu target频率的配置；</li>
</ul>
<p><img src="/images/scheduler/schedule_cpufreq_frame.png" alt="schedule_cpufreq_frame"></p>
<p>如果是MTK平台，cpufreq driver除了接受governor的频率调整还需要接受ppm的频率调整，它的框图大概如下：</p>
<p><img src="/images/scheduler/schedule_cpufreq_mtk_frame.png" alt="schedule_cpufreq_mtk_frame"></p>
<h3 id="4-3-1、cpufreq-core-amp-cpufreq-driver"><a href="#4-3-1、cpufreq-core-amp-cpufreq-driver" class="headerlink" title="4.3.1、cpufreq core &amp; cpufreq driver"></a>4.3.1、cpufreq core &amp; cpufreq driver</h3><p>cpufreq core层次最核心的就是每个cpu有一个自己的cpufreq_policy policy，放在per_cpu(cpufreq_cpu_data, cpu)变量中。实际上cpufreq_policy是一个cluster对应一个的，因为在现有的架构中，同一个cluster cpu都是同一个频率，所以同cluster中所有cpu的per_cpu(cpufreq_cpu_data, cpu)都指向同一个cpufreq_policy。</p>
<p><img src="/images/scheduler/schedule_cpufreq_core.png" alt="schedule_cpufreq_core"></p>
<h4 id="4-3-1-1、cpufreq-policy-policy初始化"><a href="#4-3-1-1、cpufreq-policy-policy初始化" class="headerlink" title="4.3.1.1、cpufreq_policy policy初始化"></a>4.3.1.1、cpufreq_policy policy初始化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">struct cpufreq_policy &#123;</span><br><span class="line">	/* CPUs sharing clock, require sw coordination */</span><br><span class="line">	cpumask_var_t		cpus;	/* Online CPUs only */</span><br><span class="line">	cpumask_var_t		related_cpus; /* Online + Offline CPUs */</span><br><span class="line">	cpumask_var_t		real_cpus; /* Related and present */</span><br><span class="line"></span><br><span class="line">	unsigned int		shared_type; /* ACPI: ANY or ALL affected CPUs</span><br><span class="line">						should set cpufreq */</span><br><span class="line">	unsigned int		cpu;    /* cpu managing this policy, must be online */</span><br><span class="line"></span><br><span class="line">	struct clk		*clk;</span><br><span class="line">	struct cpufreq_cpuinfo	cpuinfo;/* see above */</span><br><span class="line"></span><br><span class="line">	unsigned int		min;    /* in kHz */</span><br><span class="line">	unsigned int		max;    /* in kHz */</span><br><span class="line">	unsigned int		cur;    /* in kHz, only needed if cpufreq</span><br><span class="line">					 * governors are used */</span><br><span class="line">	unsigned int		restore_freq; /* = policy-&gt;cur before transition */</span><br><span class="line">	unsigned int		suspend_freq; /* freq to set during suspend */</span><br><span class="line"></span><br><span class="line">	unsigned int		policy; /* see above */</span><br><span class="line">	unsigned int		last_policy; /* policy before unplug */</span><br><span class="line">	struct cpufreq_governor	*governor; /* see below */</span><br><span class="line">	void			*governor_data;</span><br><span class="line">	bool			governor_enabled; /* governor start/stop flag */</span><br><span class="line">	char			last_governor[CPUFREQ_NAME_LEN]; /* last governor used */</span><br><span class="line"></span><br><span class="line">	struct work_struct	update; /* if update_policy() needs to be</span><br><span class="line">					 * called, but you&apos;re in IRQ context */</span><br><span class="line"></span><br><span class="line">	struct cpufreq_user_policy user_policy;</span><br><span class="line">	struct cpufreq_frequency_table	*freq_table;</span><br><span class="line"></span><br><span class="line">	struct list_head        policy_list;</span><br><span class="line">	struct kobject		kobj;</span><br><span class="line">	struct completion	kobj_unregister;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * The rules for this semaphore:</span><br><span class="line">	 * - Any routine that wants to read from the policy structure will</span><br><span class="line">	 *   do a down_read on this semaphore.</span><br><span class="line">	 * - Any routine that will write to the policy structure and/or may take away</span><br><span class="line">	 *   the policy altogether (eg. CPU hotplug), will hold this lock in write</span><br><span class="line">	 *   mode before doing so.</span><br><span class="line">	 *</span><br><span class="line">	 * Additional rules:</span><br><span class="line">	 * - Lock should not be held across</span><br><span class="line">	 *     __cpufreq_governor(data, CPUFREQ_GOV_POLICY_EXIT);</span><br><span class="line">	 */</span><br><span class="line">	struct rw_semaphore	rwsem;</span><br><span class="line"></span><br><span class="line">	/* Synchronization for frequency transitions */</span><br><span class="line">	bool			transition_ongoing; /* Tracks transition status */</span><br><span class="line">	spinlock_t		transition_lock;</span><br><span class="line">	wait_queue_head_t	transition_wait;</span><br><span class="line">	struct task_struct	*transition_task; /* Task which is doing the transition */</span><br><span class="line"></span><br><span class="line">	/* cpufreq-stats */</span><br><span class="line">	struct cpufreq_stats	*stats;</span><br><span class="line"></span><br><span class="line">	/* For cpufreq driver&apos;s internal use */</span><br><span class="line">	void			*driver_data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在系统初始化化的时候初始化online cpu的cpufreq_policy，cpu在hotplug online的时候也会重新初始化cpufreq_policy。</p>
<ul>
<li>1、在mtk的cpufreq_driver驱动初始化函数_mt_cpufreq_pdrv_probe()中注册了_mt_cpufreq_driver：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static int _mt_cpufreq_pdrv_probe(struct platform_device *pdev)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    /* 注册cpufreq_driver */</span><br><span class="line">    cpufreq_register_driver(&amp;_mt_cpufreq_driver);</span><br><span class="line">    </span><br><span class="line">    /* 注册ppm的回调 */</span><br><span class="line">    mt_ppm_register_client(PPM_CLIENT_DVFS, &amp;ppm_limit_callback);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static struct cpufreq_driver _mt_cpufreq_driver = &#123;</span><br><span class="line">	.flags = CPUFREQ_ASYNC_NOTIFICATION,</span><br><span class="line">	.verify = _mt_cpufreq_verify,</span><br><span class="line">	.target = _mt_cpufreq_target,</span><br><span class="line">	.init = _mt_cpufreq_init,</span><br><span class="line">	.exit = _mt_cpufreq_exit,</span><br><span class="line">	.get = _mt_cpufreq_get,</span><br><span class="line">	.name = &quot;mt-cpufreq&quot;,</span><br><span class="line">	.attr = _mt_cpufreq_attr,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>2、在驱动注册cpufreq_register_driver()过程中会初始化online cpu的cpufreq_policy：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br></pre></td><td class="code"><pre><span class="line">_mt_cpufreq_pdrv_probe() -&gt; cpufreq_register_driver() -&gt; subsys_interface_register() -&gt; cpufreq_add_dev() -&gt; cpufreq_online()</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static int cpufreq_online(unsigned int cpu)</span><br><span class="line">&#123;</span><br><span class="line">	struct cpufreq_policy *policy;</span><br><span class="line">	bool new_policy;</span><br><span class="line">	unsigned long flags;</span><br><span class="line">	unsigned int j;</span><br><span class="line">	int ret;</span><br><span class="line"></span><br><span class="line">	pr_debug(&quot;%s: bringing CPU%u online\n&quot;, __func__, cpu);</span><br><span class="line"></span><br><span class="line">    /* (1) 检查per_cpu(cpufreq_cpu_data, cpu)中的cpufreq_policy， </span><br><span class="line">        如果为NULL，重新分配空间</span><br><span class="line">     */</span><br><span class="line">	/* Check if this CPU already has a policy to manage it */</span><br><span class="line">	policy = per_cpu(cpufreq_cpu_data, cpu);</span><br><span class="line">	if (policy) &#123;</span><br><span class="line">		WARN_ON(!cpumask_test_cpu(cpu, policy-&gt;related_cpus));</span><br><span class="line">		if (!policy_is_inactive(policy))</span><br><span class="line">			return cpufreq_add_policy_cpu(policy, cpu);</span><br><span class="line"></span><br><span class="line">		/* This is the only online CPU for the policy.  Start over. */</span><br><span class="line">		new_policy = false;</span><br><span class="line">		down_write(&amp;policy-&gt;rwsem);</span><br><span class="line">		policy-&gt;cpu = cpu;</span><br><span class="line">		policy-&gt;governor = NULL;</span><br><span class="line">		up_write(&amp;policy-&gt;rwsem);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		new_policy = true;</span><br><span class="line">		policy = cpufreq_policy_alloc(cpu);</span><br><span class="line">		if (!policy)</span><br><span class="line">			return -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cpumask_copy(policy-&gt;cpus, cpumask_of(cpu));</span><br><span class="line"></span><br><span class="line">    /* (2) 调用cpufreq_driver的初始化函数来初始化cpufreq_policy， </span><br><span class="line">        这步比较重要，初始化了以下的数据：</span><br><span class="line">        </span><br><span class="line">     */</span><br><span class="line">	/* call driver. From then on the cpufreq must be able</span><br><span class="line">	 * to accept all calls to -&gt;verify and -&gt;setpolicy for this CPU</span><br><span class="line">	 */</span><br><span class="line">	ret = cpufreq_driver-&gt;init(policy);</span><br><span class="line">	if (ret) &#123;</span><br><span class="line">		pr_debug(&quot;initialization failed\n&quot;);</span><br><span class="line">		goto out_free_policy;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	down_write(&amp;policy-&gt;rwsem);</span><br><span class="line"></span><br><span class="line">    /* (3) 如果cpufreq_policy是新分配空间的，</span><br><span class="line">        做一些相应的初始化工作</span><br><span class="line">     */</span><br><span class="line">	if (new_policy) &#123;</span><br><span class="line">		/* related_cpus should at least include policy-&gt;cpus. */</span><br><span class="line">		cpumask_copy(policy-&gt;related_cpus, policy-&gt;cpus);</span><br><span class="line">		/* Remember CPUs present at the policy creation time. */</span><br><span class="line">		cpumask_and(policy-&gt;real_cpus, policy-&gt;cpus, cpu_present_mask);</span><br><span class="line"></span><br><span class="line">		/* Name and add the kobject */</span><br><span class="line">		ret = kobject_add(&amp;policy-&gt;kobj, cpufreq_global_kobject,</span><br><span class="line">				  &quot;policy%u&quot;,</span><br><span class="line">				  cpumask_first(policy-&gt;related_cpus));</span><br><span class="line">		if (ret) &#123;</span><br><span class="line">			pr_err(&quot;%s: failed to add policy-&gt;kobj: %d\n&quot;, __func__,</span><br><span class="line">			       ret);</span><br><span class="line">			goto out_exit_policy;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * affected cpus must always be the one, which are online. We aren&apos;t</span><br><span class="line">	 * managing offline cpus here.</span><br><span class="line">	 */</span><br><span class="line">	cpumask_and(policy-&gt;cpus, policy-&gt;cpus, cpu_online_mask);</span><br><span class="line"></span><br><span class="line">	if (new_policy) &#123;</span><br><span class="line">		policy-&gt;user_policy.min = policy-&gt;min;</span><br><span class="line">		policy-&gt;user_policy.max = policy-&gt;max;</span><br><span class="line"></span><br><span class="line">		write_lock_irqsave(&amp;cpufreq_driver_lock, flags);</span><br><span class="line">		</span><br><span class="line">		/* (3.1) 同一个cluster中所有cpu的per_cpu(cpufreq_cpu_data, j)，共享同一个cpufreq_policy */</span><br><span class="line">		for_each_cpu(j, policy-&gt;related_cpus)</span><br><span class="line">			per_cpu(cpufreq_cpu_data, j) = policy;</span><br><span class="line">		write_unlock_irqrestore(&amp;cpufreq_driver_lock, flags);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (4) 获取cpufreq_policy的当前频率</span><br><span class="line">     */</span><br><span class="line">	if (cpufreq_driver-&gt;get &amp;&amp; !cpufreq_driver-&gt;setpolicy) &#123;</span><br><span class="line">		policy-&gt;cur = cpufreq_driver-&gt;get(policy-&gt;cpu);</span><br><span class="line">		if (!policy-&gt;cur) &#123;</span><br><span class="line">			pr_err(&quot;%s: -&gt;get() failed\n&quot;, __func__);</span><br><span class="line">			goto out_exit_policy;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Sometimes boot loaders set CPU frequency to a value outside of</span><br><span class="line">	 * frequency table present with cpufreq core. In such cases CPU might be</span><br><span class="line">	 * unstable if it has to run on that frequency for long duration of time</span><br><span class="line">	 * and so its better to set it to a frequency which is specified in</span><br><span class="line">	 * freq-table. This also makes cpufreq stats inconsistent as</span><br><span class="line">	 * cpufreq-stats would fail to register because current frequency of CPU</span><br><span class="line">	 * isn&apos;t found in freq-table.</span><br><span class="line">	 *</span><br><span class="line">	 * Because we don&apos;t want this change to effect boot process badly, we go</span><br><span class="line">	 * for the next freq which is &gt;= policy-&gt;cur (&apos;cur&apos; must be set by now,</span><br><span class="line">	 * otherwise we will end up setting freq to lowest of the table as &apos;cur&apos;</span><br><span class="line">	 * is initialized to zero).</span><br><span class="line">	 *</span><br><span class="line">	 * We are passing target-freq as &quot;policy-&gt;cur - 1&quot; otherwise</span><br><span class="line">	 * __cpufreq_driver_target() would simply fail, as policy-&gt;cur will be</span><br><span class="line">	 * equal to target-freq.</span><br><span class="line">	 */</span><br><span class="line">	if ((cpufreq_driver-&gt;flags &amp; CPUFREQ_NEED_INITIAL_FREQ_CHECK)</span><br><span class="line">	    &amp;&amp; has_target()) &#123;</span><br><span class="line">		/* Are we running at unknown frequency ? */</span><br><span class="line">		ret = cpufreq_frequency_table_get_index(policy, policy-&gt;cur);</span><br><span class="line">		if (ret == -EINVAL) &#123;</span><br><span class="line">			/* Warn user and fix it */</span><br><span class="line">			pr_warn(&quot;%s: CPU%d: Running at unlisted freq: %u KHz\n&quot;,</span><br><span class="line">				__func__, policy-&gt;cpu, policy-&gt;cur);</span><br><span class="line">			ret = __cpufreq_driver_target(policy, policy-&gt;cur - 1,</span><br><span class="line">				CPUFREQ_RELATION_L);</span><br><span class="line"></span><br><span class="line">			/*</span><br><span class="line">			 * Reaching here after boot in a few seconds may not</span><br><span class="line">			 * mean that system will remain stable at &quot;unknown&quot;</span><br><span class="line">			 * frequency for longer duration. Hence, a BUG_ON().</span><br><span class="line">			 */</span><br><span class="line">			BUG_ON(ret);</span><br><span class="line">			pr_warn(&quot;%s: CPU%d: Unlisted initial frequency changed to: %u KHz\n&quot;,</span><br><span class="line">				__func__, policy-&gt;cpu, policy-&gt;cur);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	blocking_notifier_call_chain(&amp;cpufreq_policy_notifier_list,</span><br><span class="line">				     CPUFREQ_START, policy);</span><br><span class="line"></span><br><span class="line">	if (new_policy) &#123;</span><br><span class="line">		ret = cpufreq_add_dev_interface(policy);</span><br><span class="line">		if (ret)</span><br><span class="line">			goto out_exit_policy;</span><br><span class="line">		blocking_notifier_call_chain(&amp;cpufreq_policy_notifier_list,</span><br><span class="line">				CPUFREQ_CREATE_POLICY, policy);</span><br><span class="line"></span><br><span class="line">		write_lock_irqsave(&amp;cpufreq_driver_lock, flags);</span><br><span class="line">		list_add(&amp;policy-&gt;policy_list, &amp;cpufreq_policy_list);</span><br><span class="line">		write_unlock_irqrestore(&amp;cpufreq_driver_lock, flags);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (5) 调用cpufreq governor的初始化函数，来初始化cpufreq_policy</span><br><span class="line">     */</span><br><span class="line">	ret = cpufreq_init_policy(policy);</span><br><span class="line">	if (ret) &#123;</span><br><span class="line">		pr_err(&quot;%s: Failed to initialize policy for cpu: %d (%d)\n&quot;,</span><br><span class="line">		       __func__, cpu, ret);</span><br><span class="line">		/* cpufreq_policy_free() will notify based on this */</span><br><span class="line">		new_policy = false;</span><br><span class="line">		goto out_exit_policy;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	up_write(&amp;policy-&gt;rwsem);</span><br><span class="line"></span><br><span class="line">	kobject_uevent(&amp;policy-&gt;kobj, KOBJ_ADD);</span><br><span class="line"></span><br><span class="line">	/* Callback for handling stuff after policy is ready */</span><br><span class="line">	if (cpufreq_driver-&gt;ready)</span><br><span class="line">		cpufreq_driver-&gt;ready(policy);</span><br><span class="line"></span><br><span class="line">	pr_debug(&quot;initialization complete\n&quot;);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line">out_exit_policy:</span><br><span class="line">	up_write(&amp;policy-&gt;rwsem);</span><br><span class="line"></span><br><span class="line">	if (cpufreq_driver-&gt;exit)</span><br><span class="line">		cpufreq_driver-&gt;exit(policy);</span><br><span class="line">out_free_policy:</span><br><span class="line">	cpufreq_policy_free(policy, !new_policy);</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">static int _mt_cpufreq_init(struct cpufreq_policy *policy)</span><br><span class="line">&#123;</span><br><span class="line">	int ret = -EINVAL;</span><br><span class="line">	unsigned long flags;</span><br><span class="line"></span><br><span class="line">	FUNC_ENTER(FUNC_LV_MODULE);</span><br><span class="line"></span><br><span class="line">	policy-&gt;shared_type = CPUFREQ_SHARED_TYPE_ANY;</span><br><span class="line">	cpumask_setall(policy-&gt;cpus);</span><br><span class="line"></span><br><span class="line">	policy-&gt;cpuinfo.transition_latency = 1000;</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		enum mt_cpu_dvfs_id id = _get_cpu_dvfs_id(policy-&gt;cpu);</span><br><span class="line">		struct mt_cpu_dvfs *p = id_to_cpu_dvfs(id);</span><br><span class="line">		unsigned int lv = _mt_cpufreq_get_cpu_level();</span><br><span class="line">		struct opp_tbl_info *opp_tbl_info;</span><br><span class="line">		struct opp_tbl_m_info *opp_tbl_m_info;</span><br><span class="line">		struct opp_tbl_m_info *opp_tbl_m_cci_info;</span><br><span class="line">		struct mt_cpu_dvfs *p_cci;</span><br><span class="line"></span><br><span class="line">		cpufreq_ver(&quot;DVFS: _mt_cpufreq_init: %s(cpu_id = %d)\n&quot;, cpu_dvfs_get_name(p), p-&gt;cpu_id);</span><br><span class="line"></span><br><span class="line">		opp_tbl_info = &amp;opp_tbls[id][lv];</span><br><span class="line"></span><br><span class="line">		p-&gt;cpu_level = lv;</span><br><span class="line"></span><br><span class="line">        /* (2.1) 给policy-&gt;freq_table赋值 </span><br><span class="line">            给policy-&gt;cpus赋值</span><br><span class="line">            给policy-&gt;related_cpus赋值</span><br><span class="line">         */</span><br><span class="line">		ret = _mt_cpufreq_setup_freqs_table(policy,</span><br><span class="line">						    opp_tbl_info-&gt;opp_tbl, opp_tbl_info-&gt;size);</span><br><span class="line"></span><br><span class="line">        /* (2.2) 给policy-&gt;cpuinfo.max_freq赋值 </span><br><span class="line">            给policy-&gt;cpuinfo.min_freq赋值</span><br><span class="line">         */</span><br><span class="line">		policy-&gt;cpuinfo.max_freq = cpu_dvfs_get_max_freq(p);</span><br><span class="line">		policy-&gt;cpuinfo.min_freq = cpu_dvfs_get_min_freq(p);</span><br><span class="line"></span><br><span class="line">		opp_tbl_m_info = &amp;opp_tbls_m[id][lv];</span><br><span class="line">		p-&gt;freq_tbl = opp_tbl_m_info-&gt;opp_tbl_m;</span><br><span class="line"></span><br><span class="line">		cpufreq_lock(flags);</span><br><span class="line">		/* Sync p */</span><br><span class="line">		if (_mt_cpufreq_sync_opp_tbl_idx(p) &gt;= 0)</span><br><span class="line">			if (p-&gt;idx_normal_max_opp == -1)</span><br><span class="line">				p-&gt;idx_normal_max_opp = p-&gt;idx_opp_tbl;</span><br><span class="line"></span><br><span class="line">        /* (2.3) 给policy-&gt;cur赋值 </span><br><span class="line">            给policy-&gt;max赋值</span><br><span class="line">            给policy-&gt;min赋值</span><br><span class="line">         */</span><br><span class="line">		policy-&gt;cur = cpu_dvfs_get_cur_freq(p);	/* use cur phy freq is better */</span><br><span class="line">		policy-&gt;max = cpu_dvfs_get_freq_by_idx(p, p-&gt;idx_opp_ppm_limit);</span><br><span class="line">		policy-&gt;min = cpu_dvfs_get_freq_by_idx(p, p-&gt;idx_opp_ppm_base);</span><br><span class="line">		p-&gt;mt_policy = policy;</span><br><span class="line">		p-&gt;armpll_is_available = 1;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_HYBRID_CPU_DVFS</span><br><span class="line">		if (turbo_flag &amp;&amp; cpu_dvfs_is(p, MT_CPU_DVFS_B) &amp;&amp; !turbo_is_inited) &#123;</span><br><span class="line">			unsigned int turbo_f, turbo_v;</span><br><span class="line"></span><br><span class="line">			turbo_f = ((cpu_dvfs_get_max_freq(p) * 104 / 100) / 13) * 13 / 1000;</span><br><span class="line"></span><br><span class="line">			if (picachu_need_higher_volt(MT_PICACHU_DOMAIN2))</span><br><span class="line">				turbo_v = MAX_VPROC_VOLT;</span><br><span class="line">			else</span><br><span class="line">				turbo_v = MAX_VPROC_VOLT - 2000;</span><br><span class="line">			/* turbo_v = p-&gt;opp_tbl[0].cpufreq_volt; */</span><br><span class="line">			cpuhvfs_set_turbo_scale(turbo_f * 1000, turbo_v);</span><br><span class="line">			turbo_is_inited = 1;</span><br><span class="line">		&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">		/* Sync cci */</span><br><span class="line">		if (cci_is_inited == 0) &#123;</span><br><span class="line">			p_cci = id_to_cpu_dvfs(MT_CPU_DVFS_CCI);</span><br><span class="line"></span><br><span class="line">			/* init cci freq idx */</span><br><span class="line">			if (_mt_cpufreq_sync_opp_tbl_idx(p_cci) &gt;= 0)</span><br><span class="line">				if (p_cci-&gt;idx_normal_max_opp == -1)</span><br><span class="line">					p_cci-&gt;idx_normal_max_opp = p_cci-&gt;idx_opp_tbl;</span><br><span class="line"></span><br><span class="line">			opp_tbl_m_cci_info = &amp;opp_tbls_m[MT_CPU_DVFS_CCI][lv];</span><br><span class="line">			p_cci-&gt;freq_tbl = opp_tbl_m_cci_info-&gt;opp_tbl_m;</span><br><span class="line">			p_cci-&gt;mt_policy = NULL;</span><br><span class="line">			p_cci-&gt;armpll_is_available = 1;</span><br><span class="line">			cci_is_inited = 1;</span><br><span class="line">		&#125;</span><br><span class="line">#ifdef CONFIG_HYBRID_CPU_DVFS</span><br><span class="line">		cpuhvfs_set_cluster_on_off(arch_get_cluster_id(p-&gt;cpu_id), 1);</span><br><span class="line">#endif</span><br><span class="line">		cpufreq_unlock(flags);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (ret)</span><br><span class="line">		cpufreq_err(&quot;failed to setup frequency table\n&quot;);</span><br><span class="line"></span><br><span class="line">	FUNC_EXIT(FUNC_LV_MODULE);</span><br><span class="line"></span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">||→</span><br><span class="line"></span><br><span class="line">static int _mt_cpufreq_setup_freqs_table(struct cpufreq_policy *policy,</span><br><span class="line">					 struct mt_cpu_freq_info *freqs, int num)</span><br><span class="line">&#123;</span><br><span class="line">	struct mt_cpu_dvfs *p;</span><br><span class="line">	int ret = 0;</span><br><span class="line"></span><br><span class="line">	FUNC_ENTER(FUNC_LV_LOCAL);</span><br><span class="line"></span><br><span class="line">	p = id_to_cpu_dvfs(_get_cpu_dvfs_id(policy-&gt;cpu));</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_CPU_FREQ</span><br><span class="line">	ret = cpufreq_frequency_table_cpuinfo(policy, p-&gt;freq_tbl_for_cpufreq);</span><br><span class="line"></span><br><span class="line">    /* (2.1.1) 给policy-&gt;freq_table赋值 </span><br><span class="line">     */</span><br><span class="line">	if (!ret)</span><br><span class="line">		policy-&gt;freq_table = p-&gt;freq_tbl_for_cpufreq;</span><br><span class="line"></span><br><span class="line">    /* (2.1.2) 根据cpu相同cluster中有哪些cpu </span><br><span class="line">        给policy-&gt;cpus赋值</span><br><span class="line">        给policy-&gt;related_cpus赋值</span><br><span class="line">     */</span><br><span class="line">	cpumask_copy(policy-&gt;cpus, topology_core_cpumask(policy-&gt;cpu));</span><br><span class="line">	cpumask_copy(policy-&gt;related_cpus, policy-&gt;cpus);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	FUNC_EXIT(FUNC_LV_LOCAL);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>3、在cpufreq_online()初始化完cpufreq_policy，最后会调用cpufreq_init_policy()继续governor的初始化：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line">static int cpufreq_init_policy(struct cpufreq_policy *policy)</span><br><span class="line">&#123;</span><br><span class="line">	struct cpufreq_governor *gov = NULL;</span><br><span class="line">	struct cpufreq_policy new_policy;</span><br><span class="line"></span><br><span class="line">	memcpy(&amp;new_policy, policy, sizeof(*policy));</span><br><span class="line"></span><br><span class="line">    /* (5.1) 使用last或者default的governor，</span><br><span class="line">        给new_policy.governor赋值</span><br><span class="line">     */</span><br><span class="line">	/* Update governor of new_policy to the governor used before hotplug */</span><br><span class="line">	gov = find_governor(policy-&gt;last_governor);</span><br><span class="line">	if (gov)</span><br><span class="line">		pr_debug(&quot;Restoring governor %s for cpu %d\n&quot;,</span><br><span class="line">				policy-&gt;governor-&gt;name, policy-&gt;cpu);</span><br><span class="line">	else</span><br><span class="line">		gov = CPUFREQ_DEFAULT_GOVERNOR;</span><br><span class="line"></span><br><span class="line">	new_policy.governor = gov;</span><br><span class="line"></span><br><span class="line">	/* Use the default policy if there is no last_policy. */</span><br><span class="line">	if (cpufreq_driver-&gt;setpolicy) &#123;</span><br><span class="line">		if (policy-&gt;last_policy)</span><br><span class="line">			new_policy.policy = policy-&gt;last_policy;</span><br><span class="line">		else</span><br><span class="line">			cpufreq_parse_governor(gov-&gt;name, &amp;new_policy.policy,</span><br><span class="line">					       NULL);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	/* (5.2) 启动governor来使用cpufreq_policy */</span><br><span class="line">	/* set default policy */</span><br><span class="line">	return cpufreq_set_policy(policy, &amp;new_policy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">static int cpufreq_set_policy(struct cpufreq_policy *policy,</span><br><span class="line">				struct cpufreq_policy *new_policy)</span><br><span class="line">&#123;</span><br><span class="line">	struct cpufreq_governor *old_gov;</span><br><span class="line">	int ret;</span><br><span class="line"></span><br><span class="line">	pr_debug(&quot;setting new policy for CPU %u: %u - %u kHz\n&quot;,</span><br><span class="line">		 new_policy-&gt;cpu, new_policy-&gt;min, new_policy-&gt;max);</span><br><span class="line"></span><br><span class="line">	memcpy(&amp;new_policy-&gt;cpuinfo, &amp;policy-&gt;cpuinfo, sizeof(policy-&gt;cpuinfo));</span><br><span class="line"></span><br><span class="line">    /* (5.2.1) 对policy、new_policy的一堆合法性判断 */</span><br><span class="line">	/*</span><br><span class="line">	* This check works well when we store new min/max freq attributes,</span><br><span class="line">	* because new_policy is a copy of policy with one field updated.</span><br><span class="line">	*/</span><br><span class="line">	if (new_policy-&gt;min &gt; new_policy-&gt;max)</span><br><span class="line">		return -EINVAL;</span><br><span class="line"></span><br><span class="line">	/* verify the cpu speed can be set within this limit */</span><br><span class="line">	ret = cpufreq_driver-&gt;verify(new_policy);</span><br><span class="line">	if (ret)</span><br><span class="line">		return ret;</span><br><span class="line"></span><br><span class="line">	/* adjust if necessary - all reasons */</span><br><span class="line">	blocking_notifier_call_chain(&amp;cpufreq_policy_notifier_list,</span><br><span class="line">			CPUFREQ_ADJUST, new_policy);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * verify the cpu speed can be set within this limit, which might be</span><br><span class="line">	 * different to the first one</span><br><span class="line">	 */</span><br><span class="line">	ret = cpufreq_driver-&gt;verify(new_policy);</span><br><span class="line">	if (ret)</span><br><span class="line">		return ret;</span><br><span class="line"></span><br><span class="line">	/* notification of the new policy */</span><br><span class="line">	blocking_notifier_call_chain(&amp;cpufreq_policy_notifier_list,</span><br><span class="line">			CPUFREQ_NOTIFY, new_policy);</span><br><span class="line"></span><br><span class="line">	scale_freq_capacity(new_policy, NULL);</span><br><span class="line"></span><br><span class="line">	policy-&gt;min = new_policy-&gt;min;</span><br><span class="line">	policy-&gt;max = new_policy-&gt;max;</span><br><span class="line">	trace_cpu_frequency_limits(policy-&gt;max, policy-&gt;min, policy-&gt;cpu);</span><br><span class="line"></span><br><span class="line">	pr_debug(&quot;new min and max freqs are %u - %u kHz\n&quot;,</span><br><span class="line">		 policy-&gt;min, policy-&gt;max);</span><br><span class="line"></span><br><span class="line">	if (cpufreq_driver-&gt;setpolicy) &#123;</span><br><span class="line">		policy-&gt;policy = new_policy-&gt;policy;</span><br><span class="line">		pr_debug(&quot;setting range\n&quot;);</span><br><span class="line">		return cpufreq_driver-&gt;setpolicy(new_policy);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (new_policy-&gt;governor == policy-&gt;governor)</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">	pr_debug(&quot;governor switch\n&quot;);</span><br><span class="line"></span><br><span class="line">    /* (5.2.2) 如果旧的governor在工作中，</span><br><span class="line">        依次调用 CPUFREQ_GOV_STOP、CPUFREQ_GOV_POLICY_EXIT停止旧的governor</span><br><span class="line">     */</span><br><span class="line">	/* save old, working values */</span><br><span class="line">	old_gov = policy-&gt;governor;</span><br><span class="line">	/* end old governor */</span><br><span class="line">	if (old_gov) &#123;</span><br><span class="line">		ret = __cpufreq_governor(policy, CPUFREQ_GOV_STOP);</span><br><span class="line">		if (ret) &#123;</span><br><span class="line">			/* This can happen due to race with other operations */</span><br><span class="line">			pr_debug(&quot;%s: Failed to Stop Governor: %s (%d)\n&quot;,</span><br><span class="line">				 __func__, old_gov-&gt;name, ret);</span><br><span class="line">			return ret;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		up_write(&amp;policy-&gt;rwsem);</span><br><span class="line">		ret = __cpufreq_governor(policy, CPUFREQ_GOV_POLICY_EXIT);</span><br><span class="line">		down_write(&amp;policy-&gt;rwsem);</span><br><span class="line"></span><br><span class="line">		if (ret) &#123;</span><br><span class="line">			pr_err(&quot;%s: Failed to Exit Governor: %s (%d)\n&quot;,</span><br><span class="line">			       __func__, old_gov-&gt;name, ret);</span><br><span class="line">			return ret;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (5.2.3) 依次调用 CPUFREQ_GOV_POLICY_INIT、CPUFREQ_GOV_START让新的governor开工</span><br><span class="line">     */</span><br><span class="line">	/* start new governor */</span><br><span class="line">	policy-&gt;governor = new_policy-&gt;governor;</span><br><span class="line">	ret = __cpufreq_governor(policy, CPUFREQ_GOV_POLICY_INIT);</span><br><span class="line">	if (!ret) &#123;</span><br><span class="line">		ret = __cpufreq_governor(policy, CPUFREQ_GOV_START);</span><br><span class="line">		if (!ret)</span><br><span class="line">			goto out;</span><br><span class="line"></span><br><span class="line">		up_write(&amp;policy-&gt;rwsem);</span><br><span class="line">		__cpufreq_governor(policy, CPUFREQ_GOV_POLICY_EXIT);</span><br><span class="line">		down_write(&amp;policy-&gt;rwsem);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* new governor failed, so re-start old one */</span><br><span class="line">	pr_debug(&quot;starting governor %s failed\n&quot;, policy-&gt;governor-&gt;name);</span><br><span class="line">	if (old_gov) &#123;</span><br><span class="line">		policy-&gt;governor = old_gov;</span><br><span class="line">		if (__cpufreq_governor(policy, CPUFREQ_GOV_POLICY_INIT))</span><br><span class="line">			policy-&gt;governor = NULL;</span><br><span class="line">		else</span><br><span class="line">			__cpufreq_governor(policy, CPUFREQ_GOV_START);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return ret;</span><br><span class="line"></span><br><span class="line"> out:</span><br><span class="line">	pr_debug(&quot;governor: change or update limits\n&quot;);</span><br><span class="line">	return __cpufreq_governor(policy, CPUFREQ_GOV_LIMITS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">||→</span><br><span class="line"></span><br><span class="line">static int __cpufreq_governor(struct cpufreq_policy *policy,</span><br><span class="line">					unsigned int event)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    /* __cpufreq_governor()调用的各种命令最后调用的都是governor的具体函数 */</span><br><span class="line">    ret = policy-&gt;governor-&gt;governor(policy, event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>4、以interactive governor为例，说明policy-&gt;governor-&gt;governor()对CPUFREQ_GOV_POLICY_INIT、CPUFREQ_GOV_START、CPUFREQ_GOV_STOP、CPUFREQ_GOV_POLICY_EXIT这几个命令的实现：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line">struct cpufreq_governor cpufreq_gov_interactive = &#123;</span><br><span class="line">	.name = &quot;interactive&quot;,</span><br><span class="line">	.governor = cpufreq_governor_interactive,</span><br><span class="line">	.max_transition_latency = 10000000,</span><br><span class="line">	.owner = THIS_MODULE,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static int cpufreq_governor_interactive(struct cpufreq_policy *policy,</span><br><span class="line">		unsigned int event)</span><br><span class="line">&#123;</span><br><span class="line">	int rc;</span><br><span class="line">	unsigned int j;</span><br><span class="line">	struct cpufreq_interactive_cpuinfo *pcpu;</span><br><span class="line">	struct cpufreq_frequency_table *freq_table;</span><br><span class="line">	struct cpufreq_interactive_tunables *tunables;</span><br><span class="line">	unsigned long flags;</span><br><span class="line"></span><br><span class="line">	if (have_governor_per_policy())</span><br><span class="line">		tunables = policy-&gt;governor_data;</span><br><span class="line">	else</span><br><span class="line">		tunables = common_tunables;</span><br><span class="line"></span><br><span class="line">	WARN_ON(!tunables &amp;&amp; (event != CPUFREQ_GOV_POLICY_INIT));</span><br><span class="line"></span><br><span class="line">	switch (event) &#123;</span><br><span class="line">	</span><br><span class="line">	/* (1) CPUFREQ_GOV_POLICY_INIT命令的实现:</span><br><span class="line">	    初始化tunables，tunables是interactive governor在计算时使用的各种参数</span><br><span class="line">	    相关的sysfs注册</span><br><span class="line">	 */</span><br><span class="line">	case CPUFREQ_GOV_POLICY_INIT:</span><br><span class="line">		if (have_governor_per_policy()) &#123;</span><br><span class="line">			WARN_ON(tunables);</span><br><span class="line">		&#125; else if (tunables) &#123;</span><br><span class="line">			tunables-&gt;usage_count++;</span><br><span class="line">			policy-&gt;governor_data = tunables;</span><br><span class="line">			return 0;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		tunables = kzalloc(sizeof(*tunables), GFP_KERNEL);</span><br><span class="line">		if (!tunables) &#123;</span><br><span class="line">			pr_err(&quot;%s: POLICY_INIT: kzalloc failed\n&quot;, __func__);</span><br><span class="line">			return -ENOMEM;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		tunables-&gt;usage_count = 1;</span><br><span class="line">		tunables-&gt;above_hispeed_delay = default_above_hispeed_delay;</span><br><span class="line">		tunables-&gt;nabove_hispeed_delay =</span><br><span class="line">			ARRAY_SIZE(default_above_hispeed_delay);</span><br><span class="line">		tunables-&gt;go_hispeed_load = DEFAULT_GO_HISPEED_LOAD;</span><br><span class="line">		tunables-&gt;target_loads = default_target_loads;</span><br><span class="line">		tunables-&gt;ntarget_loads = ARRAY_SIZE(default_target_loads);</span><br><span class="line">		tunables-&gt;min_sample_time = DEFAULT_MIN_SAMPLE_TIME;</span><br><span class="line">		tunables-&gt;timer_rate = DEFAULT_TIMER_RATE;</span><br><span class="line">		tunables-&gt;boostpulse_duration_val = DEFAULT_MIN_SAMPLE_TIME;</span><br><span class="line">		tunables-&gt;timer_slack_val = DEFAULT_TIMER_SLACK;</span><br><span class="line"></span><br><span class="line">		spin_lock_init(&amp;tunables-&gt;target_loads_lock);</span><br><span class="line">		spin_lock_init(&amp;tunables-&gt;above_hispeed_delay_lock);</span><br><span class="line"></span><br><span class="line">		policy-&gt;governor_data = tunables;</span><br><span class="line">		if (!have_governor_per_policy()) &#123;</span><br><span class="line">			common_tunables = tunables;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		rc = sysfs_create_group(get_governor_parent_kobj(policy),</span><br><span class="line">				get_sysfs_attr());</span><br><span class="line">		if (rc) &#123;</span><br><span class="line">			kfree(tunables);</span><br><span class="line">			policy-&gt;governor_data = NULL;</span><br><span class="line">			if (!have_governor_per_policy()) &#123;</span><br><span class="line">				common_tunables = NULL;</span><br><span class="line">			&#125;</span><br><span class="line">			return rc;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (!policy-&gt;governor-&gt;initialized) &#123;</span><br><span class="line">			idle_notifier_register(&amp;cpufreq_interactive_idle_nb);</span><br><span class="line">			cpufreq_register_notifier(&amp;cpufreq_notifier_block,</span><br><span class="line">					CPUFREQ_TRANSITION_NOTIFIER);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		break;</span><br><span class="line"></span><br><span class="line">    /* (2) CPUFREQ_GOV_POLICY_EXIT命令的实现:</span><br><span class="line">	    remove相关的sysfs</span><br><span class="line">	 */</span><br><span class="line">	case CPUFREQ_GOV_POLICY_EXIT:</span><br><span class="line">		if (!--tunables-&gt;usage_count) &#123;</span><br><span class="line">			if (policy-&gt;governor-&gt;initialized == 1) &#123;</span><br><span class="line">				cpufreq_unregister_notifier(&amp;cpufreq_notifier_block,</span><br><span class="line">						CPUFREQ_TRANSITION_NOTIFIER);</span><br><span class="line">				idle_notifier_unregister(&amp;cpufreq_interactive_idle_nb);</span><br><span class="line">			&#125;</span><br><span class="line">#ifdef CONFIG_MEIZU_BSP</span><br><span class="line">		&#125;</span><br><span class="line">#else</span><br><span class="line">			sysfs_remove_group(get_governor_parent_kobj(policy),</span><br><span class="line">					get_sysfs_attr());</span><br><span class="line"></span><br><span class="line">			kfree(tunables);</span><br><span class="line">			common_tunables = NULL;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		policy-&gt;governor_data = NULL;</span><br><span class="line">#endif //CONFIG_MEIZU_BSP</span><br><span class="line">		break;</span><br><span class="line"></span><br><span class="line">    /* (3) CPUFREQ_GOV_START命令的实现:</span><br><span class="line">	    因为同一个cluster中的多个cpu是共享一个cpufreq_policy的，</span><br><span class="line">	    所以使用同一个cpufreq_policy来初始化cluster中多个online cpu的per_cpu(cpuinfo, j)变量：</span><br><span class="line">	    pcpu-&gt;target_freq    // 当前频率</span><br><span class="line">	    pcpu-&gt;freq_table     // 频率表</span><br><span class="line">	    并且启动cpu上的interactive_timer=pcpu-&gt;cpu_timer：</span><br><span class="line">	    cpufreq_interactive_timer_start(tunables, j);</span><br><span class="line">	 */</span><br><span class="line">	case CPUFREQ_GOV_START:</span><br><span class="line">		mutex_lock(&amp;gov_lock);</span><br><span class="line"></span><br><span class="line">		freq_table = cpufreq_frequency_get_table(policy-&gt;cpu);</span><br><span class="line">		if (tunables &amp;&amp; !tunables-&gt;hispeed_freq)</span><br><span class="line">			tunables-&gt;hispeed_freq = policy-&gt;max;</span><br><span class="line"></span><br><span class="line">		for_each_cpu(j, policy-&gt;cpus) &#123;</span><br><span class="line">			pcpu = &amp;per_cpu(cpuinfo, j);</span><br><span class="line">			pcpu-&gt;policy = policy;</span><br><span class="line">			pcpu-&gt;target_freq = policy-&gt;cur;</span><br><span class="line">			pcpu-&gt;freq_table = freq_table;</span><br><span class="line">			pcpu-&gt;floor_freq = pcpu-&gt;target_freq;</span><br><span class="line">			pcpu-&gt;pol_floor_val_time =</span><br><span class="line">				ktime_to_us(ktime_get());</span><br><span class="line">			pcpu-&gt;loc_floor_val_time = pcpu-&gt;pol_floor_val_time;</span><br><span class="line">			pcpu-&gt;pol_hispeed_val_time = pcpu-&gt;pol_floor_val_time;</span><br><span class="line">			pcpu-&gt;loc_hispeed_val_time = pcpu-&gt;pol_floor_val_time;</span><br><span class="line">			down_write(&amp;pcpu-&gt;enable_sem);</span><br><span class="line">			del_timer_sync(&amp;pcpu-&gt;cpu_timer);</span><br><span class="line">			del_timer_sync(&amp;pcpu-&gt;cpu_slack_timer);</span><br><span class="line">			cpufreq_interactive_timer_start(tunables, j);</span><br><span class="line">			pcpu-&gt;governor_enabled = 1;</span><br><span class="line">			up_write(&amp;pcpu-&gt;enable_sem);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		mutex_unlock(&amp;gov_lock);</span><br><span class="line">		break;</span><br><span class="line"></span><br><span class="line">    /* (4) CPUFREQ_GOV_STOP命令的实现:</span><br><span class="line">	    如果同一个cluster中的多个cpu都已经offline，停掉对应的governor：</span><br><span class="line">	    停掉cpu上的interactive_timer=pcpu-&gt;cpu_timer</span><br><span class="line">	 */</span><br><span class="line">	case CPUFREQ_GOV_STOP:</span><br><span class="line">		mutex_lock(&amp;gov_lock);</span><br><span class="line">		for_each_cpu(j, policy-&gt;cpus) &#123;</span><br><span class="line">			pcpu = &amp;per_cpu(cpuinfo, j);</span><br><span class="line">			down_write(&amp;pcpu-&gt;enable_sem);</span><br><span class="line">			pcpu-&gt;governor_enabled = 0;</span><br><span class="line">			del_timer_sync(&amp;pcpu-&gt;cpu_timer);</span><br><span class="line">			del_timer_sync(&amp;pcpu-&gt;cpu_slack_timer);</span><br><span class="line">			up_write(&amp;pcpu-&gt;enable_sem);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		mutex_unlock(&amp;gov_lock);</span><br><span class="line">		break;</span><br><span class="line"></span><br><span class="line">	case CPUFREQ_GOV_LIMITS:</span><br><span class="line">		if (policy-&gt;max &lt; policy-&gt;cur)</span><br><span class="line">			__cpufreq_driver_target(policy,</span><br><span class="line">					policy-&gt;max, CPUFREQ_RELATION_H);</span><br><span class="line">		else if (policy-&gt;min &gt; policy-&gt;cur)</span><br><span class="line">			__cpufreq_driver_target(policy,</span><br><span class="line">					policy-&gt;min, CPUFREQ_RELATION_L);</span><br><span class="line">		for_each_cpu(j, policy-&gt;cpus) &#123;</span><br><span class="line">			pcpu = &amp;per_cpu(cpuinfo, j);</span><br><span class="line"></span><br><span class="line">			down_read(&amp;pcpu-&gt;enable_sem);</span><br><span class="line">			if (pcpu-&gt;governor_enabled == 0) &#123;</span><br><span class="line">				up_read(&amp;pcpu-&gt;enable_sem);</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			spin_lock_irqsave(&amp;pcpu-&gt;target_freq_lock, flags);</span><br><span class="line">			if (policy-&gt;max &lt; pcpu-&gt;target_freq)</span><br><span class="line">				pcpu-&gt;target_freq = policy-&gt;max;</span><br><span class="line">			else if (policy-&gt;min &gt; pcpu-&gt;target_freq)</span><br><span class="line">				pcpu-&gt;target_freq = policy-&gt;min;</span><br><span class="line"></span><br><span class="line">			spin_unlock_irqrestore(&amp;pcpu-&gt;target_freq_lock, flags);</span><br><span class="line">			up_read(&amp;pcpu-&gt;enable_sem);</span><br><span class="line">		&#125;</span><br><span class="line">		break;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-3-1-2、cpufrep的频率配置"><a href="#4-3-1-2、cpufrep的频率配置" class="headerlink" title="4.3.1.2、cpufrep的频率配置"></a>4.3.1.2、cpufrep的频率配置</h4><p>cpufreq一个重要的作用就是能把用户需要的cpu频率配置下去，这部分的代码也需要cpufreq core和cpufreq driver的配合。频率调整也叫DVFS(Dynamic Voltage and Frequency Scaling)，需要按照对应关系把电压和频率一起配置下去。</p>
<p>具体的代码解析如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">int __cpufreq_driver_target(struct cpufreq_policy *policy,</span><br><span class="line">			    unsigned int target_freq,</span><br><span class="line">			    unsigned int relation)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned int old_target_freq = target_freq;</span><br><span class="line">	int retval = -EINVAL;</span><br><span class="line"></span><br><span class="line">	if (cpufreq_disabled())</span><br><span class="line">		return -ENODEV;</span><br><span class="line"></span><br><span class="line">    /* (1) target目标频率在policy中的合法性检测 */</span><br><span class="line">	/* Make sure that target_freq is within supported range */</span><br><span class="line">	if (target_freq &gt; policy-&gt;max)</span><br><span class="line">		target_freq = policy-&gt;max;</span><br><span class="line">	if (target_freq &lt; policy-&gt;min)</span><br><span class="line">		target_freq = policy-&gt;min;</span><br><span class="line"></span><br><span class="line">	pr_debug(&quot;target for CPU %u: %u kHz, relation %u, requested %u kHz\n&quot;,</span><br><span class="line">		 policy-&gt;cpu, target_freq, relation, old_target_freq);</span><br><span class="line"></span><br><span class="line">    /* (2) 如果当前频率就是target频率，不用调整直接返回 */</span><br><span class="line">	/*</span><br><span class="line">	 * This might look like a redundant call as we are checking it again</span><br><span class="line">	 * after finding index. But it is left intentionally for cases where</span><br><span class="line">	 * exactly same freq is called again and so we can save on few function</span><br><span class="line">	 * calls.</span><br><span class="line">	 */</span><br><span class="line">	if (target_freq == policy-&gt;cur)</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">	/* Save last value to restore later on errors */</span><br><span class="line">	policy-&gt;restore_freq = policy-&gt;cur;</span><br><span class="line"></span><br><span class="line">	if (cpufreq_driver-&gt;target)</span><br><span class="line">	    /* (3) 调用实际的驱动target()函数来调整cpu频率 */</span><br><span class="line">		retval = cpufreq_driver-&gt;target(policy, target_freq, relation);</span><br><span class="line">	else if (cpufreq_driver-&gt;target_index) &#123;</span><br><span class="line">		struct cpufreq_frequency_table *freq_table;</span><br><span class="line">		int index;</span><br><span class="line"></span><br><span class="line">		freq_table = cpufreq_frequency_get_table(policy-&gt;cpu);</span><br><span class="line">		if (unlikely(!freq_table)) &#123;</span><br><span class="line">			pr_err(&quot;%s: Unable to find freq_table\n&quot;, __func__);</span><br><span class="line">			goto out;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		retval = cpufreq_frequency_table_target(policy, freq_table,</span><br><span class="line">				target_freq, relation, &amp;index);</span><br><span class="line">		if (unlikely(retval)) &#123;</span><br><span class="line">			pr_err(&quot;%s: Unable to find matching freq\n&quot;, __func__);</span><br><span class="line">			goto out;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (freq_table[index].frequency == policy-&gt;cur) &#123;</span><br><span class="line">			retval = 0;</span><br><span class="line">			goto out;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		retval = __target_index(policy, freq_table, index);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	return retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">static int _mt_cpufreq_target(struct cpufreq_policy *policy, unsigned int target_freq,</span><br><span class="line">			      unsigned int relation)</span><br><span class="line">&#123;</span><br><span class="line">	struct mt_cpu_dvfs *p;</span><br><span class="line">	int ret;</span><br><span class="line">	unsigned int new_opp_idx;</span><br><span class="line"></span><br><span class="line">	p = id_to_cpu_dvfs(_get_cpu_dvfs_id(policy-&gt;cpu));</span><br><span class="line">	if (!p)</span><br><span class="line">		return -EINVAL;</span><br><span class="line"></span><br><span class="line">    /* (3.1) 驱动根据频率电压表，配置target频率和对应电压 */</span><br><span class="line">	ret = cpufreq_frequency_table_target(policy, p-&gt;freq_tbl_for_cpufreq,</span><br><span class="line">					     target_freq, relation, &amp;new_opp_idx);</span><br><span class="line">	if (ret || new_opp_idx &gt;= p-&gt;nr_opp_tbl)</span><br><span class="line">		return -EINVAL;</span><br><span class="line"></span><br><span class="line">	if (dvfs_disable_flag || p-&gt;dvfs_disable_by_suspend || p-&gt;dvfs_disable_by_procfs)</span><br><span class="line">		return -EPERM;</span><br><span class="line"></span><br><span class="line">	_mt_cpufreq_dvfs_request_wrapper(p, new_opp_idx, MT_CPU_DVFS_NORMAL, NULL);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-3-2、interactive-governor"><a href="#4-3-2、interactive-governor" class="headerlink" title="4.3.2、interactive governor"></a>4.3.2、interactive governor</h3><p>在所有的cpufreq governor中最有名气的就是interactive governor了，因为几乎所有的andriod系统中都在使用。</p>
<p>interactive的思想就是使用cpu的负载来调整cpu频率，核心就是：使用一个20ms的定时器来计算cpu占用率，根据cpu占用率的不同threshold来调整不同档位的频率。</p>
<p><img src="/images/scheduler/schedule_cpufreq_interactive.png" alt="schedule_cpufreq_interactive"></p>
<p>interactive的负载计算方法如上图所示。interactive的整个计算方法大概如下：</p>
<ul>
<li>1、计算cpu的累加负载。每20ms采样一次，每次采样统计增加的active_time和当前频率的乘积：cputime_speedadj += active_time * cur_freq;</li>
<li>2、计算cpu的占用率。当前cpu占用率 = (累加负载<em>100)/(累加时间</em>当前频率)，cpu_load = (loadadjfreq<em>100)/(delta_time</em>cur_freq)；</li>
<li>3、如果cpu_load达到高门限go_hispeed_load(99%)或者发生boost，直接调节频率到hispeed_freq(最高频率)；</li>
<li>4、其他情况下使用choose_freq()公式计算新频率：new_freq = cur_freq*(cpu_load/DEFAULT_TARGET_LOAD(90))；new_freq = cpufreq_frequency_table_target(new_freq, CPUFREQ_RELATION_L);</li>
<li>5、如果当前频率已经达到hispeed_freq，还需要往上调整，必须在之前的频率上保持above_hispeed_delay(20ms)；如果当前频率已经达到hispeed_freq，还需要往下调整，必须在之前的频率上保持min_sample_time(80ms)；</li>
</ul>
<p>interactive governor从原理上看，有以下问题：</p>
<ul>
<li>1、20ms的采样时间过长，负载变化到频率调整的反应时间过长；</li>
<li>2、负载累加计算有问题，历史负载没有老化机制，历史负载的权重和当前一样，造成当前的负载变化不真实；</li>
<li>3、计算cpu占用率=总历史负载/(总时间*当前频率)，算法不合理历史负载对当前影响太大。如果之前是高频率，现在变成低频率，那么cpu_load计算出来的值可能超过100%；如果之前是低频率，现在是高频率，那么cpu_load计算出来的值也会大大被拉低；</li>
<li>4、choose_freq()的计算公式有重大漏洞。比如我们cpu频率表={800M, 900M}，当前cur_freq=800m cur_load=100%，那么newfreq = (cur_freq*cur_load)/90 = 889M，使用CPUFREQ_RELATION_L选择档位，选择到还是800M根本不能向高档位前进。这是算法的一个漏洞，如果cpu不同档位的频率差值大于(100/90)，那么正常往上调频是调不上去的，会被CPUFREQ_RELATION_L参数拦下来。所以实际的interactive调频，都是使用go_hispeed_load(99%)调到最高值的，再使用choose_freq()来降频。</li>
</ul>
<p>所以interactive governor会逐渐的被cpufreq gorernor所取代。</p>
<h4 id="4-3-2-1、interactive-governor的初始化"><a href="#4-3-2-1、interactive-governor的初始化" class="headerlink" title="4.3.2.1、interactive governor的初始化"></a>4.3.2.1、interactive governor的初始化</h4><ul>
<li>1、interactive的一部分初始化在cpufreq_interactive_init()当中：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">static int __init cpufreq_interactive_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned int i;</span><br><span class="line">	struct cpufreq_interactive_cpuinfo *pcpu;</span><br><span class="line">	struct sched_param param = &#123; .sched_priority = MAX_RT_PRIO-1 &#125;;</span><br><span class="line"></span><br><span class="line">    /* (1) 初始化percpu变量per_cpu(cpuinfo, i)： </span><br><span class="line">        每个cpu创建负载计算定时器pcpu-&gt;cpu_timer</span><br><span class="line">        其他的锁</span><br><span class="line">     */</span><br><span class="line">	/* Initalize per-cpu timers */</span><br><span class="line">	for_each_possible_cpu(i) &#123;</span><br><span class="line">		pcpu = &amp;per_cpu(cpuinfo, i);</span><br><span class="line">		init_timer_deferrable(&amp;pcpu-&gt;cpu_timer);</span><br><span class="line">		pcpu-&gt;cpu_timer.function = cpufreq_interactive_timer;</span><br><span class="line">		pcpu-&gt;cpu_timer.data = i;</span><br><span class="line">		init_timer(&amp;pcpu-&gt;cpu_slack_timer);</span><br><span class="line">		pcpu-&gt;cpu_slack_timer.function = cpufreq_interactive_nop_timer;</span><br><span class="line">		spin_lock_init(&amp;pcpu-&gt;load_lock);</span><br><span class="line">		spin_lock_init(&amp;pcpu-&gt;target_freq_lock);</span><br><span class="line">		init_rwsem(&amp;pcpu-&gt;enable_sem);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	spin_lock_init(&amp;speedchange_cpumask_lock);</span><br><span class="line">	mutex_init(&amp;gov_lock);</span><br><span class="line">	</span><br><span class="line">	/* (2) 创建频率调整进程speedchange_task， </span><br><span class="line">	    把耗时的频率调整工作单独放到一个进程中去做</span><br><span class="line">	 */</span><br><span class="line">	speedchange_task =</span><br><span class="line">		kthread_create(cpufreq_interactive_speedchange_task, NULL,</span><br><span class="line">			       &quot;cfinteractive&quot;);</span><br><span class="line">	if (IS_ERR(speedchange_task))</span><br><span class="line">		return PTR_ERR(speedchange_task);</span><br><span class="line"></span><br><span class="line">	sched_setscheduler_nocheck(speedchange_task, SCHED_FIFO, &amp;param);</span><br><span class="line">	get_task_struct(speedchange_task);</span><br><span class="line"></span><br><span class="line">	/* NB: wake up so the thread does not look hung to the freezer */</span><br><span class="line">	wake_up_process(speedchange_task);</span><br><span class="line"></span><br><span class="line">	return cpufreq_register_governor(&amp;cpufreq_gov_interactive);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>2、interactive另一部分初始化在cpufreq_governor_interactive()中的CPUFREQ_GOV_POLICY_INIT、CPUFREQ_GOV_START命令，在cpu online时执行：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static int cpufreq_governor_interactive(struct cpufreq_policy *policy,</span><br><span class="line">		unsigned int event)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	switch (event) &#123;</span><br><span class="line">	/* (1)  CPUFREQ_GOV_POLICY_INIT命令初始化interactive governor最核心的参数</span><br><span class="line">	 */</span><br><span class="line">	case CPUFREQ_GOV_POLICY_INIT:</span><br><span class="line">		if (have_governor_per_policy()) &#123;</span><br><span class="line">			WARN_ON(tunables);</span><br><span class="line">		&#125; else if (tunables) &#123;</span><br><span class="line">			tunables-&gt;usage_count++;</span><br><span class="line">			policy-&gt;governor_data = tunables;</span><br><span class="line">			return 0;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		tunables = kzalloc(sizeof(*tunables), GFP_KERNEL);</span><br><span class="line">		if (!tunables) &#123;</span><br><span class="line">			pr_err(&quot;%s: POLICY_INIT: kzalloc failed\n&quot;, __func__);</span><br><span class="line">			return -ENOMEM;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		tunables-&gt;usage_count = 1;</span><br><span class="line">		tunables-&gt;above_hispeed_delay = default_above_hispeed_delay;</span><br><span class="line">		tunables-&gt;nabove_hispeed_delay =</span><br><span class="line">			ARRAY_SIZE(default_above_hispeed_delay);</span><br><span class="line">		tunables-&gt;go_hispeed_load = DEFAULT_GO_HISPEED_LOAD;</span><br><span class="line">		tunables-&gt;target_loads = default_target_loads;</span><br><span class="line">		tunables-&gt;ntarget_loads = ARRAY_SIZE(default_target_loads);</span><br><span class="line">		tunables-&gt;min_sample_time = DEFAULT_MIN_SAMPLE_TIME;</span><br><span class="line">		tunables-&gt;timer_rate = DEFAULT_TIMER_RATE;          // interactive负载计算timer默认时间为20ms</span><br><span class="line">		tunables-&gt;boostpulse_duration_val = DEFAULT_MIN_SAMPLE_TIME;</span><br><span class="line">		tunables-&gt;timer_slack_val = DEFAULT_TIMER_SLACK;</span><br><span class="line"></span><br><span class="line">		spin_lock_init(&amp;tunables-&gt;target_loads_lock);</span><br><span class="line">		spin_lock_init(&amp;tunables-&gt;above_hispeed_delay_lock);</span><br><span class="line"></span><br><span class="line">		policy-&gt;governor_data = tunables;</span><br><span class="line">		if (!have_governor_per_policy()) &#123;</span><br><span class="line">			common_tunables = tunables;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		rc = sysfs_create_group(get_governor_parent_kobj(policy),</span><br><span class="line">				get_sysfs_attr());</span><br><span class="line">		if (rc) &#123;</span><br><span class="line">			kfree(tunables);</span><br><span class="line">			policy-&gt;governor_data = NULL;</span><br><span class="line">			if (!have_governor_per_policy()) &#123;</span><br><span class="line">				common_tunables = NULL;</span><br><span class="line">			&#125;</span><br><span class="line">			return rc;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (!policy-&gt;governor-&gt;initialized) &#123;</span><br><span class="line">			idle_notifier_register(&amp;cpufreq_interactive_idle_nb);</span><br><span class="line">			cpufreq_register_notifier(&amp;cpufreq_notifier_block,</span><br><span class="line">					CPUFREQ_TRANSITION_NOTIFIER);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		break;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /* (2) CPUFREQ_GOV_START命令启动interactive负载计算的timer</span><br><span class="line">	 */</span><br><span class="line">	case CPUFREQ_GOV_START:</span><br><span class="line">		mutex_lock(&amp;gov_lock);</span><br><span class="line"></span><br><span class="line">		freq_table = cpufreq_frequency_get_table(policy-&gt;cpu);</span><br><span class="line">		if (tunables &amp;&amp; !tunables-&gt;hispeed_freq)</span><br><span class="line">			tunables-&gt;hispeed_freq = policy-&gt;max;</span><br><span class="line"></span><br><span class="line">		for_each_cpu(j, policy-&gt;cpus) &#123;</span><br><span class="line">			pcpu = &amp;per_cpu(cpuinfo, j);</span><br><span class="line">			pcpu-&gt;policy = policy;</span><br><span class="line">			pcpu-&gt;target_freq = policy-&gt;cur;</span><br><span class="line">			pcpu-&gt;freq_table = freq_table;</span><br><span class="line">			pcpu-&gt;floor_freq = pcpu-&gt;target_freq;</span><br><span class="line">			pcpu-&gt;pol_floor_val_time =</span><br><span class="line">				ktime_to_us(ktime_get());</span><br><span class="line">			pcpu-&gt;loc_floor_val_time = pcpu-&gt;pol_floor_val_time;</span><br><span class="line">			pcpu-&gt;pol_hispeed_val_time = pcpu-&gt;pol_floor_val_time;</span><br><span class="line">			pcpu-&gt;loc_hispeed_val_time = pcpu-&gt;pol_floor_val_time;</span><br><span class="line">			down_write(&amp;pcpu-&gt;enable_sem);</span><br><span class="line">			del_timer_sync(&amp;pcpu-&gt;cpu_timer);</span><br><span class="line">			del_timer_sync(&amp;pcpu-&gt;cpu_slack_timer);</span><br><span class="line">			cpufreq_interactive_timer_start(tunables, j);</span><br><span class="line">			pcpu-&gt;governor_enabled = 1;</span><br><span class="line">			up_write(&amp;pcpu-&gt;enable_sem);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		mutex_unlock(&amp;gov_lock);</span><br><span class="line">		break;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-3-2-2、interactive-governor的算法"><a href="#4-3-2-2、interactive-governor的算法" class="headerlink" title="4.3.2.2、interactive governor的算法"></a>4.3.2.2、interactive governor的算法</h4><p>interactive governor的核心算法在20ms周期的timer interactive governor()中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br></pre></td><td class="code"><pre><span class="line">static void cpufreq_interactive_timer(unsigned long data)</span><br><span class="line">&#123;</span><br><span class="line">	u64 now;</span><br><span class="line">	unsigned int delta_time;</span><br><span class="line">	u64 cputime_speedadj;</span><br><span class="line">	int cpu_load;</span><br><span class="line">	struct cpufreq_interactive_cpuinfo *pcpu =</span><br><span class="line">		&amp;per_cpu(cpuinfo, data);</span><br><span class="line">	struct cpufreq_interactive_tunables *tunables =</span><br><span class="line">		pcpu-&gt;policy-&gt;governor_data;</span><br><span class="line">	unsigned int new_freq;</span><br><span class="line">	unsigned int loadadjfreq;</span><br><span class="line">	unsigned int index;</span><br><span class="line">	unsigned long flags;</span><br><span class="line">	u64 max_fvtime;</span><br><span class="line">	int j;</span><br><span class="line">	unsigned int max_t_freq = 0;</span><br><span class="line"></span><br><span class="line">#ifdef CPUDVFS_POWER_MODE</span><br><span class="line">	/* default(normal), low power, just make, performance(sports) */</span><br><span class="line">	int min_sample_t[4] = &#123; 80, 20, 20, 80 &#125;;</span><br><span class="line">	int ppb_idx;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	if (!down_read_trylock(&amp;pcpu-&gt;enable_sem))</span><br><span class="line">		return;</span><br><span class="line">	if (!pcpu-&gt;governor_enabled)</span><br><span class="line">		goto exit;</span><br><span class="line"></span><br><span class="line">	spin_lock_irqsave(&amp;pcpu-&gt;load_lock, flags);</span><br><span class="line">	</span><br><span class="line">	/* (1) 累加cpu上自从cpu_up()以来的负载，</span><br><span class="line">	    pcpu-&gt;cputime_speedadj += active_time * pcpu-&gt;policy-&gt;cur;</span><br><span class="line">	    pcpu-&gt;cputime_speedadj = (active_time * pcpu-&gt;policy-&gt;cur)samp1 + ... +(active_time * pcpu-&gt;policy-&gt;cur)sampn ;</span><br><span class="line">	    每个采样周期为20mS，累加：第1个20ms中active_time*cur_cpu_freq + 第2个20ms中active_time*cur_cpu_freq +...+ 第n个20ms中active_time*cur_cpu_freq</span><br><span class="line">	 */</span><br><span class="line">	now = update_load(data);</span><br><span class="line">	</span><br><span class="line">	/* (2) 自从cpu_up()以来的总的时间</span><br><span class="line">	    delta_time = active_time + ilde_time</span><br><span class="line">	 */</span><br><span class="line">	delta_time = (unsigned int)(now - pcpu-&gt;cputime_speedadj_timestamp);</span><br><span class="line">	cputime_speedadj = pcpu-&gt;cputime_speedadj;</span><br><span class="line">	spin_unlock_irqrestore(&amp;pcpu-&gt;load_lock, flags);</span><br><span class="line"></span><br><span class="line">	if (WARN_ON_ONCE(!delta_time))</span><br><span class="line">		goto rearm;</span><br><span class="line"></span><br><span class="line">	spin_lock_irqsave(&amp;pcpu-&gt;target_freq_lock, flags);</span><br><span class="line">	</span><br><span class="line">	/* (3) 总的负载/总时间 = 平均频率 */</span><br><span class="line">	do_div(cputime_speedadj, delta_time);</span><br><span class="line">	</span><br><span class="line">	/* (4) (平均频率 * 100)/当前频率 = 当前cpu的占用率 </span><br><span class="line">	 */</span><br><span class="line">	loadadjfreq = (unsigned int)cputime_speedadj * 100;</span><br><span class="line">	cpu_load = loadadjfreq / pcpu-&gt;policy-&gt;cur;</span><br><span class="line">	tunables-&gt;boosted = tunables-&gt;boost_val || now &lt; tunables-&gt;boostpulse_endtime;</span><br><span class="line"></span><br><span class="line">#ifdef CPUDVFS_POWER_MODE</span><br><span class="line">	ppb_idx = mt_cpufreq_get_ppb_state();</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		unsigned int idx = mt_cpufreq_ppb_hispeed_freq(data, ppb_idx);</span><br><span class="line"></span><br><span class="line">		tunables-&gt;hispeed_freq = pcpu-&gt;freq_table[idx].frequency;</span><br><span class="line">		tunables-&gt;min_sample_time = min_sample_t[ppb_idx] * USEC_PER_MSEC;</span><br><span class="line"></span><br><span class="line">		if (hispeed_freq_perf != 0)</span><br><span class="line">			tunables-&gt;hispeed_freq = hispeed_freq_perf;</span><br><span class="line">		if (min_sample_time_perf != 0)</span><br><span class="line">			tunables-&gt;min_sample_time = min_sample_time_perf;</span><br><span class="line">	&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    /* (5) 如果cpu占用率达到go_hispeed_load(99%)，或者在boost状态，</span><br><span class="line">        频率直接调整到最高频率hispeed_freq</span><br><span class="line">     */</span><br><span class="line">	if (cpu_load &gt;= tunables-&gt;go_hispeed_load || tunables-&gt;boosted) &#123;</span><br><span class="line">		if (pcpu-&gt;policy-&gt;cur &lt; tunables-&gt;hispeed_freq) &#123;</span><br><span class="line">			new_freq = tunables-&gt;hispeed_freq;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			new_freq = choose_freq(pcpu, loadadjfreq);</span><br><span class="line"></span><br><span class="line">			if (new_freq &lt; tunables-&gt;hispeed_freq)</span><br><span class="line">				new_freq = tunables-&gt;hispeed_freq;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	/* (6) 否则使用choose_freq()根据当前负载来计算对应的频率</span><br><span class="line">	 */</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		new_freq = choose_freq(pcpu, loadadjfreq);</span><br><span class="line">		if (new_freq &gt; tunables-&gt;hispeed_freq &amp;&amp;</span><br><span class="line">				pcpu-&gt;policy-&gt;cur &lt; tunables-&gt;hispeed_freq)</span><br><span class="line">			new_freq = tunables-&gt;hispeed_freq;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (7) 如果计算出的新频率 &gt; hispeed_freq，不能马上调整，</span><br><span class="line">        在hispeed_freq以上的频率上必须待满above_hispeed_delay(20ms)，才能继续往上调整频率</span><br><span class="line">     */</span><br><span class="line">	if (pcpu-&gt;policy-&gt;cur &gt;= tunables-&gt;hispeed_freq &amp;&amp;</span><br><span class="line">	    new_freq &gt; pcpu-&gt;policy-&gt;cur &amp;&amp;</span><br><span class="line">	    now - pcpu-&gt;pol_hispeed_val_time &lt;</span><br><span class="line">	    freq_to_above_hispeed_delay(tunables, pcpu-&gt;policy-&gt;cur)) &#123;</span><br><span class="line">		trace_cpufreq_interactive_notyet(</span><br><span class="line">			data, cpu_load, pcpu-&gt;target_freq,</span><br><span class="line">			pcpu-&gt;policy-&gt;cur, new_freq);</span><br><span class="line">		spin_unlock_irqrestore(&amp;pcpu-&gt;target_freq_lock, flags);</span><br><span class="line">		goto rearm;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pcpu-&gt;loc_hispeed_val_time = now;</span><br><span class="line"></span><br><span class="line">	if (cpufreq_frequency_table_target(pcpu-&gt;policy, pcpu-&gt;freq_table,</span><br><span class="line">					   new_freq, CPUFREQ_RELATION_L,</span><br><span class="line">					   &amp;index)) &#123;</span><br><span class="line">		spin_unlock_irqrestore(&amp;pcpu-&gt;target_freq_lock, flags);</span><br><span class="line">		goto rearm;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	new_freq = pcpu-&gt;freq_table[index].frequency;</span><br><span class="line"></span><br><span class="line">    /* (8) 如果之前的频率 &gt; hispeed_freq，或者发生boost</span><br><span class="line">        现在需要往低调频，之前的频率需要待满min_sample_time(80ms)</span><br><span class="line">     */</span><br><span class="line">	/*</span><br><span class="line">	 * Do not scale below floor_freq unless we have been at or above the</span><br><span class="line">	 * floor frequency for the minimum sample time since last validated.</span><br><span class="line">	 */</span><br><span class="line">	max_fvtime = max(pcpu-&gt;pol_floor_val_time, pcpu-&gt;loc_floor_val_time);</span><br><span class="line">	if (new_freq &lt; pcpu-&gt;floor_freq &amp;&amp;</span><br><span class="line">	    pcpu-&gt;target_freq &gt;= pcpu-&gt;policy-&gt;cur) &#123;</span><br><span class="line">		if (now - max_fvtime &lt; tunables-&gt;min_sample_time) &#123;</span><br><span class="line">			trace_cpufreq_interactive_notyet(</span><br><span class="line">				data, cpu_load, pcpu-&gt;target_freq,</span><br><span class="line">				pcpu-&gt;policy-&gt;cur, new_freq);</span><br><span class="line">			spin_unlock_irqrestore(&amp;pcpu-&gt;target_freq_lock, flags);</span><br><span class="line">			goto rearm;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Update the timestamp for checking whether speed has been held at</span><br><span class="line">	 * or above the selected frequency for a minimum of min_sample_time,</span><br><span class="line">	 * if not boosted to hispeed_freq.  If boosted to hispeed_freq then we</span><br><span class="line">	 * allow the speed to drop as soon as the boostpulse duration expires</span><br><span class="line">	 * (or the indefinite boost is turned off).</span><br><span class="line">	 */</span><br><span class="line"></span><br><span class="line">	if (!tunables-&gt;boosted || new_freq &gt; tunables-&gt;hispeed_freq) &#123;</span><br><span class="line">		pcpu-&gt;floor_freq = new_freq;</span><br><span class="line">		if (pcpu-&gt;target_freq &gt;= pcpu-&gt;policy-&gt;cur ||</span><br><span class="line">		    new_freq &gt;= pcpu-&gt;policy-&gt;cur)</span><br><span class="line">			pcpu-&gt;loc_floor_val_time = now;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (9) 如果当前cpu往低调整频率，判断当前policy是否需要更新，</span><br><span class="line">        因为多个cpu共享一个policy，取最大期望频率cpu的值作为整个policy的调整值</span><br><span class="line">     */</span><br><span class="line">	if (pcpu-&gt;target_freq == new_freq &amp;&amp;</span><br><span class="line">			pcpu-&gt;target_freq &lt;= pcpu-&gt;policy-&gt;cur) &#123;</span><br><span class="line">		max_t_freq = 0;</span><br><span class="line">		for_each_cpu(j, pcpu-&gt;policy-&gt;cpus) &#123;</span><br><span class="line">			struct cpufreq_interactive_cpuinfo *pjcpu;</span><br><span class="line"></span><br><span class="line">			pjcpu = &amp;per_cpu(cpuinfo, j);</span><br><span class="line">			max_t_freq = max(max_t_freq, pjcpu-&gt;target_freq);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (max_t_freq != pcpu-&gt;policy-&gt;cur)</span><br><span class="line">			goto pass_t;</span><br><span class="line"></span><br><span class="line">		trace_cpufreq_interactive_already(</span><br><span class="line">			data, cpu_load, pcpu-&gt;target_freq,</span><br><span class="line">			pcpu-&gt;policy-&gt;cur, new_freq);</span><br><span class="line">		spin_unlock_irqrestore(&amp;pcpu-&gt;target_freq_lock, flags);</span><br><span class="line">		goto rearm;</span><br><span class="line">	&#125;</span><br><span class="line">pass_t:</span><br><span class="line">	trace_cpufreq_interactive_target(data, cpu_load, pcpu-&gt;target_freq,</span><br><span class="line">					 pcpu-&gt;policy-&gt;cur, new_freq);</span><br><span class="line"></span><br><span class="line">    /* (10) 如果policy需要更新唤醒speedchange_task来执行调频动作 */</span><br><span class="line">	pcpu-&gt;target_freq = new_freq;</span><br><span class="line">	spin_unlock_irqrestore(&amp;pcpu-&gt;target_freq_lock, flags);</span><br><span class="line">	spin_lock_irqsave(&amp;speedchange_cpumask_lock, flags);</span><br><span class="line">	cpumask_set_cpu(data, &amp;speedchange_cpumask);</span><br><span class="line">	spin_unlock_irqrestore(&amp;speedchange_cpumask_lock, flags);</span><br><span class="line">	wake_up_process(speedchange_task);</span><br><span class="line"></span><br><span class="line">rearm:</span><br><span class="line">	if (!timer_pending(&amp;pcpu-&gt;cpu_timer))</span><br><span class="line">		cpufreq_interactive_timer_resched(pcpu);</span><br><span class="line"></span><br><span class="line">exit:</span><br><span class="line">	up_read(&amp;pcpu-&gt;enable_sem);</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">static unsigned int choose_freq(struct cpufreq_interactive_cpuinfo *pcpu,</span><br><span class="line">		unsigned int loadadjfreq)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned int freq = pcpu-&gt;policy-&gt;cur;</span><br><span class="line">	unsigned int prevfreq, freqmin, freqmax;</span><br><span class="line">	unsigned int tl;</span><br><span class="line">	int index;</span><br><span class="line"></span><br><span class="line">	freqmin = 0;</span><br><span class="line">	freqmax = UINT_MAX;</span><br><span class="line"></span><br><span class="line">	do &#123;</span><br><span class="line">		prevfreq = freq;</span><br><span class="line">		</span><br><span class="line">		/* (6.1) tl = 90，loadadjfreq = (平均频率 * 100)</span><br><span class="line">		    即 newfreq =  (平均频率 * 100)/ 90</span><br><span class="line">		    </span><br><span class="line">		    相当于cpufreq_frequency_table_target(CPUFREQ_RELATION_L)，</span><br><span class="line">		    相当于newfreq往低档位的计算，</span><br><span class="line">		    </span><br><span class="line">		    ooooo这里带来一个非常严重的问题，如果档位之间差值大于100/90，向上调频将调不上去</span><br><span class="line">		 */</span><br><span class="line">		tl = freq_to_targetload(pcpu-&gt;policy-&gt;governor_data, freq);</span><br><span class="line"></span><br><span class="line">		/*</span><br><span class="line">		 * Find the lowest frequency where the computed load is less</span><br><span class="line">		 * than or equal to the target load.</span><br><span class="line">		 */</span><br><span class="line"></span><br><span class="line">		if (cpufreq_frequency_table_target(</span><br><span class="line">			    pcpu-&gt;policy, pcpu-&gt;freq_table, loadadjfreq / tl,</span><br><span class="line">			    CPUFREQ_RELATION_L, &amp;index))</span><br><span class="line">			break;</span><br><span class="line">		freq = pcpu-&gt;freq_table[index].frequency;</span><br><span class="line"></span><br><span class="line">		if (freq &gt; prevfreq) &#123;</span><br><span class="line">			/* The previous frequency is too low. */</span><br><span class="line">			freqmin = prevfreq;</span><br><span class="line"></span><br><span class="line">			if (freq &gt;= freqmax) &#123;</span><br><span class="line">				/*</span><br><span class="line">				 * Find the highest frequency that is less</span><br><span class="line">				 * than freqmax.</span><br><span class="line">				 */</span><br><span class="line">				if (cpufreq_frequency_table_target(</span><br><span class="line">					    pcpu-&gt;policy, pcpu-&gt;freq_table,</span><br><span class="line">					    freqmax - 1, CPUFREQ_RELATION_H,</span><br><span class="line">					    &amp;index))</span><br><span class="line">					break;</span><br><span class="line">				freq = pcpu-&gt;freq_table[index].frequency;</span><br><span class="line"></span><br><span class="line">				if (freq == freqmin) &#123;</span><br><span class="line">					/*</span><br><span class="line">					 * The first frequency below freqmax</span><br><span class="line">					 * has already been found to be too</span><br><span class="line">					 * low.  freqmax is the lowest speed</span><br><span class="line">					 * we found that is fast enough.</span><br><span class="line">					 */</span><br><span class="line">					freq = freqmax;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; else if (freq &lt; prevfreq) &#123;</span><br><span class="line">			/* The previous frequency is high enough. */</span><br><span class="line">			freqmax = prevfreq;</span><br><span class="line"></span><br><span class="line">			if (freq &lt;= freqmin) &#123;</span><br><span class="line">				/*</span><br><span class="line">				 * Find the lowest frequency that is higher</span><br><span class="line">				 * than freqmin.</span><br><span class="line">				 */</span><br><span class="line">				if (cpufreq_frequency_table_target(</span><br><span class="line">					    pcpu-&gt;policy, pcpu-&gt;freq_table,</span><br><span class="line">					    freqmin + 1, CPUFREQ_RELATION_L,</span><br><span class="line">					    &amp;index))</span><br><span class="line">					break;</span><br><span class="line">				freq = pcpu-&gt;freq_table[index].frequency;</span><br><span class="line"></span><br><span class="line">				/*</span><br><span class="line">				 * If freqmax is the first frequency above</span><br><span class="line">				 * freqmin then we have already found that</span><br><span class="line">				 * this speed is fast enough.</span><br><span class="line">				 */</span><br><span class="line">				if (freq == freqmax)</span><br><span class="line">					break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		/* If same frequency chosen as previous then done. */</span><br><span class="line">	&#125; while (freq != prevfreq);</span><br><span class="line"></span><br><span class="line">	return freq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-4、cpu-hotplug调整"><a href="#4-4、cpu-hotplug调整" class="headerlink" title="4.4、cpu hotplug调整"></a>4.4、cpu hotplug调整</h2><p>还有一种调节负载的方式是cpu hotplug：</p>
<ul>
<li>1、cpu被hotplug掉的功耗小于cpu进入idle的功耗；如果整个cluster的cpu都offline，cluster也可以poweroff；所以hotplug能够节省功耗；</li>
<li>2、但是hotplug是有开销的：hotplug动作在速度慢的时候达到了ms级别，另外进程的迁移也是有开销的；cpu的hotplug必须遵循顺序插拔的规则，如果先拔掉负载重的cpu也是不合理的；</li>
<li>3、MTK的技术限制必须使用hotplug：MTK平台只有在剩一个online cpu的情况下才能进入深度idle模式，所以MTK平台必须支持hotplug；而samsung、qualcomm在多核online的情况下可以进入深度idle，所以一般不支持cpu hotplug；</li>
</ul>
<h3 id="4-4-1、hotplug-底层实现"><a href="#4-4-1、hotplug-底层实现" class="headerlink" title="4.4.1、hotplug 底层实现"></a>4.4.1、hotplug 底层实现</h3><h4 id="4-4-1-1、cpu-cup-cpu-down"><a href="#4-4-1-1、cpu-cup-cpu-down" class="headerlink" title="4.4.1.1、cpu_cup()/cpu_down()"></a>4.4.1.1、cpu_cup()/cpu_down()</h4><p>kernel对hotplug的支持是很完善的，标准接口cpu_up()/cpu_down()可以进行hotplug。</p>
<p><img src="/images/scheduler/schedule_hotplug_cpu_up.png" alt="schedule_hotplug_cpu_up"></p>
<h4 id="4-4-1-2、hotplug-进程迁移"><a href="#4-4-1-2、hotplug-进程迁移" class="headerlink" title="4.4.1.2、hotplug 进程迁移"></a>4.4.1.2、hotplug 进程迁移</h4><p>在cpu_down()时，需要调用migration_call() -&gt; migrate_tasks()把cpu上所有runnable进程迁移到其他cpu；在cpu_up()时，并不需要在函数中迁移进程，直接等待负载均衡算法的迁移。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line">static void migrate_tasks(struct rq *dead_rq)</span><br><span class="line">&#123;</span><br><span class="line">	struct rq *rq = dead_rq;</span><br><span class="line">	struct task_struct *next, *stop = rq-&gt;stop;</span><br><span class="line">	int dest_cpu;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Fudge the rq selection such that the below task selection loop</span><br><span class="line">	 * doesn&apos;t get stuck on the currently eligible stop task.</span><br><span class="line">	 *</span><br><span class="line">	 * We&apos;re currently inside stop_machine() and the rq is either stuck</span><br><span class="line">	 * in the stop_machine_cpu_stop() loop, or we&apos;re executing this code,</span><br><span class="line">	 * either way we should never end up calling schedule() until we&apos;re</span><br><span class="line">	 * done here.</span><br><span class="line">	 */</span><br><span class="line">	rq-&gt;stop = NULL;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * put_prev_task() and pick_next_task() sched</span><br><span class="line">	 * class method both need to have an up-to-date</span><br><span class="line">	 * value of rq-&gt;clock[_task]</span><br><span class="line">	 */</span><br><span class="line">	update_rq_clock(rq);</span><br><span class="line">	unthrottle_offline_rt_rqs(rq);</span><br><span class="line"></span><br><span class="line">	for (;;) &#123;</span><br><span class="line">		/*</span><br><span class="line">		 * There&apos;s this thread running, bail when that&apos;s the only</span><br><span class="line">		 * remaining thread.</span><br><span class="line">		 */</span><br><span class="line">		if (rq-&gt;nr_running == 1)</span><br><span class="line">			break;</span><br><span class="line"></span><br><span class="line">        /* (1) 逐个从rq中获取task = next */</span><br><span class="line">		/*</span><br><span class="line">		 * pick_next_task assumes pinned rq-&gt;lock.</span><br><span class="line">		 */</span><br><span class="line">		lockdep_pin_lock(&amp;rq-&gt;lock);</span><br><span class="line">		next = pick_next_task(rq, &amp;fake_task);</span><br><span class="line">		BUG_ON(!next);</span><br><span class="line">		next-&gt;sched_class-&gt;put_prev_task(rq, next);</span><br><span class="line"></span><br><span class="line">		/*</span><br><span class="line">		 * Rules for changing task_struct::cpus_allowed are holding</span><br><span class="line">		 * both pi_lock and rq-&gt;lock, such that holding either</span><br><span class="line">		 * stabilizes the mask.</span><br><span class="line">		 *</span><br><span class="line">		 * Drop rq-&gt;lock is not quite as disastrous as it usually is</span><br><span class="line">		 * because !cpu_active at this point, which means load-balance</span><br><span class="line">		 * will not interfere. Also, stop-machine.</span><br><span class="line">		 */</span><br><span class="line">		lockdep_unpin_lock(&amp;rq-&gt;lock);</span><br><span class="line">		raw_spin_unlock(&amp;rq-&gt;lock);</span><br><span class="line">		raw_spin_lock(&amp;next-&gt;pi_lock);</span><br><span class="line">		raw_spin_lock(&amp;rq-&gt;lock);</span><br><span class="line"></span><br><span class="line">		/*</span><br><span class="line">		 * Since we&apos;re inside stop-machine, _nothing_ should have</span><br><span class="line">		 * changed the task, WARN if weird stuff happened, because in</span><br><span class="line">		 * that case the above rq-&gt;lock drop is a fail too.</span><br><span class="line">		 */</span><br><span class="line">		if (WARN_ON(task_rq(next) != rq || !task_on_rq_queued(next))) &#123;</span><br><span class="line">			raw_spin_unlock(&amp;next-&gt;pi_lock);</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        /* (2) 找到最适合next进程迁移的目的cpu */</span><br><span class="line">		/* Find suitable destination for @next, with force if needed. */</span><br><span class="line">		dest_cpu = select_fallback_rq(dead_rq-&gt;cpu, next);</span><br><span class="line"></span><br><span class="line">        /* (3) 实施进程迁移 */</span><br><span class="line">		rq = __migrate_task(rq, next, dest_cpu);</span><br><span class="line">		if (rq != dead_rq) &#123;</span><br><span class="line">			raw_spin_unlock(&amp;rq-&gt;lock);</span><br><span class="line">			rq = dead_rq;</span><br><span class="line">			raw_spin_lock(&amp;rq-&gt;lock);</span><br><span class="line">		&#125;</span><br><span class="line">		raw_spin_unlock(&amp;next-&gt;pi_lock);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rq-&gt;stop = stop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">static int select_fallback_rq(int cpu, struct task_struct *p)</span><br><span class="line">&#123;</span><br><span class="line">	int nid = cpu_to_node(cpu);</span><br><span class="line">	const struct cpumask *nodemask = NULL;</span><br><span class="line">	enum &#123; cpuset, possible, fail &#125; state = cpuset;</span><br><span class="line">	int dest_cpu;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * If the node that the cpu is on has been offlined, cpu_to_node()</span><br><span class="line">	 * will return -1. There is no cpu on the node, and we should</span><br><span class="line">	 * select the cpu on the other node.</span><br><span class="line">	 */</span><br><span class="line">	if (nid != -1) &#123;</span><br><span class="line">		nodemask = cpumask_of_node(nid);</span><br><span class="line"></span><br><span class="line">		/* Look for allowed, online CPU in same node. */</span><br><span class="line">		for_each_cpu(dest_cpu, nodemask) &#123;</span><br><span class="line">			if (!cpu_online(dest_cpu))</span><br><span class="line">				continue;</span><br><span class="line">			if (!cpu_active(dest_cpu))</span><br><span class="line">				continue;</span><br><span class="line">			if (cpumask_test_cpu(dest_cpu, tsk_cpus_allowed(p)))</span><br><span class="line">				return dest_cpu;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for (;;) &#123;</span><br><span class="line">	</span><br><span class="line">	    /* (2.1) 最好的情况：在tsk_cpus_allowed(p)中能找到online cpu迁移 */</span><br><span class="line">		/* Any allowed, online CPU? */</span><br><span class="line">		for_each_cpu(dest_cpu, tsk_cpus_allowed(p)) &#123;</span><br><span class="line">			if (!cpu_online(dest_cpu))</span><br><span class="line">				continue;</span><br><span class="line">			if (!cpu_active(dest_cpu))</span><br><span class="line">				continue;</span><br><span class="line">			goto out;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		/* No more Mr. Nice Guy. */</span><br><span class="line">		switch (state) &#123;</span><br><span class="line">		</span><br><span class="line">		/* (2.2) 其次的情况：在cpuset中能找到online cpu迁移 */</span><br><span class="line">		case cpuset:</span><br><span class="line">			if (IS_ENABLED(CONFIG_CPUSETS)) &#123;</span><br><span class="line">				cpuset_cpus_allowed_fallback(p);</span><br><span class="line">				state = possible;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		/* (2.3) 最差的情况：在系统所有cpu中能找到online cpu迁移 */</span><br><span class="line">			/* fall-through */</span><br><span class="line">		case possible:</span><br><span class="line">			do_set_cpus_allowed(p, cpu_possible_mask);</span><br><span class="line">			state = fail;</span><br><span class="line">			break;</span><br><span class="line"></span><br><span class="line">		case fail:</span><br><span class="line">			BUG();</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	if (state != cpuset) &#123;</span><br><span class="line">		/*</span><br><span class="line">		 * Don&apos;t tell them about moving exiting tasks or</span><br><span class="line">		 * kernel threads (both mm NULL), since they never</span><br><span class="line">		 * leave kernel.</span><br><span class="line">		 */</span><br><span class="line">		if (p-&gt;mm &amp;&amp; printk_ratelimit()) &#123;</span><br><span class="line">			printk_deferred(&quot;process %d (%s) no longer affine to cpu%d\n&quot;,</span><br><span class="line">					task_pid_nr(p), p-&gt;comm, cpu);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return dest_cpu;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-4-2、MTK-hotplug算法"><a href="#4-4-2、MTK-hotplug算法" class="headerlink" title="4.4.2、MTK hotplug算法"></a>4.4.2、MTK hotplug算法</h3><p>在有了hotplug的底层cpu_cup()、cpu_down()的实现以后，在此之上还需要有一套算法根据cpu的负载来动态hotplug。MTK这套算法比较齐全，主要分为HICA、hps_algo_main两部分。</p>
<p><img src="/images/scheduler/schedule_hotplug_mtk.png" alt="schedule_hotplug_mtk"></p>
<h4 id="4-4-2-1、HICA-PPM"><a href="#4-4-2-1、HICA-PPM" class="headerlink" title="4.4.2.1、HICA/PPM"></a>4.4.2.1、HICA/PPM</h4><p>HICA和hps的关系，其实是HICA决定了一种大的mode，而hps在大的mode中实现精细化的调整。</p>
<p>比如对MT6799 HICA支持3种模式：</p>
<ul>
<li>1、LL_ONLY。  // 只开小核</li>
<li>2、L_ONLY。   // 只开中核</li>
<li>3、ALL。      // LL、L、B10核都可以使用</li>
</ul>
<p>HICA在mt_ppm_hica_update_algo_data()中计算负载，根据负载变化来决定mode：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">_hps_task_main() -&gt; mt_ppm_hica_update_algo_data()</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">void mt_ppm_hica_update_algo_data(unsigned int cur_loads,</span><br><span class="line">					unsigned int cur_nr_heavy_task, unsigned int cur_tlp)</span><br><span class="line">&#123;</span><br><span class="line">	struct ppm_power_state_data *state_info = ppm_get_power_state_info();</span><br><span class="line">	struct ppm_state_transfer_data *data;</span><br><span class="line">	enum ppm_power_state cur_state;</span><br><span class="line">	enum ppm_mode cur_mode;</span><br><span class="line">	int i, j;</span><br><span class="line"></span><br><span class="line">	FUNC_ENTER(FUNC_LV_HICA);</span><br><span class="line"></span><br><span class="line">	ppm_lock(&amp;hica_policy.lock);</span><br><span class="line"></span><br><span class="line">	ppm_hica_algo_data.ppm_cur_loads = cur_loads;</span><br><span class="line">	ppm_hica_algo_data.ppm_cur_tlp = cur_tlp;</span><br><span class="line">	ppm_hica_algo_data.ppm_cur_nr_heavy_task = cur_nr_heavy_task;</span><br><span class="line"></span><br><span class="line">	cur_state = ppm_hica_algo_data.cur_state;</span><br><span class="line">	cur_mode = ppm_main_info.cur_mode;</span><br><span class="line"></span><br><span class="line">	ppm_dbg(HICA, &quot;cur_loads = %d, cur_tlp = %d, cur_nr_heavy_task = %d, cur_state = %s, cur_mode = %d\n&quot;,</span><br><span class="line">		cur_loads, cur_tlp, cur_nr_heavy_task, ppm_get_power_state_name(cur_state), cur_mode);</span><br><span class="line"></span><br><span class="line">	if (!ppm_main_info.is_enabled || !hica_policy.is_enabled || ppm_main_info.is_in_suspend ||</span><br><span class="line">		cur_state == PPM_POWER_STATE_NONE)</span><br><span class="line">		goto end;</span><br><span class="line"></span><br><span class="line">#if defined(CONFIG_MACH_MT6757) || defined(CONFIG_MACH_KIBOPLUS)</span><br><span class="line">	if (setup_max_cpus == 4)</span><br><span class="line">		goto end;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifdef PPM_IC_SEGMENT_CHECK</span><br><span class="line">	if (ppm_main_info.fix_state_by_segment != PPM_POWER_STATE_NONE)</span><br><span class="line">		goto end;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	/* skip HICA if DVFS is not ready (we cannot get current freq...) */</span><br><span class="line">	if (!ppm_main_info.client_info[PPM_CLIENT_DVFS].limit_cb)</span><br><span class="line">		goto end;</span><br><span class="line"></span><br><span class="line">	/* Power state is fixed by user, skip HICA state calculation */</span><br><span class="line">	if (fix_power_state != PPM_POWER_STATE_NONE)</span><br><span class="line">		goto end;</span><br><span class="line"></span><br><span class="line">    /* (1) 从transfer_by_perf到transfer_by_pwr逐个遍历判断当前state是否需要改变 */</span><br><span class="line">	for (i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">		data = (i == 0) ? state_info[cur_state].transfer_by_perf</span><br><span class="line">				: state_info[cur_state].transfer_by_pwr;</span><br><span class="line"></span><br><span class="line">        /* (2) 如果当前state有几种变化逐个遍历，比如：</span><br><span class="line">            当前state为ALL，</span><br><span class="line">            可以ALL -&gt; LL_ONLY</span><br><span class="line">            也可以ALL -&gt; L_ONLY</span><br><span class="line">         */</span><br><span class="line">		for (j = 0; j &lt; data-&gt;size; j++) &#123;</span><br><span class="line">			if (!data-&gt;transition_data[j].transition_rule</span><br><span class="line">				|| !((1 &lt;&lt; cur_mode) &amp; data-&gt;transition_data[j].mode_mask))</span><br><span class="line">				continue;</span><br><span class="line"></span><br><span class="line">            /* (3) 如果state变化，获取新的state返回 */</span><br><span class="line">			if (data-&gt;transition_data[j].transition_rule(</span><br><span class="line">				ppm_hica_algo_data, &amp;data-&gt;transition_data[j])) &#123;</span><br><span class="line">				ppm_hica_algo_data.new_state = data-&gt;transition_data[j].next_state;</span><br><span class="line">				ppm_dbg(HICA, &quot;[%s(%d)] Need state transfer: %s --&gt; %s\n&quot;,</span><br><span class="line">					(i == 0) ? &quot;PERF&quot; : &quot;PWR&quot;,</span><br><span class="line">					j,</span><br><span class="line">					ppm_get_power_state_name(cur_state),</span><br><span class="line">					ppm_get_power_state_name(ppm_hica_algo_data.new_state)</span><br><span class="line">					);</span><br><span class="line">				goto end;</span><br><span class="line">				</span><br><span class="line">			/* (4) 如果state不变化，维持当前state，继续遍历*/</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				ppm_hica_algo_data.new_state = cur_state;</span><br><span class="line">#ifdef PPM_HICA_2P0</span><br><span class="line">				ppm_dbg(HICA, &quot;[%s(%d)]hold in %s state, capacity_hold_cnt = %d, bigtsk_hold_cnt = %d, freq_hold_cnt = %d\n&quot;,</span><br><span class="line">					(i == 0) ? &quot;PERF&quot; : &quot;PWR&quot;,</span><br><span class="line">					j,</span><br><span class="line">					ppm_get_power_state_name(cur_state),</span><br><span class="line">					data-&gt;transition_data[j].capacity_hold_cnt,</span><br><span class="line">					data-&gt;transition_data[j].bigtsk_hold_cnt,</span><br><span class="line">					data-&gt;transition_data[j].freq_hold_cnt</span><br><span class="line">					);</span><br><span class="line">#else</span><br><span class="line">#if PPM_HICA_VARIANT_SUPPORT</span><br><span class="line">				ppm_dbg(HICA, &quot;[%s(%d)]hold in %s state, loading_cnt = %d, freq_cnt = %d, overutil_l_hold_cnt = %d, .overutil_h_hold_cnt = %d\n&quot;,</span><br><span class="line">					(i == 0) ? &quot;PERF&quot; : &quot;PWR&quot;,</span><br><span class="line">					j,</span><br><span class="line">					ppm_get_power_state_name(cur_state),</span><br><span class="line">					data-&gt;transition_data[j].loading_hold_cnt,</span><br><span class="line">					data-&gt;transition_data[j].freq_hold_cnt,</span><br><span class="line">					data-&gt;transition_data[j].overutil_l_hold_cnt,</span><br><span class="line">					data-&gt;transition_data[j].overutil_h_hold_cnt</span><br><span class="line">					);</span><br><span class="line">#else</span><br><span class="line">				ppm_dbg(HICA, &quot;[%s(%d)]hold in %s state, loading_cnt = %d, freq_cnt = %d\n&quot;,</span><br><span class="line">					(i == 0) ? &quot;PERF&quot; : &quot;PWR&quot;,</span><br><span class="line">					j,</span><br><span class="line">					ppm_get_power_state_name(cur_state),</span><br><span class="line">					data-&gt;transition_data[j].loading_hold_cnt,</span><br><span class="line">					data-&gt;transition_data[j].freq_hold_cnt</span><br><span class="line">					);</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">end:</span><br><span class="line">	ppm_unlock(&amp;hica_policy.lock);</span><br><span class="line">	FUNC_EXIT(FUNC_LV_HICA);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于计算state的函数和阈值定义在表中，除了heavy_task和big_task，基本是计算util/capacity的cpu占用情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line">struct ppm_power_state_data pwr_state_info_SB[NR_PPM_POWER_STATE] = &#123;</span><br><span class="line">	[0] = &#123;</span><br><span class="line">		.name = __stringify(LL_ONLY),</span><br><span class="line">		.state = PPM_POWER_STATE_LL_ONLY,</span><br><span class="line">		PWR_STATE_INFO(LL_ONLY, SB)</span><br><span class="line">	&#125;,</span><br><span class="line">	[1] = &#123;</span><br><span class="line">		.name = __stringify(L_ONLY),</span><br><span class="line">		.state = PPM_POWER_STATE_L_ONLY,</span><br><span class="line">		PWR_STATE_INFO(L_ONLY, SB)</span><br><span class="line">	&#125;,</span><br><span class="line">	[2] = &#123;</span><br><span class="line">		.name = __stringify(ALL),</span><br><span class="line">		.state = PPM_POWER_STATE_ALL,</span><br><span class="line">		PWR_STATE_INFO(ALL, SB)</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct ppm_state_transfer state_pwr_transfer_ALL[] = &#123;</span><br><span class="line">	TRANS_DATA(</span><br><span class="line">		LL_ONLY,</span><br><span class="line">		PPM_MODE_MASK_ALL_MODE,</span><br><span class="line">		ppm_trans_rule_ALL_to_LL_ONLY,</span><br><span class="line">		PPM_DEFAULT_HOLD_TIME,</span><br><span class="line">		PPM_CAPACITY_DOWN,</span><br><span class="line">		PPM_DEFAULT_BIGTSK_TIME,</span><br><span class="line">		0,</span><br><span class="line">		0,</span><br><span class="line">		0</span><br><span class="line">		),</span><br><span class="line">	TRANS_DATA(</span><br><span class="line">		L_ONLY,</span><br><span class="line">		PPM_MODE_MASK_ALL_MODE,</span><br><span class="line">		ppm_trans_rule_ALL_to_L_ONLY,</span><br><span class="line">		PPM_DEFAULT_HOLD_TIME,</span><br><span class="line">		PPM_CAPACITY_DOWN,</span><br><span class="line">		PPM_DEFAULT_BIGTSK_TIME,</span><br><span class="line">		2,</span><br><span class="line">		4,</span><br><span class="line">		0</span><br><span class="line">		),</span><br><span class="line">&#125;;</span><br><span class="line">STATE_TRANSFER_DATA_PWR(ALL);</span><br><span class="line"></span><br><span class="line">static struct ppm_state_transfer state_perf_transfer_ALL[] = &#123;</span><br><span class="line">	TRANS_DATA(NONE, 0, NULL, 0, 0, 0, 0, 0, 0),</span><br><span class="line">&#125;;</span><br><span class="line">STATE_TRANSFER_DATA_PERF(ALL);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* 举例：当前state为ALL</span><br><span class="line">    尝试从power的角度从ALL切换到LL_ONLY：ppm_trans_rule_ALL_to_LL_ONLY()</span><br><span class="line">    尝试从power的角度从ALL切换到L_ONLY：ppm_trans_rule_ALL_to_L_ONLY()</span><br><span class="line"> */</span><br><span class="line">static bool ppm_trans_rule_ALL_to_LL_ONLY(</span><br><span class="line">	struct ppm_hica_algo_data data, struct ppm_state_transfer *settings)</span><br><span class="line">&#123;</span><br><span class="line">	/* keep in ALL state if root cluster is fixed at L or B */</span><br><span class="line">	if (ppm_main_info.fixed_root_cluster == PPM_CLUSTER_L</span><br><span class="line">		|| ppm_main_info.fixed_root_cluster == PPM_CLUSTER_B)</span><br><span class="line">		return false;</span><br><span class="line"></span><br><span class="line">    /* (1) 从heavy task负载判断是否需要切换模式 */</span><br><span class="line">#if PPM_HEAVY_TASK_INDICATE_SUPPORT</span><br><span class="line">	&#123;</span><br><span class="line">		unsigned int heavy_task, i;</span><br><span class="line"></span><br><span class="line">		for_each_ppm_clusters(i) &#123;</span><br><span class="line">			heavy_task = hps_get_hvytsk(i);</span><br><span class="line">			if (heavy_task) &#123;</span><br><span class="line">				ppm_dbg(HICA, &quot;Stay in ALL due to cluster%d heavy task = %d\n&quot;,</span><br><span class="line">					i, heavy_task);</span><br><span class="line">				trace_ppm_hica(</span><br><span class="line">					ppm_get_power_state_name(PPM_POWER_STATE_ALL),</span><br><span class="line">					ppm_get_power_state_name(PPM_POWER_STATE_LL_ONLY),</span><br><span class="line">					-1, -1, -1, -1, heavy_task, -1, false);</span><br><span class="line">				settings-&gt;capacity_hold_cnt = 0;</span><br><span class="line">				return false;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    /* (2) 从big task负载判断是否需要切换模式 */</span><br><span class="line">#if PPM_BIG_TASK_INDICATE_SUPPORT</span><br><span class="line">	&#123;</span><br><span class="line">		unsigned int big_task_L = hps_get_bigtsk(PPM_CLUSTER_L);</span><br><span class="line">		unsigned int big_task_B = hps_get_bigtsk(PPM_CLUSTER_B);</span><br><span class="line"></span><br><span class="line">		if (big_task_L || big_task_B) &#123;</span><br><span class="line">			ppm_dbg(HICA, &quot;Stay in ALL due to L/B big task = %d/%d\n&quot;,</span><br><span class="line">				big_task_L, big_task_B);</span><br><span class="line">			trace_ppm_hica(</span><br><span class="line">				ppm_get_power_state_name(PPM_POWER_STATE_ALL),</span><br><span class="line">				ppm_get_power_state_name(PPM_POWER_STATE_LL_ONLY),</span><br><span class="line">				-1, -1, big_task_L, big_task_B, -1, -1, false);</span><br><span class="line">			settings-&gt;capacity_hold_cnt = 0;</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    /* (3) 从util/capacity负载判断是否需要切换模式 */</span><br><span class="line">	&#123;</span><br><span class="line">		/* check capacity */</span><br><span class="line">		unsigned long usage, usage_total = 0, capacity = 0, dummy;</span><br><span class="line">		unsigned int i;</span><br><span class="line"></span><br><span class="line">		for_each_ppm_clusters(i) &#123;</span><br><span class="line">			if (sched_get_cluster_util(i, &amp;usage, &amp;dummy)) &#123;</span><br><span class="line">				ppm_err(&quot;Get cluster %d util failed\n&quot;, i);</span><br><span class="line">				return false;</span><br><span class="line">			&#125;</span><br><span class="line">			usage_total += usage;</span><br><span class="line">			if (i == PPM_CLUSTER_LL)</span><br><span class="line">				capacity = dummy;</span><br><span class="line">		&#125;</span><br><span class="line">		ppm_dbg(HICA, &quot;usage_total = %ld, LL capacity = %ld\n&quot;, usage_total, capacity);</span><br><span class="line"></span><br><span class="line">        /* (3.1) (util/capacity)超过门限值(settings-&gt;capacity_bond) 是否达到次数settings-&gt;capacity_hold_time，</span><br><span class="line">            如果条件满足进行state切换</span><br><span class="line">         */</span><br><span class="line">		if (usage_total &lt; capacity * settings-&gt;capacity_bond / 100) &#123;</span><br><span class="line">			settings-&gt;capacity_hold_cnt++;</span><br><span class="line">			if (settings-&gt;capacity_hold_cnt &gt;= settings-&gt;capacity_hold_time) &#123;</span><br><span class="line">				trace_ppm_hica(</span><br><span class="line">					ppm_get_power_state_name(PPM_POWER_STATE_ALL),</span><br><span class="line">					ppm_get_power_state_name(PPM_POWER_STATE_LL_ONLY),</span><br><span class="line">					usage_total, capacity, -1, -1, -1, -1, true);</span><br><span class="line">				return true;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; else</span><br><span class="line">			settings-&gt;capacity_hold_cnt = 0;</span><br><span class="line"></span><br><span class="line">		trace_ppm_hica(</span><br><span class="line">			ppm_get_power_state_name(PPM_POWER_STATE_ALL),</span><br><span class="line">			ppm_get_power_state_name(PPM_POWER_STATE_LL_ONLY),</span><br><span class="line">			usage_total, capacity, -1, -1, -1, -1, false);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新的state计算完成后，是通过以下通道配置下去的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">_hps_task_main() -&gt; mt_ppm_main() -&gt; ppm_hica_update_limit_cb() -&gt; ppm_hica_set_default_limit_by_state()</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">void ppm_hica_set_default_limit_by_state(enum ppm_power_state state,</span><br><span class="line">					struct ppm_policy_data *policy)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned int i;</span><br><span class="line">	struct ppm_power_state_data *state_info = ppm_get_power_state_info();</span><br><span class="line"></span><br><span class="line">	FUNC_ENTER(FUNC_LV_HICA);</span><br><span class="line"></span><br><span class="line">	for (i = 0; i &lt; policy-&gt;req.cluster_num; i++) &#123;</span><br><span class="line">		if (state &gt;= PPM_POWER_STATE_NONE) &#123;</span><br><span class="line">			if (state &gt; NR_PPM_POWER_STATE)</span><br><span class="line">				ppm_err(&quot;@%s: Invalid PPM state(%d)\n&quot;, __func__, state);</span><br><span class="line"></span><br><span class="line">			policy-&gt;req.limit[i].min_cpu_core = get_cluster_min_cpu_core(i);</span><br><span class="line">			policy-&gt;req.limit[i].max_cpu_core = get_cluster_max_cpu_core(i);</span><br><span class="line">			policy-&gt;req.limit[i].min_cpufreq_idx = get_cluster_min_cpufreq_idx(i);</span><br><span class="line">			policy-&gt;req.limit[i].max_cpufreq_idx = get_cluster_max_cpufreq_idx(i);</span><br><span class="line"></span><br><span class="line">#ifdef PPM_DISABLE_CLUSTER_MIGRATION</span><br><span class="line">			/* keep at least 1 LL */</span><br><span class="line">			if (i == 0)</span><br><span class="line">				policy-&gt;req.limit[i].min_cpu_core = 1;</span><br><span class="line">#endif</span><br><span class="line">        /* (1) HICA根据新的state，配置对应的min_cpu_core/max_cpu_core到本policy当中 */</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			policy-&gt;req.limit[i].min_cpu_core =</span><br><span class="line">				state_info[state].cluster_limit-&gt;state_limit[i].min_cpu_core;</span><br><span class="line">			policy-&gt;req.limit[i].max_cpu_core =</span><br><span class="line">				state_info[state].cluster_limit-&gt;state_limit[i].max_cpu_core;</span><br><span class="line">			policy-&gt;req.limit[i].min_cpufreq_idx =</span><br><span class="line">				state_info[state].cluster_limit-&gt;state_limit[i].min_cpufreq_idx;</span><br><span class="line">			policy-&gt;req.limit[i].max_cpufreq_idx =</span><br><span class="line">				state_info[state].cluster_limit-&gt;state_limit[i].max_cpufreq_idx;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">#ifdef PPM_IC_SEGMENT_CHECK</span><br><span class="line">		/* ignore HICA min freq setting for L cluster in L_ONLY state */</span><br><span class="line">		if (state == PPM_POWER_STATE_L_ONLY &amp;&amp; ppm_main_info.fix_state_by_segment == PPM_POWER_STATE_L_ONLY)</span><br><span class="line">			policy-&gt;req.limit[1].min_cpufreq_idx = get_cluster_min_cpufreq_idx(1);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	FUNC_EXIT(FUNC_LV_HICA);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*==============================================================*/</span><br><span class="line">/* Local Variables						*/</span><br><span class="line">/*==============================================================*/</span><br><span class="line">/* cluster limit for each power state */</span><br><span class="line">static const struct ppm_cluster_limit state_limit_LL_ONLY[] = &#123;</span><br><span class="line">	[0] = LIMIT(15, 0, 1, 4),</span><br><span class="line">	[1] = LIMIT(15, 0, 0, 0),</span><br><span class="line">	[2] = LIMIT(15, 0, 0, 0),</span><br><span class="line">&#125;;</span><br><span class="line">STATE_LIMIT(LL_ONLY);</span><br><span class="line"></span><br><span class="line">static const struct ppm_cluster_limit state_limit_L_ONLY[] = &#123;</span><br><span class="line">	[0] = LIMIT(15, 0, 0, 0),</span><br><span class="line">	[1] = LIMIT(8, 0, 1, 4),</span><br><span class="line">	[2] = LIMIT(15, 0, 0, 0),</span><br><span class="line">&#125;;</span><br><span class="line">STATE_LIMIT(L_ONLY);</span><br><span class="line"></span><br><span class="line">static const struct ppm_cluster_limit state_limit_ALL[] = &#123;</span><br><span class="line">	[0] = LIMIT(15, 0, 0, 4),</span><br><span class="line">	[1] = LIMIT(15, 0, 0, 4),</span><br><span class="line">	[2] = LIMIT(15, 0, 0, 2),</span><br><span class="line">&#125;;</span><br><span class="line">STATE_LIMIT(ALL);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_hps_task_main() -&gt; mt_ppm_main() -&gt; ppm_limit_callback()</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static void ppm_limit_callback(struct ppm_client_req req)</span><br><span class="line">&#123;</span><br><span class="line">	struct ppm_client_req *p = (struct ppm_client_req *)&amp;req;</span><br><span class="line">	int i;</span><br><span class="line"></span><br><span class="line">    /* (2) 将HICA state对应的policy配置到hps限制中hps_sys.cluster_info[i].ref_base_value/ref_limit_value */</span><br><span class="line">	mutex_lock(&amp;hps_ctxt.para_lock);</span><br><span class="line">	hps_sys.ppm_root_cluster = p-&gt;root_cluster;</span><br><span class="line">	for (i = 0; i &lt; p-&gt;cluster_num; i++) &#123;</span><br><span class="line">		/*</span><br><span class="line">		 * hps_warn(&quot;ppm_limit_callback -&gt; cluster%d: has_advise_core = %d, [%d, %d]\n&quot;,</span><br><span class="line">		 *	i, p-&gt;cpu_limit[i].has_advise_core,</span><br><span class="line">		 *	p-&gt;cpu_limit[i].min_cpu_core, p-&gt;cpu_limit[i].max_cpu_core);</span><br><span class="line">		 */</span><br><span class="line">#ifdef _TRACE_</span><br><span class="line">		trace_ppm_limit_callback_update(i, p-&gt;cpu_limit[i].has_advise_core,</span><br><span class="line">			p-&gt;cpu_limit[i].min_cpu_core, p-&gt;cpu_limit[i].max_cpu_core);</span><br><span class="line">#endif</span><br><span class="line">		if (!p-&gt;cpu_limit[i].has_advise_core) &#123;</span><br><span class="line">			hps_sys.cluster_info[i].ref_base_value = p-&gt;cpu_limit[i].min_cpu_core;</span><br><span class="line">			hps_sys.cluster_info[i].ref_limit_value = p-&gt;cpu_limit[i].max_cpu_core;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			hps_sys.cluster_info[i].ref_base_value =</span><br><span class="line">			    hps_sys.cluster_info[i].ref_limit_value =</span><br><span class="line">			    p-&gt;cpu_limit[i].advise_cpu_core;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	mutex_unlock(&amp;hps_ctxt.para_lock);</span><br><span class="line">	hps_ctxt.is_interrupt = 1;</span><br><span class="line">	hps_task_wakeup_nolock();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-4-2-2、hps-algo-main"><a href="#4-4-2-2、hps-algo-main" class="headerlink" title="4.4.2.2、hps_algo_main"></a>4.4.2.2、hps_algo_main</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br></pre></td><td class="code"><pre><span class="line">_hps_task_main() -&gt; hps_algo_main()</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">void hps_algo_main(void)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned int i, val, base_val, action_print, origin_root, action_break;</span><br><span class="line">	char str_online[64], str_ref_limit[64], str_ref_base[64], str_criteria_limit[64],</span><br><span class="line">	    str_criteria_base[64], str_target[64], str_hvytsk[64], str_pwrseq[64], str_bigtsk[64];</span><br><span class="line">	char *online_ptr = str_online;</span><br><span class="line">	char *criteria_limit_ptr = str_criteria_limit;</span><br><span class="line">	char *criteria_base_ptr = str_criteria_base;</span><br><span class="line">	char *ref_limit_ptr = str_ref_limit;</span><br><span class="line">	char *ref_base_ptr = str_ref_base;</span><br><span class="line">	char *hvytsk_ptr = str_hvytsk;</span><br><span class="line">	char *target_ptr = str_target;</span><br><span class="line">	char *pwrseq_ptr = str_pwrseq;</span><br><span class="line">	char *bigtsk_ptr = str_bigtsk;</span><br><span class="line">	static unsigned int hrtbt_dbg;</span><br><span class="line">#ifdef CONFIG_MEIZU_BSP</span><br><span class="line">	static unsigned long int j;</span><br><span class="line">#endif //CONFIG_MEIZU_BSP</span><br><span class="line">#ifdef CONFIG_MTK_ICCS_SUPPORT</span><br><span class="line">	unsigned char real_online_power_state_bitmask = 0;</span><br><span class="line">	unsigned char real_target_power_state_bitmask = 0;</span><br><span class="line">	unsigned char iccs_online_power_state_bitmask = 0;</span><br><span class="line">	unsigned char iccs_target_power_state_bitmask = iccs_get_target_power_state_bitmask();</span><br><span class="line">	unsigned char target_cache_shared_state_bitmask = 0;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	/* Initial value */</span><br><span class="line">	base_val = action_print = action_break = hps_sys.total_online_cores = 0;</span><br><span class="line">	hps_sys.up_load_avg = hps_sys.down_load_avg = hps_sys.tlp_avg = hps_sys.rush_cnt = 0;</span><br><span class="line">	hps_sys.action_id = origin_root = 0;</span><br><span class="line">	/*</span><br><span class="line">	 * run algo or not by hps_ctxt.enabled</span><br><span class="line">	 */</span><br><span class="line">	if ((u64) ktime_to_ms(ktime_sub(ktime_get(), hps_ctxt.hps_hrt_ktime)) &gt;= HPS_HRT_DBG_MS)</span><br><span class="line">		action_print = hrtbt_dbg = 1;</span><br><span class="line">	else</span><br><span class="line">		hrtbt_dbg = 0;</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;hps_ctxt.lock);</span><br><span class="line">	hps_ctxt.action = ACTION_NONE;</span><br><span class="line">	atomic_set(&amp;hps_ctxt.is_ondemand, 0);</span><br><span class="line"></span><br><span class="line">	if (!hps_ctxt.enabled)</span><br><span class="line">		goto HPS_END;</span><br><span class="line">	if (hps_ctxt.eas_indicator) &#123;</span><br><span class="line">		/*Set cpu cores by scheduler*/</span><br><span class="line">		goto HPS_ALGO_END;</span><br><span class="line">	&#125;</span><br><span class="line">	/*</span><br><span class="line">	 * algo - begin</span><br><span class="line">	 */</span><br><span class="line">	/*Back up limit and base value for check */</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;hps_ctxt.para_lock);</span><br><span class="line">	if ((hps_sys.cluster_info[0].base_value == 0) &amp;&amp;</span><br><span class="line">		(hps_sys.cluster_info[1].base_value == 0) &amp;&amp;</span><br><span class="line">		(hps_sys.cluster_info[2].base_value == 0) &amp;&amp;</span><br><span class="line">		(hps_sys.cluster_info[0].limit_value == 0) &amp;&amp;</span><br><span class="line">		(hps_sys.cluster_info[1].limit_value == 0) &amp;&amp;</span><br><span class="line">		(hps_sys.cluster_info[2].limit_value == 0)) &#123;</span><br><span class="line">		hps_sys.cluster_info[0].base_value = hps_sys.cluster_info[0].ref_base_value = 0;</span><br><span class="line">		hps_sys.cluster_info[1].base_value = hps_sys.cluster_info[1].ref_base_value = 0;</span><br><span class="line">		hps_sys.cluster_info[2].base_value = hps_sys.cluster_info[2].ref_base_value = 0;</span><br><span class="line">		hps_sys.cluster_info[0].limit_value = hps_sys.cluster_info[0].ref_limit_value = 4;</span><br><span class="line">		hps_sys.cluster_info[1].limit_value = hps_sys.cluster_info[1].ref_limit_value = 4;</span><br><span class="line">		hps_sys.cluster_info[2].limit_value = hps_sys.cluster_info[2].ref_limit_value = 0;</span><br><span class="line">	&#125;</span><br><span class="line">	for (i = 0; i &lt; hps_sys.cluster_num; i++) &#123;</span><br><span class="line">		hps_sys.cluster_info[i].base_value = hps_sys.cluster_info[i].ref_base_value;</span><br><span class="line">		hps_sys.cluster_info[i].limit_value = hps_sys.cluster_info[i].ref_limit_value;</span><br><span class="line">	&#125;</span><br><span class="line">	for (i = 0; i &lt; hps_sys.cluster_num; i++) &#123;</span><br><span class="line">		base_val += hps_sys.cluster_info[i].base_value;</span><br><span class="line">		hps_sys.cluster_info[i].target_core_num = hps_sys.cluster_info[i].online_core_num =</span><br><span class="line">		    0;</span><br><span class="line">		hps_sys.cluster_info[i].online_core_num =</span><br><span class="line">		    hps_get_cluster_cpus(hps_sys.cluster_info[i].cluster_id);</span><br><span class="line">		hps_sys.total_online_cores += hps_sys.cluster_info[i].online_core_num;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	mutex_unlock(&amp;hps_ctxt.para_lock);</span><br><span class="line">	/* Determine root cluster */</span><br><span class="line">	origin_root = hps_sys.root_cluster_id;</span><br><span class="line">	hps_define_root_cluster(&amp;hps_sys);</span><br><span class="line">#ifdef CONFIG_MACH_MT6799</span><br><span class="line">	if (hps_ctxt.smart_det_enabled) &#123;</span><br><span class="line">		mutex_lock(&amp;hps_ctxt.para_lock);</span><br><span class="line">		hps_sys.root_cluster_id = 1;/*Change root to L cluster when smart detection is enabled*/</span><br><span class="line">		mutex_unlock(&amp;hps_ctxt.para_lock);</span><br><span class="line">	&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	if (origin_root != hps_sys.root_cluster_id)</span><br><span class="line">		hps_sys.action_id = HPS_SYS_CHANGE_ROOT;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * update history - tlp</span><br><span class="line">	 */</span><br><span class="line">	val = hps_ctxt.tlp_history[hps_ctxt.tlp_history_index];</span><br><span class="line">	hps_ctxt.tlp_history[hps_ctxt.tlp_history_index] = hps_ctxt.cur_tlp;</span><br><span class="line">	hps_ctxt.tlp_sum += hps_ctxt.cur_tlp;</span><br><span class="line">	hps_ctxt.tlp_history_index =</span><br><span class="line">	    (hps_ctxt.tlp_history_index + 1 ==</span><br><span class="line">	     hps_ctxt.tlp_times) ? 0 : hps_ctxt.tlp_history_index + 1;</span><br><span class="line">	++hps_ctxt.tlp_count;</span><br><span class="line">	if (hps_ctxt.tlp_count &gt; hps_ctxt.tlp_times) &#123;</span><br><span class="line">		WARN_ON(hps_ctxt.tlp_sum &lt; val);</span><br><span class="line">		hps_ctxt.tlp_sum -= val;</span><br><span class="line">		hps_ctxt.tlp_avg = hps_ctxt.tlp_sum / hps_ctxt.tlp_times;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		hps_ctxt.tlp_avg = hps_ctxt.tlp_sum / hps_ctxt.tlp_count;</span><br><span class="line">	&#125;</span><br><span class="line">	if (hps_ctxt.stats_dump_enabled)</span><br><span class="line">		hps_ctxt_print_algo_stats_tlp(0);</span><br><span class="line"></span><br><span class="line">	/*Determine eas enabled or not*/</span><br><span class="line">	if (!hps_ctxt.eas_enabled)</span><br><span class="line">		hps_sys.hps_sys_ops[2].enabled = 0;</span><br><span class="line"></span><br><span class="line">	for (i = 0 ; i &lt; hps_sys.cluster_num ; i++)</span><br><span class="line">		hps_sys.cluster_info[i].target_core_num = hps_sys.cluster_info[i].online_core_num;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /* (1) 逐个调用 hps_sys_ops()根据各种算法来判断当前cpu是否需要hotplug */</span><br><span class="line">	for (i = 0; i &lt; hps_sys.func_num; i++) &#123;</span><br><span class="line">		if (hps_sys.hps_sys_ops[i].enabled == 1) &#123;</span><br><span class="line">			if (hps_sys.hps_sys_ops[i].hps_sys_func_ptr()) &#123;</span><br><span class="line">				hps_sys.action_id = hps_sys.hps_sys_ops[i].func_id;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">/*</span><br><span class="line">	if (hps_ctxt.heavy_task_enabled)</span><br><span class="line">		if (hps_algo_heavytsk_det())</span><br><span class="line">			hps_sys.action_id = 0xE1;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">	if (hps_ctxt.big_task_enabled)</span><br><span class="line">		if (hps_algo_big_task_det())</span><br><span class="line">			hps_sys.action_id = 0xE2;</span><br><span class="line"></span><br><span class="line">	if (hps_sys.action_id == 0)</span><br><span class="line">		goto HPS_END;</span><br><span class="line"></span><br><span class="line">HPS_ALGO_END:</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_MACH_MT6799</span><br><span class="line">	if (hps_ctxt.smart_det_enabled) &#123;</span><br><span class="line">		if (hps_sys.cluster_info[2].bigTsk_value &lt;= 1) &#123;</span><br><span class="line">			mutex_lock(&amp;hps_ctxt.para_lock);</span><br><span class="line">			hps_sys.cluster_info[2].target_core_num = 1;</span><br><span class="line">			mutex_unlock(&amp;hps_ctxt.para_lock);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * algo - end</span><br><span class="line">	 */</span><br><span class="line"></span><br><span class="line">    /* (2) 对limit进行判断，HICA的值就配置到这里 */</span><br><span class="line">	/*Base and limit check */</span><br><span class="line">	hps_check_base_limit(&amp;hps_sys);</span><br><span class="line"></span><br><span class="line">	/* Ensure that root cluster must one online cpu at less */</span><br><span class="line">	if (hps_sys.cluster_info[hps_sys.root_cluster_id].target_core_num &lt;= 0)</span><br><span class="line">		hps_sys.cluster_info[hps_sys.root_cluster_id].target_core_num = 1;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_MTK_ICCS_SUPPORT</span><br><span class="line">	real_online_power_state_bitmask = 0;</span><br><span class="line">	real_target_power_state_bitmask = 0;</span><br><span class="line">	for (i = 0; i &lt; hps_sys.cluster_num; i++) &#123;</span><br><span class="line">		real_online_power_state_bitmask |= ((hps_sys.cluster_info[i].online_core_num &gt; 0) &lt;&lt; i);</span><br><span class="line">		real_target_power_state_bitmask |= ((hps_sys.cluster_info[i].target_core_num &gt; 0) &lt;&lt; i);</span><br><span class="line">	&#125;</span><br><span class="line">	iccs_online_power_state_bitmask = iccs_target_power_state_bitmask;</span><br><span class="line">	iccs_target_power_state_bitmask = real_target_power_state_bitmask;</span><br><span class="line">	iccs_get_target_state(&amp;iccs_target_power_state_bitmask, &amp;target_cache_shared_state_bitmask);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * pr_err(&quot;[%s] iccs_target_power_state_bitmask: 0x%x\n&quot;, __func__, iccs_target_power_state_bitmask);</span><br><span class="line">	 */</span><br><span class="line"></span><br><span class="line">	for (i = 0; i &lt; hps_sys.cluster_num; i++) &#123;</span><br><span class="line">		hps_sys.cluster_info[i].iccs_state = (((real_online_power_state_bitmask &gt;&gt; i) &amp; 1) &lt;&lt; 3) |</span><br><span class="line">						     (((real_target_power_state_bitmask &gt;&gt; i) &amp; 1) &lt;&lt; 2) |</span><br><span class="line">						     (((iccs_online_power_state_bitmask &gt;&gt; i) &amp; 1) &lt;&lt; 1) |</span><br><span class="line">						     (((iccs_target_power_state_bitmask &gt;&gt; i) &amp; 1) &lt;&lt; 0);</span><br><span class="line"></span><br><span class="line">		/*</span><br><span class="line">		 * pr_err(&quot;[%s] cluster: 0x%x iccs_state: 0x%x\n&quot;, __func__, i, hps_sys.cluster_info[i].iccs_state);</span><br><span class="line">		 */</span><br><span class="line"></span><br><span class="line">		if (hps_get_iccs_pwr_status(i) == 0x1)</span><br><span class="line">			iccs_cluster_on_off(i, 1);</span><br><span class="line">		else if (hps_get_iccs_pwr_status(i) == 0x2)</span><br><span class="line">			iccs_cluster_on_off(i, 0);</span><br><span class="line">	&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    /* (3) 经过各种算法计算后目标值是target_core_num，而当前值是online_core_num；</span><br><span class="line">        如果不一致，进行cpu_up()/cpu_down()操作</span><br><span class="line">     */</span><br><span class="line">#if 1				/*Make sure that priority of power on action is higher than power down. */</span><br><span class="line">	for (i = 0; i &lt; hps_sys.cluster_num; i++) &#123;</span><br><span class="line">		if (hps_sys.cluster_info[i].target_core_num &gt;</span><br><span class="line">		    hps_sys.cluster_info[i].online_core_num) &#123;</span><br><span class="line">			if (hps_algo_do_cluster_action(i) == 1) &#123;</span><br><span class="line">				action_print = action_break = 1;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			action_print = 1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if (!action_break) &#123;</span><br><span class="line">		for (i = 0; i &lt; hps_sys.cluster_num; i++) &#123;</span><br><span class="line">			if (hps_sys.cluster_info[i].target_core_num &lt;</span><br><span class="line">			    hps_sys.cluster_info[i].online_core_num) &#123;</span><br><span class="line">				if (hps_algo_do_cluster_action(i) == 1) &#123;</span><br><span class="line">					action_print = action_break = 1;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				action_print = 1;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">#else</span><br><span class="line">	/*Process root cluster first */</span><br><span class="line">	if (hps_sys.cluster_info[hps_sys.root_cluster_id].target_core_num !=</span><br><span class="line">	    hps_sys.cluster_info[hps_sys.root_cluster_id].online_core_num) &#123;</span><br><span class="line">		if (hps_algo_do_cluster_action(hps_sys.root_cluster_id) == 1)</span><br><span class="line">			action_break = 1;</span><br><span class="line">		else</span><br><span class="line">			action_break = 0;</span><br><span class="line">		action_print = 1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for (i = 0; i &lt; hps_sys.cluster_num; i++) &#123;</span><br><span class="line">		if (i == hps_sys.root_cluster_id)</span><br><span class="line">			continue;</span><br><span class="line">		if (hps_sys.cluster_info[i].target_core_num !=</span><br><span class="line">		    hps_sys.cluster_info[i].online_core_num) &#123;</span><br><span class="line">			if (hps_algo_do_cluster_action(i) == 1)</span><br><span class="line">				action_break = 1;</span><br><span class="line">			else</span><br><span class="line">				action_break = 0;</span><br><span class="line">			action_print = 1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_MTK_ICCS_SUPPORT</span><br><span class="line">	for (i = 0; i &lt; hps_sys.cluster_num; i++) &#123;</span><br><span class="line">		if (hps_get_cluster_cpus(hps_sys.cluster_info[i].cluster_id) !=</span><br><span class="line">				hps_sys.cluster_info[i].target_core_num) &#123;</span><br><span class="line">			if (hps_get_cluster_cpus(hps_sys.cluster_info[i].cluster_id) == 0)</span><br><span class="line">				iccs_target_power_state_bitmask &amp;= ~(1 &lt;&lt; i);</span><br><span class="line">			else if (hps_sys.cluster_info[i].target_core_num == 0)</span><br><span class="line">				iccs_target_power_state_bitmask |= (1 &lt;&lt; i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	/*</span><br><span class="line">	 * pr_err(&quot;[%s] iccs_target_power_state_bitmask: 0x%x\n&quot;, __func__, iccs_target_power_state_bitmask);</span><br><span class="line">	 */</span><br><span class="line">	iccs_set_target_power_state_bitmask(iccs_target_power_state_bitmask);</span><br><span class="line">#endif</span><br><span class="line">HPS_END:</span><br><span class="line">	if (action_print || hrtbt_dbg) &#123;</span><br><span class="line">		int online, target, ref_limit, ref_base, criteria_limit, criteria_base, hvytsk, pwrseq, bigtsk;</span><br><span class="line"></span><br><span class="line">		mutex_lock(&amp;hps_ctxt.para_lock);</span><br><span class="line"></span><br><span class="line">		online = target = criteria_limit = criteria_base = 0;</span><br><span class="line">		for (i = 0; i &lt; hps_sys.cluster_num; i++) &#123;</span><br><span class="line">			if (i == origin_root)</span><br><span class="line">				online =</span><br><span class="line">				    sprintf(online_ptr, &quot;&lt;%d&gt;&quot;,</span><br><span class="line">					    hps_sys.cluster_info[i].online_core_num);</span><br><span class="line">			else</span><br><span class="line">				online =</span><br><span class="line">				    sprintf(online_ptr, &quot;(%d)&quot;,</span><br><span class="line">					    hps_sys.cluster_info[i].online_core_num);</span><br><span class="line"></span><br><span class="line">			if (i == hps_sys.root_cluster_id)</span><br><span class="line">				target =</span><br><span class="line">				    sprintf(target_ptr, &quot;&lt;%d&gt;&quot;,</span><br><span class="line">					    hps_sys.cluster_info[i].target_core_num);</span><br><span class="line">			else</span><br><span class="line">				target =</span><br><span class="line">				    sprintf(target_ptr, &quot;(%d)&quot;,</span><br><span class="line">					    hps_sys.cluster_info[i].target_core_num);</span><br><span class="line"></span><br><span class="line">			criteria_limit =</span><br><span class="line">			    sprintf(criteria_limit_ptr, &quot;(%d)&quot;,</span><br><span class="line">				    hps_sys.cluster_info[i].limit_value);</span><br><span class="line">			criteria_base =</span><br><span class="line">			    sprintf(criteria_base_ptr, &quot;(%d)&quot;, hps_sys.cluster_info[i].base_value);</span><br><span class="line">			ref_limit =</span><br><span class="line">			    sprintf(ref_limit_ptr, &quot;(%d)&quot;, hps_sys.cluster_info[i].ref_limit_value);</span><br><span class="line">			ref_base =</span><br><span class="line">			    sprintf(ref_base_ptr, &quot;(%d)&quot;, hps_sys.cluster_info[i].ref_base_value);</span><br><span class="line">			hvytsk = sprintf(hvytsk_ptr, &quot;(%d)&quot;, hps_sys.cluster_info[i].hvyTsk_value);</span><br><span class="line">			bigtsk = sprintf(bigtsk_ptr, &quot;(%d)&quot;, hps_sys.cluster_info[i].bigTsk_value);</span><br><span class="line">			if (i == 0)</span><br><span class="line">				pwrseq = sprintf(pwrseq_ptr, &quot;(%d-&gt;&quot;, hps_sys.cluster_info[i].pwr_seq);</span><br><span class="line">			else if ((i != 0) &amp;&amp; (i != (hps_sys.cluster_num - 1)))</span><br><span class="line">				pwrseq = sprintf(pwrseq_ptr, &quot;%d-&gt;&quot;, hps_sys.cluster_info[i].pwr_seq);</span><br><span class="line">			else if (i == (hps_sys.cluster_num - 1))</span><br><span class="line">				pwrseq = sprintf(pwrseq_ptr, &quot;%d) &quot;, hps_sys.cluster_info[i].pwr_seq);</span><br><span class="line"></span><br><span class="line">			online_ptr += online;</span><br><span class="line">			target_ptr += target;</span><br><span class="line">			criteria_limit_ptr += criteria_limit;</span><br><span class="line">			criteria_base_ptr += criteria_base;</span><br><span class="line">			ref_limit_ptr += ref_limit;</span><br><span class="line">			ref_base_ptr += ref_base;</span><br><span class="line">			hvytsk_ptr += hvytsk;</span><br><span class="line">			bigtsk_ptr += bigtsk;</span><br><span class="line">			pwrseq_ptr += pwrseq;</span><br><span class="line">		&#125;</span><br><span class="line">		mutex_unlock(&amp;hps_ctxt.para_lock);</span><br><span class="line">		if (action_print) &#123;</span><br><span class="line">			hps_set_funct_ctrl();</span><br><span class="line">			if (action_break)</span><br><span class="line">				hps_warn</span><br><span class="line">				    (&quot;(0x%X)%s action break!! (%u)(%u)(%u) %s %s%s--&gt;%s%s (%u)(%u)(%u)(%u) %s\n&quot;,</span><br><span class="line">				     ((hps_ctxt.hps_func_control &lt;&lt; 12) | hps_sys.action_id),</span><br><span class="line">				     str_online, hps_ctxt.cur_loads,</span><br><span class="line">				     hps_ctxt.cur_tlp, hps_ctxt.cur_iowait, str_hvytsk,</span><br><span class="line">				     str_criteria_limit, str_criteria_base,</span><br><span class="line">				     str_ref_limit, str_ref_base,</span><br><span class="line">				     hps_sys.up_load_avg,</span><br><span class="line">				     hps_sys.down_load_avg, hps_sys.tlp_avg, hps_sys.rush_cnt,</span><br><span class="line">				     str_target);</span><br><span class="line">			else &#123;</span><br><span class="line">				char str1[256];</span><br><span class="line">				char str2[256];</span><br><span class="line"></span><br><span class="line">				snprintf(str1, sizeof(str1),</span><br><span class="line">	&quot;(0x%X)%s action end (%u)(%u)(%u) %s %s[%u][%u](%u) %s %s%s (%u)(%u)(%u)(%u)&quot;,</span><br><span class="line">						((hps_ctxt.hps_func_control &lt;&lt; 12) | hps_sys.action_id),</span><br><span class="line">						str_online, hps_ctxt.cur_loads,</span><br><span class="line">						hps_ctxt.cur_tlp, hps_ctxt.cur_iowait,</span><br><span class="line">						str_hvytsk, str_bigtsk, hps_ctxt.is_screen_off,</span><br><span class="line">						hps_ctxt.is_idle, hps_ctxt.idle_ratio,</span><br><span class="line">						str_pwrseq, str_criteria_limit, str_criteria_base,</span><br><span class="line">						hps_sys.up_load_avg,</span><br><span class="line">						hps_sys.down_load_avg,</span><br><span class="line">						hps_sys.tlp_avg, hps_sys.rush_cnt);</span><br><span class="line"></span><br><span class="line">				snprintf(str2, sizeof(str2),</span><br><span class="line">	&quot;[%u,%u|%u,%u|%u,%u][%u,%u,%u] [%u,%u,%u] [%u,%u,%u] [%u,%u,%u] %s&quot;,</span><br><span class="line">						hps_sys.cluster_info[0].up_threshold,</span><br><span class="line">						hps_sys.cluster_info[0].down_threshold,</span><br><span class="line">						hps_sys.cluster_info[1].up_threshold,</span><br><span class="line">						hps_sys.cluster_info[1].down_threshold,</span><br><span class="line">						hps_sys.cluster_info[2].up_threshold,</span><br><span class="line">						hps_sys.cluster_info[2].down_threshold,</span><br><span class="line">						hps_sys.cluster_info[0].loading,</span><br><span class="line">						hps_sys.cluster_info[1].loading,</span><br><span class="line">						hps_sys.cluster_info[2].loading,</span><br><span class="line">						hps_sys.cluster_info[0].rel_load,</span><br><span class="line">						hps_sys.cluster_info[1].rel_load,</span><br><span class="line">						hps_sys.cluster_info[2].rel_load,</span><br><span class="line">						hps_sys.cluster_info[0].abs_load,</span><br><span class="line">						hps_sys.cluster_info[1].abs_load,</span><br><span class="line">						hps_sys.cluster_info[2].abs_load,</span><br><span class="line">						/* sched-assist hotplug: for debug */</span><br><span class="line">						hps_sys.cluster_info[0].sched_load,</span><br><span class="line">						hps_sys.cluster_info[1].sched_load,</span><br><span class="line">						hps_sys.cluster_info[2].sched_load,</span><br><span class="line">						str_target);</span><br><span class="line">#ifdef CONFIG_MEIZU_BSP</span><br><span class="line">				if (printk_timed_ratelimit(&amp;j, 500))</span><br><span class="line">					hps_warn(&quot;%s%s\n&quot;, str1, str2);</span><br><span class="line">#else</span><br><span class="line">					hps_warn(&quot;%s%s\n&quot;, str1, str2);</span><br><span class="line">#endif //CONFIG_MEIZU_BSP</span><br><span class="line">#ifdef _TRACE_</span><br><span class="line">				trace_hps_update(hps_sys.action_id, str_online, hps_ctxt.cur_loads,</span><br><span class="line">						hps_ctxt.cur_tlp, hps_ctxt.cur_iowait, str_hvytsk,</span><br><span class="line">						str_criteria_limit, str_criteria_base,</span><br><span class="line">						hps_sys.up_load_avg, hps_sys.down_load_avg,</span><br><span class="line">						hps_sys.tlp_avg,</span><br><span class="line">						hps_sys.rush_hps_sys.cluster_info[0].up_threshold,</span><br><span class="line">						hps_sys.cluster_info[0].down_threshold,</span><br><span class="line">						hps_sys.cluster_info[0].up_threshold,</span><br><span class="line">						hps_sys.cluster_info[0].down_threshold,</span><br><span class="line">						hps_sys.cluster_info[2].up_threshold,</span><br><span class="line">						hps_sys.cluster_info[2].down_threshold,</span><br><span class="line">						hps_sys.cluster_info[0].loading, hps_sys.cluster_info[1].loading,</span><br><span class="line">						hps_sys.cluster_info[2].loading,</span><br><span class="line">						hps_ctxt.up_times, hps_ctxt.down_times, str_target);</span><br><span class="line">#endif</span><br><span class="line">			&#125;</span><br><span class="line">			hps_ctxt_reset_stas_nolock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">#if HPS_HRT_BT_EN</span><br><span class="line">	if (hrtbt_dbg &amp;&amp; (action_print)) &#123;</span><br><span class="line">		hps_set_funct_ctrl();</span><br><span class="line">		hps_warn(&quot;(0x%X)%s HRT_BT_DBG (%u)(%u)(%u) %s %s %s %s%s (%u)(%u)(%u)(%u) %s\n&quot;,</span><br><span class="line">			 ((hps_ctxt.hps_func_control &lt;&lt; 12) | hps_sys.action_id),</span><br><span class="line">			 str_online, hps_ctxt.cur_loads, hps_ctxt.cur_tlp,</span><br><span class="line">			 hps_ctxt.cur_iowait, str_hvytsk, str_bigtsk, str_pwrseq, str_criteria_limit,</span><br><span class="line">			 str_criteria_base, hps_sys.up_load_avg, hps_sys.down_load_avg,</span><br><span class="line">			 hps_sys.tlp_avg, hps_sys.rush_cnt, str_target);</span><br><span class="line">		hrtbt_dbg = 0;</span><br><span class="line">		hps_ctxt.hps_hrt_ktime = ktime_get();</span><br><span class="line">	&#125;</span><br><span class="line">#endif</span><br><span class="line">	action_print = 0;</span><br><span class="line">	action_break = 0;</span><br><span class="line">	mutex_unlock(&amp;hps_ctxt.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当前hps_algo_main()的算法对应有几种：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">static int (*hps_func[]) (void) = &#123;</span><br><span class="line">/*hps_algo_perf_indicator, hps_algo_rush_boost, hps_algo_eas, hps_algo_up, hps_algo_down&#125;;*/</span><br><span class="line">hps_algo_perf_indicator, hps_algo_rush_boost, hps_algo_eas&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* (1) 取perf规定的最小值 */</span><br><span class="line">static int hps_algo_perf_indicator(void)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned int i;</span><br><span class="line"></span><br><span class="line">	if (atomic_read(&amp;hps_ctxt.is_ondemand) != 0) &#123; /* for ondemand request */</span><br><span class="line">		atomic_set(&amp;hps_ctxt.is_ondemand, 0);</span><br><span class="line"></span><br><span class="line">		mutex_lock(&amp;hps_ctxt.para_lock);</span><br><span class="line">		for (i = 0; i &lt; hps_sys.cluster_num; i++)</span><br><span class="line">			hps_sys.cluster_info[i].target_core_num =</span><br><span class="line">				max(hps_sys.cluster_info[i].base_value, hps_sys.cluster_info[i].online_core_num);</span><br><span class="line"></span><br><span class="line">		mutex_unlock(&amp;hps_ctxt.para_lock);</span><br><span class="line"></span><br><span class="line">		return 1;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* (2) 根据当前load的值是否达到boost门限，来决定是否启动boost */</span><br><span class="line">static int hps_algo_rush_boost(void)</span><br><span class="line">&#123;</span><br><span class="line">	int val, base_val;</span><br><span class="line">	unsigned int idx, total_rel_load;</span><br><span class="line"></span><br><span class="line">	idx = total_rel_load = 0;</span><br><span class="line">	for (idx = 0 ; idx &lt; hps_sys.cluster_num ; idx++)</span><br><span class="line">		total_rel_load += hps_sys.cluster_info[idx].rel_load;</span><br><span class="line"></span><br><span class="line">	if (!hps_ctxt.rush_boost_enabled)</span><br><span class="line">		return 0;</span><br><span class="line">	base_val = cal_base_cores();</span><br><span class="line"></span><br><span class="line">	if (total_rel_load &gt; hps_ctxt.rush_boost_threshold * hps_sys.total_online_cores)</span><br><span class="line">		++hps_ctxt.rush_count;</span><br><span class="line">	else</span><br><span class="line">		hps_ctxt.rush_count = 0;</span><br><span class="line">	if (hps_ctxt.rush_boost_times == 1)</span><br><span class="line">		hps_ctxt.tlp_avg = hps_ctxt.cur_tlp;</span><br><span class="line"></span><br><span class="line">	if ((hps_ctxt.rush_count &gt;= hps_ctxt.rush_boost_times) &amp;&amp;</span><br><span class="line">	    (hps_sys.total_online_cores * 100 &lt; hps_ctxt.tlp_avg)) &#123;</span><br><span class="line">		val = hps_ctxt.tlp_avg / 100 + (hps_ctxt.tlp_avg % 100 ? 1 : 0);</span><br><span class="line">		WARN_ON(!(val &gt; hps_sys.total_online_cores));</span><br><span class="line">		if (val &gt; num_possible_cpus())</span><br><span class="line">			val = num_possible_cpus();</span><br><span class="line">		if (val &gt; base_val)</span><br><span class="line">			val -= base_val;</span><br><span class="line">		else</span><br><span class="line">			val = 0;</span><br><span class="line">		hps_sys.tlp_avg = hps_ctxt.tlp_avg;</span><br><span class="line">		hps_sys.rush_cnt = hps_ctxt.rush_count;</span><br><span class="line">		hps_cal_core_num(&amp;hps_sys, val, base_val);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		/* [MET] debug for geekbench */</span><br><span class="line">		met_tag_oneshot(0, &quot;sched_rush_boost&quot;, 1);</span><br><span class="line"></span><br><span class="line">		return 1;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		/* [MET] debug for geekbench */</span><br><span class="line">		met_tag_oneshot(0, &quot;sched_rush_boost&quot;, 0);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* (3) 根据负载来计算需要的online cpu */</span><br><span class="line">static int hps_algo_eas(void)</span><br><span class="line">&#123;</span><br><span class="line">	int val, ret, i;</span><br><span class="line"></span><br><span class="line">	ret = 0;</span><br><span class="line">	for (i = 0 ; i &lt; hps_sys.cluster_num ; i++) &#123;</span><br><span class="line">		hps_sys.cluster_info[i].target_core_num = hps_sys.cluster_info[i].online_core_num;</span><br><span class="line"></span><br><span class="line">		/*if up_threshold &gt; loading &gt; down_threshold ==&gt; No action*/</span><br><span class="line">		if ((hps_sys.cluster_info[i].loading &lt;</span><br><span class="line">		(hps_sys.cluster_info[i].up_threshold*hps_sys.cluster_info[i].online_core_num)) &amp;&amp;</span><br><span class="line">		(hps_sys.cluster_info[i].loading &gt;</span><br><span class="line">		(hps_sys.cluster_info[i].down_threshold*hps_sys.cluster_info[i].online_core_num)))</span><br><span class="line">		continue;</span><br><span class="line"></span><br><span class="line">		/*if loading &gt; up_threshod ==&gt; power on cores*/</span><br><span class="line">		if ((hps_sys.cluster_info[i].loading &gt;</span><br><span class="line">			(hps_sys.cluster_info[i].up_threshold*hps_sys.cluster_info[i].online_core_num))) &#123;</span><br><span class="line">			val = hps_sys.cluster_info[i].loading / hps_sys.cluster_info[i].up_threshold;</span><br><span class="line">			if (hps_sys.cluster_info[i].loading % hps_sys.cluster_info[i].up_threshold)</span><br><span class="line">				val++;</span><br><span class="line">			if (val &lt;= hps_sys.cluster_info[i].limit_value)</span><br><span class="line">				hps_sys.cluster_info[i].target_core_num = val;</span><br><span class="line">			else</span><br><span class="line">				hps_sys.cluster_info[i].target_core_num = hps_sys.cluster_info[i].limit_value;</span><br><span class="line">			ret = 1;</span><br><span class="line">		&#125; else if ((hps_sys.cluster_info[i].loading &lt;</span><br><span class="line">			(hps_sys.cluster_info[i].down_threshold*hps_sys.cluster_info[i].online_core_num))) &#123;</span><br><span class="line">		/*if loading &lt; down_threshod ==&gt; power off cores*/</span><br><span class="line">			if (!hps_sys.cluster_info[i].loading) &#123;</span><br><span class="line">				hps_sys.cluster_info[i].target_core_num = 0;</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line">			val = hps_sys.cluster_info[i].loading /	hps_sys.cluster_info[i].down_threshold;</span><br><span class="line">			if (hps_sys.cluster_info[i].loading % hps_sys.cluster_info[i].down_threshold)</span><br><span class="line">				val++;</span><br><span class="line">			if (val &gt;= hps_sys.cluster_info[i].base_value)</span><br><span class="line">				hps_sys.cluster_info[i].target_core_num = val;</span><br><span class="line">			else</span><br><span class="line">				hps_sys.cluster_info[i].target_core_num = hps_sys.cluster_info[i].base_value;</span><br><span class="line">			ret = 1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">#if 0</span><br><span class="line">	/*Check with big task criteriai*/</span><br><span class="line">	for (i = 1 ; i &lt; hps_sys.cluster_num ; i++) &#123;</span><br><span class="line">		if ((!hps_sys.cluster_info[i].bigTsk_value) &amp;&amp;</span><br><span class="line">		(!(hps_sys.cluster_info[i].loading / hps_sys.cluster_info[i].down_threshold)))</span><br><span class="line">			hps_sys.cluster_info[i].target_core_num = 0;</span><br><span class="line">	&#125;</span><br><span class="line">#endif</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-5、NUMA负载均衡"><a href="#4-5、NUMA负载均衡" class="headerlink" title="4.5、NUMA负载均衡"></a>4.5、NUMA负载均衡</h2><p>NUMA arm架构没有使用，暂时不去解析。</p>
<h1 id="5、EAS-Energy-Aware-Scheduling"><a href="#5、EAS-Energy-Aware-Scheduling" class="headerlink" title="5、EAS(Energy-Aware Scheduling)"></a>5、EAS(Energy-Aware Scheduling)</h1><h2 id="5-1、smp-rebalance"><a href="#5-1、smp-rebalance" class="headerlink" title="5.1、smp rebalance"></a>5.1、smp rebalance</h2><p>通过搜索关键字“energy_aware()”，来查看EAS对smp负载均衡的影响。</p>
<p>可以看到EAS对负载均衡的策略是这样的：在overutilized的情况下，使用传统的smp/hmp负载均衡方法；在非overutilized的情况下，使用eas的均衡方法。</p>
<p>EAS的负载均衡和原有方法的区别有几部分：</p>
<ul>
<li>1、在EAS使能且没有overutilized的情况下，hmp负载均衡不工作；</li>
<li>2、在EAS使能且没有overutilized的情况下，smp负载均衡不工作；</li>
<li>3、在EAS使能且没有overutilized的情况下，EAS的主要工作集中在进程唤醒/新建时选择运行cpu上select_task_rq_fair()；</li>
</ul>
<h3 id="5-1-1、rebalance-domains"><a href="#5-1-1、rebalance-domains" class="headerlink" title="5.1.1、rebalance_domains()"></a>5.1.1、rebalance_domains()</h3><ul>
<li>1、在EAS使能且没有overutilized的情况下，hmp负载均衡不使能；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">static void run_rebalance_domains(struct softirq_action *h)</span><br><span class="line">&#123;</span><br><span class="line">	struct rq *this_rq = this_rq();</span><br><span class="line">	enum cpu_idle_type idle = this_rq-&gt;idle_balance ?</span><br><span class="line">						CPU_IDLE : CPU_NOT_IDLE;</span><br><span class="line">	int this_cpu = smp_processor_id();</span><br><span class="line"></span><br><span class="line">	/* bypass load balance of HMP if EAS consideration */</span><br><span class="line">	if ((!energy_aware() &amp;&amp; sched_feat(SCHED_HMP)) ||</span><br><span class="line">			(hybrid_support() &amp;&amp; cpu_rq(this_cpu)-&gt;rd-&gt;overutilized))</span><br><span class="line">		hmp_force_up_migration(this_cpu);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * If this cpu has a pending nohz_balance_kick, then do the</span><br><span class="line">	 * balancing on behalf of the other idle cpus whose ticks are</span><br><span class="line">	 * stopped. Do nohz_idle_balance *before* rebalance_domains to</span><br><span class="line">	 * give the idle cpus a chance to load balance. Else we may</span><br><span class="line">	 * load balance only within the local sched_domain hierarchy</span><br><span class="line">	 * and abort nohz_idle_balance altogether if we pull some load.</span><br><span class="line">	 */</span><br><span class="line">	nohz_idle_balance(this_rq, idle);</span><br><span class="line">	rebalance_domains(this_rq, idle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>2、在load_balance() -&gt; find_busiest_group()中，如果在EAS使能且没有overutilized的情况下，不进行常规的smp负载均衡；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static struct sched_group *find_busiest_group(struct lb_env *env)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if (energy_aware() &amp;&amp; !env-&gt;dst_rq-&gt;rd-&gt;overutilized &amp;&amp; !same_clus)</span><br><span class="line">		goto out_balanced;</span><br><span class="line"></span><br><span class="line">out_balanced:</span><br><span class="line">	env-&gt;imbalance = 0;</span><br><span class="line">	return NULL;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-1-2、select-task-rq-fair"><a href="#5-1-2、select-task-rq-fair" class="headerlink" title="5.1.2、select_task_rq_fair()"></a>5.1.2、select_task_rq_fair()</h3><p>参考4.1.2.3、select_task_rq_fair()这一节的详细描述。</p>
<h2 id="5-2、cpufreq-sched-schedutil-governor"><a href="#5-2、cpufreq-sched-schedutil-governor" class="headerlink" title="5.2、cpufreq_sched/schedutil governor"></a>5.2、cpufreq_sched/schedutil governor</h2><p>sched governor比较传统interactive governor有以下优点：</p>
<ul>
<li>1、负载变化的时间更快。interactive是20ms统计一次负载，而sched governor是在schedule_tick()中更新负载，tick的时间更短；</li>
<li>2、interactive的负载计算有问题：历史负载没有老化；历史频率除以现在频率不合理；</li>
</ul>
<p>interactive governor的主要思想就是综合rt、cfs的负载，判断当前freq的capacity是否满足需求，是否需要调频。</p>
<p><img src="/images/scheduler/schedule_sched_governor.png" alt="schedule_sched_governor"></p>
<h3 id="5-2-1、rt-request"><a href="#5-2-1、rt-request" class="headerlink" title="5.2.1、rt request"></a>5.2.1、rt request</h3><p>针对CONFIG_CPU_FREQ_GOV_SCHED，rt有3条关键计算路径：</p>
<ul>
<li>1、rt负载的(rq-&gt;rt_avg)的累加：scheduler_tick() -&gt; task_tick_rt() -&gt; update_curr_rt() -&gt; sched_rt_avg_update()</li>
</ul>
<p>rq-&gt;rt_avg = 累加时间分量 * 当前frq分量(最大1024)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static inline void sched_rt_avg_update(struct rq *rq, u64 rt_delta)</span><br><span class="line">&#123;</span><br><span class="line">	rq-&gt;rt_avg += rt_delta * arch_scale_freq_capacity(NULL, cpu_of(rq));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>2、rt负载的老化：scheduler_tick() -&gt; <strong>update_cpu_load() -&gt; </strong>update_cpu_load() -&gt; sched_avg_update()<pre><code>或者scheduler_tick() -&gt; task_tick_rt() -&gt; sched_rt_update_capacity_req() -&gt; sched_avg_update()
</code></pre></li>
</ul>
<p>rq-&gt;rt_avg的老化比较简单，每个period老化1/2。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void sched_avg_update(struct rq *rq)</span><br><span class="line">&#123;</span><br><span class="line">    /* (1) 默认老化周期为1s/2 = 500ms */</span><br><span class="line">	s64 period = sched_avg_period();</span><br><span class="line"></span><br><span class="line">	while ((s64)(rq_clock(rq) - rq-&gt;age_stamp) &gt; period) &#123;</span><br><span class="line">		/*</span><br><span class="line">		 * Inline assembly required to prevent the compiler</span><br><span class="line">		 * optimising this loop into a divmod call.</span><br><span class="line">		 * See __iter_div_u64_rem() for another example of this.</span><br><span class="line">		 */</span><br><span class="line">		asm(&quot;&quot; : &quot;+rm&quot; (rq-&gt;age_stamp));</span><br><span class="line">		rq-&gt;age_stamp += period;</span><br><span class="line">		/* (2) 每个老化周期，负载老化为原来的1/2 */</span><br><span class="line">		rq-&gt;rt_avg /= 2;</span><br><span class="line">		rq-&gt;dl_avg /= 2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">static inline u64 sched_avg_period(void)</span><br><span class="line">&#123;</span><br><span class="line">    /* (1.1) 老化周期 = sysctl_sched_time_avg/2 = 500ms */</span><br><span class="line">	return (u64)sysctl_sched_time_avg * NSEC_PER_MSEC / 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>3、rt request的更新：scheduler_tick() -&gt; task_tick_rt() -&gt; sched_rt_update_capacity_req() -&gt; set_rt_cpu_capacity()</li>
</ul>
<p>rt request的计算有点粗糙: request = rt_avg/(sched_avg_period() + delta)，rt_avg中没有加上delta时间的负载。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">static void sched_rt_update_capacity_req(struct rq *rq)</span><br><span class="line">&#123;</span><br><span class="line">	u64 total, used, age_stamp, avg;</span><br><span class="line">	s64 delta;</span><br><span class="line"></span><br><span class="line">	if (!sched_freq())</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">    /* (1) 最新的负载进行老化 */</span><br><span class="line">	sched_avg_update(rq);</span><br><span class="line">	/*</span><br><span class="line">	 * Since we&apos;re reading these variables without serialization make sure</span><br><span class="line">	 * we read them once before doing sanity checks on them.</span><br><span class="line">	 */</span><br><span class="line">	age_stamp = READ_ONCE(rq-&gt;age_stamp);</span><br><span class="line">	/* (2) avg=老化后的负载 */</span><br><span class="line">	avg = READ_ONCE(rq-&gt;rt_avg);</span><br><span class="line">	delta = rq_clock(rq) - age_stamp;</span><br><span class="line"></span><br><span class="line">	if (unlikely(delta &lt; 0))</span><br><span class="line">		delta = 0;</span><br><span class="line"></span><br><span class="line">    /* (3) total时间=一个老化周期+上次老化剩余时间 */</span><br><span class="line">	total = sched_avg_period() + delta;</span><br><span class="line"></span><br><span class="line">    /* (4) avg/total=request，(最大频率=1024) */</span><br><span class="line">	used = div_u64(avg, total);</span><br><span class="line">	if (unlikely(used &gt; SCHED_CAPACITY_SCALE))</span><br><span class="line">		used = SCHED_CAPACITY_SCALE;</span><br><span class="line"></span><br><span class="line">    /* (5) update request */</span><br><span class="line">	set_rt_cpu_capacity(rq-&gt;cpu, true, (unsigned long)(used), SCHE_ONESHOT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">static inline void set_rt_cpu_capacity(int cpu, bool request,</span><br><span class="line">				       unsigned long capacity,</span><br><span class="line">					int type)</span><br><span class="line">&#123;</span><br><span class="line">#ifdef CONFIG_CPU_FREQ_SCHED_ASSIST</span><br><span class="line">	if (true) &#123;</span><br><span class="line">#else</span><br><span class="line">	if (per_cpu(cpu_sched_capacity_reqs, cpu).rt != capacity) &#123;</span><br><span class="line">#endif</span><br><span class="line">        /* (5.1) 把RT负载更新到per_cpu(cpu_sched_capacity_reqs, cpu).rt */</span><br><span class="line">		per_cpu(cpu_sched_capacity_reqs, cpu).rt = capacity;</span><br><span class="line">		update_cpu_capacity_request(cpu, request, type);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-2-2、cfs-request"><a href="#5-2-2、cfs-request" class="headerlink" title="5.2.2、cfs request"></a>5.2.2、cfs request</h3><p>同样，cfs也有3条关键计算路径：</p>
<ul>
<li>1、cfs负载的(rq-&gt;rt_avg)的累加：scheduler_tick() -&gt; task_tick_fair() -&gt; entity_tick() -&gt; update_load_avg()</li>
<li>2、cfs负载的老化：scheduler_tick() -&gt; task_tick_fair() -&gt; entity_tick() -&gt; update_load_avg()</li>
<li>3、cfs request的更新：scheduler_tick() -&gt; sched_freq_tick() -&gt; set_cfs_cpu_capacity()</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">static void sched_freq_tick(int cpu)</span><br><span class="line">&#123;</span><br><span class="line">	struct sched_capacity_reqs *scr;</span><br><span class="line">	unsigned long capacity_orig, capacity_curr;</span><br><span class="line">	unsigned long capacity_req;</span><br><span class="line">	struct sched_domain *sd = rcu_dereference(per_cpu(sd_ea, cpu));</span><br><span class="line"></span><br><span class="line">	if (!sched_freq())</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	capacity_orig = capacity_orig_of(cpu);</span><br><span class="line">	capacity_curr = capacity_curr_of(cpu);</span><br><span class="line"></span><br><span class="line">    /* (1) 如果当前频率已经是最高频率，直接返回 </span><br><span class="line">        目前只支持频率从低往高调整？</span><br><span class="line">     */</span><br><span class="line">	if (capacity_curr == capacity_orig)</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * To make free room for a task that is building up its &quot;real&quot;</span><br><span class="line">	 * utilization and to harm its performance the least, request</span><br><span class="line">	 * a jump to bigger OPP as soon as the margin of free capacity is</span><br><span class="line">	 * impacted (specified by capacity_margin).</span><br><span class="line">	 */</span><br><span class="line">	scr = &amp;per_cpu(cpu_sched_capacity_reqs, cpu);</span><br><span class="line"></span><br><span class="line">    /* (2) 计算最新的(cfs capacity+ rt capacity) * (1126/1024) </span><br><span class="line">        放大一些，等于对capacity的需求request</span><br><span class="line">        ooooo这里的计算有问题：cpu_util(cpu)是带capacity分量的，而scr-&gt;rt是不带capacity分量的，不能直接相加？</span><br><span class="line">     */</span><br><span class="line">	/* capacity_req which includes RT loading &amp; capacity_margin */</span><br><span class="line">	capacity_req = sum_capacity_reqs(cpu_util(cpu), scr);</span><br><span class="line"></span><br><span class="line">    /* (3) 如果capacity request大于当前频率的capacity */</span><br><span class="line">	if (capacity_curr &lt;= capacity_req) &#123;</span><br><span class="line">		if (sd) &#123;### 5.3.1、WALT的负载计算</span><br><span class="line">			const struct sched_group_energy *const sge = sd-&gt;groups-&gt;sge;</span><br><span class="line">			int nr_cap_states = sge-&gt;nr_cap_states;</span><br><span class="line">			int idx, tmp_idx;</span><br><span class="line">			int opp_jump_step;</span><br><span class="line"></span><br><span class="line">			for (idx = 0; idx &lt; nr_cap_states; idx++) &#123;</span><br><span class="line">				if (sge-&gt;cap_states[idx].cap &gt; capacity_curr+1)</span><br><span class="line">					break;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">            /* (4) 尝试计算一个合理的频率等级来满足capacity request */</span><br><span class="line">			if (idx &lt; nr_cap_states/3)</span><br><span class="line">				opp_jump_step = 2; /* far step */</span><br><span class="line">			else</span><br><span class="line">				opp_jump_step = 1; /* near step */</span><br><span class="line"></span><br><span class="line">			tmp_idx = idx + (opp_jump_step - 1);</span><br><span class="line"></span><br><span class="line">			idx = tmp_idx &gt; (nr_cap_states - 1) ?</span><br><span class="line">				(nr_cap_states - 1) : tmp_idx;</span><br><span class="line"></span><br><span class="line">			if (idx)</span><br><span class="line">				capacity_req = (sge-&gt;cap_states[idx].cap +</span><br><span class="line">						sge-&gt;cap_states[idx-1].cap)/2;</span><br><span class="line">			else</span><br><span class="line">				/* should not arrive here!*/</span><br><span class="line">				capacity_req = sge-&gt;cap_states[idx].cap + 2;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        /* (5) 去掉request中的capacity分量，转化成scale_freq */</span><br><span class="line">		/* convert scale-invariant capacity */</span><br><span class="line">		capacity_req = capacity_req * SCHED_CAPACITY_SCALE / capacity_orig_of(cpu);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        /* (6) update request， </span><br><span class="line">            ooooo这里有问题啊：capacity_req计算的时候是按照rt+cfs加起来计算的，怎么有把结果配置给了scr-&gt;cfs？</span><br><span class="line">         */</span><br><span class="line">		/*</span><br><span class="line">		 * If free room ~5% impact, jump to 1 more index hihger OPP.</span><br><span class="line">		 * Whatever it should be better than capacity_max.</span><br><span class="line">		 */</span><br><span class="line">		set_cfs_cpu_capacity(cpu, true, capacity_req, SCHE_ONESHOT);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">static inline void set_cfs_cpu_capacity(int cpu, bool request,</span><br><span class="line">					unsigned long capacity, int type)</span><br><span class="line">&#123;</span><br><span class="line">#ifdef CONFIG_CPU_FREQ_SCHED_ASSIST</span><br><span class="line">	if (true) &#123;</span><br><span class="line">#else</span><br><span class="line">	if (per_cpu(cpu_sched_capacity_reqs, cpu).cfs != capacity) &#123;</span><br><span class="line">#endif</span><br><span class="line">        /* (6.1) 把RT负载更新到per_cpu(cpu_sched_capacity_reqs, cpu).cfs */</span><br><span class="line">		per_cpu(cpu_sched_capacity_reqs, cpu).cfs = capacity;</span><br><span class="line">		update_cpu_capacity_request(cpu, request, type);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-2-3、freq-target"><a href="#5-2-3、freq-target" class="headerlink" title="5.2.3、freq target"></a>5.2.3、freq target</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">void update_cpu_capacity_request(int cpu, bool request, int type)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned long new_capacity;</span><br><span class="line">	struct sched_capacity_reqs *scr;</span><br><span class="line"></span><br><span class="line">	/* The rq lock serializes access to the CPU&apos;s sched_capacity_reqs. */</span><br><span class="line">	lockdep_assert_held(&amp;cpu_rq(cpu)-&gt;lock);</span><br><span class="line"></span><br><span class="line">	scr = &amp;per_cpu(cpu_sched_capacity_reqs, cpu);</span><br><span class="line"></span><br><span class="line">    /* (1) 综合rt、cfs的request */</span><br><span class="line">	new_capacity = scr-&gt;cfs + scr-&gt;rt;</span><br><span class="line">	new_capacity = new_capacity * capacity_margin_dvfs</span><br><span class="line">		/ SCHED_CAPACITY_SCALE;</span><br><span class="line">	new_capacity += scr-&gt;dl;</span><br><span class="line"></span><br><span class="line">#ifndef CONFIG_CPU_FREQ_SCHED_ASSIST</span><br><span class="line">	if (new_capacity == scr-&gt;total)</span><br><span class="line">		return;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	scr-&gt;total = new_capacity;</span><br><span class="line">	if (request)</span><br><span class="line">		update_fdomain_capacity_request(cpu, type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">static void update_fdomain_capacity_request(int cpu, int type)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned int freq_new, cpu_tmp;</span><br><span class="line">	struct gov_data *gd;</span><br><span class="line">	unsigned long capacity = 0;</span><br><span class="line">#ifdef CONFIG_CPU_FREQ_SCHED_ASSIST</span><br><span class="line">	int cid = arch_get_cluster_id(cpu);</span><br><span class="line">	struct cpumask cls_cpus;</span><br><span class="line">#endif</span><br><span class="line">	struct cpufreq_policy *policy = NULL;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Avoid grabbing the policy if possible. A test is still</span><br><span class="line">	 * required after locking the CPU&apos;s policy to avoid racing</span><br><span class="line">	 * with the governor changing.</span><br><span class="line">	 */</span><br><span class="line">	if (!per_cpu(enabled, cpu))</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_CPU_FREQ_SCHED_ASSIST</span><br><span class="line">	gd = g_gd[cid];</span><br><span class="line"></span><br><span class="line">	/* bail early if we are throttled */</span><br><span class="line">	if (ktime_before(ktime_get(), gd-&gt;throttle))</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">	arch_get_cluster_cpus(&amp;cls_cpus, cid);</span><br><span class="line"></span><br><span class="line">	/* find max capacity requested by cpus in this policy */</span><br><span class="line">	for_each_cpu(cpu_tmp, &amp;cls_cpus) &#123;</span><br><span class="line">		struct sched_capacity_reqs *scr;</span><br><span class="line"></span><br><span class="line">		if (!cpu_online(cpu_tmp))</span><br><span class="line">			continue;</span><br><span class="line"></span><br><span class="line">		scr = &amp;per_cpu(cpu_sched_capacity_reqs, cpu_tmp);</span><br><span class="line">		capacity = max(capacity, scr-&gt;total);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	freq_new = capacity * arch_scale_get_max_freq(cpu) &gt;&gt; SCHED_CAPACITY_SHIFT;</span><br><span class="line">#else</span><br><span class="line">	if (likely(cpu_online(cpu)))</span><br><span class="line">		policy = cpufreq_cpu_get(cpu);</span><br><span class="line"></span><br><span class="line">	if (IS_ERR_OR_NULL(policy))</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	if (policy-&gt;governor != &amp;cpufreq_gov_sched ||</span><br><span class="line">	    !policy-&gt;governor_data)</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">	gd = policy-&gt;governor_data;</span><br><span class="line"></span><br><span class="line">	/* bail early if we are throttled */</span><br><span class="line">	if (ktime_before(ktime_get(), gd-&gt;throttle))</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">    /* (1) 选择policy cpus中最大的capacity */</span><br><span class="line">	/* find max capacity requested by cpus in this policy */</span><br><span class="line">	for_each_cpu(cpu_tmp, policy-&gt;cpus) &#123;</span><br><span class="line">		struct sched_capacity_reqs *scr;</span><br><span class="line"></span><br><span class="line">		scr = &amp;per_cpu(cpu_sched_capacity_reqs, cpu_tmp);</span><br><span class="line">		capacity = max(capacity, scr-&gt;total);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (2) 把相对capacity转换成绝对freq */</span><br><span class="line">	/* Convert the new maximum capacity request into a cpu frequency */</span><br><span class="line">	freq_new = capacity * policy-&gt;max &gt;&gt; SCHED_CAPACITY_SHIFT;</span><br><span class="line"></span><br><span class="line">	if (freq_new == gd-&gt;requested_freq)</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">#endif /* !CONFIG_CPU_FREQ_SCHED_ASSIST */</span><br><span class="line"></span><br><span class="line">	gd-&gt;requested_freq = freq_new;</span><br><span class="line">	gd-&gt;target_cpu = cpu;</span><br><span class="line"></span><br><span class="line">    /* (3) 使用irq_work或者直接配置的方式来配置新的频率 </span><br><span class="line">        直接在schedule_tick()中配置频率的方式估计不会使用，因为这样会阻塞中断</span><br><span class="line">     */</span><br><span class="line">	/*</span><br><span class="line">	 * Throttling is not yet supported on platforms with fast cpufreq</span><br><span class="line">	 * drivers.</span><br><span class="line">	 */</span><br><span class="line">	if (cpufreq_driver_slow)</span><br><span class="line">		irq_work_queue_on(&amp;gd-&gt;irq_work, cpu);</span><br><span class="line">	else</span><br><span class="line">		cpufreq_sched_try_driver_target(cpu, policy, freq_new, type);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	if (policy)</span><br><span class="line">		cpufreq_cpu_put(policy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-3、WALT-Windows-Assisted-Load-Tracking"><a href="#5-3、WALT-Windows-Assisted-Load-Tracking" class="headerlink" title="5.3、WALT(Windows Assisted Load Tracking)"></a>5.3、WALT(Windows Assisted Load Tracking)</h2><p>在qualcomm 8898中，使用了WALT作为负载计算方法，也使用了自己的负载均衡算法来使用WALT负载。代码中使用CONFIG_SCHED_HMP来标示qualcomm自己负载均衡方法。</p>
<h3 id="5-3-1、WALT的负载计算"><a href="#5-3-1、WALT的负载计算" class="headerlink" title="5.3.1、WALT的负载计算"></a>5.3.1、WALT的负载计算</h3><p>Walt的本质也是时间窗分量，结合freq分量、capacity分量等一起表达的一个负载相对值。我们首先来看看几个分量的计算方法。</p>
<ul>
<li>1、cluster-&gt;efficiency计算：从dts中读取，我们可以看到，四个小核的efficiency是1024，四个大核的efficiency是1638；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">static struct sched_cluster *alloc_new_cluster(const struct cpumask *cpus)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	cluster-&gt;efficiency = arch_get_cpu_efficiency(cpumask_first(cpus));</span><br><span class="line">	</span><br><span class="line">	if (cluster-&gt;efficiency &gt; max_possible_efficiency)</span><br><span class="line">		max_possible_efficiency = cluster-&gt;efficiency;</span><br><span class="line">	if (cluster-&gt;efficiency &lt; min_possible_efficiency)</span><br><span class="line">		min_possible_efficiency = cluster-&gt;efficiency;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unsigned long arch_get_cpu_efficiency(int cpu)</span><br><span class="line">&#123;</span><br><span class="line">	return per_cpu(cpu_efficiency, cpu);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __init parse_dt_cpu_power(void)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">		/*</span><br><span class="line">		 * The CPU efficiency value passed from the device tree</span><br><span class="line">		 * overrides the value defined in the table_efficiency[]</span><br><span class="line">		 */</span><br><span class="line">		if (of_property_read_u32(cn, &quot;efficiency&quot;, &amp;efficiency) &lt; 0) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		per_cpu(cpu_efficiency, cpu) = efficiency;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">从 arch/arm64/boot/dts/qcom/sdm660.dtsi读到&quot;efficiency&quot;配置：</span><br><span class="line"></span><br><span class="line">	cpus &#123;</span><br><span class="line">		#address-cells = &lt;2&gt;;</span><br><span class="line">		#size-cells = &lt;0&gt;;</span><br><span class="line"></span><br><span class="line">		CPU0: cpu@0 &#123;</span><br><span class="line"></span><br><span class="line">			efficiency = &lt;1024&gt;;</span><br><span class="line"></span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		CPU1: cpu@1 &#123;</span><br><span class="line"></span><br><span class="line">			efficiency = &lt;1024&gt;;</span><br><span class="line"></span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		CPU2: cpu@2 &#123;</span><br><span class="line"></span><br><span class="line">			efficiency = &lt;1024&gt;;</span><br><span class="line"></span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		CPU3: cpu@3 &#123;</span><br><span class="line"></span><br><span class="line">			efficiency = &lt;1024&gt;;</span><br><span class="line"></span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		CPU4: cpu@100 &#123;</span><br><span class="line"></span><br><span class="line">			efficiency = &lt;1638&gt;;</span><br><span class="line"></span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		CPU5: cpu@101 &#123;</span><br><span class="line"></span><br><span class="line">			efficiency = &lt;1638&gt;;</span><br><span class="line"></span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		CPU6: cpu@102 &#123;</span><br><span class="line"></span><br><span class="line">			efficiency = &lt;1638&gt;;</span><br><span class="line"></span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		CPU7: cpu@103 &#123;</span><br><span class="line"></span><br><span class="line">			efficiency = &lt;1638&gt;;</span><br><span class="line"></span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		cpu-map &#123;</span><br><span class="line">			cluster0 &#123;</span><br><span class="line">				core0 &#123;</span><br><span class="line">					cpu = &lt;&amp;CPU0&gt;;</span><br><span class="line">				&#125;;</span><br><span class="line"></span><br><span class="line">				core1 &#123;</span><br><span class="line">					cpu = &lt;&amp;CPU1&gt;;</span><br><span class="line">				&#125;;</span><br><span class="line"></span><br><span class="line">				core2 &#123;</span><br><span class="line">					cpu = &lt;&amp;CPU2&gt;;</span><br><span class="line">				&#125;;</span><br><span class="line"></span><br><span class="line">				core3 &#123;</span><br><span class="line">					cpu = &lt;&amp;CPU3&gt;;</span><br><span class="line">				&#125;;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			cluster1 &#123;</span><br><span class="line">				core0 &#123;</span><br><span class="line">					cpu = &lt;&amp;CPU4&gt;;</span><br><span class="line">				&#125;;</span><br><span class="line"></span><br><span class="line">				core1 &#123;</span><br><span class="line">					cpu = &lt;&amp;CPU5&gt;;</span><br><span class="line">				&#125;;</span><br><span class="line"></span><br><span class="line">				core2 &#123;</span><br><span class="line">					cpu = &lt;&amp;CPU6&gt;;</span><br><span class="line">				&#125;;</span><br><span class="line"></span><br><span class="line">				core3 &#123;</span><br><span class="line">					cpu = &lt;&amp;CPU7&gt;;</span><br><span class="line">				&#125;;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>2、cluster-&gt;capacity：计算和最小值的正比：capacity = 1024 <em> (cluster-&gt;efficiency</em>cluster_max_freq(cluster)) / (min_possible_efficiency*min_max_freq)</li>
<li>3、cluster-&gt;max_possible_capacity：计算和最小值的正比：capacity = 1024 <em> (cluster-&gt;efficiency</em>cluster-&gt;max_possible_freq) / (min_possible_efficiency*min_max_freq)</li>
<li>4、cluster-&gt;load_scale_factor：计算和最大值的反比：lsf = 1024 <em> (max_possible_efficiency</em>max_possible_freq) / (cluster-&gt;efficiency*cluster_max_freq(cluster))</li>
<li>5、cluster-&gt;exec_scale_factor：计算和最大值的正比：exec_scale_factor = 1024 * cluster-&gt;efficiency / max_possible_efficiency</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line">static void update_all_clusters_stats(void)</span><br><span class="line">&#123;</span><br><span class="line">	struct sched_cluster *cluster;</span><br><span class="line">	u64 highest_mpc = 0, lowest_mpc = U64_MAX;</span><br><span class="line"></span><br><span class="line">	pre_big_task_count_change(cpu_possible_mask);</span><br><span class="line"></span><br><span class="line">	for_each_sched_cluster(cluster) &#123;</span><br><span class="line">		u64 mpc;</span><br><span class="line"></span><br><span class="line">        /* (1) 计算cluster-&gt;capacity：capacity = efficiency * cluster_max_freq</span><br><span class="line">            最小值：min_possible_efficiency*min_max_freq = 1024，</span><br><span class="line">            计算和最小值的正比：capacity = 1024 * (cluster-&gt;efficiency*cluster_max_freq(cluster)) / (min_possible_efficiency*min_max_freq)</span><br><span class="line">         */</span><br><span class="line">		cluster-&gt;capacity = compute_capacity(cluster);</span><br><span class="line">		</span><br><span class="line">		/* (2) 计算cluster-&gt;max_possible_capacity：capacity = efficiency * cluster_max_freq</span><br><span class="line">		    最小值：min_possible_efficiency*min_max_freq = 1024，</span><br><span class="line">            计算和最小值的正比：capacity = 1024 * (cluster-&gt;efficiency*cluster-&gt;max_possible_freq) / (min_possible_efficiency*min_max_freq)</span><br><span class="line">		 */</span><br><span class="line">		mpc = cluster-&gt;max_possible_capacity =</span><br><span class="line">			compute_max_possible_capacity(cluster);</span><br><span class="line">			</span><br><span class="line">		/* (3) 计算cluster-&gt;load_scale_factor： lsf = efficiency * cluster_max_freq</span><br><span class="line">		    最大值：max_possible_efficiency*max_possible_freq = 1024</span><br><span class="line">		    计算和最大值的反比：lsf = 1024 * (max_possible_efficiency*max_possible_freq) / (cluster-&gt;efficiency*cluster_max_freq(cluster))</span><br><span class="line">		 */</span><br><span class="line">		cluster-&gt;load_scale_factor = compute_load_scale_factor(cluster);</span><br><span class="line"></span><br><span class="line">        /* (4) 计算cluster-&gt;exec_scale_factor：</span><br><span class="line">            最大值：max_possible_efficiency = 1024</span><br><span class="line">            计算和最大值的正比：exec_scale_factor = 1024 * cluster-&gt;efficiency / max_possible_efficiency</span><br><span class="line">         */</span><br><span class="line">		cluster-&gt;exec_scale_factor =</span><br><span class="line">			DIV_ROUND_UP(cluster-&gt;efficiency * 1024,</span><br><span class="line">				     max_possible_efficiency);</span><br><span class="line"></span><br><span class="line">		if (mpc &gt; highest_mpc)</span><br><span class="line">			highest_mpc = mpc;</span><br><span class="line"></span><br><span class="line">		if (mpc &lt; lowest_mpc)</span><br><span class="line">			lowest_mpc = mpc;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	max_possible_capacity = highest_mpc;</span><br><span class="line">	min_max_possible_capacity = lowest_mpc;</span><br><span class="line"></span><br><span class="line">	__update_min_max_capacity();</span><br><span class="line">	sched_update_freq_max_load(cpu_possible_mask);</span><br><span class="line">	post_big_task_count_change(cpu_possible_mask);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">static int compute_capacity(struct sched_cluster *cluster)</span><br><span class="line">&#123;</span><br><span class="line">	int capacity = 1024;</span><br><span class="line"></span><br><span class="line">	capacity *= capacity_scale_cpu_efficiency(cluster);</span><br><span class="line">	capacity &gt;&gt;= 10;</span><br><span class="line"></span><br><span class="line">	capacity *= capacity_scale_cpu_freq(cluster);</span><br><span class="line">	capacity &gt;&gt;= 10;</span><br><span class="line"></span><br><span class="line">	return capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">||→</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Return &apos;capacity&apos; of a cpu in reference to &quot;least&quot; efficient cpu, such that</span><br><span class="line"> * least efficient cpu gets capacity of 1024</span><br><span class="line"> */</span><br><span class="line">static unsigned long</span><br><span class="line">capacity_scale_cpu_efficiency(struct sched_cluster *cluster)</span><br><span class="line">&#123;</span><br><span class="line">	return (1024 * cluster-&gt;efficiency) / min_possible_efficiency;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">||→</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Return &apos;capacity&apos; of a cpu in reference to cpu with lowest max_freq</span><br><span class="line"> * (min_max_freq), such that one with lowest max_freq gets capacity of 1024.</span><br><span class="line"> */</span><br><span class="line">static unsigned long capacity_scale_cpu_freq(struct sched_cluster *cluster)</span><br><span class="line">&#123;</span><br><span class="line">	return (1024 * cluster_max_freq(cluster)) / min_max_freq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">static int compute_load_scale_factor(struct sched_cluster *cluster)</span><br><span class="line">&#123;</span><br><span class="line">	int load_scale = 1024;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * load_scale_factor accounts for the fact that task load</span><br><span class="line">	 * is in reference to &quot;best&quot; performing cpu. Task&apos;s load will need to be</span><br><span class="line">	 * scaled (up) by a factor to determine suitability to be placed on a</span><br><span class="line">	 * (little) cpu.</span><br><span class="line">	 */</span><br><span class="line">	load_scale *= load_scale_cpu_efficiency(cluster);</span><br><span class="line">	load_scale &gt;&gt;= 10;</span><br><span class="line"></span><br><span class="line">	load_scale *= load_scale_cpu_freq(cluster);</span><br><span class="line">	load_scale &gt;&gt;= 10;</span><br><span class="line"></span><br><span class="line">	return load_scale;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">||→</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Return load_scale_factor of a cpu in reference to &quot;most&quot; efficient cpu, so</span><br><span class="line"> * that &quot;most&quot; efficient cpu gets a load_scale_factor of 1</span><br><span class="line"> */</span><br><span class="line">static inline unsigned long</span><br><span class="line">load_scale_cpu_efficiency(struct sched_cluster *cluster)</span><br><span class="line">&#123;</span><br><span class="line">	return DIV_ROUND_UP(1024 * max_possible_efficiency,</span><br><span class="line">			    cluster-&gt;efficiency);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">||→</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Return load_scale_factor of a cpu in reference to cpu with best max_freq</span><br><span class="line"> * (max_possible_freq), so that one with best max_freq gets a load_scale_factor</span><br><span class="line"> * of 1.</span><br><span class="line"> */</span><br><span class="line">static inline unsigned long load_scale_cpu_freq(struct sched_cluster *cluster)</span><br><span class="line">&#123;</span><br><span class="line">	return DIV_ROUND_UP(1024 * max_possible_freq,</span><br><span class="line">			   cluster_max_freq(cluster));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>6、cluster-&gt;max_power_cost：cluster的最大功耗 = voltage^2 * frequence</li>
<li>7、cluster-&gt;min_power_cost：cluster的最小功耗 = voltage^2 * frequence</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">static void sort_clusters(void)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	for_each_sched_cluster(cluster) &#123;</span><br><span class="line">		cluster-&gt;max_power_cost = power_cost(cluster_first_cpu(cluster),</span><br><span class="line">							       max_task_load());</span><br><span class="line">		cluster-&gt;min_power_cost = power_cost(cluster_first_cpu(cluster),</span><br><span class="line">							       0);</span><br><span class="line"></span><br><span class="line">		if (cluster-&gt;max_power_cost &gt; tmp_max)</span><br><span class="line">			tmp_max = cluster-&gt;max_power_cost;</span><br><span class="line">	&#125;</span><br><span class="line">	max_power_cost = tmp_max;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">unsigned int power_cost(int cpu, u64 demand)</span><br><span class="line">&#123;</span><br><span class="line">	int first, mid, last;</span><br><span class="line">	struct cpu_pwr_stats *per_cpu_info = get_cpu_pwr_stats();</span><br><span class="line">	struct cpu_pstate_pwr *costs;</span><br><span class="line">	struct freq_max_load *max_load;</span><br><span class="line">	int total_static_pwr_cost = 0;</span><br><span class="line">	struct rq *rq = cpu_rq(cpu);</span><br><span class="line">	unsigned int pc;</span><br><span class="line"></span><br><span class="line">	if (!per_cpu_info || !per_cpu_info[cpu].ptable)</span><br><span class="line">		/*</span><br><span class="line">		 * When power aware scheduling is not in use, or CPU</span><br><span class="line">		 * power data is not available, just use the CPU</span><br><span class="line">		 * capacity as a rough stand-in for real CPU power</span><br><span class="line">		 * numbers, assuming bigger CPUs are more power</span><br><span class="line">		 * hungry.</span><br><span class="line">		 */</span><br><span class="line">		return cpu_max_possible_capacity(cpu);</span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	max_load = rcu_dereference(per_cpu(freq_max_load, cpu));</span><br><span class="line">	if (!max_load) &#123;</span><br><span class="line">		pc = cpu_max_possible_capacity(cpu);</span><br><span class="line">		goto unlock;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	costs = per_cpu_info[cpu].ptable;</span><br><span class="line"></span><br><span class="line">	if (demand &lt;= max_load-&gt;freqs[0].hdemand) &#123;</span><br><span class="line">		pc = costs[0].power;</span><br><span class="line">		goto unlock;</span><br><span class="line">	&#125; else if (demand &gt; max_load-&gt;freqs[max_load-&gt;length - 1].hdemand) &#123;</span><br><span class="line">		pc = costs[max_load-&gt;length - 1].power;</span><br><span class="line">		goto unlock;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	first = 0;</span><br><span class="line">	last = max_load-&gt;length - 1;</span><br><span class="line">	mid = (last - first) &gt;&gt; 1;</span><br><span class="line">	while (1) &#123;</span><br><span class="line">		if (demand &lt;= max_load-&gt;freqs[mid].hdemand)</span><br><span class="line">			last = mid;</span><br><span class="line">		else</span><br><span class="line">			first = mid;</span><br><span class="line"></span><br><span class="line">		if (last - first == 1)</span><br><span class="line">			break;</span><br><span class="line">		mid = first + ((last - first) &gt;&gt; 1);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pc = costs[last].power;</span><br><span class="line"></span><br><span class="line">unlock:</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">	if (idle_cpu(cpu) &amp;&amp; rq-&gt;cstate) &#123;</span><br><span class="line">		total_static_pwr_cost += rq-&gt;static_cpu_pwr_cost;</span><br><span class="line">		if (rq-&gt;cluster-&gt;dstate)</span><br><span class="line">			total_static_pwr_cost +=</span><br><span class="line">				rq-&gt;cluster-&gt;static_cluster_pwr_cost;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return pc + total_static_pwr_cost;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* qualcom的power的计算公式 = voltage^2 * frequence */</span><br><span class="line">static int msm_get_power_values(int cpu, struct cpu_static_info *sp)</span><br><span class="line">&#123;</span><br><span class="line">	int i = 0, j;</span><br><span class="line">	int ret = 0;</span><br><span class="line">	uint64_t power;</span><br><span class="line"></span><br><span class="line">	/* Calculate dynamic power spent for every frequency using formula:</span><br><span class="line">	 * Power = V * V * f</span><br><span class="line">	 * where V = voltage for frequency</span><br><span class="line">	 *       f = frequency</span><br><span class="line">	 * */</span><br><span class="line">	sp-&gt;power = allocate_2d_array_uint32_t(sp-&gt;num_of_freqs);</span><br><span class="line">	if (IS_ERR_OR_NULL(sp-&gt;power))</span><br><span class="line">		return PTR_ERR(sp-&gt;power);</span><br><span class="line"></span><br><span class="line">	for (i = 0; i &lt; TEMP_DATA_POINTS; i++) &#123;</span><br><span class="line">		for (j = 0; j &lt; sp-&gt;num_of_freqs; j++) &#123;</span><br><span class="line">			power = sp-&gt;voltage[j] *</span><br><span class="line">						sp-&gt;table[j].frequency;</span><br><span class="line">			do_div(power, 1000);</span><br><span class="line">			do_div(power, 1000);</span><br><span class="line">			power *= sp-&gt;voltage[j];</span><br><span class="line">			do_div(power, 1000);</span><br><span class="line">			sp-&gt;power[i][j] = power;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-3-1-1、update-task-ravg"><a href="#5-3-1-1、update-task-ravg" class="headerlink" title="5.3.1.1、update_task_ravg()"></a>5.3.1.1、update_task_ravg()</h4><p>walt关于进程的负载计算流程如下：</p>
<ul>
<li>1、把时间分成一个个window窗口，累加时间时，需要综合efficiency和freq分量(也就是capacity)：delta = delta_time <em> (curr_freq/max_possible_freq) </em> (cluster-&gt;efficiency/max_possible_efficiency);</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static inline u64 scale_exec_time(u64 delta, struct rq *rq)</span><br><span class="line">&#123;</span><br><span class="line">	u32 freq;</span><br><span class="line"></span><br><span class="line">    /* curr_freq / max_possible_freq */</span><br><span class="line">	freq = cpu_cycles_to_freq(rq-&gt;cc.cycles, rq-&gt;cc.time);</span><br><span class="line">	delta = DIV64_U64_ROUNDUP(delta * freq, max_possible_freq);</span><br><span class="line">	</span><br><span class="line">	/* exec_scale_factor = cluster-&gt;efficiency / max_possible_efficiency */</span><br><span class="line">	delta *= rq-&gt;cluster-&gt;exec_scale_factor;</span><br><span class="line">	delta &gt;&gt;= 10;</span><br><span class="line"></span><br><span class="line">	return delta;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>2、统计runnable状态的时间：account_busy_for_task_demand()屏蔽掉runnable以外的其他状态的时间统计；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">static int account_busy_for_task_demand(struct task_struct *p, int event)</span><br><span class="line">&#123;</span><br><span class="line">	/*</span><br><span class="line">	 * No need to bother updating task demand for exiting tasks</span><br><span class="line">	 * or the idle task.</span><br><span class="line">	 */</span><br><span class="line">	/* (3.1.1) exit、idle任务不计入统计 */</span><br><span class="line">	if (exiting_task(p) || is_idle_task(p))</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * When a task is waking up it is completing a segment of non-busy</span><br><span class="line">	 * time. Likewise, if wait time is not treated as busy time, then</span><br><span class="line">	 * when a task begins to run or is migrated, it is not running and</span><br><span class="line">	 * is completing a segment of non-busy time.</span><br><span class="line">	 */</span><br><span class="line">	/* (3.1.2) 任务被wakeup，之前的等待时间不计入统计 </span><br><span class="line">	    SCHED_ACCOUNT_WAIT_TIME用来控制ruannable的等待时间是否计入统计，默认是计入的</span><br><span class="line">	 */</span><br><span class="line">	if (event == TASK_WAKE || (!SCHED_ACCOUNT_WAIT_TIME &amp;&amp;</span><br><span class="line">			 (event == PICK_NEXT_TASK || event == TASK_MIGRATE)))</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>3、在统计时间时，可能碰到的3种组合情况：</li>
</ul>
<p><img src="/images/scheduler/schedule_walt_update_task_demand.png" alt="schedule_walt_update_task_demand"></p>
<ul>
<li>4、如果一个window还没有完成，会逐步累加时间到p-&gt;ravg.sum；如果一个window完成，存储最新window负载到p-&gt;ravg.sum_history[RAVG_HIST_SIZE_MAX]中，sum_history[]一共有5个槽位；系统根据sched_window_stats_policy选择策略(RECENT、MAX、AVG、MAX_RECENT_AVG)，根据sum_history[]计算选择一个合适的值作为进程负载p-&gt;ravg.demand；同时根据sum_history[]的计算进程的负载预测p-&gt;ravg.pred_demand；</li>
</ul>
<p><img src="/images/scheduler/schedule_walt_update_history.png" alt="schedule_walt_update_history"></p>
<ul>
<li><p>5、walt的task级别的负载是p-&gt;ravg.demand，cpu级别负载是rq-&gt;hmp_stats.cumulative_runnable_avg；</p>
</li>
<li><p>6、</p>
</li>
</ul>
<p>具体的update_task_ravg()代码解析如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br></pre></td><td class="code"><pre><span class="line">scheduler_tick() -&gt; update_task_ravg()</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">/* Reflect task activity on its demand and cpu&apos;s busy time statistics */</span><br><span class="line">void update_task_ravg(struct task_struct *p, struct rq *rq, int event,</span><br><span class="line">						u64 wallclock, u64 irqtime)</span><br><span class="line">&#123;</span><br><span class="line">	u64 runtime;</span><br><span class="line"></span><br><span class="line">	if (!rq-&gt;window_start || sched_disable_window_stats ||</span><br><span class="line">	    p-&gt;ravg.mark_start == wallclock)</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	lockdep_assert_held(&amp;rq-&gt;lock);</span><br><span class="line"></span><br><span class="line">    /* (1) 根据wallclock更新rq-&gt;window_start */</span><br><span class="line">	update_window_start(rq, wallclock);</span><br><span class="line"></span><br><span class="line">	if (!p-&gt;ravg.mark_start) &#123;</span><br><span class="line">		update_task_cpu_cycles(p, cpu_of(rq));</span><br><span class="line">		goto done;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (2) 更新cycle、walltime的差值，用来计算cpu的当前freq */</span><br><span class="line">	update_task_rq_cpu_cycles(p, rq, event, wallclock, irqtime);</span><br><span class="line">	</span><br><span class="line">	/* (3) 更新task的负载demand */</span><br><span class="line">	runtime = update_task_demand(p, rq, event, wallclock);</span><br><span class="line">	if (runtime)</span><br><span class="line">		update_task_burst(p, rq, event, runtime);</span><br><span class="line">		</span><br><span class="line">	/* (4) 更新cpu的busy时间 */</span><br><span class="line">	update_cpu_busy_time(p, rq, event, wallclock, irqtime);</span><br><span class="line">	</span><br><span class="line">	/* (5) 更新task的负载预测pred_demand */</span><br><span class="line">	update_task_pred_demand(rq, p, event);</span><br><span class="line">done:</span><br><span class="line">	trace_sched_update_task_ravg(p, rq, event, wallclock, irqtime,</span><br><span class="line">				     rq-&gt;cc.cycles, rq-&gt;cc.time,</span><br><span class="line">				     p-&gt;grp ? &amp;rq-&gt;grp_time : NULL);</span><br><span class="line"></span><br><span class="line">    /* (6) 更新task的时间更新点：p-&gt;ravg.mark_start */</span><br><span class="line">	p-&gt;ravg.mark_start = wallclock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">static u64 update_task_demand(struct task_struct *p, struct rq *rq,</span><br><span class="line">			       int event, u64 wallclock)</span><br><span class="line">&#123;</span><br><span class="line">	u64 mark_start = p-&gt;ravg.mark_start;</span><br><span class="line">	u64 delta, window_start = rq-&gt;window_start;</span><br><span class="line">	int new_window, nr_full_windows;</span><br><span class="line">	u32 window_size = sched_ravg_window;</span><br><span class="line">	u64 runtime;</span><br><span class="line"></span><br><span class="line">	new_window = mark_start &lt; window_start;</span><br><span class="line">	</span><br><span class="line">	/* (3.1) 这是一个关键点，非runnable状态的统计需要在这里异常返回 */</span><br><span class="line">	if (!account_busy_for_task_demand(p, event)) &#123;</span><br><span class="line">		if (new_window)</span><br><span class="line">			/*</span><br><span class="line">			 * If the time accounted isn&apos;t being accounted as</span><br><span class="line">			 * busy time, and a new window started, only the</span><br><span class="line">			 * previous window need be closed out with the</span><br><span class="line">			 * pre-existing demand. Multiple windows may have</span><br><span class="line">			 * elapsed, but since empty windows are dropped,</span><br><span class="line">			 * it is not necessary to account those.</span><br><span class="line">			 */</span><br><span class="line">			update_history(rq, p, p-&gt;ravg.sum, 1, event);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (3.2) 第一种情况：还在原窗口内，简单继续累加p-&gt;ravg.sum */</span><br><span class="line">	if (!new_window) &#123;</span><br><span class="line">		/*</span><br><span class="line">		 * The simple case - busy time contained within the existing</span><br><span class="line">		 * window.</span><br><span class="line">		 */</span><br><span class="line">		return add_to_task_demand(rq, p, wallclock - mark_start);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (3.3) 第二、三种情况：原窗口已经填满 */</span><br><span class="line">	/*</span><br><span class="line">	 * Busy time spans at least two windows. Temporarily rewind</span><br><span class="line">	 * window_start to first window boundary after mark_start.</span><br><span class="line">	 */</span><br><span class="line">	delta = window_start - mark_start;</span><br><span class="line">	nr_full_windows = div64_u64(delta, window_size);</span><br><span class="line">	window_start -= (u64)nr_full_windows * (u64)window_size;</span><br><span class="line"></span><br><span class="line">    /* (3.4.1) 补全第一个窗口 */</span><br><span class="line">	/* Process (window_start - mark_start) first */</span><br><span class="line">	runtime = add_to_task_demand(rq, p, window_start - mark_start);</span><br><span class="line"></span><br><span class="line">    /* (3.4.2) 把第一个窗口更新到进程task负载history中, </span><br><span class="line">        更新p-&gt;ravg.demand、p-&gt;ravg.pred_demand</span><br><span class="line">     */</span><br><span class="line">	/* Push new sample(s) into task&apos;s demand history */</span><br><span class="line">	update_history(rq, p, p-&gt;ravg.sum, 1, event);</span><br><span class="line">	</span><br><span class="line">	/* (3.5) 如果中间有几个完整窗口，更新负载，更新history */</span><br><span class="line">	if (nr_full_windows) &#123;</span><br><span class="line">		u64 scaled_window = scale_exec_time(window_size, rq);</span><br><span class="line"></span><br><span class="line">		update_history(rq, p, scaled_window, nr_full_windows, event);</span><br><span class="line">		runtime += nr_full_windows * scaled_window;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (3.6) 最后一个没有完成的窗口，只是简单累加时间，不更新history */</span><br><span class="line">	/*</span><br><span class="line">	 * Roll window_start back to current to process any remainder</span><br><span class="line">	 * in current window.</span><br><span class="line">	 */</span><br><span class="line">	window_start += (u64)nr_full_windows * (u64)window_size;</span><br><span class="line"></span><br><span class="line">	/* Process (wallclock - window_start) next */</span><br><span class="line">	mark_start = window_start;</span><br><span class="line">	runtime += add_to_task_demand(rq, p, wallclock - mark_start);</span><br><span class="line"></span><br><span class="line">	return runtime;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">||→</span><br><span class="line"></span><br><span class="line">static int account_busy_for_task_demand(struct task_struct *p, int event)</span><br><span class="line">&#123;</span><br><span class="line">	/*</span><br><span class="line">	 * No need to bother updating task demand for exiting tasks</span><br><span class="line">	 * or the idle task.</span><br><span class="line">	 */</span><br><span class="line">	/* (3.1.1) exit、idle任务不计入统计 */</span><br><span class="line">	if (exiting_task(p) || is_idle_task(p))</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * When a task is waking up it is completing a segment of non-busy</span><br><span class="line">	 * time. Likewise, if wait time is not treated as busy time, then</span><br><span class="line">	 * when a task begins to run or is migrated, it is not running and</span><br><span class="line">	 * is completing a segment of non-busy time.</span><br><span class="line">	 */</span><br><span class="line">	/* (3.1.2) 任务被wakeup，之前的等待时间不计入统计 </span><br><span class="line">	    SCHED_ACCOUNT_WAIT_TIME用来控制ruannable的等待时间是否计入统计，默认是计入的</span><br><span class="line">	 */</span><br><span class="line">	if (event == TASK_WAKE || (!SCHED_ACCOUNT_WAIT_TIME &amp;&amp;</span><br><span class="line">			 (event == PICK_NEXT_TASK || event == TASK_MIGRATE)))</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">||→</span><br><span class="line"></span><br><span class="line">static void add_to_task_demand(struct rq *rq, struct task_struct *p,</span><br><span class="line">				u64 delta)</span><br><span class="line">&#123;</span><br><span class="line">    /* (3.4.1) 累加窗口的时间值 */</span><br><span class="line">	delta = scale_exec_time(delta, rq);</span><br><span class="line">	p-&gt;ravg.sum += delta;</span><br><span class="line">	if (unlikely(p-&gt;ravg.sum &gt; walt_ravg_window))</span><br><span class="line">		p-&gt;ravg.sum = walt_ravg_window;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline u64 scale_exec_time(u64 delta, struct rq *rq)</span><br><span class="line">&#123;</span><br><span class="line">	u32 freq;</span><br><span class="line"></span><br><span class="line">    /* curr_freq / max_possible_freq */</span><br><span class="line">	freq = cpu_cycles_to_freq(rq-&gt;cc.cycles, rq-&gt;cc.time);</span><br><span class="line">	delta = DIV64_U64_ROUNDUP(delta * freq, max_possible_freq);</span><br><span class="line">	</span><br><span class="line">	/* exec_scale_factor = cluster-&gt;efficiency / max_possible_efficiency */</span><br><span class="line">	delta *= rq-&gt;cluster-&gt;exec_scale_factor;</span><br><span class="line">	delta &gt;&gt;= 10;</span><br><span class="line"></span><br><span class="line">	return delta;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">||→</span><br><span class="line"></span><br><span class="line">static void update_history(struct rq *rq, struct task_struct *p,</span><br><span class="line">			 u32 runtime, int samples, int event)</span><br><span class="line">&#123;</span><br><span class="line">	u32 *hist = &amp;p-&gt;ravg.sum_history[0];</span><br><span class="line">	int ridx, widx;</span><br><span class="line">	u32 max = 0, avg, demand, pred_demand;</span><br><span class="line">	u64 sum = 0;</span><br><span class="line"></span><br><span class="line">    /* (3.4.2.1) 不活跃的进程不进行更新 */</span><br><span class="line">	/* Ignore windows where task had no activity */</span><br><span class="line">	if (!runtime || is_idle_task(p) || exiting_task(p) || !samples)</span><br><span class="line">		goto done;</span><br><span class="line"></span><br><span class="line">    /* (3.4.2.2) 把新窗口的runtime推送到history stack中 */</span><br><span class="line">	/* Push new &apos;runtime&apos; value onto stack */</span><br><span class="line">	widx = sched_ravg_hist_size - 1;</span><br><span class="line">	ridx = widx - samples;</span><br><span class="line">	for (; ridx &gt;= 0; --widx, --ridx) &#123;</span><br><span class="line">		hist[widx] = hist[ridx];</span><br><span class="line">		sum += hist[widx];</span><br><span class="line">		if (hist[widx] &gt; max)</span><br><span class="line">			max = hist[widx];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for (widx = 0; widx &lt; samples &amp;&amp; widx &lt; sched_ravg_hist_size; widx++) &#123;</span><br><span class="line">		hist[widx] = runtime;</span><br><span class="line">		sum += hist[widx];</span><br><span class="line">		if (hist[widx] &gt; max)</span><br><span class="line">			max = hist[widx];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	p-&gt;ravg.sum = 0;</span><br><span class="line"></span><br><span class="line">    /* (3.4.2.3) 根据sched_window_stats_policy策略(RECENT、MAX、AVG、MAX_RECENT_AVG)，</span><br><span class="line">        从sum_history[]中选择合适的值作为进程负载p-&gt;ravg.demand</span><br><span class="line">     */</span><br><span class="line">	if (sched_window_stats_policy == WINDOW_STATS_RECENT) &#123;</span><br><span class="line">		demand = runtime;</span><br><span class="line">	&#125; else if (sched_window_stats_policy == WINDOW_STATS_MAX) &#123;</span><br><span class="line">		demand = max;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		avg = div64_u64(sum, sched_ravg_hist_size);</span><br><span class="line">		if (sched_window_stats_policy == WINDOW_STATS_AVG)</span><br><span class="line">			demand = avg;</span><br><span class="line">		else</span><br><span class="line">			demand = max(avg, runtime);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	/* (3.4.2.4) 计算进程的预测负载 */</span><br><span class="line">	pred_demand = predict_and_update_buckets(rq, p, runtime);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * A throttled deadline sched class task gets dequeued without</span><br><span class="line">	 * changing p-&gt;on_rq. Since the dequeue decrements hmp stats</span><br><span class="line">	 * avoid decrementing it here again.</span><br><span class="line">	 */</span><br><span class="line">	/* (3.4.2.5) 更新进程负载(p-&gt;ravg.demand)到cpu负载(rq-&gt;hmp_stats.cumulative_runnable_avg)中 </span><br><span class="line">	    cfs中p-&gt;sched_class-&gt;fixup_hmp_sched_stats对应函数fixup_hmp_sched_stats_fair()</span><br><span class="line">	 */</span><br><span class="line">	if (task_on_rq_queued(p) &amp;&amp; (!task_has_dl_policy(p) ||</span><br><span class="line">						!p-&gt;dl.dl_throttled))</span><br><span class="line">		p-&gt;sched_class-&gt;fixup_hmp_sched_stats(rq, p, demand,</span><br><span class="line">						      pred_demand);</span><br><span class="line"></span><br><span class="line">	p-&gt;ravg.demand = demand;</span><br><span class="line">	p-&gt;ravg.pred_demand = pred_demand;</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">	trace_sched_update_history(rq, p, runtime, samples, event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|||→</span><br><span class="line"></span><br><span class="line">static inline u32 predict_and_update_buckets(struct rq *rq,</span><br><span class="line">			struct task_struct *p, u32 runtime) &#123;</span><br><span class="line"></span><br><span class="line">	int bidx;</span><br><span class="line">	u32 pred_demand;</span><br><span class="line"></span><br><span class="line">    /* (3.4.2.4.1) 把window负载转换成bucket index(最大10) */</span><br><span class="line">	bidx = busy_to_bucket(runtime);</span><br><span class="line">	</span><br><span class="line">	/* (3.4.2.4.2) 根据index，找到历史曾经达到过的更大值，取历史的值作为预测值 */</span><br><span class="line">	pred_demand = get_pred_busy(rq, p, bidx, runtime);</span><br><span class="line">	</span><br><span class="line">	/* (3.4.2.4.3) 对bucket[]中本次index权重进行增加，其他权重减少 */</span><br><span class="line">	bucket_increase(p-&gt;ravg.busy_buckets, bidx);</span><br><span class="line"></span><br><span class="line">	return pred_demand;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|||→</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">fixup_hmp_sched_stats_fair(struct rq *rq, struct task_struct *p,</span><br><span class="line">			   u32 new_task_load, u32 new_pred_demand)</span><br><span class="line">&#123;</span><br><span class="line">    /* (3.4.2.5.1) 计算task负载和预测的变化值delta */</span><br><span class="line">	s64 task_load_delta = (s64)new_task_load - task_load(p);</span><br><span class="line">	s64 pred_demand_delta = PRED_DEMAND_DELTA;</span><br><span class="line"></span><br><span class="line">    /* (3.4.2.5.2) 将进程级别的delta计入cpu级别的负载统计(rq-&gt;hmp_stats)中 */</span><br><span class="line">	fixup_cumulative_runnable_avg(&amp;rq-&gt;hmp_stats, p, task_load_delta,</span><br><span class="line">				      pred_demand_delta);</span><br><span class="line">				      </span><br><span class="line">    /* (3.4.2.5.3) 更新cpu级别big_task的数量 */</span><br><span class="line">	fixup_nr_big_tasks(&amp;rq-&gt;hmp_stats, p, task_load_delta);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline void</span><br><span class="line">fixup_cumulative_runnable_avg(struct hmp_sched_stats *stats,</span><br><span class="line">			      struct task_struct *p, s64 task_load_delta,</span><br><span class="line">			      s64 pred_demand_delta)</span><br><span class="line">&#123;</span><br><span class="line">	if (sched_disable_window_stats)</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	stats-&gt;cumulative_runnable_avg += task_load_delta;</span><br><span class="line">	BUG_ON((s64)stats-&gt;cumulative_runnable_avg &lt; 0);</span><br><span class="line"></span><br><span class="line">	stats-&gt;pred_demands_sum += pred_demand_delta;</span><br><span class="line">	BUG_ON((s64)stats-&gt;pred_demands_sum &lt; 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void fixup_nr_big_tasks(struct hmp_sched_stats *stats,</span><br><span class="line">				struct task_struct *p, s64 delta)</span><br><span class="line">&#123;</span><br><span class="line">	u64 new_task_load;</span><br><span class="line">	u64 old_task_load;</span><br><span class="line"></span><br><span class="line">	if (sched_disable_window_stats)</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">    /* task_load按照capacity反比放大，让所有cpu处在同一级别 */</span><br><span class="line">	old_task_load = scale_load_to_cpu(task_load(p), task_cpu(p));</span><br><span class="line">	new_task_load = scale_load_to_cpu(delta + task_load(p), task_cpu(p));</span><br><span class="line"></span><br><span class="line">    /* 如果进程负载 &gt; 最大负载 * 80% (sysctl_sched_upmigrate_pct)</span><br><span class="line">        该任务为big_task</span><br><span class="line">     */</span><br><span class="line">	if (__is_big_task(p, old_task_load) &amp;&amp; !__is_big_task(p, new_task_load))</span><br><span class="line">		stats-&gt;nr_big_tasks--;</span><br><span class="line">	else if (!__is_big_task(p, old_task_load) &amp;&amp;</span><br><span class="line">		 __is_big_task(p, new_task_load))</span><br><span class="line">		stats-&gt;nr_big_tasks++;</span><br><span class="line"></span><br><span class="line">	BUG_ON(stats-&gt;nr_big_tasks &lt; 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们再来详细看看cpu级别的busy time计算：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br></pre></td><td class="code"><pre><span class="line">static void update_cpu_busy_time(struct task_struct *p, struct rq *rq,</span><br><span class="line">				 int event, u64 wallclock, u64 irqtime)</span><br><span class="line">&#123;</span><br><span class="line">	int new_window, full_window = 0;</span><br><span class="line">	int p_is_curr_task = (p == rq-&gt;curr);</span><br><span class="line">	u64 mark_start = p-&gt;ravg.mark_start;</span><br><span class="line">	u64 window_start = rq-&gt;window_start;</span><br><span class="line">	u32 window_size = sched_ravg_window;</span><br><span class="line">	u64 delta;</span><br><span class="line">	u64 *curr_runnable_sum = &amp;rq-&gt;curr_runnable_sum;</span><br><span class="line">	u64 *prev_runnable_sum = &amp;rq-&gt;prev_runnable_sum;</span><br><span class="line">	u64 *nt_curr_runnable_sum = &amp;rq-&gt;nt_curr_runnable_sum;</span><br><span class="line">	u64 *nt_prev_runnable_sum = &amp;rq-&gt;nt_prev_runnable_sum;</span><br><span class="line">	bool new_task;</span><br><span class="line">	struct related_thread_group *grp;</span><br><span class="line">	int cpu = rq-&gt;cpu;</span><br><span class="line">	u32 old_curr_window = p-&gt;ravg.curr_window;</span><br><span class="line"></span><br><span class="line">	new_window = mark_start &lt; window_start;</span><br><span class="line">	if (new_window) &#123;</span><br><span class="line">		full_window = (window_start - mark_start) &gt;= window_size;</span><br><span class="line">		if (p-&gt;ravg.active_windows &lt; USHRT_MAX)</span><br><span class="line">			p-&gt;ravg.active_windows++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	new_task = is_new_task(p);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Handle per-task window rollover. We don&apos;t care about the idle</span><br><span class="line">	 * task or exiting tasks.</span><br><span class="line">	 */</span><br><span class="line">	/* (1) 如果有新window，滚动进程窗口：p-&gt;ravg.prev_window、p-&gt;ravg.curr_window */</span><br><span class="line">	if (!is_idle_task(p) &amp;&amp; !exiting_task(p)) &#123;</span><br><span class="line">		if (new_window)</span><br><span class="line">			rollover_task_window(p, full_window);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (2) 如果有新window且进程是rq的当前进程，</span><br><span class="line">        cpu级别的窗口滚动：rq-&gt;prev_runnable_sum、rq-&gt;curr_runnable_sum</span><br><span class="line">        cpu级别的进程统计窗口滚动：rq-&gt;top_tasks[prev_table]、rq-&gt;top_tasks[curr_table]</span><br><span class="line">     */</span><br><span class="line">	if (p_is_curr_task &amp;&amp; new_window) &#123;</span><br><span class="line">		rollover_cpu_window(rq, full_window);</span><br><span class="line">		rollover_top_tasks(rq, full_window);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (3) 判断哪些情况可以统计进cpu time */</span><br><span class="line">	if (!account_busy_for_cpu_time(rq, p, irqtime, event))</span><br><span class="line">		goto done;</span><br><span class="line"></span><br><span class="line">	grp = p-&gt;grp;</span><br><span class="line">	if (grp &amp;&amp; sched_freq_aggregate) &#123;</span><br><span class="line">		struct group_cpu_time *cpu_time = &amp;rq-&gt;grp_time;</span><br><span class="line"></span><br><span class="line">		curr_runnable_sum = &amp;cpu_time-&gt;curr_runnable_sum;</span><br><span class="line">		prev_runnable_sum = &amp;cpu_time-&gt;prev_runnable_sum;</span><br><span class="line"></span><br><span class="line">		nt_curr_runnable_sum = &amp;cpu_time-&gt;nt_curr_runnable_sum;</span><br><span class="line">		nt_prev_runnable_sum = &amp;cpu_time-&gt;nt_prev_runnable_sum;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (4) 如果时间没有达到新window，</span><br><span class="line">        在cpu级别的当前负载上累加：rq-&gt;curr_runnable_sum</span><br><span class="line">        在进程级别的基础上累加：p-&gt;ravg.curr_window</span><br><span class="line">     */</span><br><span class="line">	if (!new_window) &#123;</span><br><span class="line">		/*</span><br><span class="line">		 * account_busy_for_cpu_time() = 1 so busy time needs</span><br><span class="line">		 * to be accounted to the current window. No rollover</span><br><span class="line">		 * since we didn&apos;t start a new window. An example of this is</span><br><span class="line">		 * when a task starts execution and then sleeps within the</span><br><span class="line">		 * same window.</span><br><span class="line">		 */</span><br><span class="line"></span><br><span class="line">		if (!irqtime || !is_idle_task(p) || cpu_is_waiting_on_io(rq))</span><br><span class="line">			delta = wallclock - mark_start;</span><br><span class="line">		else</span><br><span class="line">			delta = irqtime;</span><br><span class="line">		delta = scale_exec_time(delta, rq);</span><br><span class="line">		*curr_runnable_sum += delta;</span><br><span class="line">		if (new_task)</span><br><span class="line">			*nt_curr_runnable_sum += delta;</span><br><span class="line"></span><br><span class="line">		if (!is_idle_task(p) &amp;&amp; !exiting_task(p)) &#123;</span><br><span class="line">			p-&gt;ravg.curr_window += delta;</span><br><span class="line">			p-&gt;ravg.curr_window_cpu[cpu] += delta;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		goto done;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (5) 如果时间达到新window，但是进程不是rq的当前进程</span><br><span class="line">        在进程级别的基础上累加：p-&gt;ravg.prev_window、p-&gt;ravg.curr_window</span><br><span class="line">        在cpu级别的当前负载上累加：rq-&gt;prev_runnable_sum、rq-&gt;curr_runnable_sum</span><br><span class="line">     */</span><br><span class="line">	if (!p_is_curr_task) &#123;</span><br><span class="line">		/*</span><br><span class="line">		 * account_busy_for_cpu_time() = 1 so busy time needs</span><br><span class="line">		 * to be accounted to the current window. A new window</span><br><span class="line">		 * has also started, but p is not the current task, so the</span><br><span class="line">		 * window is not rolled over - just split up and account</span><br><span class="line">		 * as necessary into curr and prev. The window is only</span><br><span class="line">		 * rolled over when a new window is processed for the current</span><br><span class="line">		 * task.</span><br><span class="line">		 *</span><br><span class="line">		 * Irqtime can&apos;t be accounted by a task that isn&apos;t the</span><br><span class="line">		 * currently running task.</span><br><span class="line">		 */</span><br><span class="line"></span><br><span class="line">		if (!full_window) &#123;</span><br><span class="line">			/*</span><br><span class="line">			 * A full window hasn&apos;t elapsed, account partial</span><br><span class="line">			 * contribution to previous completed window.</span><br><span class="line">			 */</span><br><span class="line">			delta = scale_exec_time(window_start - mark_start, rq);</span><br><span class="line">			if (!exiting_task(p)) &#123;</span><br><span class="line">				p-&gt;ravg.prev_window += delta;</span><br><span class="line">				p-&gt;ravg.prev_window_cpu[cpu] += delta;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			/*</span><br><span class="line">			 * Since at least one full window has elapsed,</span><br><span class="line">			 * the contribution to the previous window is the</span><br><span class="line">			 * full window (window_size).</span><br><span class="line">			 */</span><br><span class="line">			delta = scale_exec_time(window_size, rq);</span><br><span class="line">			if (!exiting_task(p)) &#123;</span><br><span class="line">				p-&gt;ravg.prev_window = delta;</span><br><span class="line">				p-&gt;ravg.prev_window_cpu[cpu] = delta;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		*prev_runnable_sum += delta;</span><br><span class="line">		if (new_task)</span><br><span class="line">			*nt_prev_runnable_sum += delta;</span><br><span class="line"></span><br><span class="line">		/* Account piece of busy time in the current window. */</span><br><span class="line">		delta = scale_exec_time(wallclock - window_start, rq);</span><br><span class="line">		*curr_runnable_sum += delta;</span><br><span class="line">		if (new_task)</span><br><span class="line">			*nt_curr_runnable_sum += delta;</span><br><span class="line"></span><br><span class="line">		if (!exiting_task(p)) &#123;</span><br><span class="line">			p-&gt;ravg.curr_window = delta;</span><br><span class="line">			p-&gt;ravg.curr_window_cpu[cpu] = delta;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		goto done;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (6) 如果时间达到新window，且进程是rq的当前进程</span><br><span class="line">        在进程级别的基础上累加：p-&gt;ravg.prev_window、p-&gt;ravg.curr_window</span><br><span class="line">        在cpu级别的当前负载上累加：rq-&gt;prev_runnable_sum、rq-&gt;curr_runnable_sum</span><br><span class="line">     */</span><br><span class="line">	if (!irqtime || !is_idle_task(p) || cpu_is_waiting_on_io(rq)) &#123;</span><br><span class="line">		/*</span><br><span class="line">		 * account_busy_for_cpu_time() = 1 so busy time needs</span><br><span class="line">		 * to be accounted to the current window. A new window</span><br><span class="line">		 * has started and p is the current task so rollover is</span><br><span class="line">		 * needed. If any of these three above conditions are true</span><br><span class="line">		 * then this busy time can&apos;t be accounted as irqtime.</span><br><span class="line">		 *</span><br><span class="line">		 * Busy time for the idle task or exiting tasks need not</span><br><span class="line">		 * be accounted.</span><br><span class="line">		 *</span><br><span class="line">		 * An example of this would be a task that starts execution</span><br><span class="line">		 * and then sleeps once a new window has begun.</span><br><span class="line">		 */</span><br><span class="line"></span><br><span class="line">		if (!full_window) &#123;</span><br><span class="line">			/*</span><br><span class="line">			 * A full window hasn&apos;t elapsed, account partial</span><br><span class="line">			 * contribution to previous completed window.</span><br><span class="line">			 */</span><br><span class="line">			delta = scale_exec_time(window_start - mark_start, rq);</span><br><span class="line">			if (!is_idle_task(p) &amp;&amp; !exiting_task(p)) &#123;</span><br><span class="line">				p-&gt;ravg.prev_window += delta;</span><br><span class="line">				p-&gt;ravg.prev_window_cpu[cpu] += delta;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			/*</span><br><span class="line">			 * Since at least one full window has elapsed,</span><br><span class="line">			 * the contribution to the previous window is the</span><br><span class="line">			 * full window (window_size).</span><br><span class="line">			 */</span><br><span class="line">			delta = scale_exec_time(window_size, rq);</span><br><span class="line">			if (!is_idle_task(p) &amp;&amp; !exiting_task(p)) &#123;</span><br><span class="line">				p-&gt;ravg.prev_window = delta;</span><br><span class="line">				p-&gt;ravg.prev_window_cpu[cpu] = delta;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		/*</span><br><span class="line">		 * Rollover is done here by overwriting the values in</span><br><span class="line">		 * prev_runnable_sum and curr_runnable_sum.</span><br><span class="line">		 */</span><br><span class="line">		*prev_runnable_sum += delta;</span><br><span class="line">		if (new_task)</span><br><span class="line">			*nt_prev_runnable_sum += delta;</span><br><span class="line"></span><br><span class="line">		/* Account piece of busy time in the current window. */</span><br><span class="line">		delta = scale_exec_time(wallclock - window_start, rq);</span><br><span class="line">		*curr_runnable_sum += delta;</span><br><span class="line">		if (new_task)</span><br><span class="line">			*nt_curr_runnable_sum += delta;</span><br><span class="line"></span><br><span class="line">		if (!is_idle_task(p) &amp;&amp; !exiting_task(p)) &#123;</span><br><span class="line">			p-&gt;ravg.curr_window = delta;</span><br><span class="line">			p-&gt;ravg.curr_window_cpu[cpu] = delta;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		goto done;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (irqtime) &#123;</span><br><span class="line">		/*</span><br><span class="line">		 * account_busy_for_cpu_time() = 1 so busy time needs</span><br><span class="line">		 * to be accounted to the current window. A new window</span><br><span class="line">		 * has started and p is the current task so rollover is</span><br><span class="line">		 * needed. The current task must be the idle task because</span><br><span class="line">		 * irqtime is not accounted for any other task.</span><br><span class="line">		 *</span><br><span class="line">		 * Irqtime will be accounted each time we process IRQ activity</span><br><span class="line">		 * after a period of idleness, so we know the IRQ busy time</span><br><span class="line">		 * started at wallclock - irqtime.</span><br><span class="line">		 */</span><br><span class="line"></span><br><span class="line">		BUG_ON(!is_idle_task(p));</span><br><span class="line">		mark_start = wallclock - irqtime;</span><br><span class="line"></span><br><span class="line">		/*</span><br><span class="line">		 * Roll window over. If IRQ busy time was just in the current</span><br><span class="line">		 * window then that is all that need be accounted.</span><br><span class="line">		 */</span><br><span class="line">		if (mark_start &gt; window_start) &#123;</span><br><span class="line">			*curr_runnable_sum = scale_exec_time(irqtime, rq);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		/*</span><br><span class="line">		 * The IRQ busy time spanned multiple windows. Process the</span><br><span class="line">		 * busy time preceding the current window start first.</span><br><span class="line">		 */</span><br><span class="line">		delta = window_start - mark_start;</span><br><span class="line">		if (delta &gt; window_size)</span><br><span class="line">			delta = window_size;</span><br><span class="line">		delta = scale_exec_time(delta, rq);</span><br><span class="line">		*prev_runnable_sum += delta;</span><br><span class="line"></span><br><span class="line">		/* Process the remaining IRQ busy time in the current window. */</span><br><span class="line">		delta = wallclock - window_start;</span><br><span class="line">		rq-&gt;curr_runnable_sum = scale_exec_time(delta, rq);</span><br><span class="line"></span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">    /* (7) 更新cpu上的top task */</span><br><span class="line">	if (!is_idle_task(p) &amp;&amp; !exiting_task(p))</span><br><span class="line">		update_top_tasks(p, rq, old_curr_window,</span><br><span class="line">					new_window, full_window);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">static void update_top_tasks(struct task_struct *p, struct rq *rq,</span><br><span class="line">		u32 old_curr_window, int new_window, bool full_window)</span><br><span class="line">&#123;</span><br><span class="line">	u8 curr = rq-&gt;curr_table;</span><br><span class="line">	u8 prev = 1 - curr;</span><br><span class="line">	u8 *curr_table = rq-&gt;top_tasks[curr];</span><br><span class="line">	u8 *prev_table = rq-&gt;top_tasks[prev];</span><br><span class="line">	int old_index, new_index, update_index;</span><br><span class="line">	u32 curr_window = p-&gt;ravg.curr_window;</span><br><span class="line">	u32 prev_window = p-&gt;ravg.prev_window;</span><br><span class="line">	bool zero_index_update;</span><br><span class="line"></span><br><span class="line">	if (old_curr_window == curr_window &amp;&amp; !new_window)</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">    /* (1) 把就进程p的&quot;当前window负载&quot;、&quot;旧的当前window负载&quot;转换成index(NUM_LOAD_INDICES=1000) */</span><br><span class="line">	old_index = load_to_index(old_curr_window);</span><br><span class="line">	new_index = load_to_index(curr_window);</span><br><span class="line"></span><br><span class="line">    /* (2) 如果没有新window </span><br><span class="line">        更新当前top表rq-&gt;top_tasks[curr][]中新旧index的计数</span><br><span class="line">        根据index的计数是否为0，更新rq-&gt;top_tasks_bitmap[curr] bitmap中对应index的值</span><br><span class="line">     */</span><br><span class="line">	if (!new_window) &#123;</span><br><span class="line">		zero_index_update = !old_curr_window &amp;&amp; curr_window;</span><br><span class="line">		if (old_index != new_index || zero_index_update) &#123;</span><br><span class="line">			if (old_curr_window)</span><br><span class="line">				curr_table[old_index] -= 1;</span><br><span class="line">			if (curr_window)</span><br><span class="line">				curr_table[new_index] += 1;</span><br><span class="line">			if (new_index &gt; rq-&gt;curr_top)</span><br><span class="line">				rq-&gt;curr_top = new_index;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (!curr_table[old_index])</span><br><span class="line">			__clear_bit(NUM_LOAD_INDICES - old_index - 1,</span><br><span class="line">				rq-&gt;top_tasks_bitmap[curr]);</span><br><span class="line"></span><br><span class="line">		if (curr_table[new_index] == 1)</span><br><span class="line">			__set_bit(NUM_LOAD_INDICES - new_index - 1,</span><br><span class="line">				rq-&gt;top_tasks_bitmap[curr]);</span><br><span class="line"></span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * The window has rolled over for this task. By the time we get</span><br><span class="line">	 * here, curr/prev swaps would has already occurred. So we need</span><br><span class="line">	 * to use prev_window for the new index.</span><br><span class="line">	 */</span><br><span class="line">	update_index = load_to_index(prev_window);</span><br><span class="line"></span><br><span class="line">	if (full_window) &#123;</span><br><span class="line">		/*</span><br><span class="line">		 * Two cases here. Either &apos;p&apos; ran for the entire window or</span><br><span class="line">		 * it didn&apos;t run at all. In either case there is no entry</span><br><span class="line">		 * in the prev table. If &apos;p&apos; ran the entire window, we just</span><br><span class="line">		 * need to create a new entry in the prev table. In this case</span><br><span class="line">		 * update_index will be correspond to sched_ravg_window</span><br><span class="line">		 * so we can unconditionally update the top index.</span><br><span class="line">		 */</span><br><span class="line">		if (prev_window) &#123;</span><br><span class="line">			prev_table[update_index] += 1;</span><br><span class="line">			rq-&gt;prev_top = update_index;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (prev_table[update_index] == 1)</span><br><span class="line">			__set_bit(NUM_LOAD_INDICES - update_index - 1,</span><br><span class="line">				rq-&gt;top_tasks_bitmap[prev]);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		zero_index_update = !old_curr_window &amp;&amp; prev_window;</span><br><span class="line">		if (old_index != update_index || zero_index_update) &#123;</span><br><span class="line">			if (old_curr_window)</span><br><span class="line">				prev_table[old_index] -= 1;</span><br><span class="line"></span><br><span class="line">			prev_table[update_index] += 1;</span><br><span class="line"></span><br><span class="line">			if (update_index &gt; rq-&gt;prev_top)</span><br><span class="line">				rq-&gt;prev_top = update_index;</span><br><span class="line"></span><br><span class="line">			if (!prev_table[old_index])</span><br><span class="line">				__clear_bit(NUM_LOAD_INDICES - old_index - 1,</span><br><span class="line">						rq-&gt;top_tasks_bitmap[prev]);</span><br><span class="line"></span><br><span class="line">			if (prev_table[update_index] == 1)</span><br><span class="line">				__set_bit(NUM_LOAD_INDICES - update_index - 1,</span><br><span class="line">						rq-&gt;top_tasks_bitmap[prev]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (curr_window) &#123;</span><br><span class="line">		curr_table[new_index] += 1;</span><br><span class="line"></span><br><span class="line">		if (new_index &gt; rq-&gt;curr_top)</span><br><span class="line">			rq-&gt;curr_top = new_index;</span><br><span class="line"></span><br><span class="line">		if (curr_table[new_index] == 1)</span><br><span class="line">			__set_bit(NUM_LOAD_INDICES - new_index - 1,</span><br><span class="line">				rq-&gt;top_tasks_bitmap[curr]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-3-2、基于WALT的负载均衡"><a href="#5-3-2、基于WALT的负载均衡" class="headerlink" title="5.3.2、基于WALT的负载均衡"></a>5.3.2、基于WALT的负载均衡</h3><h4 id="5-3-2-1、load-balance"><a href="#5-3-2-1、load-balance" class="headerlink" title="5.3.2.1、load_balance()"></a>5.3.2.1、load_balance()</h4><p>其他部分和主干内核算法一致，这里只标识出qualcom的HMP算法特有的部分。在负载均衡部分，walt用来找出cpu；但是在负载迁移时，计算负载还是使用pelt？</p>
<ul>
<li>在find_busiest_queue()中：原本是找出cfs_rq-&gt;runnable_load_avg * capacity负载最大的cpu，qualcom HMP改为找出walt runnable负载(rq-&gt;hmp_stats.cumulative_runnable_avg)最重的cpu。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">run_rebalance_domains() -&gt; rebalance_domains() -&gt; load_balance() -&gt; find_busiest_queue() -&gt; find_busiest_queue_hmp()</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static struct rq *find_busiest_queue_hmp(struct lb_env *env,</span><br><span class="line">				     struct sched_group *group)</span><br><span class="line">&#123;</span><br><span class="line">	struct rq *busiest = NULL, *busiest_big = NULL;</span><br><span class="line">	u64 max_runnable_avg = 0, max_runnable_avg_big = 0;</span><br><span class="line">	int max_nr_big = 0, nr_big;</span><br><span class="line">	bool find_big = !!(env-&gt;flags &amp; LBF_BIG_TASK_ACTIVE_BALANCE);</span><br><span class="line">	int i;</span><br><span class="line">	cpumask_t cpus;</span><br><span class="line"></span><br><span class="line">	cpumask_andnot(&amp;cpus, sched_group_cpus(group), cpu_isolated_mask);</span><br><span class="line"></span><br><span class="line">    /* (1) 遍历sg中的cpu */</span><br><span class="line">	for_each_cpu(i, &amp;cpus) &#123;</span><br><span class="line">		struct rq *rq = cpu_rq(i);</span><br><span class="line">		u64 cumulative_runnable_avg =</span><br><span class="line">				rq-&gt;hmp_stats.cumulative_runnable_avg;</span><br><span class="line"></span><br><span class="line">		if (!cpumask_test_cpu(i, env-&gt;cpus))</span><br><span class="line">			continue;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        /* (2) 考虑big_task，找出big_task最重的cpu */</span><br><span class="line">		if (find_big) &#123;</span><br><span class="line">			nr_big = nr_big_tasks(rq);</span><br><span class="line">			if (nr_big &gt; max_nr_big ||</span><br><span class="line">			    (nr_big &gt; 0 &amp;&amp; nr_big == max_nr_big &amp;&amp;</span><br><span class="line">			     cumulative_runnable_avg &gt; max_runnable_avg_big)) &#123;</span><br><span class="line">				max_runnable_avg_big = cumulative_runnable_avg;</span><br><span class="line">				busiest_big = rq;</span><br><span class="line">				max_nr_big = nr_big;</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        /* (3) 找出walt runnable负载(rq-&gt;hmp_stats.cumulative_runnable_avg)最重的cpu */</span><br><span class="line">		if (cumulative_runnable_avg &gt; max_runnable_avg) &#123;</span><br><span class="line">			max_runnable_avg = cumulative_runnable_avg;</span><br><span class="line">			busiest = rq;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (busiest_big)</span><br><span class="line">		return busiest_big;</span><br><span class="line"></span><br><span class="line">	env-&gt;flags &amp;= ~LBF_BIG_TASK_ACTIVE_BALANCE;</span><br><span class="line">	return busiest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-3-2-2、nohz-idle-balance"><a href="#5-3-2-2、nohz-idle-balance" class="headerlink" title="5.3.2.2、nohz_idle_balance()"></a>5.3.2.2、nohz_idle_balance()</h4><ul>
<li>_nohz_kick_needed()：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">scheduler_tick() -&gt; trigger_load_balance() -&gt; nohz_kick_needed() -&gt; _nohz_kick_needed() -&gt; nohz_kick_needed_hmp()</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static inline int _nohz_kick_needed_hmp(struct rq *rq, int cpu, int *type)</span><br><span class="line">&#123;</span><br><span class="line">	struct sched_domain *sd;</span><br><span class="line">	int i;</span><br><span class="line"></span><br><span class="line">	if (rq-&gt;nr_running &lt; 2)</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">    /* (1) 如果是SCHED_BOOST_ON_ALL，返回true */</span><br><span class="line">	if (!sysctl_sched_restrict_cluster_spill ||</span><br><span class="line">			sched_boost_policy() == SCHED_BOOST_ON_ALL)</span><br><span class="line">		return 1;</span><br><span class="line"></span><br><span class="line">    /* (2) 如果当前cpu是max cpu，返回true */</span><br><span class="line">	if (cpu_max_power_cost(cpu) == max_power_cost)</span><br><span class="line">		return 1;</span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	sd = rcu_dereference_check_sched_domain(rq-&gt;sd);</span><br><span class="line">	if (!sd) &#123;</span><br><span class="line">		rcu_read_unlock();</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for_each_cpu(i, sched_domain_span(sd)) &#123;</span><br><span class="line">		if (cpu_load(i) &lt; sched_spill_load &amp;&amp;</span><br><span class="line">				cpu_rq(i)-&gt;nr_running &lt;</span><br><span class="line">				sysctl_sched_spill_nr_run) &#123;</span><br><span class="line">			/* Change the kick type to limit to CPUs that</span><br><span class="line">			 * are of equal or lower capacity.</span><br><span class="line">			 */</span><br><span class="line">			*type = NOHZ_KICK_RESTRICT;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>find_new_hmp_ilb()：原本是找出nohz.idle_cpus_mask中的第一个cpu作为ilb cpu，qualcom HMP改为尝试在nohz.idle_cpus_mask中找到一个max power小于当前cpu的作为ilb cpu。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">scheduler_tick() -&gt; trigger_load_balance() -&gt; nohz_balancer_kick() -&gt; find_new_ilb()</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static inline int find_new_hmp_ilb(int type)</span><br><span class="line">&#123;</span><br><span class="line">	int call_cpu = raw_smp_processor_id();</span><br><span class="line">	struct sched_domain *sd;</span><br><span class="line">	int ilb;</span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line"></span><br><span class="line">	/* Pick an idle cpu &quot;closest&quot; to call_cpu */</span><br><span class="line">	for_each_domain(call_cpu, sd) &#123;</span><br><span class="line">		for_each_cpu_and(ilb, nohz.idle_cpus_mask,</span><br><span class="line">						sched_domain_span(sd)) &#123;</span><br><span class="line">		    </span><br><span class="line">		    /* (1) 尝试找到一个max power小于当前power的cpu作为ilb cpu */</span><br><span class="line">			if (idle_cpu(ilb) &amp;&amp; (type != NOHZ_KICK_RESTRICT ||</span><br><span class="line">					cpu_max_power_cost(ilb) &lt;=</span><br><span class="line">					cpu_max_power_cost(call_cpu))) &#123;</span><br><span class="line">				rcu_read_unlock();</span><br><span class="line">				reset_balance_interval(ilb);</span><br><span class="line">				return ilb;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	return nr_cpu_ids;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-3-2-3、select-task-rq-fair"><a href="#5-3-2-3、select-task-rq-fair" class="headerlink" title="5.3.2.3、select_task_rq_fair()"></a>5.3.2.3、select_task_rq_fair()</h4><ul>
<li>select_task_rq_fair()：使用qualcom自己的算法，综合capacity、power、idle给出一个best cpu。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line">select_task_rq_fair() -&gt; select_best_cpu()</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">/* return cheapest cpu that can fit this task */</span><br><span class="line">static int select_best_cpu(struct task_struct *p, int target, int reason,</span><br><span class="line">			   int sync)</span><br><span class="line">&#123;</span><br><span class="line">	struct sched_cluster *cluster, *pref_cluster = NULL;</span><br><span class="line">	struct cluster_cpu_stats stats;</span><br><span class="line">	struct related_thread_group *grp;</span><br><span class="line">	unsigned int sbc_flag = 0;</span><br><span class="line">	int cpu = raw_smp_processor_id();</span><br><span class="line">	bool special;</span><br><span class="line"></span><br><span class="line">	struct cpu_select_env env = &#123;</span><br><span class="line">		.p			= p,</span><br><span class="line">		.reason			= reason,</span><br><span class="line">		.need_idle		= wake_to_idle(p),</span><br><span class="line">		.need_waker_cluster	= 0,</span><br><span class="line">		.sync			= sync,</span><br><span class="line">		.prev_cpu		= target,</span><br><span class="line">		.rtg			= NULL,</span><br><span class="line">		.sbc_best_flag		= 0,</span><br><span class="line">		.sbc_best_cluster_flag	= 0,</span><br><span class="line">		.pack_task              = false,</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	env.boost_policy = task_sched_boost(p) ?</span><br><span class="line">			sched_boost_policy() : SCHED_BOOST_NONE;</span><br><span class="line"></span><br><span class="line">	bitmap_copy(env.candidate_list, all_cluster_ids, NR_CPUS);</span><br><span class="line">	bitmap_zero(env.backup_list, NR_CPUS);</span><br><span class="line"></span><br><span class="line">	cpumask_and(&amp;env.search_cpus, tsk_cpus_allowed(p), cpu_active_mask);</span><br><span class="line">	cpumask_andnot(&amp;env.search_cpus, &amp;env.search_cpus, cpu_isolated_mask);</span><br><span class="line"></span><br><span class="line">	init_cluster_cpu_stats(&amp;stats);</span><br><span class="line">	special = env_has_special_flags(&amp;env);</span><br><span class="line"></span><br><span class="line">	grp = task_related_thread_group(p);</span><br><span class="line"></span><br><span class="line">	if (grp &amp;&amp; grp-&gt;preferred_cluster) &#123;</span><br><span class="line">		pref_cluster = grp-&gt;preferred_cluster;</span><br><span class="line">		if (!cluster_allowed(&amp;env, pref_cluster))</span><br><span class="line">			clear_bit(pref_cluster-&gt;id, env.candidate_list);</span><br><span class="line">		else</span><br><span class="line">			env.rtg = grp;</span><br><span class="line">	&#125; else if (!special) &#123;</span><br><span class="line">		cluster = cpu_rq(cpu)-&gt;cluster;</span><br><span class="line">		if (wake_to_waker_cluster(&amp;env)) &#123;</span><br><span class="line">			if (bias_to_waker_cpu(&amp;env, cpu)) &#123;</span><br><span class="line">				target = cpu;</span><br><span class="line">				sbc_flag = SBC_FLAG_WAKER_CLUSTER |</span><br><span class="line">					   SBC_FLAG_WAKER_CPU;</span><br><span class="line">				goto out;</span><br><span class="line">			&#125; else if (cluster_allowed(&amp;env, cluster)) &#123;</span><br><span class="line">				env.need_waker_cluster = 1;</span><br><span class="line">				bitmap_zero(env.candidate_list, NR_CPUS);</span><br><span class="line">				__set_bit(cluster-&gt;id, env.candidate_list);</span><br><span class="line">				env.sbc_best_cluster_flag =</span><br><span class="line">							SBC_FLAG_WAKER_CLUSTER;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; else if (bias_to_prev_cpu(&amp;env, &amp;stats)) &#123;</span><br><span class="line">			sbc_flag = SBC_FLAG_PREV_CPU;</span><br><span class="line">			goto out;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (!special &amp;&amp; is_short_burst_task(p)) &#123;</span><br><span class="line">		env.pack_task = true;</span><br><span class="line">		sbc_flag = SBC_FLAG_PACK_TASK;</span><br><span class="line">	&#125;</span><br><span class="line">retry:</span><br><span class="line"></span><br><span class="line">    /* (1) 从低到高找到一个power最低，且capacity能满足task_load的cluster */</span><br><span class="line">	cluster = select_least_power_cluster(&amp;env);</span><br><span class="line"></span><br><span class="line">	if (!cluster)</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * &apos;cluster&apos; now points to the minimum power cluster which can satisfy</span><br><span class="line">	 * task&apos;s perf goals. Walk down the cluster list starting with that</span><br><span class="line">	 * cluster. For non-small tasks, skip clusters that don&apos;t have</span><br><span class="line">	 * mostly_idle/idle cpus</span><br><span class="line">	 */</span><br><span class="line"></span><br><span class="line">	do &#123;</span><br><span class="line">	    /* (2) 全方位统计：capacity spare、cost、idle */</span><br><span class="line">		find_best_cpu_in_cluster(cluster, &amp;env, &amp;stats);</span><br><span class="line"></span><br><span class="line">	&#125; while ((cluster = next_best_cluster(cluster, &amp;env, &amp;stats)));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /* (3) 从idle角度给出best cpu */</span><br><span class="line">	if (env.need_idle) &#123;</span><br><span class="line">		if (stats.best_idle_cpu &gt;= 0) &#123;</span><br><span class="line">			target = stats.best_idle_cpu;</span><br><span class="line">			sbc_flag |= SBC_FLAG_IDLE_CSTATE;</span><br><span class="line">		&#125; else if (stats.least_loaded_cpu &gt;= 0) &#123;</span><br><span class="line">			target = stats.least_loaded_cpu;</span><br><span class="line">			sbc_flag |= SBC_FLAG_IDLE_LEAST_LOADED;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	/* (4) 从综合角度给出best cpu */</span><br><span class="line">	&#125; else if (stats.best_cpu &gt;= 0) &#123;</span><br><span class="line">		if (stats.best_sibling_cpu &gt;= 0 &amp;&amp;</span><br><span class="line">				stats.best_cpu != task_cpu(p) &amp;&amp;</span><br><span class="line">				stats.min_cost == stats.best_sibling_cpu_cost) &#123;</span><br><span class="line">			stats.best_cpu = stats.best_sibling_cpu;</span><br><span class="line">			sbc_flag |= SBC_FLAG_BEST_SIBLING;</span><br><span class="line">		&#125;</span><br><span class="line">		sbc_flag |= env.sbc_best_flag;</span><br><span class="line">		target = stats.best_cpu;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		if (env.rtg &amp;&amp; env.boost_policy == SCHED_BOOST_NONE) &#123;</span><br><span class="line">			env.rtg = NULL;</span><br><span class="line">			goto retry;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		/*</span><br><span class="line">		 * With boost_policy == SCHED_BOOST_ON_BIG, we reach here with</span><br><span class="line">		 * backup_list = little cluster, candidate_list = none and</span><br><span class="line">		 * stats-&gt;best_capacity_cpu points the best spare capacity</span><br><span class="line">		 * CPU among the CPUs in the big cluster.</span><br><span class="line">		 */</span><br><span class="line">		if (env.boost_policy == SCHED_BOOST_ON_BIG &amp;&amp;</span><br><span class="line">		    stats.best_capacity_cpu &gt;= 0)</span><br><span class="line">			sbc_flag |= SBC_FLAG_BOOST_CLUSTER;</span><br><span class="line">		else</span><br><span class="line">			find_backup_cluster(&amp;env, &amp;stats);</span><br><span class="line"></span><br><span class="line">		if (stats.best_capacity_cpu &gt;= 0) &#123;</span><br><span class="line">			target = stats.best_capacity_cpu;</span><br><span class="line">			sbc_flag |= SBC_FLAG_BEST_CAP_CPU;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	p-&gt;last_cpu_selected_ts = sched_ktime_clock();</span><br><span class="line">out:</span><br><span class="line">	sbc_flag |= env.sbc_best_cluster_flag;</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	trace_sched_task_load(p, sched_boost_policy() &amp;&amp; task_sched_boost(p),</span><br><span class="line">		env.reason, env.sync, env.need_idle, sbc_flag, target);</span><br><span class="line">	return target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-3-2-4、Interaction-Governor-amp-sched-load"><a href="#5-3-2-4、Interaction-Governor-amp-sched-load" class="headerlink" title="5.3.2.4、Interaction Governor &amp; sched_load"></a>5.3.2.4、Interaction Governor &amp; sched_load</h4><p>qualcom对interactive governor进行了改造，打造成了可以使用sched_load的interactive governor。</p>
<p><img src="/images/scheduler/schedule_walt_qualcom_interactive.png" alt="schedule_walt_qualcom_interactive"></p>
<ul>
<li>1、interactive governor注册回调函数，接收sched_load变化事件；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">static ssize_t store_use_sched_load(</span><br><span class="line">			struct cpufreq_interactive_tunables *tunables,</span><br><span class="line">			const char *buf, size_t count)</span><br><span class="line">&#123;</span><br><span class="line">	int ret;</span><br><span class="line">	unsigned long val;</span><br><span class="line"></span><br><span class="line">	ret = kstrtoul(buf, 0, &amp;val);</span><br><span class="line">	if (ret &lt; 0)</span><br><span class="line">		return ret;</span><br><span class="line"></span><br><span class="line">	if (tunables-&gt;use_sched_load == (bool) val)</span><br><span class="line">		return count;</span><br><span class="line"></span><br><span class="line">	tunables-&gt;use_sched_load = val;</span><br><span class="line"></span><br><span class="line">	if (val)</span><br><span class="line">		ret = cpufreq_interactive_enable_sched_input(tunables);</span><br><span class="line">	else</span><br><span class="line">		ret = cpufreq_interactive_disable_sched_input(tunables);</span><br><span class="line"></span><br><span class="line">	if (ret) &#123;</span><br><span class="line">		tunables-&gt;use_sched_load = !val;</span><br><span class="line">		return ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">static int cpufreq_interactive_enable_sched_input(</span><br><span class="line">			struct cpufreq_interactive_tunables *tunables)</span><br><span class="line">&#123;</span><br><span class="line">	int rc = 0, j;</span><br><span class="line">	struct cpufreq_interactive_tunables *t;</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;sched_lock);</span><br><span class="line"></span><br><span class="line">	set_window_count++;</span><br><span class="line">	if (set_window_count &gt; 1) &#123;</span><br><span class="line">		for_each_possible_cpu(j) &#123;</span><br><span class="line">			if (!per_cpu(polinfo, j))</span><br><span class="line">				continue;</span><br><span class="line">			t = per_cpu(polinfo, j)-&gt;cached_tunables;</span><br><span class="line">			if (t &amp;&amp; t-&gt;use_sched_load) &#123;</span><br><span class="line">				tunables-&gt;timer_rate = t-&gt;timer_rate;</span><br><span class="line">				tunables-&gt;io_is_busy = t-&gt;io_is_busy;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">	    /* (1) 设置walt窗口大小 */</span><br><span class="line">		rc = set_window_helper(tunables);</span><br><span class="line">		if (rc) &#123;</span><br><span class="line">			pr_err(&quot;%s: Failed to set sched window\n&quot;, __func__);</span><br><span class="line">			set_window_count--;</span><br><span class="line">			goto out;</span><br><span class="line">		&#125;</span><br><span class="line">		sched_set_io_is_busy(tunables-&gt;io_is_busy);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (!tunables-&gt;use_migration_notif)</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">	migration_register_count++;</span><br><span class="line">	if (migration_register_count &gt; 1)</span><br><span class="line">		goto out;</span><br><span class="line">	else</span><br><span class="line">	    /* (2) 注册sched_load变化的回调函数 */</span><br><span class="line">		atomic_notifier_chain_register(&amp;load_alert_notifier_head,</span><br><span class="line">						&amp;load_notifier_block);</span><br><span class="line">out:</span><br><span class="line">	mutex_unlock(&amp;sched_lock);</span><br><span class="line">	return rc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">||→</span><br><span class="line"></span><br><span class="line">static inline int set_window_helper(</span><br><span class="line">			struct cpufreq_interactive_tunables *tunables)</span><br><span class="line">&#123;</span><br><span class="line">    /* 设置默认窗口size为DEFAULT_TIMER_RATE(20ms) */</span><br><span class="line">	return sched_set_window(round_to_nw_start(get_jiffies_64(), tunables),</span><br><span class="line">			 usecs_to_jiffies(tunables-&gt;timer_rate));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static struct notifier_block load_notifier_block = &#123;</span><br><span class="line">	.notifier_call = load_change_callback,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>2、sched_load的变化通过回调函数通知给Interaction Governor；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">check_for_freq_change（） -&gt; load_alert_notifier_head -&gt; load_change_callback()</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static int load_change_callback(struct notifier_block *nb, unsigned long val,</span><br><span class="line">				void *data)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned long cpu = (unsigned long) data;</span><br><span class="line">	struct cpufreq_interactive_policyinfo *ppol = per_cpu(polinfo, cpu);</span><br><span class="line">	struct cpufreq_interactive_tunables *tunables;</span><br><span class="line">	unsigned long flags;</span><br><span class="line"></span><br><span class="line">	if (!ppol || ppol-&gt;reject_notification)</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">	if (!down_read_trylock(&amp;ppol-&gt;enable_sem))</span><br><span class="line">		return 0;</span><br><span class="line">	if (!ppol-&gt;governor_enabled)</span><br><span class="line">		goto exit;</span><br><span class="line"></span><br><span class="line">	tunables = ppol-&gt;policy-&gt;governor_data;</span><br><span class="line">	if (!tunables-&gt;use_sched_load || !tunables-&gt;use_migration_notif)</span><br><span class="line">		goto exit;</span><br><span class="line"></span><br><span class="line">	spin_lock_irqsave(&amp;ppol-&gt;target_freq_lock, flags);</span><br><span class="line">	ppol-&gt;notif_pending = true;</span><br><span class="line">	ppol-&gt;notif_cpu = cpu;</span><br><span class="line">	spin_unlock_irqrestore(&amp;ppol-&gt;target_freq_lock, flags);</span><br><span class="line"></span><br><span class="line">	if (!hrtimer_is_queued(&amp;ppol-&gt;notif_timer))</span><br><span class="line">		hrtimer_start(&amp;ppol-&gt;notif_timer, ms_to_ktime(1),</span><br><span class="line">			      HRTIMER_MODE_REL);</span><br><span class="line">exit:</span><br><span class="line">	up_read(&amp;ppol-&gt;enable_sem);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>3、除了事件通知，interactive governor还会在20ms timer中轮询sched_load的变化来决定是否需要调频。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br></pre></td><td class="code"><pre><span class="line">static void cpufreq_interactive_timer(unsigned long data)</span><br><span class="line">&#123;</span><br><span class="line">	s64 now;</span><br><span class="line">	unsigned int delta_time;</span><br><span class="line">	u64 cputime_speedadj;</span><br><span class="line">	int cpu_load;</span><br><span class="line">	int pol_load = 0;</span><br><span class="line">	struct cpufreq_interactive_policyinfo *ppol = per_cpu(polinfo, data);</span><br><span class="line">	struct cpufreq_interactive_tunables *tunables =</span><br><span class="line">		ppol-&gt;policy-&gt;governor_data;</span><br><span class="line">	struct sched_load *sl = ppol-&gt;sl;</span><br><span class="line">	struct cpufreq_interactive_cpuinfo *pcpu;</span><br><span class="line">	unsigned int new_freq;</span><br><span class="line">	unsigned int prev_laf = 0, t_prevlaf;</span><br><span class="line">	unsigned int pred_laf = 0, t_predlaf = 0;</span><br><span class="line">	unsigned int prev_chfreq, pred_chfreq, chosen_freq;</span><br><span class="line">	unsigned int index;</span><br><span class="line">	unsigned long flags;</span><br><span class="line">	unsigned long max_cpu;</span><br><span class="line">	int cpu, i;</span><br><span class="line">	int new_load_pct = 0;</span><br><span class="line">	int prev_l, pred_l = 0;</span><br><span class="line">	struct cpufreq_govinfo govinfo;</span><br><span class="line">	bool skip_hispeed_logic, skip_min_sample_time;</span><br><span class="line">	bool jump_to_max_no_ts = false;</span><br><span class="line">	bool jump_to_max = false;</span><br><span class="line">	bool start_hyst = true;</span><br><span class="line"></span><br><span class="line">	if (!down_read_trylock(&amp;ppol-&gt;enable_sem))</span><br><span class="line">		return;</span><br><span class="line">	if (!ppol-&gt;governor_enabled)</span><br><span class="line">		goto exit;</span><br><span class="line"></span><br><span class="line">	now = ktime_to_us(ktime_get());</span><br><span class="line"></span><br><span class="line">	spin_lock_irqsave(&amp;ppol-&gt;target_freq_lock, flags);</span><br><span class="line">	spin_lock(&amp;ppol-&gt;load_lock);</span><br><span class="line"></span><br><span class="line">	skip_hispeed_logic =</span><br><span class="line">		tunables-&gt;ignore_hispeed_on_notif &amp;&amp; ppol-&gt;notif_pending;</span><br><span class="line">	skip_min_sample_time = tunables-&gt;fast_ramp_down &amp;&amp; ppol-&gt;notif_pending;</span><br><span class="line">	ppol-&gt;notif_pending = false;</span><br><span class="line">	now = ktime_to_us(ktime_get());</span><br><span class="line">	ppol-&gt;last_evaluated_jiffy = get_jiffies_64();</span><br><span class="line"></span><br><span class="line">    /* (1) sched_load模式，查询最新的sched_load  */</span><br><span class="line">	if (tunables-&gt;use_sched_load)</span><br><span class="line">		sched_get_cpus_busy(sl, ppol-&gt;policy-&gt;cpus);</span><br><span class="line">	max_cpu = cpumask_first(ppol-&gt;policy-&gt;cpus);</span><br><span class="line">	i = 0;</span><br><span class="line">	for_each_cpu(cpu, ppol-&gt;policy-&gt;cpus) &#123;</span><br><span class="line">		pcpu = &amp;per_cpu(cpuinfo, cpu);</span><br><span class="line">		</span><br><span class="line">		/* (2) sched_load模式，使用sched_load来计算负载变化  */</span><br><span class="line">		if (tunables-&gt;use_sched_load) &#123;</span><br><span class="line">		    </span><br><span class="line">		    /* (2.1) 根据上个窗口负载，获得当前目标值 */</span><br><span class="line">			t_prevlaf = sl_busy_to_laf(ppol, sl[i].prev_load);</span><br><span class="line">			prev_l = t_prevlaf / ppol-&gt;target_freq;</span><br><span class="line">			</span><br><span class="line">			/* (2.2) 根据上个窗口负载预测，获得当前的预测值 */</span><br><span class="line">			if (tunables-&gt;enable_prediction) &#123;</span><br><span class="line">				t_predlaf = sl_busy_to_laf(ppol,</span><br><span class="line">						sl[i].predicted_load);</span><br><span class="line">				pred_l = t_predlaf / ppol-&gt;target_freq;</span><br><span class="line">			&#125;</span><br><span class="line">			if (sl[i].prev_load)</span><br><span class="line">				new_load_pct = sl[i].new_task_load * 100 /</span><br><span class="line">							sl[i].prev_load;</span><br><span class="line">			else</span><br><span class="line">				new_load_pct = 0;</span><br><span class="line">				</span><br><span class="line">		/* (3) 传统模式，使用time*freq的模式来计算负载变化  */</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			now = update_load(cpu);</span><br><span class="line">			delta_time = (unsigned int)</span><br><span class="line">				(now - pcpu-&gt;cputime_speedadj_timestamp);</span><br><span class="line">			if (WARN_ON_ONCE(!delta_time))</span><br><span class="line">				continue;</span><br><span class="line">			cputime_speedadj = pcpu-&gt;cputime_speedadj;</span><br><span class="line">			do_div(cputime_speedadj, delta_time);</span><br><span class="line">			t_prevlaf = (unsigned int)cputime_speedadj * 100;</span><br><span class="line">			prev_l = t_prevlaf / ppol-&gt;target_freq;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		/* find max of loadadjfreq inside policy */</span><br><span class="line">		if (t_prevlaf &gt; prev_laf) &#123;</span><br><span class="line">			prev_laf = t_prevlaf;</span><br><span class="line">			max_cpu = cpu;</span><br><span class="line">		&#125;</span><br><span class="line">		pred_laf = max(t_predlaf, pred_laf);</span><br><span class="line"></span><br><span class="line">		cpu_load = max(prev_l, pred_l);</span><br><span class="line">		pol_load = max(pol_load, cpu_load);</span><br><span class="line">		trace_cpufreq_interactive_cpuload(cpu, cpu_load, new_load_pct,</span><br><span class="line">						  prev_l, pred_l);</span><br><span class="line"></span><br><span class="line">		/* save loadadjfreq for notification */</span><br><span class="line">		pcpu-&gt;loadadjfreq = max(t_prevlaf, t_predlaf);</span><br><span class="line"></span><br><span class="line">		/* detect heavy new task and jump to policy-&gt;max */</span><br><span class="line">		if (prev_l &gt;= tunables-&gt;go_hispeed_load &amp;&amp;</span><br><span class="line">		    new_load_pct &gt;= NEW_TASK_RATIO) &#123;</span><br><span class="line">			skip_hispeed_logic = true;</span><br><span class="line">			jump_to_max = true;</span><br><span class="line">		&#125;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	spin_unlock(&amp;ppol-&gt;load_lock);</span><br><span class="line"></span><br><span class="line">	tunables-&gt;boosted = tunables-&gt;boost_val || now &lt; tunables-&gt;boostpulse_endtime;</span><br><span class="line"></span><br><span class="line">    /* (4) 取目标值和预测值中的较大值，作为调频目标 */</span><br><span class="line">	prev_chfreq = choose_freq(ppol, prev_laf);</span><br><span class="line">	pred_chfreq = choose_freq(ppol, pred_laf);</span><br><span class="line">	chosen_freq = max(prev_chfreq, pred_chfreq);</span><br><span class="line"></span><br><span class="line">	if (prev_chfreq &lt; ppol-&gt;policy-&gt;max &amp;&amp; pred_chfreq &gt;= ppol-&gt;policy-&gt;max)</span><br><span class="line">		if (!jump_to_max)</span><br><span class="line">			jump_to_max_no_ts = true;</span><br><span class="line"></span><br><span class="line">	if (now - ppol-&gt;max_freq_hyst_start_time &lt;</span><br><span class="line">	    tunables-&gt;max_freq_hysteresis &amp;&amp;</span><br><span class="line">	    pol_load &gt;= tunables-&gt;go_hispeed_load &amp;&amp;</span><br><span class="line">	    ppol-&gt;target_freq &lt; ppol-&gt;policy-&gt;max) &#123;</span><br><span class="line">		skip_hispeed_logic = true;</span><br><span class="line">		skip_min_sample_time = true;</span><br><span class="line">		if (!jump_to_max)</span><br><span class="line">			jump_to_max_no_ts = true;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	new_freq = chosen_freq;</span><br><span class="line">	if (jump_to_max_no_ts || jump_to_max) &#123;</span><br><span class="line">		new_freq = ppol-&gt;policy-&gt;cpuinfo.max_freq;</span><br><span class="line">	&#125; else if (!skip_hispeed_logic) &#123;</span><br><span class="line">		if (pol_load &gt;= tunables-&gt;go_hispeed_load ||</span><br><span class="line">		    tunables-&gt;boosted) &#123;</span><br><span class="line">			if (ppol-&gt;target_freq &lt; tunables-&gt;hispeed_freq)</span><br><span class="line">				new_freq = tunables-&gt;hispeed_freq;</span><br><span class="line">			else</span><br><span class="line">				new_freq = max(new_freq,</span><br><span class="line">					       tunables-&gt;hispeed_freq);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (now - ppol-&gt;max_freq_hyst_start_time &lt;</span><br><span class="line">	    tunables-&gt;max_freq_hysteresis) &#123;</span><br><span class="line">		if (new_freq &lt; ppol-&gt;policy-&gt;max &amp;&amp;</span><br><span class="line">				ppol-&gt;policy-&gt;max &lt;= tunables-&gt;hispeed_freq)</span><br><span class="line">			start_hyst = false;</span><br><span class="line">		new_freq = max(tunables-&gt;hispeed_freq, new_freq);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (!skip_hispeed_logic &amp;&amp;</span><br><span class="line">	    ppol-&gt;target_freq &gt;= tunables-&gt;hispeed_freq &amp;&amp;</span><br><span class="line">	    new_freq &gt; ppol-&gt;target_freq &amp;&amp;</span><br><span class="line">	    now - ppol-&gt;hispeed_validate_time &lt;</span><br><span class="line">	    freq_to_above_hispeed_delay(tunables, ppol-&gt;target_freq)) &#123;</span><br><span class="line">		trace_cpufreq_interactive_notyet(</span><br><span class="line">			max_cpu, pol_load, ppol-&gt;target_freq,</span><br><span class="line">			ppol-&gt;policy-&gt;cur, new_freq);</span><br><span class="line">		spin_unlock_irqrestore(&amp;ppol-&gt;target_freq_lock, flags);</span><br><span class="line">		goto rearm;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ppol-&gt;hispeed_validate_time = now;</span><br><span class="line"></span><br><span class="line">	if (cpufreq_frequency_table_target(&amp;ppol-&gt;p_nolim, ppol-&gt;freq_table,</span><br><span class="line">					   new_freq, CPUFREQ_RELATION_L,</span><br><span class="line">					   &amp;index)) &#123;</span><br><span class="line">		spin_unlock_irqrestore(&amp;ppol-&gt;target_freq_lock, flags);</span><br><span class="line">		goto rearm;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	new_freq = ppol-&gt;freq_table[index].frequency;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Do not scale below floor_freq unless we have been at or above the</span><br><span class="line">	 * floor frequency for the minimum sample time since last validated.</span><br><span class="line">	 */</span><br><span class="line">	if (!skip_min_sample_time &amp;&amp; new_freq &lt; ppol-&gt;floor_freq) &#123;</span><br><span class="line">		if (now - ppol-&gt;floor_validate_time &lt;</span><br><span class="line">				tunables-&gt;min_sample_time) &#123;</span><br><span class="line">			trace_cpufreq_interactive_notyet(</span><br><span class="line">				max_cpu, pol_load, ppol-&gt;target_freq,</span><br><span class="line">				ppol-&gt;policy-&gt;cur, new_freq);</span><br><span class="line">			spin_unlock_irqrestore(&amp;ppol-&gt;target_freq_lock, flags);</span><br><span class="line">			goto rearm;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Update the timestamp for checking whether speed has been held at</span><br><span class="line">	 * or above the selected frequency for a minimum of min_sample_time,</span><br><span class="line">	 * if not boosted to hispeed_freq.  If boosted to hispeed_freq then we</span><br><span class="line">	 * allow the speed to drop as soon as the boostpulse duration expires</span><br><span class="line">	 * (or the indefinite boost is turned off). If policy-&gt;max is restored</span><br><span class="line">	 * for max_freq_hysteresis, don&apos;t extend the timestamp. Otherwise, it</span><br><span class="line">	 * could incorrectly extended the duration of max_freq_hysteresis by</span><br><span class="line">	 * min_sample_time.</span><br><span class="line">	 */</span><br><span class="line"></span><br><span class="line">	if ((!tunables-&gt;boosted || new_freq &gt; tunables-&gt;hispeed_freq)</span><br><span class="line">	    &amp;&amp; !jump_to_max_no_ts) &#123;</span><br><span class="line">		ppol-&gt;floor_freq = new_freq;</span><br><span class="line">		ppol-&gt;floor_validate_time = now;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (start_hyst &amp;&amp; new_freq &gt;= ppol-&gt;policy-&gt;max &amp;&amp; !jump_to_max_no_ts)</span><br><span class="line">		ppol-&gt;max_freq_hyst_start_time = now;</span><br><span class="line"></span><br><span class="line">	if (ppol-&gt;target_freq == new_freq &amp;&amp;</span><br><span class="line">			ppol-&gt;target_freq &lt;= ppol-&gt;policy-&gt;cur) &#123;</span><br><span class="line">		trace_cpufreq_interactive_already(</span><br><span class="line">			max_cpu, pol_load, ppol-&gt;target_freq,</span><br><span class="line">			ppol-&gt;policy-&gt;cur, new_freq);</span><br><span class="line">		spin_unlock_irqrestore(&amp;ppol-&gt;target_freq_lock, flags);</span><br><span class="line">		goto rearm;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	trace_cpufreq_interactive_target(max_cpu, pol_load, ppol-&gt;target_freq,</span><br><span class="line">					 ppol-&gt;policy-&gt;cur, new_freq);</span><br><span class="line"></span><br><span class="line">	ppol-&gt;target_freq = new_freq;</span><br><span class="line">	spin_unlock_irqrestore(&amp;ppol-&gt;target_freq_lock, flags);</span><br><span class="line">	spin_lock_irqsave(&amp;speedchange_cpumask_lock, flags);</span><br><span class="line">	cpumask_set_cpu(max_cpu, &amp;speedchange_cpumask);</span><br><span class="line">	spin_unlock_irqrestore(&amp;speedchange_cpumask_lock, flags);</span><br><span class="line">	wake_up_process_no_notif(speedchange_task);</span><br><span class="line"></span><br><span class="line">rearm:</span><br><span class="line">	if (!timer_pending(&amp;ppol-&gt;policy_timer))</span><br><span class="line">		cpufreq_interactive_timer_resched(data, false);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Send govinfo notification.</span><br><span class="line">	 * Govinfo notification could potentially wake up another thread</span><br><span class="line">	 * managed by its clients. Thread wakeups might trigger a load</span><br><span class="line">	 * change callback that executes this function again. Therefore</span><br><span class="line">	 * no spinlock could be held when sending the notification.</span><br><span class="line">	 */</span><br><span class="line">	for_each_cpu(i, ppol-&gt;policy-&gt;cpus) &#123;</span><br><span class="line">		pcpu = &amp;per_cpu(cpuinfo, i);</span><br><span class="line">		govinfo.cpu = i;</span><br><span class="line">		govinfo.load = pcpu-&gt;loadadjfreq / ppol-&gt;policy-&gt;max;</span><br><span class="line">		govinfo.sampling_rate_us = tunables-&gt;timer_rate;</span><br><span class="line">		atomic_notifier_call_chain(&amp;cpufreq_govinfo_notifier_list,</span><br><span class="line">					   CPUFREQ_LOAD_CHANGE, &amp;govinfo);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">exit:</span><br><span class="line">	up_read(&amp;ppol-&gt;enable_sem);</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">void sched_get_cpus_busy(struct sched_load *busy,</span><br><span class="line">			 const struct cpumask *query_cpus)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned long flags;</span><br><span class="line">	struct rq *rq;</span><br><span class="line">	const int cpus = cpumask_weight(query_cpus);</span><br><span class="line">	u64 load[cpus], group_load[cpus];</span><br><span class="line">	u64 nload[cpus], ngload[cpus];</span><br><span class="line">	u64 pload[cpus];</span><br><span class="line">	unsigned int max_freq[cpus];</span><br><span class="line">	int notifier_sent = 0;</span><br><span class="line">	int early_detection[cpus];</span><br><span class="line">	int cpu, i = 0;</span><br><span class="line">	unsigned int window_size;</span><br><span class="line">	u64 max_prev_sum = 0;</span><br><span class="line">	int max_busy_cpu = cpumask_first(query_cpus);</span><br><span class="line">	u64 total_group_load = 0, total_ngload = 0;</span><br><span class="line">	bool aggregate_load = false;</span><br><span class="line">	struct sched_cluster *cluster = cpu_cluster(cpumask_first(query_cpus));</span><br><span class="line"></span><br><span class="line">	if (unlikely(cpus == 0))</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	local_irq_save(flags);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * This function could be called in timer context, and the</span><br><span class="line">	 * current task may have been executing for a long time. Ensure</span><br><span class="line">	 * that the window stats are current by doing an update.</span><br><span class="line">	 */</span><br><span class="line"></span><br><span class="line">	for_each_cpu(cpu, query_cpus)</span><br><span class="line">		raw_spin_lock_nested(&amp;cpu_rq(cpu)-&gt;lock, cpu);</span><br><span class="line"></span><br><span class="line">	window_size = sched_ravg_window;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * We don&apos;t really need the cluster lock for this entire for loop</span><br><span class="line">	 * block. However, there is no advantage in optimizing this as rq</span><br><span class="line">	 * locks are held regardless and would prevent migration anyways</span><br><span class="line">	 */</span><br><span class="line">	raw_spin_lock(&amp;cluster-&gt;load_lock);</span><br><span class="line"></span><br><span class="line">	for_each_cpu(cpu, query_cpus) &#123;</span><br><span class="line">		rq = cpu_rq(cpu);</span><br><span class="line"></span><br><span class="line">		update_task_ravg(rq-&gt;curr, rq, TASK_UPDATE, sched_ktime_clock(),</span><br><span class="line">				 0);</span><br><span class="line"></span><br><span class="line">		account_load_subtractions(rq);</span><br><span class="line">		</span><br><span class="line">		/* (1) 获取: </span><br><span class="line">		    cpu上一个窗口的负载：rq-&gt;prev_runnable_sum</span><br><span class="line">		    cpu上一个窗口的的新任务负载：rq-&gt;nt_prev_runnable_sum</span><br><span class="line">		    cpu上一个窗口的负载预测：rq-&gt;hmp_stats.pred_demands_sum</span><br><span class="line">		 */</span><br><span class="line">		load[i] = rq-&gt;prev_runnable_sum;</span><br><span class="line">		nload[i] = rq-&gt;nt_prev_runnable_sum;</span><br><span class="line">		pload[i] = rq-&gt;hmp_stats.pred_demands_sum;</span><br><span class="line">		rq-&gt;old_estimated_time = pload[i];</span><br><span class="line"></span><br><span class="line">		if (load[i] &gt; max_prev_sum) &#123;</span><br><span class="line">			max_prev_sum = load[i];</span><br><span class="line">			max_busy_cpu = cpu;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		/*</span><br><span class="line">		 * sched_get_cpus_busy() is called for all CPUs in a</span><br><span class="line">		 * frequency domain. So the notifier_sent flag per</span><br><span class="line">		 * cluster works even when a frequency domain spans</span><br><span class="line">		 * more than 1 cluster.</span><br><span class="line">		 */</span><br><span class="line">		if (rq-&gt;cluster-&gt;notifier_sent) &#123;</span><br><span class="line">			notifier_sent = 1;</span><br><span class="line">			rq-&gt;cluster-&gt;notifier_sent = 0;</span><br><span class="line">		&#125;</span><br><span class="line">		early_detection[i] = (rq-&gt;ed_task != NULL);</span><br><span class="line">		max_freq[i] = cpu_max_freq(cpu);</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	raw_spin_unlock(&amp;cluster-&gt;load_lock);</span><br><span class="line"></span><br><span class="line">	group_load_in_freq_domain(</span><br><span class="line">			&amp;cpu_rq(max_busy_cpu)-&gt;freq_domain_cpumask,</span><br><span class="line">			&amp;total_group_load, &amp;total_ngload);</span><br><span class="line">	aggregate_load = !!(total_group_load &gt; sched_freq_aggregate_threshold);</span><br><span class="line"></span><br><span class="line">	i = 0;</span><br><span class="line">	for_each_cpu(cpu, query_cpus) &#123;</span><br><span class="line">		group_load[i] = 0;</span><br><span class="line">		ngload[i] = 0;</span><br><span class="line"></span><br><span class="line">		if (early_detection[i])</span><br><span class="line">			goto skip_early;</span><br><span class="line"></span><br><span class="line">		rq = cpu_rq(cpu);</span><br><span class="line">		if (aggregate_load) &#123;</span><br><span class="line">			if (cpu == max_busy_cpu) &#123;</span><br><span class="line">				group_load[i] = total_group_load;</span><br><span class="line">				ngload[i] = total_ngload;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			group_load[i] = rq-&gt;grp_time.prev_runnable_sum;</span><br><span class="line">			ngload[i] = rq-&gt;grp_time.nt_prev_runnable_sum;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		load[i] += group_load[i];</span><br><span class="line">		nload[i] += ngload[i];</span><br><span class="line"></span><br><span class="line">		load[i] = freq_policy_load(rq, load[i]);</span><br><span class="line">		rq-&gt;old_busy_time = load[i];</span><br><span class="line"></span><br><span class="line">		/*</span><br><span class="line">		 * Scale load in reference to cluster max_possible_freq.</span><br><span class="line">		 *</span><br><span class="line">		 * Note that scale_load_to_cpu() scales load in reference to</span><br><span class="line">		 * the cluster max_freq.</span><br><span class="line">		 */</span><br><span class="line">		load[i] = scale_load_to_cpu(load[i], cpu);</span><br><span class="line">		nload[i] = scale_load_to_cpu(nload[i], cpu);</span><br><span class="line">		pload[i] = scale_load_to_cpu(pload[i], cpu);</span><br><span class="line">skip_early:</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for_each_cpu(cpu, query_cpus)</span><br><span class="line">		raw_spin_unlock(&amp;(cpu_rq(cpu))-&gt;lock);</span><br><span class="line"></span><br><span class="line">	local_irq_restore(flags);</span><br><span class="line"></span><br><span class="line">	i = 0;</span><br><span class="line">	for_each_cpu(cpu, query_cpus) &#123;</span><br><span class="line">		rq = cpu_rq(cpu);</span><br><span class="line"></span><br><span class="line">		if (early_detection[i]) &#123;</span><br><span class="line">			busy[i].prev_load = div64_u64(sched_ravg_window,</span><br><span class="line">							NSEC_PER_USEC);</span><br><span class="line">			busy[i].new_task_load = 0;</span><br><span class="line">			busy[i].predicted_load = 0;</span><br><span class="line">			goto exit_early;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		load[i] = scale_load_to_freq(load[i], max_freq[i],</span><br><span class="line">				cpu_max_possible_freq(cpu));</span><br><span class="line">		nload[i] = scale_load_to_freq(nload[i], max_freq[i],</span><br><span class="line">				cpu_max_possible_freq(cpu));</span><br><span class="line"></span><br><span class="line">		pload[i] = scale_load_to_freq(pload[i], max_freq[i],</span><br><span class="line">					     rq-&gt;cluster-&gt;max_possible_freq);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        /* (2) 负载经过转换后赋值给busy: </span><br><span class="line">		    cpu上一个窗口的负载：busy[i].prev_load</span><br><span class="line">		    cpu上一个窗口的的新任务负载：busy[i].new_task_load</span><br><span class="line">		    cpu上一个窗口的负载预测：busy[i].predicted_load</span><br><span class="line">		 */</span><br><span class="line">		busy[i].prev_load = div64_u64(load[i], NSEC_PER_USEC);</span><br><span class="line">		busy[i].new_task_load = div64_u64(nload[i], NSEC_PER_USEC);</span><br><span class="line">		busy[i].predicted_load = div64_u64(pload[i], NSEC_PER_USEC);</span><br><span class="line"></span><br><span class="line">exit_early:</span><br><span class="line">		trace_sched_get_busy(cpu, busy[i].prev_load,</span><br><span class="line">				     busy[i].new_task_load,</span><br><span class="line">				     busy[i].predicted_load,</span><br><span class="line">				     early_detection[i],</span><br><span class="line">				     aggregate_load &amp;&amp;</span><br><span class="line">				      cpu == max_busy_cpu);</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="6、Cgoup"><a href="#6、Cgoup" class="headerlink" title="6、Cgoup"></a>6、Cgoup</h1><h2 id="6-1、cgroup概念"><a href="#6-1、cgroup概念" class="headerlink" title="6.1、cgroup概念"></a>6.1、cgroup概念</h2><p>cgroup最基本的操作时我们可以使用以下命令创建一个cgroup文件夹：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t cgroup -o cpu,cpuset cpu&amp;cpuset /dev/cpu_cpuset_test</span><br></pre></td></tr></table></figure>
<p>那么/dev/cpu_cpuset_test文件夹下就有一系列的cpu、cpuset cgroup相关的控制节点，tasks文件中默认加入了所有进程到这个cgroup中。可以继续创建子文件夹，子文件夹继承了父文件夹的结构形式，我们可以给子文件夹配置不同的参数，把一部分进程加入到子文件夹中的tasks文件当中，久可以实现分开的cgroup控制了。</p>
<p>一个简单明了的例子如下图所示：</p>
<p><img src="/images/scheduler/schedule_cgroup_frame.png" alt="schedule_cgroup_frame"></p>
<p>关于cgroup的结构有以下规则和规律：</p>
<ul>
<li>1、cgroup有很多subsys，我们平时接触到的cpu、cpuset、cpuacct、memory、blkio都是cgroup_subsys；</li>
<li>2、一个cgroup hierarchy，就是使用mount命令挂载的一个cgroup文件系统，hierarchy对应mount的根cgroup_root；</li>
<li>3、一个hierarchy可以制定一个subsys，也可以制定多个subsys。可以是一个subsys，也可以是一个subsys组合；</li>
<li>4、一个subsys只能被一个hierarchy引用一次，如果subsys已经被hierarchy引用，新hierarchy创建时不能引用这个subsys；唯一例外的是，我们可以创建和旧的hierarchy相同的subsys组合，这其实没有创建新的hierarchy，只是简单的符号链接；</li>
<li>5、hierarchy对应一个文件系统，cgroup对应这个文件系统中的文件夹；subsys是基类，而css(cgroup_subsys_state)是cgroup引用subsys的实例；比如父目录和子目录分别是两个cgroup，他们都要引用相同的subsys，但是他们需要不同的配置，所以会创建不同的css供cgroup-&gt;subsys[]来引用；</li>
<li>6、一个任务对系统中不同的subsys一定会有引用，但是会引用到不同的hierarchy不同的cgroup即不同css当中；所以系统使用css_set结构来管理任务对css的引。如果任务引用的css组合相同，那他们开源使用相同的css_set；</li>
<li>7、还有cgroup到task的反向引用，系统引入了cg_group_link结构。这部分可以参考<a href="http://www.infoq.com/cn/articles/docker-kernel-knowledge-cgroups-resource-isolation" target="_blank" rel="noopener">Docker背后的内核知识——cgroups资源限制</a>一文的描述，如下图的结构关系：</li>
</ul>
<p><img src="/images/scheduler/schedule_cgroup_frame_detail.png" alt="schedule_cgroup_frame_detail"></p>
<h2 id="6-2、代码分析"><a href="#6-2、代码分析" class="headerlink" title="6.2、代码分析"></a>6.2、代码分析</h2><p>1、”/proc/cgroups”</p>
<ul>
<li>subsys的链表：for_each_subsys(ss, i)</li>
<li>一个susbsys对应一个hierarchy：ss-&gt;root</li>
<li>一个hierarchy有多少个cgroup：ss-&gt;root-&gt;nr_cgrps</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># ount -t cgroup -o freezer,debug bbb freezer_test/ </span><br><span class="line"></span><br><span class="line"># cat /proc/cgroups</span><br><span class="line">#subsys_name    hierarchy       num_cgroups     enabled</span><br><span class="line">cpuset  4       6       1</span><br><span class="line">cpu     3       2       1</span><br><span class="line">cpuacct 1       147     1</span><br><span class="line">schedtune       2       3       1</span><br><span class="line">freezer 6       1       1</span><br><span class="line">debug   6       1       1</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static int proc_cgroupstats_show(struct seq_file *m, void *v)</span><br><span class="line">&#123;</span><br><span class="line">	struct cgroup_subsys *ss;</span><br><span class="line">	int i;</span><br><span class="line"></span><br><span class="line">	seq_puts(m, &quot;#subsys_name\thierarchy\tnum_cgroups\tenabled\n&quot;);</span><br><span class="line">	/*</span><br><span class="line">	 * ideally we don&apos;t want subsystems moving around while we do this.</span><br><span class="line">	 * cgroup_mutex is also necessary to guarantee an atomic snapshot of</span><br><span class="line">	 * subsys/hierarchy state.</span><br><span class="line">	 */</span><br><span class="line">	mutex_lock(&amp;cgroup_mutex);</span><br><span class="line"></span><br><span class="line">	for_each_subsys(ss, i)</span><br><span class="line">		seq_printf(m, &quot;%s\t%d\t%d\t%d\n&quot;,</span><br><span class="line">			   ss-&gt;legacy_name, ss-&gt;root-&gt;hierarchy_id,</span><br><span class="line">			   atomic_read(&amp;ss-&gt;root-&gt;nr_cgrps),</span><br><span class="line">			   cgroup_ssid_enabled(i));</span><br><span class="line"></span><br><span class="line">	mutex_unlock(&amp;cgroup_mutex);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、”/proc/pid/cgroup”</p>
<ul>
<li>每种subsys组合组成一个新的hierarchy，每个hierarchy在for_each_root(root)中创建一个root树；</li>
<li>每个hierarchy顶层目录和子目录都是一个cgroup，一个hierarchy可以有多个cgroup，对应的subsys组合一样，但是参数不一样</li>
<li>cgroup_root自带一个cgroup即root-&gt;cgrp，作为hierarchy的顶级目录</li>
<li>一个cgroup对应多个subsys，使用cgroup_subsys_state类型(css)的cgroup-&gt;subsys[CGROUP_SUBSYS_COUNT]数组去和多个subsys链接;</li>
<li>一个cgroup自带一个cgroup_subsys_state即cgrp-&gt;self，这个css的作用是css-&gt;parent指针，建立起cgroup之间的父子关系；</li>
<li>css一个公用结构，每个subsys使用自己的函数ss-&gt;css_alloc()分配自己的css结构，这个结构包含公用css + subsys私有数据；</li>
<li>每个subsys只能存在于一个组合(hierarchy)当中，如果一个subsys已经被一个组合引用，其他组合不能再引用这个subsys。唯一例外的是，我们可以重复mount相同的组合，但是这样并没有创建新组合，只是创建了一个链接指向旧组合；</li>
<li>进程对应每一种hierarchy，一定有一个cgroup对应。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># cat /proc/832/cgroup</span><br><span class="line">6:freezer,debug:/</span><br><span class="line">4:cpuset:/</span><br><span class="line">3:cpu:/</span><br><span class="line">2:schedtune:/</span><br><span class="line">1:cpuacct:/</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">int proc_cgroup_show(struct seq_file *m, struct pid_namespace *ns,</span><br><span class="line">		     struct pid *pid, struct task_struct *tsk)</span><br><span class="line">&#123;</span><br><span class="line">	char *buf, *path;</span><br><span class="line">	int retval;</span><br><span class="line">	struct cgroup_root *root;</span><br><span class="line"></span><br><span class="line">	retval = -ENOMEM;</span><br><span class="line">	buf = kmalloc(PATH_MAX, GFP_KERNEL);</span><br><span class="line">	if (!buf)</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;cgroup_mutex);</span><br><span class="line">	spin_lock_bh(&amp;css_set_lock);</span><br><span class="line"></span><br><span class="line">	for_each_root(root) &#123;</span><br><span class="line">		struct cgroup_subsys *ss;</span><br><span class="line">		struct cgroup *cgrp;</span><br><span class="line">		int ssid, count = 0;</span><br><span class="line"></span><br><span class="line">		if (root == &amp;cgrp_dfl_root &amp;&amp; !cgrp_dfl_root_visible)</span><br><span class="line">			continue;</span><br><span class="line"></span><br><span class="line">		seq_printf(m, &quot;%d:&quot;, root-&gt;hierarchy_id);</span><br><span class="line">		if (root != &amp;cgrp_dfl_root)</span><br><span class="line">			for_each_subsys(ss, ssid)</span><br><span class="line">				if (root-&gt;subsys_mask &amp; (1 &lt;&lt; ssid))</span><br><span class="line">					seq_printf(m, &quot;%s%s&quot;, count++ ? &quot;,&quot; : &quot;&quot;,</span><br><span class="line">						   ss-&gt;legacy_name);</span><br><span class="line">		if (strlen(root-&gt;name))</span><br><span class="line">			seq_printf(m, &quot;%sname=%s&quot;, count ? &quot;,&quot; : &quot;&quot;,</span><br><span class="line">				   root-&gt;name);</span><br><span class="line">		seq_putc(m, &apos;:&apos;);</span><br><span class="line"></span><br><span class="line">		cgrp = task_cgroup_from_root(tsk, root);</span><br><span class="line"></span><br><span class="line">		/*</span><br><span class="line">		 * On traditional hierarchies, all zombie tasks show up as</span><br><span class="line">		 * belonging to the root cgroup.  On the default hierarchy,</span><br><span class="line">		 * while a zombie doesn&apos;t show up in &quot;cgroup.procs&quot; and</span><br><span class="line">		 * thus can&apos;t be migrated, its /proc/PID/cgroup keeps</span><br><span class="line">		 * reporting the cgroup it belonged to before exiting.  If</span><br><span class="line">		 * the cgroup is removed before the zombie is reaped,</span><br><span class="line">		 * &quot; (deleted)&quot; is appended to the cgroup path.</span><br><span class="line">		 */</span><br><span class="line">		if (cgroup_on_dfl(cgrp) || !(tsk-&gt;flags &amp; PF_EXITING)) &#123;</span><br><span class="line">			path = cgroup_path(cgrp, buf, PATH_MAX);</span><br><span class="line">			if (!path) &#123;</span><br><span class="line">				retval = -ENAMETOOLONG;</span><br><span class="line">				goto out_unlock;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			path = &quot;/&quot;;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		seq_puts(m, path);</span><br><span class="line"></span><br><span class="line">		if (cgroup_on_dfl(cgrp) &amp;&amp; cgroup_is_dead(cgrp))</span><br><span class="line">			seq_puts(m, &quot; (deleted)\n&quot;);</span><br><span class="line">		else</span><br><span class="line">			seq_putc(m, &apos;\n&apos;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	retval = 0;</span><br><span class="line">out_unlock:</span><br><span class="line">	spin_unlock_bh(&amp;css_set_lock);</span><br><span class="line">	mutex_unlock(&amp;cgroup_mutex);</span><br><span class="line">	kfree(buf);</span><br><span class="line">out:</span><br><span class="line">	return retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line">int __init cgroup_init_early(void)</span><br><span class="line">&#123;</span><br><span class="line">	static struct cgroup_sb_opts __initdata opts;</span><br><span class="line">	struct cgroup_subsys *ss;</span><br><span class="line">	int i;</span><br><span class="line"></span><br><span class="line">    /* (1) 初始化默认root cgrp_dfl_root，选项opts为空，初始了</span><br><span class="line">        root-&gt;cgrp          // cgrp-&gt;root = root;</span><br><span class="line">        root-&gt;cgrp.self     // cgrp-&gt;self.cgroup = cgrp; cgrp-&gt;self.flags |= CSS_ONLINE; </span><br><span class="line">     */</span><br><span class="line">	init_cgroup_root(&amp;cgrp_dfl_root, &amp;opts);</span><br><span class="line">	cgrp_dfl_root.cgrp.self.flags |= CSS_NO_REF;</span><br><span class="line"></span><br><span class="line">	RCU_INIT_POINTER(init_task.cgroups, &amp;init_css_set);</span><br><span class="line"></span><br><span class="line">    /* (2) 轮询subsys进行初始化 */</span><br><span class="line">	for_each_subsys(ss, i) &#123;</span><br><span class="line">		WARN(!ss-&gt;css_alloc || !ss-&gt;css_free || ss-&gt;name || ss-&gt;id,</span><br><span class="line">		     &quot;invalid cgroup_subsys %d:%s css_alloc=%p css_free=%p name:id=%d:%s\n&quot;,</span><br><span class="line">		     i, cgroup_subsys_name[i], ss-&gt;css_alloc, ss-&gt;css_free,</span><br><span class="line">		     ss-&gt;id, ss-&gt;name);</span><br><span class="line">		WARN(strlen(cgroup_subsys_name[i]) &gt; MAX_CGROUP_TYPE_NAMELEN,</span><br><span class="line">		     &quot;cgroup_subsys_name %s too long\n&quot;, cgroup_subsys_name[i]);</span><br><span class="line"></span><br><span class="line">        /* (3) 初始化ss-&gt;id、ss-&gt;name */</span><br><span class="line">		ss-&gt;id = i;</span><br><span class="line">		ss-&gt;name = cgroup_subsys_name[i];</span><br><span class="line">		if (!ss-&gt;legacy_name)</span><br><span class="line">			ss-&gt;legacy_name = cgroup_subsys_name[i];</span><br><span class="line"></span><br><span class="line">        /* (4) ss链接到默认root(cgrp_dfl_root)  </span><br><span class="line">            默认css_set(init_css_set)指向ss</span><br><span class="line">         */</span><br><span class="line">		if (ss-&gt;early_init)</span><br><span class="line">			cgroup_init_subsys(ss, true);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">static void __init cgroup_init_subsys(struct cgroup_subsys *ss, bool early)</span><br><span class="line">&#123;</span><br><span class="line">	struct cgroup_subsys_state *css;</span><br><span class="line"></span><br><span class="line">	printk(KERN_INFO &quot;Initializing cgroup subsys %s\n&quot;, ss-&gt;name);</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;cgroup_mutex);</span><br><span class="line"></span><br><span class="line">	idr_init(&amp;ss-&gt;css_idr);</span><br><span class="line">	INIT_LIST_HEAD(&amp;ss-&gt;cfts);</span><br><span class="line"></span><br><span class="line">	/* Create the root cgroup state for this subsystem */</span><br><span class="line">	ss-&gt;root = &amp;cgrp_dfl_root;</span><br><span class="line">	</span><br><span class="line">	/* (4.1) subsys分配一个新的相关的cgroup_subsys_state */</span><br><span class="line">	css = ss-&gt;css_alloc(cgroup_css(&amp;cgrp_dfl_root.cgrp, ss));</span><br><span class="line">	/* We don&apos;t handle early failures gracefully */</span><br><span class="line">	BUG_ON(IS_ERR(css));</span><br><span class="line">	</span><br><span class="line">	/* (4.2) 初始化css的成员指向cgroup </span><br><span class="line">	    cgroup为默认值cgrp_dfl_root.cgrp:</span><br><span class="line">	    css-&gt;cgroup = cgrp;</span><br><span class="line">	    css-&gt;ss = ss;</span><br><span class="line">	    INIT_LIST_HEAD(&amp;css-&gt;sibling);</span><br><span class="line">	    INIT_LIST_HEAD(&amp;css-&gt;children);</span><br><span class="line">	 */</span><br><span class="line">	init_and_link_css(css, ss, &amp;cgrp_dfl_root.cgrp);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Root csses are never destroyed and we can&apos;t initialize</span><br><span class="line">	 * percpu_ref during early init.  Disable refcnting.</span><br><span class="line">	 */</span><br><span class="line">	css-&gt;flags |= CSS_NO_REF;</span><br><span class="line"></span><br><span class="line">	if (early) &#123;</span><br><span class="line">		/* allocation can&apos;t be done safely during early init */</span><br><span class="line">		css-&gt;id = 1;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		css-&gt;id = cgroup_idr_alloc(&amp;ss-&gt;css_idr, css, 1, 2, GFP_KERNEL);</span><br><span class="line">		BUG_ON(css-&gt;id &lt; 0);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* Update the init_css_set to contain a subsys</span><br><span class="line">	 * pointer to this state - since the subsystem is</span><br><span class="line">	 * newly registered, all tasks and hence the</span><br><span class="line">	 * init_css_set is in the subsystem&apos;s root cgroup. */</span><br><span class="line">	/* (4.3) css_set指向新的css */</span><br><span class="line">	init_css_set.subsys[ss-&gt;id] = css;</span><br><span class="line"></span><br><span class="line">	have_fork_callback |= (bool)ss-&gt;fork &lt;&lt; ss-&gt;id;</span><br><span class="line">	have_exit_callback |= (bool)ss-&gt;exit &lt;&lt; ss-&gt;id;</span><br><span class="line">	have_free_callback |= (bool)ss-&gt;free &lt;&lt; ss-&gt;id;</span><br><span class="line">	have_canfork_callback |= (bool)ss-&gt;can_fork &lt;&lt; ss-&gt;id;</span><br><span class="line"></span><br><span class="line">	/* At system boot, before all subsystems have been</span><br><span class="line">	 * registered, no tasks have been forked, so we don&apos;t</span><br><span class="line">	 * need to invoke fork callbacks here. */</span><br><span class="line">	BUG_ON(!list_empty(&amp;init_task.tasks));</span><br><span class="line">    </span><br><span class="line">    /* (4.4) cgroup测指向css： </span><br><span class="line">        执行ss-&gt;css_online(css);</span><br><span class="line">        css-&gt;cgroup-&gt;subsys[ss-&gt;id] = css;</span><br><span class="line">     */</span><br><span class="line">	BUG_ON(online_css(css));</span><br><span class="line"></span><br><span class="line">	mutex_unlock(&amp;cgroup_mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int __init cgroup_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	struct cgroup_subsys *ss;</span><br><span class="line">	int ssid;</span><br><span class="line"></span><br><span class="line">	BUG_ON(percpu_init_rwsem(&amp;cgroup_threadgroup_rwsem));</span><br><span class="line">	BUG_ON(cgroup_init_cftypes(NULL, cgroup_dfl_base_files));</span><br><span class="line">	BUG_ON(cgroup_init_cftypes(NULL, cgroup_legacy_base_files));</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * The latency of the synchronize_sched() is too high for cgroups,</span><br><span class="line">	 * avoid it at the cost of forcing all readers into the slow path.</span><br><span class="line">	 */</span><br><span class="line">	rcu_sync_enter_start(&amp;cgroup_threadgroup_rwsem.rss);</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;cgroup_mutex);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Add init_css_set to the hash table so that dfl_root can link to</span><br><span class="line">	 * it during init.</span><br><span class="line">	 */</span><br><span class="line">	hash_add(css_set_table, &amp;init_css_set.hlist,</span><br><span class="line">		 css_set_hash(init_css_set.subsys));</span><br><span class="line"></span><br><span class="line">	BUG_ON(cgroup_setup_root(&amp;cgrp_dfl_root, 0));</span><br><span class="line"></span><br><span class="line">	mutex_unlock(&amp;cgroup_mutex);</span><br><span class="line"></span><br><span class="line">	for_each_subsys(ss, ssid) &#123;</span><br><span class="line">		if (ss-&gt;early_init) &#123;</span><br><span class="line">			struct cgroup_subsys_state *css =</span><br><span class="line">				init_css_set.subsys[ss-&gt;id];</span><br><span class="line"></span><br><span class="line">			css-&gt;id = cgroup_idr_alloc(&amp;ss-&gt;css_idr, css, 1, 2,</span><br><span class="line">						   GFP_KERNEL);</span><br><span class="line">			BUG_ON(css-&gt;id &lt; 0);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			cgroup_init_subsys(ss, false);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		list_add_tail(&amp;init_css_set.e_cset_node[ssid],</span><br><span class="line">			      &amp;cgrp_dfl_root.cgrp.e_csets[ssid]);</span><br><span class="line"></span><br><span class="line">		/*</span><br><span class="line">		 * Setting dfl_root subsys_mask needs to consider the</span><br><span class="line">		 * disabled flag and cftype registration needs kmalloc,</span><br><span class="line">		 * both of which aren&apos;t available during early_init.</span><br><span class="line">		 */</span><br><span class="line">		if (cgroup_disable_mask &amp; (1 &lt;&lt; ssid)) &#123;</span><br><span class="line">			static_branch_disable(cgroup_subsys_enabled_key[ssid]);</span><br><span class="line">			printk(KERN_INFO &quot;Disabling %s control group subsystem\n&quot;,</span><br><span class="line">			       ss-&gt;name);</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        /* (1) 默认root(cgrp_dfl_root)，支持所有ss */</span><br><span class="line">		cgrp_dfl_root.subsys_mask |= 1 &lt;&lt; ss-&gt;id;</span><br><span class="line"></span><br><span class="line">		if (!ss-&gt;dfl_cftypes)</span><br><span class="line">			cgrp_dfl_root_inhibit_ss_mask |= 1 &lt;&lt; ss-&gt;id;</span><br><span class="line"></span><br><span class="line">        /* (2) 将cftypes(ss-&gt;legacy_cftypes/ss-&gt;legacy_cftypes)加入到ss-&gt;cfts链表 */</span><br><span class="line">		if (ss-&gt;dfl_cftypes == ss-&gt;legacy_cftypes) &#123;</span><br><span class="line">			WARN_ON(cgroup_add_cftypes(ss, ss-&gt;dfl_cftypes));</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			WARN_ON(cgroup_add_dfl_cftypes(ss, ss-&gt;dfl_cftypes));</span><br><span class="line">			WARN_ON(cgroup_add_legacy_cftypes(ss, ss-&gt;legacy_cftypes));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (ss-&gt;bind)</span><br><span class="line">			ss-&gt;bind(init_css_set.subsys[ssid]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* init_css_set.subsys[] has been updated, re-hash */</span><br><span class="line">	hash_del(&amp;init_css_set.hlist);</span><br><span class="line">	hash_add(css_set_table, &amp;init_css_set.hlist,</span><br><span class="line">		 css_set_hash(init_css_set.subsys));</span><br><span class="line"></span><br><span class="line">	WARN_ON(sysfs_create_mount_point(fs_kobj, &quot;cgroup&quot;));</span><br><span class="line">	WARN_ON(register_filesystem(&amp;cgroup_fs_type));</span><br><span class="line">	WARN_ON(!proc_create(&quot;cgroups&quot;, 0, NULL, &amp;proc_cgroupstats_operations));</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、mount操作</p>
<p>创建新的root，因为ss默认都和默认root(cgrp_dfl_root)建立了关系，所以ss需要先解除旧的root链接，再和新root建立起链接。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br></pre></td><td class="code"><pre><span class="line">static struct dentry *cgroup_mount(struct file_system_type *fs_type,</span><br><span class="line">			 int flags, const char *unused_dev_name,</span><br><span class="line">			 void *data)</span><br><span class="line">&#123;</span><br><span class="line">	struct super_block *pinned_sb = NULL;</span><br><span class="line">	struct cgroup_subsys *ss;</span><br><span class="line">	struct cgroup_root *root;</span><br><span class="line">	struct cgroup_sb_opts opts;</span><br><span class="line">	struct dentry *dentry;</span><br><span class="line">	int ret;</span><br><span class="line">	int i;</span><br><span class="line">	bool new_sb;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * The first time anyone tries to mount a cgroup, enable the list</span><br><span class="line">	 * linking each css_set to its tasks and fix up all existing tasks.</span><br><span class="line">	 */</span><br><span class="line">	if (!use_task_css_set_links)</span><br><span class="line">		cgroup_enable_task_cg_lists();</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;cgroup_mutex);</span><br><span class="line"></span><br><span class="line">	/* First find the desired set of subsystems */</span><br><span class="line">	/* (1) 解析mount选项到opts */</span><br><span class="line">	ret = parse_cgroupfs_options(data, &amp;opts);</span><br><span class="line">	if (ret)</span><br><span class="line">		goto out_unlock;</span><br><span class="line"></span><br><span class="line">	/* look for a matching existing root */</span><br><span class="line">	if (opts.flags &amp; CGRP_ROOT_SANE_BEHAVIOR) &#123;</span><br><span class="line">		cgrp_dfl_root_visible = true;</span><br><span class="line">		root = &amp;cgrp_dfl_root;</span><br><span class="line">		cgroup_get(&amp;root-&gt;cgrp);</span><br><span class="line">		ret = 0;</span><br><span class="line">		goto out_unlock;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Destruction of cgroup root is asynchronous, so subsystems may</span><br><span class="line">	 * still be dying after the previous unmount.  Let&apos;s drain the</span><br><span class="line">	 * dying subsystems.  We just need to ensure that the ones</span><br><span class="line">	 * unmounted previously finish dying and don&apos;t care about new ones</span><br><span class="line">	 * starting.  Testing ref liveliness is good enough.</span><br><span class="line">	 */</span><br><span class="line">	/* (2) */</span><br><span class="line">	for_each_subsys(ss, i) &#123;</span><br><span class="line">		if (!(opts.subsys_mask &amp; (1 &lt;&lt; i)) ||</span><br><span class="line">		    ss-&gt;root == &amp;cgrp_dfl_root)</span><br><span class="line">			continue;</span><br><span class="line"></span><br><span class="line">		if (!percpu_ref_tryget_live(&amp;ss-&gt;root-&gt;cgrp.self.refcnt)) &#123;</span><br><span class="line">			mutex_unlock(&amp;cgroup_mutex);</span><br><span class="line">			msleep(10);</span><br><span class="line">			ret = restart_syscall();</span><br><span class="line">			goto out_free;</span><br><span class="line">		&#125;</span><br><span class="line">		cgroup_put(&amp;ss-&gt;root-&gt;cgrp);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (3) */</span><br><span class="line">	for_each_root(root) &#123;</span><br><span class="line">		bool name_match = false;</span><br><span class="line"></span><br><span class="line">		if (root == &amp;cgrp_dfl_root)</span><br><span class="line">			continue;</span><br><span class="line"></span><br><span class="line">		/*</span><br><span class="line">		 * If we asked for a name then it must match.  Also, if</span><br><span class="line">		 * name matches but sybsys_mask doesn&apos;t, we should fail.</span><br><span class="line">		 * Remember whether name matched.</span><br><span class="line">		 */</span><br><span class="line">		if (opts.name) &#123;</span><br><span class="line">			if (strcmp(opts.name, root-&gt;name))</span><br><span class="line">				continue;</span><br><span class="line">			name_match = true;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		/*</span><br><span class="line">		 * If we asked for subsystems (or explicitly for no</span><br><span class="line">		 * subsystems) then they must match.</span><br><span class="line">		 */</span><br><span class="line">		if ((opts.subsys_mask || opts.none) &amp;&amp;</span><br><span class="line">		    (opts.subsys_mask != root-&gt;subsys_mask)) &#123;</span><br><span class="line">			if (!name_match)</span><br><span class="line">				continue;</span><br><span class="line">			ret = -EBUSY;</span><br><span class="line">			goto out_unlock;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (root-&gt;flags ^ opts.flags)</span><br><span class="line">			pr_warn(&quot;new mount options do not match the existing superblock, will be ignored\n&quot;);</span><br><span class="line"></span><br><span class="line">		/*</span><br><span class="line">		 * We want to reuse @root whose lifetime is governed by its</span><br><span class="line">		 * -&gt;cgrp.  Let&apos;s check whether @root is alive and keep it</span><br><span class="line">		 * that way.  As cgroup_kill_sb() can happen anytime, we</span><br><span class="line">		 * want to block it by pinning the sb so that @root doesn&apos;t</span><br><span class="line">		 * get killed before mount is complete.</span><br><span class="line">		 *</span><br><span class="line">		 * With the sb pinned, tryget_live can reliably indicate</span><br><span class="line">		 * whether @root can be reused.  If it&apos;s being killed,</span><br><span class="line">		 * drain it.  We can use wait_queue for the wait but this</span><br><span class="line">		 * path is super cold.  Let&apos;s just sleep a bit and retry.</span><br><span class="line">		 */</span><br><span class="line">		pinned_sb = kernfs_pin_sb(root-&gt;kf_root, NULL);</span><br><span class="line">		if (IS_ERR(pinned_sb) ||</span><br><span class="line">		    !percpu_ref_tryget_live(&amp;root-&gt;cgrp.self.refcnt)) &#123;</span><br><span class="line">			mutex_unlock(&amp;cgroup_mutex);</span><br><span class="line">			if (!IS_ERR_OR_NULL(pinned_sb))</span><br><span class="line">				deactivate_super(pinned_sb);</span><br><span class="line">			msleep(10);</span><br><span class="line">			ret = restart_syscall();</span><br><span class="line">			goto out_free;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ret = 0;</span><br><span class="line">		goto out_unlock;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * No such thing, create a new one.  name= matching without subsys</span><br><span class="line">	 * specification is allowed for already existing hierarchies but we</span><br><span class="line">	 * can&apos;t create new one without subsys specification.</span><br><span class="line">	 */</span><br><span class="line">	if (!opts.subsys_mask &amp;&amp; !opts.none) &#123;</span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">		goto out_unlock;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (4) 分配新的root */</span><br><span class="line">	root = kzalloc(sizeof(*root), GFP_KERNEL);</span><br><span class="line">	if (!root) &#123;</span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		goto out_unlock;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">     /* (5) 初始化新的root，初始了</span><br><span class="line">        root-&gt;cgrp          // cgrp-&gt;root = root;</span><br><span class="line">        root-&gt;cgrp.self     // cgrp-&gt;self.cgroup = cgrp; cgrp-&gt;self.flags |= CSS_ONLINE; </span><br><span class="line">        root-&gt;name = opts-&gt;name</span><br><span class="line">     */</span><br><span class="line">	init_cgroup_root(root, &amp;opts);</span><br><span class="line"></span><br><span class="line">    /* (6) 将新的root和opts.subsys_mask指向的多个ss进行链接 */</span><br><span class="line">	ret = cgroup_setup_root(root, opts.subsys_mask);</span><br><span class="line">	if (ret)</span><br><span class="line">		cgroup_free_root(root);</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">	mutex_unlock(&amp;cgroup_mutex);</span><br><span class="line">out_free:</span><br><span class="line">	kfree(opts.release_agent);</span><br><span class="line">	kfree(opts.name);</span><br><span class="line"></span><br><span class="line">	if (ret)</span><br><span class="line">		return ERR_PTR(ret);</span><br><span class="line"></span><br><span class="line">    /* (7) mount新root对应的根目录 */</span><br><span class="line">	dentry = kernfs_mount(fs_type, flags, root-&gt;kf_root,</span><br><span class="line">				CGROUP_SUPER_MAGIC, &amp;new_sb);</span><br><span class="line">	if (IS_ERR(dentry) || !new_sb)</span><br><span class="line">		cgroup_put(&amp;root-&gt;cgrp);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * If @pinned_sb, we&apos;re reusing an existing root and holding an</span><br><span class="line">	 * extra ref on its sb.  Mount is complete.  Put the extra ref.</span><br><span class="line">	 */</span><br><span class="line">	if (pinned_sb) &#123;</span><br><span class="line">		WARN_ON(new_sb);</span><br><span class="line">		deactivate_super(pinned_sb);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return dentry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">static int cgroup_setup_root(struct cgroup_root *root, unsigned long ss_mask)</span><br><span class="line">&#123;</span><br><span class="line">	LIST_HEAD(tmp_links);</span><br><span class="line">	struct cgroup *root_cgrp = &amp;root-&gt;cgrp;</span><br><span class="line">	struct css_set *cset;</span><br><span class="line">	int i, ret;</span><br><span class="line"></span><br><span class="line">	lockdep_assert_held(&amp;cgroup_mutex);</span><br><span class="line"></span><br><span class="line">	ret = cgroup_idr_alloc(&amp;root-&gt;cgroup_idr, root_cgrp, 1, 2, GFP_KERNEL);</span><br><span class="line">	if (ret &lt; 0)</span><br><span class="line">		goto out;</span><br><span class="line">	root_cgrp-&gt;id = ret;</span><br><span class="line"></span><br><span class="line">	ret = percpu_ref_init(&amp;root_cgrp-&gt;self.refcnt, css_release, 0,</span><br><span class="line">			      GFP_KERNEL);</span><br><span class="line">	if (ret)</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * We&apos;re accessing css_set_count without locking css_set_lock here,</span><br><span class="line">	 * but that&apos;s OK - it can only be increased by someone holding</span><br><span class="line">	 * cgroup_lock, and that&apos;s us. The worst that can happen is that we</span><br><span class="line">	 * have some link structures left over</span><br><span class="line">	 */</span><br><span class="line">	ret = allocate_cgrp_cset_links(css_set_count, &amp;tmp_links);</span><br><span class="line">	if (ret)</span><br><span class="line">		goto cancel_ref;</span><br><span class="line"></span><br><span class="line">	ret = cgroup_init_root_id(root);</span><br><span class="line">	if (ret)</span><br><span class="line">		goto cancel_ref;</span><br><span class="line"></span><br><span class="line">    /* (6.1) 创建root对应的顶层root文件夹 */</span><br><span class="line">	root-&gt;kf_root = kernfs_create_root(&amp;cgroup_kf_syscall_ops,</span><br><span class="line">					   KERNFS_ROOT_CREATE_DEACTIVATED,</span><br><span class="line">					   root_cgrp);</span><br><span class="line">	if (IS_ERR(root-&gt;kf_root)) &#123;</span><br><span class="line">		ret = PTR_ERR(root-&gt;kf_root);</span><br><span class="line">		goto exit_root_id;</span><br><span class="line">	&#125;</span><br><span class="line">	root_cgrp-&gt;kn = root-&gt;kf_root-&gt;kn;</span><br><span class="line"></span><br><span class="line">    /* (6.2) 创建cgroup自己对应的一些file，cgroup自己的file由cgroup自己的css(cgrp-&gt;self)承担，</span><br><span class="line">        后面cgroup会依次创建每个subsys的file，subsys的file由每个ss对应的css(cgrp-&gt;subsys[])承担</span><br><span class="line">     */</span><br><span class="line">	ret = css_populate_dir(&amp;root_cgrp-&gt;self, NULL);</span><br><span class="line">	if (ret)</span><br><span class="line">		goto destroy_root;</span><br><span class="line"></span><br><span class="line">    /* (6.3) 将新root需要的subsys和原默认root(cgrp_dfl_root)解除关系，</span><br><span class="line">        并且把这些ss重新和新root建立关系</span><br><span class="line">     */</span><br><span class="line">	ret = rebind_subsystems(root, ss_mask);</span><br><span class="line">	if (ret)</span><br><span class="line">		goto destroy_root;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * There must be no failure case after here, since rebinding takes</span><br><span class="line">	 * care of subsystems&apos; refcounts, which are explicitly dropped in</span><br><span class="line">	 * the failure exit path.</span><br><span class="line">	 */</span><br><span class="line">	list_add(&amp;root-&gt;root_list, &amp;cgroup_roots);</span><br><span class="line">	cgroup_root_count++;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Link the root cgroup in this hierarchy into all the css_set</span><br><span class="line">	 * objects.</span><br><span class="line">	 */</span><br><span class="line">	spin_lock_bh(&amp;css_set_lock);</span><br><span class="line">	hash_for_each(css_set_table, i, cset, hlist) &#123;</span><br><span class="line">		link_css_set(&amp;tmp_links, cset, root_cgrp);</span><br><span class="line">		if (css_set_populated(cset))</span><br><span class="line">			cgroup_update_populated(root_cgrp, true);</span><br><span class="line">	&#125;</span><br><span class="line">	spin_unlock_bh(&amp;css_set_lock);</span><br><span class="line"></span><br><span class="line">	BUG_ON(!list_empty(&amp;root_cgrp-&gt;self.children));</span><br><span class="line">	BUG_ON(atomic_read(&amp;root-&gt;nr_cgrps) != 1);</span><br><span class="line"></span><br><span class="line">	kernfs_activate(root_cgrp-&gt;kn);</span><br><span class="line">	ret = 0;</span><br><span class="line">	goto out;</span><br><span class="line"></span><br><span class="line">destroy_root:</span><br><span class="line">	kernfs_destroy_root(root-&gt;kf_root);</span><br><span class="line">	root-&gt;kf_root = NULL;</span><br><span class="line">exit_root_id:</span><br><span class="line">	cgroup_exit_root_id(root);</span><br><span class="line">cancel_ref:</span><br><span class="line">	percpu_ref_exit(&amp;root_cgrp-&gt;self.refcnt);</span><br><span class="line">out:</span><br><span class="line">	free_cgrp_cset_links(&amp;tmp_links);</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">||→</span><br><span class="line"></span><br><span class="line">static int rebind_subsystems(struct cgroup_root *dst_root,</span><br><span class="line">			     unsigned long ss_mask)</span><br><span class="line">&#123;</span><br><span class="line">	struct cgroup *dcgrp = &amp;dst_root-&gt;cgrp;</span><br><span class="line">	struct cgroup_subsys *ss;</span><br><span class="line">	unsigned long tmp_ss_mask;</span><br><span class="line">	int ssid, i, ret;</span><br><span class="line"></span><br><span class="line">	lockdep_assert_held(&amp;cgroup_mutex);</span><br><span class="line"></span><br><span class="line">	for_each_subsys_which(ss, ssid, &amp;ss_mask) &#123;</span><br><span class="line">		/* if @ss has non-root csses attached to it, can&apos;t move */</span><br><span class="line">		if (css_next_child(NULL, cgroup_css(&amp;ss-&gt;root-&gt;cgrp, ss)))</span><br><span class="line">			return -EBUSY;</span><br><span class="line"></span><br><span class="line">		/* can&apos;t move between two non-dummy roots either */</span><br><span class="line">		if (ss-&gt;root != &amp;cgrp_dfl_root &amp;&amp; dst_root != &amp;cgrp_dfl_root)</span><br><span class="line">			return -EBUSY;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* skip creating root files on dfl_root for inhibited subsystems */</span><br><span class="line">	tmp_ss_mask = ss_mask;</span><br><span class="line">	if (dst_root == &amp;cgrp_dfl_root)</span><br><span class="line">		tmp_ss_mask &amp;= ~cgrp_dfl_root_inhibit_ss_mask;</span><br><span class="line"></span><br><span class="line">	for_each_subsys_which(ss, ssid, &amp;tmp_ss_mask) &#123;</span><br><span class="line">		struct cgroup *scgrp = &amp;ss-&gt;root-&gt;cgrp;</span><br><span class="line">		int tssid;</span><br><span class="line"></span><br><span class="line">        /* (6.3.1) 在新root的根cgroup(dst_root-&gt;cgrp)下，</span><br><span class="line">            根据subsys的file链表(css-&gt;ss-&gt;cfts)创建subsys对应的file </span><br><span class="line">        */</span><br><span class="line">		ret = css_populate_dir(cgroup_css(scgrp, ss), dcgrp);</span><br><span class="line">		if (!ret)</span><br><span class="line">			continue;</span><br><span class="line"></span><br><span class="line">		/*</span><br><span class="line">		 * Rebinding back to the default root is not allowed to</span><br><span class="line">		 * fail.  Using both default and non-default roots should</span><br><span class="line">		 * be rare.  Moving subsystems back and forth even more so.</span><br><span class="line">		 * Just warn about it and continue.</span><br><span class="line">		 */</span><br><span class="line">		if (dst_root == &amp;cgrp_dfl_root) &#123;</span><br><span class="line">			if (cgrp_dfl_root_visible) &#123;</span><br><span class="line">				pr_warn(&quot;failed to create files (%d) while rebinding 0x%lx to default root\n&quot;,</span><br><span class="line">					ret, ss_mask);</span><br><span class="line">				pr_warn(&quot;you may retry by moving them to a different hierarchy and unbinding\n&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		for_each_subsys_which(ss, tssid, &amp;tmp_ss_mask) &#123;</span><br><span class="line">			if (tssid == ssid)</span><br><span class="line">				break;</span><br><span class="line">			css_clear_dir(cgroup_css(scgrp, ss), dcgrp);</span><br><span class="line">		&#125;</span><br><span class="line">		return ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Nothing can fail from this point on.  Remove files for the</span><br><span class="line">	 * removed subsystems and rebind each subsystem.</span><br><span class="line">	 */</span><br><span class="line">	for_each_subsys_which(ss, ssid, &amp;ss_mask) &#123;</span><br><span class="line">		struct cgroup_root *src_root = ss-&gt;root;</span><br><span class="line">		struct cgroup *scgrp = &amp;src_root-&gt;cgrp;</span><br><span class="line">		struct cgroup_subsys_state *css = cgroup_css(scgrp, ss);</span><br><span class="line">		struct css_set *cset;</span><br><span class="line"></span><br><span class="line">		WARN_ON(!css || cgroup_css(dcgrp, ss));</span><br><span class="line"></span><br><span class="line">		css_clear_dir(css, NULL);</span><br><span class="line"></span><br><span class="line">        /* (6.3.2) 取消原root cgroup对subsys的css的引用 */</span><br><span class="line">		RCU_INIT_POINTER(scgrp-&gt;subsys[ssid], NULL);</span><br><span class="line">		</span><br><span class="line">		/* (6.3.3) 链接新root cgroup和subsys的css的引用 */</span><br><span class="line">		rcu_assign_pointer(dcgrp-&gt;subsys[ssid], css);</span><br><span class="line">		ss-&gt;root = dst_root;</span><br><span class="line">		css-&gt;cgroup = dcgrp;</span><br><span class="line"></span><br><span class="line">		spin_lock_bh(&amp;css_set_lock);</span><br><span class="line">		hash_for_each(css_set_table, i, cset, hlist)</span><br><span class="line">			list_move_tail(&amp;cset-&gt;e_cset_node[ss-&gt;id],</span><br><span class="line">				       &amp;dcgrp-&gt;e_csets[ss-&gt;id]);</span><br><span class="line">		spin_unlock_bh(&amp;css_set_lock);</span><br><span class="line"></span><br><span class="line">		src_root-&gt;subsys_mask &amp;= ~(1 &lt;&lt; ssid);</span><br><span class="line">		scgrp-&gt;subtree_control &amp;= ~(1 &lt;&lt; ssid);</span><br><span class="line">		cgroup_refresh_child_subsys_mask(scgrp);</span><br><span class="line"></span><br><span class="line">		/* default hierarchy doesn&apos;t enable controllers by default */</span><br><span class="line">		dst_root-&gt;subsys_mask |= 1 &lt;&lt; ssid;</span><br><span class="line">		if (dst_root == &amp;cgrp_dfl_root) &#123;</span><br><span class="line">			static_branch_enable(cgroup_subsys_on_dfl_key[ssid]);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			dcgrp-&gt;subtree_control |= 1 &lt;&lt; ssid;</span><br><span class="line">			cgroup_refresh_child_subsys_mask(dcgrp);</span><br><span class="line">			static_branch_disable(cgroup_subsys_on_dfl_key[ssid]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (ss-&gt;bind)</span><br><span class="line">			ss-&gt;bind(css);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	kernfs_activate(dcgrp-&gt;kn);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5、文件操作</p>
<p>创建一个新文件夹，相当于创建一个新的cgroup。我们重点来看看新建文件夹的操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line">static struct kernfs_syscall_ops cgroup_kf_syscall_ops = &#123;</span><br><span class="line">	.remount_fs		= cgroup_remount,</span><br><span class="line">	.show_options		= cgroup_show_options,</span><br><span class="line">	.mkdir			= cgroup_mkdir,</span><br><span class="line">	.rmdir			= cgroup_rmdir,</span><br><span class="line">	.rename			= cgroup_rename,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int cgroup_mkdir(struct kernfs_node *parent_kn, const char *name,</span><br><span class="line">			umode_t mode)</span><br><span class="line">&#123;</span><br><span class="line">	struct cgroup *parent, *cgrp;</span><br><span class="line">	struct cgroup_root *root;</span><br><span class="line">	struct cgroup_subsys *ss;</span><br><span class="line">	struct kernfs_node *kn;</span><br><span class="line">	int ssid, ret;</span><br><span class="line"></span><br><span class="line">	/* Do not accept &apos;\n&apos; to prevent making /proc/&lt;pid&gt;/cgroup unparsable.</span><br><span class="line">	 */</span><br><span class="line">	if (strchr(name, &apos;\n&apos;))</span><br><span class="line">		return -EINVAL;</span><br><span class="line"></span><br><span class="line">	parent = cgroup_kn_lock_live(parent_kn);</span><br><span class="line">	if (!parent)</span><br><span class="line">		return -ENODEV;</span><br><span class="line">	root = parent-&gt;root;</span><br><span class="line"></span><br><span class="line">	/* allocate the cgroup and its ID, 0 is reserved for the root */</span><br><span class="line">	/* (1) 分配新的cgroup */</span><br><span class="line">	cgrp = kzalloc(sizeof(*cgrp), GFP_KERNEL);</span><br><span class="line">	if (!cgrp) &#123;</span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		goto out_unlock;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = percpu_ref_init(&amp;cgrp-&gt;self.refcnt, css_release, 0, GFP_KERNEL);</span><br><span class="line">	if (ret)</span><br><span class="line">		goto out_free_cgrp;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Temporarily set the pointer to NULL, so idr_find() won&apos;t return</span><br><span class="line">	 * a half-baked cgroup.</span><br><span class="line">	 */</span><br><span class="line">	cgrp-&gt;id = cgroup_idr_alloc(&amp;root-&gt;cgroup_idr, NULL, 2, 0, GFP_KERNEL);</span><br><span class="line">	if (cgrp-&gt;id &lt; 0) &#123;</span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		goto out_cancel_ref;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (2) 初始化cgroup */</span><br><span class="line">	init_cgroup_housekeeping(cgrp);</span><br><span class="line"></span><br><span class="line">    /* (3) 和父cgroup之间建立起关系 */</span><br><span class="line">	cgrp-&gt;self.parent = &amp;parent-&gt;self;</span><br><span class="line">	cgrp-&gt;root = root;</span><br><span class="line"></span><br><span class="line">	if (notify_on_release(parent))</span><br><span class="line">		set_bit(CGRP_NOTIFY_ON_RELEASE, &amp;cgrp-&gt;flags);</span><br><span class="line"></span><br><span class="line">	if (test_bit(CGRP_CPUSET_CLONE_CHILDREN, &amp;parent-&gt;flags))</span><br><span class="line">		set_bit(CGRP_CPUSET_CLONE_CHILDREN, &amp;cgrp-&gt;flags);</span><br><span class="line"></span><br><span class="line">	/* create the directory */</span><br><span class="line">	/* (3) 创建新的cgroup对应的文件夹 */</span><br><span class="line">	kn = kernfs_create_dir(parent-&gt;kn, name, mode, cgrp);</span><br><span class="line">	if (IS_ERR(kn)) &#123;</span><br><span class="line">		ret = PTR_ERR(kn);</span><br><span class="line">		goto out_free_id;</span><br><span class="line">	&#125;</span><br><span class="line">	cgrp-&gt;kn = kn;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * This extra ref will be put in cgroup_free_fn() and guarantees</span><br><span class="line">	 * that @cgrp-&gt;kn is always accessible.</span><br><span class="line">	 */</span><br><span class="line">	kernfs_get(kn);</span><br><span class="line"></span><br><span class="line">	cgrp-&gt;self.serial_nr = css_serial_nr_next++;</span><br><span class="line"></span><br><span class="line">	/* allocation complete, commit to creation */</span><br><span class="line">	list_add_tail_rcu(&amp;cgrp-&gt;self.sibling, &amp;cgroup_parent(cgrp)-&gt;self.children);</span><br><span class="line">	atomic_inc(&amp;root-&gt;nr_cgrps);</span><br><span class="line">	cgroup_get(parent);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * @cgrp is now fully operational.  If something fails after this</span><br><span class="line">	 * point, it&apos;ll be released via the normal destruction path.</span><br><span class="line">	 */</span><br><span class="line">	cgroup_idr_replace(&amp;root-&gt;cgroup_idr, cgrp, cgrp-&gt;id);</span><br><span class="line"></span><br><span class="line">	ret = cgroup_kn_set_ugid(kn);</span><br><span class="line">	if (ret)</span><br><span class="line">		goto out_destroy;</span><br><span class="line"></span><br><span class="line">    /* (4) 新cgroup文件夹下创建cgroup自己css对应的默认file */</span><br><span class="line">	ret = css_populate_dir(&amp;cgrp-&gt;self, NULL);</span><br><span class="line">	if (ret)</span><br><span class="line">		goto out_destroy;</span><br><span class="line"></span><br><span class="line">	/* let&apos;s create and online css&apos;s */</span><br><span class="line">	/* (5) 针对root对应的各个susbsys， 每个subsys创建新的css</span><br><span class="line">	    并且在cgroup文件夹下创建css对应的file</span><br><span class="line">	*/</span><br><span class="line">	for_each_subsys(ss, ssid) &#123;</span><br><span class="line">		if (parent-&gt;child_subsys_mask &amp; (1 &lt;&lt; ssid)) &#123;</span><br><span class="line">			ret = create_css(cgrp, ss,</span><br><span class="line">					 parent-&gt;subtree_control &amp; (1 &lt;&lt; ssid));</span><br><span class="line">			if (ret)</span><br><span class="line">				goto out_destroy;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * On the default hierarchy, a child doesn&apos;t automatically inherit</span><br><span class="line">	 * subtree_control from the parent.  Each is configured manually.</span><br><span class="line">	 */</span><br><span class="line">	if (!cgroup_on_dfl(cgrp)) &#123;</span><br><span class="line">		cgrp-&gt;subtree_control = parent-&gt;subtree_control;</span><br><span class="line">		cgroup_refresh_child_subsys_mask(cgrp);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	kernfs_activate(kn);</span><br><span class="line"></span><br><span class="line">	ret = 0;</span><br><span class="line">	goto out_unlock;</span><br><span class="line"></span><br><span class="line">out_free_id:</span><br><span class="line">	cgroup_idr_remove(&amp;root-&gt;cgroup_idr, cgrp-&gt;id);</span><br><span class="line">out_cancel_ref:</span><br><span class="line">	percpu_ref_exit(&amp;cgrp-&gt;self.refcnt);</span><br><span class="line">out_free_cgrp:</span><br><span class="line">	kfree(cgrp);</span><br><span class="line">out_unlock:</span><br><span class="line">	cgroup_kn_unlock(parent_kn);</span><br><span class="line">	return ret;</span><br><span class="line"></span><br><span class="line">out_destroy:</span><br><span class="line">	cgroup_destroy_locked(cgrp);</span><br><span class="line">	goto out_unlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>cgroup默认文件，有一些重要的文件比如“tasks”，我们来看看具体的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line">static struct cftype cgroup_legacy_base_files[] = &#123;</span><br><span class="line">	&#123;</span><br><span class="line">		.name = &quot;cgroup.procs&quot;,</span><br><span class="line">		.seq_start = cgroup_pidlist_start,</span><br><span class="line">		.seq_next = cgroup_pidlist_next,</span><br><span class="line">		.seq_stop = cgroup_pidlist_stop,</span><br><span class="line">		.seq_show = cgroup_pidlist_show,</span><br><span class="line">		.private = CGROUP_FILE_PROCS,</span><br><span class="line">		.write = cgroup_procs_write,</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		.name = &quot;cgroup.clone_children&quot;,</span><br><span class="line">		.read_u64 = cgroup_clone_children_read,</span><br><span class="line">		.write_u64 = cgroup_clone_children_write,</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		.name = &quot;cgroup.sane_behavior&quot;,</span><br><span class="line">		.flags = CFTYPE_ONLY_ON_ROOT,</span><br><span class="line">		.seq_show = cgroup_sane_behavior_show,</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		.name = &quot;tasks&quot;,</span><br><span class="line">		.seq_start = cgroup_pidlist_start,</span><br><span class="line">		.seq_next = cgroup_pidlist_next,</span><br><span class="line">		.seq_stop = cgroup_pidlist_stop,</span><br><span class="line">		.seq_show = cgroup_pidlist_show,</span><br><span class="line">		.private = CGROUP_FILE_TASKS,</span><br><span class="line">		.write = cgroup_tasks_write,</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		.name = &quot;notify_on_release&quot;,</span><br><span class="line">		.read_u64 = cgroup_read_notify_on_release,</span><br><span class="line">		.write_u64 = cgroup_write_notify_on_release,</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		.name = &quot;release_agent&quot;,</span><br><span class="line">		.flags = CFTYPE_ONLY_ON_ROOT,</span><br><span class="line">		.seq_show = cgroup_release_agent_show,</span><br><span class="line">		.write = cgroup_release_agent_write,</span><br><span class="line">		.max_write_len = PATH_MAX - 1,</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123; &#125;	/* terminate */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static ssize_t cgroup_tasks_write(struct kernfs_open_file *of,</span><br><span class="line">				  char *buf, size_t nbytes, loff_t off)</span><br><span class="line">&#123;</span><br><span class="line">	return __cgroup_procs_write(of, buf, nbytes, off, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">static ssize_t __cgroup_procs_write(struct kernfs_open_file *of, char *buf,</span><br><span class="line">				    size_t nbytes, loff_t off, bool threadgroup)</span><br><span class="line">&#123;</span><br><span class="line">	struct task_struct *tsk;</span><br><span class="line">	struct cgroup_subsys *ss;</span><br><span class="line">	struct cgroup *cgrp;</span><br><span class="line">	pid_t pid;</span><br><span class="line">	int ssid, ret;</span><br><span class="line"></span><br><span class="line">	if (kstrtoint(strstrip(buf), 0, &amp;pid) || pid &lt; 0)</span><br><span class="line">		return -EINVAL;</span><br><span class="line"></span><br><span class="line">	cgrp = cgroup_kn_lock_live(of-&gt;kn);</span><br><span class="line">	if (!cgrp)</span><br><span class="line">		return -ENODEV;</span><br><span class="line"></span><br><span class="line">	percpu_down_write(&amp;cgroup_threadgroup_rwsem);</span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	if (pid) &#123;</span><br><span class="line">		tsk = find_task_by_vpid(pid);</span><br><span class="line">		if (!tsk) &#123;</span><br><span class="line">			ret = -ESRCH;</span><br><span class="line">			goto out_unlock_rcu;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		tsk = current;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (threadgroup)</span><br><span class="line">		tsk = tsk-&gt;group_leader;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Workqueue threads may acquire PF_NO_SETAFFINITY and become</span><br><span class="line">	 * trapped in a cpuset, or RT worker may be born in a cgroup</span><br><span class="line">	 * with no rt_runtime allocated.  Just say no.</span><br><span class="line">	 */</span><br><span class="line">	if (tsk == kthreadd_task || (tsk-&gt;flags &amp; PF_NO_SETAFFINITY)) &#123;</span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">		goto out_unlock_rcu;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	get_task_struct(tsk);</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">	ret = cgroup_procs_write_permission(tsk, cgrp, of);</span><br><span class="line">	if (!ret) &#123;</span><br><span class="line">	    /* (1) attach task到cgroup */</span><br><span class="line">		ret = cgroup_attach_task(cgrp, tsk, threadgroup);</span><br><span class="line">#if defined(CONFIG_CPUSETS) &amp;&amp; !defined(CONFIG_MTK_ACAO)</span><br><span class="line">		if (cgrp-&gt;id != SS_TOP_GROUP_ID &amp;&amp; cgrp-&gt;child_subsys_mask == CSS_CPUSET_MASK</span><br><span class="line">		&amp;&amp; excl_task_count &gt; 0) &#123;</span><br><span class="line">			remove_set_exclusive_task(tsk-&gt;pid, 0);</span><br><span class="line">		&#125;</span><br><span class="line">#endif</span><br><span class="line">	&#125;</span><br><span class="line">	put_task_struct(tsk);</span><br><span class="line">	goto out_unlock_threadgroup;</span><br><span class="line"></span><br><span class="line">out_unlock_rcu:</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">out_unlock_threadgroup:</span><br><span class="line">	percpu_up_write(&amp;cgroup_threadgroup_rwsem);</span><br><span class="line">	for_each_subsys(ss, ssid)</span><br><span class="line">		if (ss-&gt;post_attach)</span><br><span class="line">			ss-&gt;post_attach();</span><br><span class="line">	cgroup_kn_unlock(of-&gt;kn);</span><br><span class="line">	return ret ?: nbytes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">||→</span><br><span class="line"></span><br><span class="line">static int cgroup_attach_task(struct cgroup *dst_cgrp,</span><br><span class="line">			      struct task_struct *leader, bool threadgroup)</span><br><span class="line">&#123;</span><br><span class="line">	LIST_HEAD(preloaded_csets);</span><br><span class="line">	struct task_struct *task;</span><br><span class="line">	int ret;</span><br><span class="line"></span><br><span class="line">	/* look up all src csets */</span><br><span class="line">	spin_lock_bh(&amp;css_set_lock);</span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	task = leader;</span><br><span class="line">	</span><br><span class="line">	/* (1.1) 遍历task所在线程组，把需要迁移的进程的css_set加入到preloaded_csets链表 */</span><br><span class="line">	do &#123;</span><br><span class="line">		cgroup_migrate_add_src(task_css_set(task), dst_cgrp,</span><br><span class="line">				       &amp;preloaded_csets);</span><br><span class="line">		if (!threadgroup)</span><br><span class="line">			break;</span><br><span class="line">	&#125; while_each_thread(leader, task);</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	spin_unlock_bh(&amp;css_set_lock);</span><br><span class="line"></span><br><span class="line">    /* (1.2) 去掉旧的css_set对css的应用, </span><br><span class="line">        分配新的css_set承担新的css组合的应用，并且给进程使用</span><br><span class="line">     */</span><br><span class="line">	/* prepare dst csets and commit */</span><br><span class="line">	ret = cgroup_migrate_prepare_dst(dst_cgrp, &amp;preloaded_csets);</span><br><span class="line">	if (!ret)</span><br><span class="line">		ret = cgroup_migrate(leader, threadgroup, dst_cgrp);</span><br><span class="line"></span><br><span class="line">	cgroup_migrate_finish(&amp;preloaded_csets);</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-3、cgroup-subsystem"><a href="#6-3、cgroup-subsystem" class="headerlink" title="6.3、cgroup subsystem"></a>6.3、cgroup subsystem</h2><p>我们关注cgroup子系统具体能提供的功能。</p>
<h3 id="6-3-1、cpu"><a href="#6-3-1、cpu" class="headerlink" title="6.3.1、cpu"></a>6.3.1、cpu</h3><p>kernel/sched/core.c。会创建新的task_group，可以对cgroup对应的task_group进行cfs/rt类型的带宽控制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">static struct cftype cpu_files[] = &#123;</span><br><span class="line">#ifdef CONFIG_FAIR_GROUP_SCHED</span><br><span class="line">	&#123;</span><br><span class="line">		.name = &quot;shares&quot;,</span><br><span class="line">		.read_u64 = cpu_shares_read_u64,</span><br><span class="line">		.write_u64 = cpu_shares_write_u64,</span><br><span class="line">	&#125;,</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_CFS_BANDWIDTH     // cfs 带宽控制</span><br><span class="line">	&#123;</span><br><span class="line">		.name = &quot;cfs_quota_us&quot;,</span><br><span class="line">		.read_s64 = cpu_cfs_quota_read_s64,</span><br><span class="line">		.write_s64 = cpu_cfs_quota_write_s64,</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		.name = &quot;cfs_period_us&quot;,</span><br><span class="line">		.read_u64 = cpu_cfs_period_read_u64,</span><br><span class="line">		.write_u64 = cpu_cfs_period_write_u64,</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		.name = &quot;stat&quot;,</span><br><span class="line">		.seq_show = cpu_stats_show,</span><br><span class="line">	&#125;,</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_RT_GROUP_SCHED    // rt 带宽控制</span><br><span class="line">	&#123;</span><br><span class="line">		.name = &quot;rt_runtime_us&quot;,</span><br><span class="line">		.read_s64 = cpu_rt_runtime_read,</span><br><span class="line">		.write_s64 = cpu_rt_runtime_write,</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		.name = &quot;rt_period_us&quot;,</span><br><span class="line">		.read_u64 = cpu_rt_period_read_uint,</span><br><span class="line">		.write_u64 = cpu_rt_period_write_uint,</span><br><span class="line">	&#125;,</span><br><span class="line">#endif</span><br><span class="line">	&#123; &#125;	/* terminate */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct cgroup_subsys cpu_cgrp_subsys = &#123;</span><br><span class="line">	.css_alloc	= cpu_cgroup_css_alloc,         // 分配新的task_group</span><br><span class="line">	.css_released	= cpu_cgroup_css_released,</span><br><span class="line">	.css_free	= cpu_cgroup_css_free,</span><br><span class="line">	.fork		= cpu_cgroup_fork,</span><br><span class="line">	.can_attach	= cpu_cgroup_can_attach,</span><br><span class="line">	.attach		= cpu_cgroup_attach,</span><br><span class="line">	.legacy_cftypes	= cpu_files,</span><br><span class="line">	.early_init	= 1,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="6-3-2、cpuset"><a href="#6-3-2、cpuset" class="headerlink" title="6.3.2、cpuset"></a>6.3.2、cpuset</h3><p>kernel/cpusec.c。给cgroup分配不同的cpu和mem node节点，还可以配置一些flag。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">static struct cftype files[] = &#123;</span><br><span class="line">	&#123;</span><br><span class="line">		.name = &quot;cpus&quot;,</span><br><span class="line">		.seq_show = cpuset_common_seq_show,</span><br><span class="line">		.write = cpuset_write_resmask,</span><br><span class="line">		.max_write_len = (100U + 6 * NR_CPUS),</span><br><span class="line">		.private = FILE_CPULIST,</span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		.name = &quot;mems&quot;,</span><br><span class="line">		.seq_show = cpuset_common_seq_show,</span><br><span class="line">		.write = cpuset_write_resmask,</span><br><span class="line">		.max_write_len = (100U + 6 * MAX_NUMNODES),</span><br><span class="line">		.private = FILE_MEMLIST,</span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		.name = &quot;effective_cpus&quot;,</span><br><span class="line">		.seq_show = cpuset_common_seq_show,</span><br><span class="line">		.private = FILE_EFFECTIVE_CPULIST,</span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		.name = &quot;effective_mems&quot;,</span><br><span class="line">		.seq_show = cpuset_common_seq_show,</span><br><span class="line">		.private = FILE_EFFECTIVE_MEMLIST,</span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		.name = &quot;cpu_exclusive&quot;,</span><br><span class="line">		.read_u64 = cpuset_read_u64,</span><br><span class="line">		.write_u64 = cpuset_write_u64,</span><br><span class="line">		.private = FILE_CPU_EXCLUSIVE,</span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		.name = &quot;mem_exclusive&quot;,</span><br><span class="line">		.read_u64 = cpuset_read_u64,</span><br><span class="line">		.write_u64 = cpuset_write_u64,</span><br><span class="line">		.private = FILE_MEM_EXCLUSIVE,</span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		.name = &quot;mem_hardwall&quot;,</span><br><span class="line">		.read_u64 = cpuset_read_u64,</span><br><span class="line">		.write_u64 = cpuset_write_u64,</span><br><span class="line">		.private = FILE_MEM_HARDWALL,</span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		.name = &quot;sched_load_balance&quot;,</span><br><span class="line">		.read_u64 = cpuset_read_u64,</span><br><span class="line">		.write_u64 = cpuset_write_u64,</span><br><span class="line">		.private = FILE_SCHED_LOAD_BALANCE,</span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		.name = &quot;sched_relax_domain_level&quot;,</span><br><span class="line">		.read_s64 = cpuset_read_s64,</span><br><span class="line">		.write_s64 = cpuset_write_s64,</span><br><span class="line">		.private = FILE_SCHED_RELAX_DOMAIN_LEVEL,</span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		.name = &quot;memory_migrate&quot;,</span><br><span class="line">		.read_u64 = cpuset_read_u64,</span><br><span class="line">		.write_u64 = cpuset_write_u64,</span><br><span class="line">		.private = FILE_MEMORY_MIGRATE,</span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		.name = &quot;memory_pressure&quot;,</span><br><span class="line">		.read_u64 = cpuset_read_u64,</span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		.name = &quot;memory_spread_page&quot;,</span><br><span class="line">		.read_u64 = cpuset_read_u64,</span><br><span class="line">		.write_u64 = cpuset_write_u64,</span><br><span class="line">		.private = FILE_SPREAD_PAGE,</span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		.name = &quot;memory_spread_slab&quot;,</span><br><span class="line">		.read_u64 = cpuset_read_u64,</span><br><span class="line">		.write_u64 = cpuset_write_u64,</span><br><span class="line">		.private = FILE_SPREAD_SLAB,</span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		.name = &quot;memory_pressure_enabled&quot;,</span><br><span class="line">		.flags = CFTYPE_ONLY_ON_ROOT,</span><br><span class="line">		.read_u64 = cpuset_read_u64,</span><br><span class="line">		.write_u64 = cpuset_write_u64,</span><br><span class="line">		.private = FILE_MEMORY_PRESSURE_ENABLED,</span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	&#123; &#125;	/* terminate */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct cgroup_subsys cpuset_cgrp_subsys = &#123;</span><br><span class="line">	.css_alloc	= cpuset_css_alloc,</span><br><span class="line">	.css_online	= cpuset_css_online,</span><br><span class="line">	.css_offline	= cpuset_css_offline,</span><br><span class="line">	.css_free	= cpuset_css_free,</span><br><span class="line">	.can_attach	= cpuset_can_attach,</span><br><span class="line">	.cancel_attach	= cpuset_cancel_attach,</span><br><span class="line">	.attach		= cpuset_attach,</span><br><span class="line">	.post_attach	= cpuset_post_attach,</span><br><span class="line">	.bind		= cpuset_bind,</span><br><span class="line">	.fork		= cpuset_fork,</span><br><span class="line">	.legacy_cftypes	= files,</span><br><span class="line">	.early_init	= 1,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="6-3-3、schedtune"><a href="#6-3-3、schedtune" class="headerlink" title="6.3.3、schedtune"></a>6.3.3、schedtune</h3><p>kernel/sched/tune.c，可以进行schedle boost操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static struct cftype files[] = &#123;</span><br><span class="line">	&#123;</span><br><span class="line">		.name = &quot;boost&quot;,</span><br><span class="line">		.read_u64 = boost_read,</span><br><span class="line">		.write_u64 = boost_write,</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		.name = &quot;prefer_idle&quot;,</span><br><span class="line">		.read_u64 = prefer_idle_read,</span><br><span class="line">		.write_u64 = prefer_idle_write,</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123; &#125;	/* terminate */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct cgroup_subsys schedtune_cgrp_subsys = &#123;</span><br><span class="line">	.css_alloc	= schedtune_css_alloc,</span><br><span class="line">	.css_free	= schedtune_css_free,</span><br><span class="line">	.legacy_cftypes	= files,</span><br><span class="line">	.early_init	= 1,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="6-3-4、cpuacct"><a href="#6-3-4、cpuacct" class="headerlink" title="6.3.4、cpuacct"></a>6.3.4、cpuacct</h3><p>kernel/sched/cpuacct.c，可以按照cgroup的分组来统计cpu占用率。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">static struct cftype files[] = &#123;</span><br><span class="line">	&#123;</span><br><span class="line">		.name = &quot;usage&quot;,</span><br><span class="line">		.read_u64 = cpuusage_read,</span><br><span class="line">		.write_u64 = cpuusage_write,</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		.name = &quot;usage_percpu&quot;,</span><br><span class="line">		.seq_show = cpuacct_percpu_seq_show,</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		.name = &quot;stat&quot;,</span><br><span class="line">		.seq_show = cpuacct_stats_show,</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123; &#125;	/* terminate */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct cgroup_subsys cpuacct_cgrp_subsys = &#123;</span><br><span class="line">	.css_alloc	= cpuacct_css_alloc,</span><br><span class="line">	.css_free	= cpuacct_css_free,</span><br><span class="line">	.legacy_cftypes	= files,</span><br><span class="line">	.early_init	= 1,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>1、<a href="http://blog.csdn.net/zhoudaxia/article/details/7375668" target="_blank" rel="noopener">linux 2.6 O(1)调度算法</a></p>
<p>2、<a href="http://www.cnblogs.com/openix/p/3254394.html" target="_blank" rel="noopener">linux cfs调度器_理论模型</a></p>
<p>3、<a href="http://blog.chinaunix.net/uid-27052262-id-3239260.html" target="_blank" rel="noopener">linux cfs调度框图</a></p>
<p>4、<a href="http://linuxperf.com/?p=42" target="_blank" rel="noopener">linux cfs之特殊时刻vruntime的计算</a></p>
<p>5、<a href="http://blog.csdn.net/helloanthea/article/details/30081627" target="_blank" rel="noopener">entity级负载的计算</a></p>
<p>6、<a href="http://blog.csdn.net/justlinux2010/article/details/17580583?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">cpu级负载的计算update_cpu_load</a></p>
<p>7、<a href="http://www.brendangregg.com/blog/2017-08-08/linux-load-averages.html" target="_blank" rel="noopener">系统级负载的计算:Linux Load Averages: Solving the Mystery</a></p>
<p>8、<a href="https://www.teamquest.com/import/pdfs/whitepaper/ldavg1.pdf" target="_blank" rel="noopener">系统级负载的计算:UNIX Load Average</a></p>
<p>9、<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-schldom/" target="_blank" rel="noopener">Linux Scheduling Domains</a></p>
<p>10、[MTK文档：CPU Utilization-scheduler(V1.1)]</p>
<p>10、<a href="http://www.infoq.com/cn/articles/docker-kernel-knowledge-cgroups-resource-isolation" target="_blank" rel="noopener">Docker背后的内核知识——cgroups资源限制</a></p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/scheduler-pelt-welt-EAS/" rel="tag"># scheduler, pelt, welt, EAS</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/12/21/ftrace_use_ftrace/" rel="prev" title="Linux Ftrace 2.1、ftrace的使用">
                Linux Ftrace 2.1、ftrace的使用 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/touxiang/ycqs.jpg" alt="pwl999">
            
              <p class="site-author-name" itemprop="name">pwl999</p>
              <p class="site-description motion-element" itemprop="description">RTFSC(Read The Fucking Source Code)</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives">
                
                    <span class="site-state-item-count">30</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">3</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">22</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1、Linux-schedule框架-调度的时刻"><span class="nav-number">1.</span> <span class="nav-text">1、Linux schedule框架(调度的时刻)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1、中心是rq-runqueue"><span class="nav-number">1.1.</span> <span class="nav-text">1.1、中心是rq(runqueue)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2、入rq-enqueue"><span class="nav-number">1.2.</span> <span class="nav-text">1.2、入rq(enqueue)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3、出rq-dequeue"><span class="nav-number">1.3.</span> <span class="nav-text">1.3、出rq(dequeue)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4、定时调度rq-scheduler-tick"><span class="nav-number">1.4.</span> <span class="nav-text">1.4、定时调度rq(scheduler_tick)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-5、中断-异常返回-Interrupt-Exception"><span class="nav-number">1.5.</span> <span class="nav-text">1.5、中断/异常返回(Interrupt/Exception)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-6、什么叫抢占-preempt-？"><span class="nav-number">1.6.</span> <span class="nav-text">1.6、什么叫抢占(preempt)？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-1、PREEMPT-ACTIVE标志"><span class="nav-number">1.6.1.</span> <span class="nav-text">1.6.1、PREEMPT_ACTIVE标志</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-7、代码分析"><span class="nav-number">1.7.</span> <span class="nav-text">1.7、代码分析</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2、调度算法"><span class="nav-number">2.</span> <span class="nav-text">2、调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1、linux2-6的O-1-调度算法"><span class="nav-number">2.1.</span> <span class="nav-text">2.1、linux2.6的O(1)调度算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2、CFS调度算法"><span class="nav-number">2.2.</span> <span class="nav-text">2.2、CFS调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-1、vruntime"><span class="nav-number">2.2.1.</span> <span class="nav-text">2.2.1、vruntime</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-2、period和ideal-runtime"><span class="nav-number">2.2.2.</span> <span class="nav-text">2.2.2、period和ideal_runtime</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-3、红黑树-Red-Black-Tree"><span class="nav-number">2.2.3.</span> <span class="nav-text">2.2.3、红黑树(Red Black Tree)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-4、sched-entity和task-group"><span class="nav-number">2.2.4.</span> <span class="nav-text">2.2.4、sched_entity和task_group</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-5、scheduler-tick"><span class="nav-number">2.2.5.</span> <span class="nav-text">2.2.5、scheduler_tick()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-6、几个特殊时刻vruntime的变化"><span class="nav-number">2.2.6.</span> <span class="nav-text">2.2.6、几个特殊时刻vruntime的变化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-7、cfs-bandwidth"><span class="nav-number">2.2.7.</span> <span class="nav-text">2.2.7、cfs bandwidth</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-8、sched-sysctl参数"><span class="nav-number">2.2.8.</span> <span class="nav-text">2.2.8、sched sysctl参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-9、”-proc-sched-debug”"><span class="nav-number">2.2.9.</span> <span class="nav-text">2.2.9、”/proc/sched_debug”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-10、”-proc-schedstat”-amp-“-proc-pid-schedstat”"><span class="nav-number">2.2.10.</span> <span class="nav-text">2.2.10、”/proc/schedstat” &amp; “/proc/pid/schedstat”</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3、RT调度算法"><span class="nav-number">2.3.</span> <span class="nav-text">2.3、RT调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-1、task-tick-rt"><span class="nav-number">2.3.1.</span> <span class="nav-text">2.3.1、task_tick_rt()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-2、rq-gt-rt-avg"><span class="nav-number">2.3.2.</span> <span class="nav-text">2.3.2、rq-&gt;rt_avg</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-3、rt-bandwidth-rt-throttle"><span class="nav-number">2.3.3.</span> <span class="nav-text">2.3.3、rt bandwidth(rt-throttle)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3、负载计算"><span class="nav-number">3.</span> <span class="nav-text">3、负载计算</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1、PELT-Per-Entity-Load-Tracking-Entity级的负载计算"><span class="nav-number">3.1.</span> <span class="nav-text">3.1、PELT(Per-Entity Load Tracking)Entity级的负载计算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-1、核心函数-update-load-avg"><span class="nav-number">3.1.1.</span> <span class="nav-text">3.1.1、核心函数__update_load_avg()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2、cpu级的负载计算update-cpu-load-active"><span class="nav-number">3.2.</span> <span class="nav-text">3.2、cpu级的负载计算update_cpu_load_active()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3、系统级的负载计算calc-global-load-tick"><span class="nav-number">3.3.</span> <span class="nav-text">3.3、系统级的负载计算calc_global_load_tick()</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-1、calc-global-load-tick"><span class="nav-number">3.3.1.</span> <span class="nav-text">3.3.1、calc_global_load_tick()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-占用率统计"><span class="nav-number">3.4.</span> <span class="nav-text">3.4 占用率统计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-1、cputime-c"><span class="nav-number">3.4.1.</span> <span class="nav-text">3.4.1、cputime.c</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4、负载均衡"><span class="nav-number">4.</span> <span class="nav-text">4、负载均衡</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1、SMP负载均衡"><span class="nav-number">4.1.</span> <span class="nav-text">4.1、SMP负载均衡</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-1、Scheduling-Domains"><span class="nav-number">4.1.1.</span> <span class="nav-text">4.1.1、Scheduling Domains</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-1-1、Scheduling-Domains概念"><span class="nav-number">4.1.1.1.</span> <span class="nav-text">4.1.1.1、Scheduling Domains概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-1-2、arm64-cpu-topology"><span class="nav-number">4.1.1.2.</span> <span class="nav-text">4.1.1.2、arm64 cpu_topology</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-1-3、Scheduling-Domains的初始化"><span class="nav-number">4.1.1.3.</span> <span class="nav-text">4.1.1.3、Scheduling Domains的初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-1-4、mt6799的Scheduling-Domains"><span class="nav-number">4.1.1.4.</span> <span class="nav-text">4.1.1.4、mt6799的Scheduling Domains</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-2、smp负载均衡的实现"><span class="nav-number">4.1.2.</span> <span class="nav-text">4.1.2、smp负载均衡的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-2-1、rebalance-domains"><span class="nav-number">4.1.2.1.</span> <span class="nav-text">4.1.2.1、rebalance_domains()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-2-2、nohz-idle-balance"><span class="nav-number">4.1.2.2.</span> <span class="nav-text">4.1.2.2、nohz_idle_balance()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-2-3、select-task-rq-fair"><span class="nav-number">4.1.2.3.</span> <span class="nav-text">4.1.2.3、select_task_rq_fair()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2、HMP负载均衡"><span class="nav-number">4.2.</span> <span class="nav-text">4.2、HMP负载均衡</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-1、hmp-domain初始化"><span class="nav-number">4.2.1.</span> <span class="nav-text">4.2.1、hmp domain初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-2、hmp-force-up-migration"><span class="nav-number">4.2.2.</span> <span class="nav-text">4.2.2、hmp_force_up_migration()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-3、hmp-force-down-migration"><span class="nav-number">4.2.3.</span> <span class="nav-text">4.2.3、hmp_force_down_migration()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-4、hmp-select-task-rq-fair"><span class="nav-number">4.2.4.</span> <span class="nav-text">4.2.4、hmp_select_task_rq_fair()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3、cpu-freq调整"><span class="nav-number">4.3.</span> <span class="nav-text">4.3、cpu freq调整</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-1、cpufreq-core-amp-cpufreq-driver"><span class="nav-number">4.3.1.</span> <span class="nav-text">4.3.1、cpufreq core &amp; cpufreq driver</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-1-1、cpufreq-policy-policy初始化"><span class="nav-number">4.3.1.1.</span> <span class="nav-text">4.3.1.1、cpufreq_policy policy初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-1-2、cpufrep的频率配置"><span class="nav-number">4.3.1.2.</span> <span class="nav-text">4.3.1.2、cpufrep的频率配置</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-2、interactive-governor"><span class="nav-number">4.3.2.</span> <span class="nav-text">4.3.2、interactive governor</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-2-1、interactive-governor的初始化"><span class="nav-number">4.3.2.1.</span> <span class="nav-text">4.3.2.1、interactive governor的初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-2-2、interactive-governor的算法"><span class="nav-number">4.3.2.2.</span> <span class="nav-text">4.3.2.2、interactive governor的算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4、cpu-hotplug调整"><span class="nav-number">4.4.</span> <span class="nav-text">4.4、cpu hotplug调整</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-1、hotplug-底层实现"><span class="nav-number">4.4.1.</span> <span class="nav-text">4.4.1、hotplug 底层实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-1-1、cpu-cup-cpu-down"><span class="nav-number">4.4.1.1.</span> <span class="nav-text">4.4.1.1、cpu_cup()/cpu_down()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-1-2、hotplug-进程迁移"><span class="nav-number">4.4.1.2.</span> <span class="nav-text">4.4.1.2、hotplug 进程迁移</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-2、MTK-hotplug算法"><span class="nav-number">4.4.2.</span> <span class="nav-text">4.4.2、MTK hotplug算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-2-1、HICA-PPM"><span class="nav-number">4.4.2.1.</span> <span class="nav-text">4.4.2.1、HICA/PPM</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-2-2、hps-algo-main"><span class="nav-number">4.4.2.2.</span> <span class="nav-text">4.4.2.2、hps_algo_main</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-5、NUMA负载均衡"><span class="nav-number">4.5.</span> <span class="nav-text">4.5、NUMA负载均衡</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5、EAS-Energy-Aware-Scheduling"><span class="nav-number">5.</span> <span class="nav-text">5、EAS(Energy-Aware Scheduling)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1、smp-rebalance"><span class="nav-number">5.1.</span> <span class="nav-text">5.1、smp rebalance</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-1、rebalance-domains"><span class="nav-number">5.1.1.</span> <span class="nav-text">5.1.1、rebalance_domains()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-2、select-task-rq-fair"><span class="nav-number">5.1.2.</span> <span class="nav-text">5.1.2、select_task_rq_fair()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2、cpufreq-sched-schedutil-governor"><span class="nav-number">5.2.</span> <span class="nav-text">5.2、cpufreq_sched/schedutil governor</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-1、rt-request"><span class="nav-number">5.2.1.</span> <span class="nav-text">5.2.1、rt request</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-2、cfs-request"><span class="nav-number">5.2.2.</span> <span class="nav-text">5.2.2、cfs request</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-3、freq-target"><span class="nav-number">5.2.3.</span> <span class="nav-text">5.2.3、freq target</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3、WALT-Windows-Assisted-Load-Tracking"><span class="nav-number">5.3.</span> <span class="nav-text">5.3、WALT(Windows Assisted Load Tracking)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-1、WALT的负载计算"><span class="nav-number">5.3.1.</span> <span class="nav-text">5.3.1、WALT的负载计算</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-1-1、update-task-ravg"><span class="nav-number">5.3.1.1.</span> <span class="nav-text">5.3.1.1、update_task_ravg()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-2、基于WALT的负载均衡"><span class="nav-number">5.3.2.</span> <span class="nav-text">5.3.2、基于WALT的负载均衡</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-2-1、load-balance"><span class="nav-number">5.3.2.1.</span> <span class="nav-text">5.3.2.1、load_balance()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-2-2、nohz-idle-balance"><span class="nav-number">5.3.2.2.</span> <span class="nav-text">5.3.2.2、nohz_idle_balance()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-2-3、select-task-rq-fair"><span class="nav-number">5.3.2.3.</span> <span class="nav-text">5.3.2.3、select_task_rq_fair()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-2-4、Interaction-Governor-amp-sched-load"><span class="nav-number">5.3.2.4.</span> <span class="nav-text">5.3.2.4、Interaction Governor &amp; sched_load</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6、Cgoup"><span class="nav-number">6.</span> <span class="nav-text">6、Cgoup</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1、cgroup概念"><span class="nav-number">6.1.</span> <span class="nav-text">6.1、cgroup概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2、代码分析"><span class="nav-number">6.2.</span> <span class="nav-text">6.2、代码分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3、cgroup-subsystem"><span class="nav-number">6.3.</span> <span class="nav-text">6.3、cgroup subsystem</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-1、cpu"><span class="nav-number">6.3.1.</span> <span class="nav-text">6.3.1、cpu</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-2、cpuset"><span class="nav-number">6.3.2.</span> <span class="nav-text">6.3.2、cpuset</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-3、schedtune"><span class="nav-number">6.3.3.</span> <span class="nav-text">6.3.3、schedtune</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-4、cpuacct"><span class="nav-number">6.3.4.</span> <span class="nav-text">6.3.4、cpuacct</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考资料"><span class="nav-number">7.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">pwl999</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v6.6.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script src="/js/src/utils.js?v=6.6.0"></script>

  <script src="/js/src/motion.js?v=6.6.0"></script>



  
  


  <script src="/js/src/affix.js?v=6.6.0"></script>

  <script src="/js/src/schemes/pisces.js?v=6.6.0"></script>



  
  <script src="/js/src/scrollspy.js?v=6.6.0"></script>
<script src="/js/src/post-details.js?v=6.6.0"></script>



  


  <script src="/js/src/bootstrap.js?v=6.6.0"></script>



  

  
    <script id="dsq-count-scr" src="https://.disqus.com/count.js" async></script>
  

  
    <script>
      var disqus_config = function () {
        this.page.url = "http://yoursite.com/2018/12/21/linux_scheduler/";
        this.page.identifier = "2018/12/21/linux_scheduler/";
        this.page.title = 'Linux Schedule';
        };
      function loadComments () {
        var d = document, s = d.createElement('script');
        s.src = 'https://.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      }
      
        loadComments();
      
    </script>
  





  











  





  

  

  

  

  

  
  

  

  

  

  

  

  

</body>
</html>
