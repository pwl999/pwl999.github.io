<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
































<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.6.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.6.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.6.0" color="#222">









<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.6.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="关于bpf最早是应用于network的filter，后续才被应用到trace，所以kernel中关于bpf的文档是”Documentation/networking/filter.txt”。 参考原文：Linux Socket Filtering aka Berkeley Packet Filter (BPF) 1、简介：LSF(Linux Socket Filtering)是从BPF(Berke">
<meta name="keywords" content="BPF">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux BPF 3.1、Berkeley Packet Filter (BPF) (Kernel Document)">
<meta property="og:url" content="http://yoursite.com/2018/12/21/bpf_kernel_doc/index.html">
<meta property="og:site_name" content="pwl999&#39;s blog">
<meta property="og:description" content="关于bpf最早是应用于network的filter，后续才被应用到trace，所以kernel中关于bpf的文档是”Documentation/networking/filter.txt”。 参考原文：Linux Socket Filtering aka Berkeley Packet Filter (BPF) 1、简介：LSF(Linux Socket Filtering)是从BPF(Berke">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-12-21T03:28:08.012Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Linux BPF 3.1、Berkeley Packet Filter (BPF) (Kernel Document)">
<meta name="twitter:description" content="关于bpf最早是应用于network的filter，后续才被应用到trace，所以kernel中关于bpf的文档是”Documentation/networking/filter.txt”。 参考原文：Linux Socket Filtering aka Berkeley Packet Filter (BPF) 1、简介：LSF(Linux Socket Filtering)是从BPF(Berke">






  <link rel="canonical" href="http://yoursite.com/2018/12/21/bpf_kernel_doc/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Linux BPF 3.1、Berkeley Packet Filter (BPF) (Kernel Document) | pwl999's blog</title>
  












  <noscript>
  <style>
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion .logo-line-before i { left: initial; }
    .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">pwl999's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/21/bpf_kernel_doc/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="pwl999">
      <meta itemprop="description" content="RTFSC(Read The Fucking Source Code)">
      <meta itemprop="image" content="/images/touxiang/ycqs.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="pwl999's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Linux BPF 3.1、Berkeley Packet Filter (BPF) (Kernel Document)

              
            
          </h1>
        

        <div class="post-meta">

          

        <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-21 10:18:21 / 修改时间：11:28:08" itemprop="dateCreated datePublished" datetime="2018-12-21T10:18:21+08:00">2018-12-21</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/Trace/" itemprop="url" rel="index"><span itemprop="name">Trace</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>关于bpf最早是应用于network的filter，后续才被应用到trace，所以kernel中关于bpf的文档是”Documentation/networking/filter.txt”。</p>
<p>参考原文：<a href="https://www.kernel.org/doc/Documentation/networking/filter.txt" target="_blank" rel="noopener">Linux Socket Filtering aka Berkeley Packet Filter (BPF)</a></p>
<h1 id="1、简介："><a href="#1、简介：" class="headerlink" title="1、简介："></a>1、简介：</h1><p>LSF(Linux Socket Filtering)是从BPF(Berkeley Packet Filter)派生而来。尽管BSD和Linux kernel的过滤(filter)有一些明显的区别，但是当我们在linux环境中谈到BPF或LSF时，我们指的在Linux kernel中完全相同的过滤机制。</p>
<p>BPF允许用户空间程序将一个过滤(filter)附加到任何的套接字(socket)上面用来允许或不允许某些类型的数据通过socket。LSF遵循和BSD’s BPF相同的filter代码架构，所以参考BSD bpf.4的man手册在创建filter时非常有帮助。</p>
<p>在Linux上，BPF比在BSD上简单的多。不需要担心devices之类的事情。你只需要简单的创建你的filter代码，通过SO_ATTTACH_FILTER选项发送到内核，并且你的filter代码能通过内核的检查，这样你就可以立即过滤socket上面的数据了。</p>
<p>你还可以通过SO_DETACH_FILTER选项把filter从socket上移除。这可能不会被经常使用，因为当你关闭socket的时候如果有filter会被自动移除。另外一个不太常见的情况是在同一个socket上添加不同的filter，当你还有另一个filter正在运行：如果你的新filter代码能够通过内核检查，内核小心的把旧的filter移除把新的filter换上，如果检查失败旧的filter将继续保留在socket上。</p>
<p>SO_LOCK_FILTER选项运行锁定附加到socket上的filter。一旦设置，filter不能被移除或者改变。这种允许一个进程设置一个socket、附加一个filter、锁定它们并放弃特权，确保这个filter保持到socket的关闭。</p>
<p>这个构造最大的用户是libpcap。发布一个高级别的filter命令类似’tcpdump -i em1 port 22’，通过libpcap内部的编译器生成一个结构，最终通过SO_ATTACH_FILTER加载到内核。’tcpdump -i em1 port 22 -ddd’命令能够显示放到这个结构中的内容。</p>
<p>尽管我们这里只是讨论了soket，BPF在linux中应用到了很多地方。xt_bpf对netfilter，cls_bpf在内核的qdisk层，SECCOMP-BPF(SECure COMPuting<a href="[Documentation/userspace-api/seccomp_filter.rst](Documentation/userspace-api/seccomp_filter.rst)">^seccomp_filter</a>)，以及一系列其他地方例如：team driver、PTP code等BPF都被用到。</p>
<p>原始的BPF论文：<br>Steven McCanne和Van Jacobson, 1993。“The BSD packet filter: a new<br>architecture for user-level packet capture. ”。在USENIX冬季1993会议论文集会议论文集(USENIX ‘ 93)。USENIX协会伯克利分校美国CA,2 - 2。<a href="http://www.tcpdump.org/papers/bpf-usenix93.pdf" target="_blank" rel="noopener">http://www.tcpdump.org/papers/bpf-usenix93.pdf</a></p>
<h1 id="2、filter-code结构"><a href="#2、filter-code结构" class="headerlink" title="2、filter code结构"></a>2、filter code结构</h1><p>用户空间的应用include &lt;linux/filter.h&gt;头文件包含以下的相关结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct sock_filter &#123;	/* Filter block */</span><br><span class="line">	__u16	code;   /* Actual filter code */</span><br><span class="line">	__u8	jt;	/* Jump true */</span><br><span class="line">	__u8	jf;	/* Jump false */</span><br><span class="line">	__u32	k;      /* Generic multiuse field */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样的结构被组装成一个4元数组，包含：code、jt、jf和K值。jt和jf是跳转偏移量，k是一个通用值提供给code使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct sock_fprog &#123;			/* Required for SO_ATTACH_FILTER. */</span><br><span class="line">	unsigned short		   len;	/* Number of filter blocks */</span><br><span class="line">	struct sock_filter __user *filter;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对socket过滤，一个指向上述结构的指针通过setsockopt(2)系统调用传递给内核。</p>
<h2 id="2-1、filter实例"><a href="#2-1、filter实例" class="headerlink" title="2.1、filter实例"></a>2.1、filter实例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;linux/if_ether.h&gt;</span><br><span class="line">/* ... */</span><br><span class="line"></span><br><span class="line">/* From the example above: tcpdump -i em1 port 22 -dd */</span><br><span class="line">struct sock_filter code[] = &#123;</span><br><span class="line">	&#123; 0x28,  0,  0, 0x0000000c &#125;,</span><br><span class="line">	&#123; 0x15,  0,  8, 0x000086dd &#125;,</span><br><span class="line">	&#123; 0x30,  0,  0, 0x00000014 &#125;,</span><br><span class="line">	&#123; 0x15,  2,  0, 0x00000084 &#125;,</span><br><span class="line">	&#123; 0x15,  1,  0, 0x00000006 &#125;,</span><br><span class="line">	&#123; 0x15,  0, 17, 0x00000011 &#125;,</span><br><span class="line">	&#123; 0x28,  0,  0, 0x00000036 &#125;,</span><br><span class="line">	&#123; 0x15, 14,  0, 0x00000016 &#125;,</span><br><span class="line">	&#123; 0x28,  0,  0, 0x00000038 &#125;,</span><br><span class="line">	&#123; 0x15, 12, 13, 0x00000016 &#125;,</span><br><span class="line">	&#123; 0x15,  0, 12, 0x00000800 &#125;,</span><br><span class="line">	&#123; 0x30,  0,  0, 0x00000017 &#125;,</span><br><span class="line">	&#123; 0x15,  2,  0, 0x00000084 &#125;,</span><br><span class="line">	&#123; 0x15,  1,  0, 0x00000006 &#125;,</span><br><span class="line">	&#123; 0x15,  0,  8, 0x00000011 &#125;,</span><br><span class="line">	&#123; 0x28,  0,  0, 0x00000014 &#125;,</span><br><span class="line">	&#123; 0x45,  6,  0, 0x00001fff &#125;,</span><br><span class="line">	&#123; 0xb1,  0,  0, 0x0000000e &#125;,</span><br><span class="line">	&#123; 0x48,  0,  0, 0x0000000e &#125;,</span><br><span class="line">	&#123; 0x15,  2,  0, 0x00000016 &#125;,</span><br><span class="line">	&#123; 0x48,  0,  0, 0x00000010 &#125;,</span><br><span class="line">	&#123; 0x15,  0,  1, 0x00000016 &#125;,</span><br><span class="line">	&#123; 0x06,  0,  0, 0x0000ffff &#125;,</span><br><span class="line">	&#123; 0x06,  0,  0, 0x00000000 &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct sock_fprog bpf = &#123;</span><br><span class="line">	.len = ARRAY_SIZE(code),</span><br><span class="line">	.filter = code,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">sock = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_ALL));</span><br><span class="line">if (sock &lt; 0)</span><br><span class="line">	/* ... bail out ... */</span><br><span class="line"></span><br><span class="line">ret = setsockopt(sock, SOL_SOCKET, SO_ATTACH_FILTER, &amp;bpf, sizeof(bpf));</span><br><span class="line">if (ret &lt; 0)</span><br><span class="line">	/* ... bail out ... */</span><br><span class="line"></span><br><span class="line">/* ... */</span><br><span class="line">close(sock);</span><br></pre></td></tr></table></figure>
<p>上述实例代码附加一个socket filter到一个PF_PACKET socket上，为了让所有IPv4/IPv6 port 22的包通过。这个socket上所有其他的包将会被丢弃。</p>
<p>setsockopt(2)调用SO_DETACH_FILTER不需要任何参数，调用SO_LOCK_FILTER来预防filter被解绑附带一个整数参数0或1.</p>
<p>注意socket filter没有限制仅仅用在PF_PACKET socket上，也可以用于其他socket家族。</p>
<p>相关系统调用概要：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* setsockopt(sockfd, SOL_SOCKET, SO_ATTACH_FILTER, &amp;val, sizeof(val));</span><br><span class="line">* setsockopt(sockfd, SOL_SOCKET, SO_DETACH_FILTER, &amp;val, sizeof(val));</span><br><span class="line">* setsockopt(sockfd, SOL_SOCKET, SO_LOCK_FILTER,   &amp;val, sizeof(val));</span><br></pre></td></tr></table></figure>
<p>通常，大多数对包socket上socket filter的使用已经被libpcap高层次的语法所覆盖，作为应用开发人员应当坚持使用。libpcap wraps是它的封装层。</p>
<p>除非：</p>
<ul>
<li>i) 使用/链接libpcap不是选项；  </li>
<li>ii) 需要的BPF filter使用了linux扩展，libpcap的编译器不支持；  </li>
<li>iii) filter可能更复杂，不能由libpcap编译器清晰的实现；  </li>
<li>iv) 特定的filter代码需要被优化成和libpcap内部编译器不同，在这种情况下“手工”编写filter可能是一种选择。例如，xt_bpf和cls_bpf用户有可能产生的需求需要更复杂的filter代码或者不能使用libpcap表达(例如不同代码路径对应不同返回码)。此外，BPF JIT实现者希望手工写测试用例，因此需要低层次的访问BPF代码。</li>
</ul>
<h1 id="3、BPF引擎和指令集"><a href="#3、BPF引擎和指令集" class="headerlink" title="3、BPF引擎和指令集"></a>3、BPF引擎和指令集</h1><p>在/tools/bpf路径下有个小的辅助工具叫做bpf_asm，它可以用来写低层次的filter例如上一节提到的实例场景。这里提到的asm类似的语法在bsp_asm中实现，并且会用来做进一步的解析(用来替代直接操作可读性差的opcodes，原理上是相同的)。语法以 Steven McCanne’s和Van Jacobson’s的BPF论文为原型。</p>
<p>BPF架构以下列基本的元素组成：</p>
<table border="1"><br><caption> BPF architecture element </caption><br><br><tr><br><th style="width: 200px;">Element</th><br><th style="width: 600px;">Description</th><br></tr><br><br><tr><br><td> A </td><br><td><br>32 bit wide accumulator<br></td><br></tr><br><br><tr><br><td> X </td><br><td><br>32 bit wide X register<br></td><br></tr><br><br><tr><br><td> M[] </td><br><td><br>16 x 32 bit wide misc registers aka “scratch memory store”, addressable from 0 to 15<br></td><br></tr><br><br></table>

<p>一个程序可以被bpf_asm翻译成”opcodes”，即一个由下列元素组成的数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">op:16, jt:8, jf:8, k:32</span><br></pre></td></tr></table></figure>
<p>其中op元素是一个16位宽的操作码，具有特定的指令编码。jt和jf是两个8位宽的跳转目标，一个用于条件“跳转如果真”，另一个“跳转如果假”。最后k元素包含一个可以用不同方式解析的杂项参数，依赖于op给定的指令。</p>
<p>指令集由load、store、branch、alu、misc和return几种类型的指令组成，这些指令也使用bpf_asm语法表示。这个表列出了bpf_asm所有的指令。他们的底层opcode在linux/filter.h中定义：</p>
<table border="1"><br><caption> BPF instruction set </caption><br><br><tr><br><th style="width: 200px;">Instruction</th><br><th style="width: 200px;">Addressing mode</th><br><th style="width: 400px;">Description</th><br></tr><br><br><tr><br><td> ld </td><br><td><br>1, 2, 3, 4, 10<br></td><br><td><br>Load word into A<br></td><br></tr><br><br><tr><br><td> ldi </td><br><td><br>4<br></td><br><td><br>Load word into A<br></td><br></tr><br><br><tr><br><td> ldh </td><br><td><br>1, 2<br></td><br><td><br>Load half-word into A<br></td><br></tr><br><br><tr><br><td> ldb </td><br><td><br>1, 2<br></td><br><td><br>Load byte into A<br></td><br></tr><br><br><tr><br><td> ldx </td><br><td><br>3, 4, 5, 10<br></td><br><td><br>Load word into X<br></td><br></tr><br><br><tr><br><td> ldxi </td><br><td><br>4<br></td><br><td><br>Load word into X<br></td><br></tr><br><br><tr><br><td> ldxb </td><br><td><br>5<br></td><br><td><br>Load word into X<br></td><br></tr><br><br><tr><br><td>   </td><br><td><br></td><br><td><br></td><br></tr><br><br><tr><br><td> st </td><br><td><br>3<br></td><br><td><br>Store A into M[]<br></td><br></tr><br><br><tr><br><td> stx </td><br><td><br>3<br></td><br><td><br>Store X into M[]<br></td><br></tr><br><br><tr><br><td>   </td><br><td><br></td><br><td><br></td><br></tr><br><br><tr><br><td> jmp </td><br><td><br>6<br></td><br><td><br>Jump to label<br></td><br></tr><br><br><tr><br><td> ja </td><br><td><br>6<br></td><br><td><br>Jump to label<br></td><br></tr><br><br><tr><br><td> jeq </td><br><td><br>7, 8<br></td><br><td><br>Jump on A == k<br></td><br></tr><br><br><tr><br><td> jneq </td><br><td><br>8<br></td><br><td><br>Jump on A != k<br></td><br></tr><br><br><tr><br><td> jne </td><br><td><br>8<br></td><br><td><br>Jump on A != k<br></td><br></tr><br><br><tr><br><td> jlt </td><br><td><br>8<br></td><br><td><br>Jump on A &lt;  k<br></td><br></tr><br><br><tr><br><td> jle </td><br><td><br>8<br></td><br><td><br>Jump on A &lt;= k<br></td><br></tr><br><br><tr><br><td> jgt </td><br><td><br>7, 8<br></td><br><td><br>Jump on A &gt;  k<br></td><br></tr><br><br><tr><br><td> jge </td><br><td><br>7, 8<br></td><br><td><br>Jump on A &gt;= k<br></td><br></tr><br><br><tr><br><td> jset </td><br><td><br>7, 8<br></td><br><td><br>Jump on A &amp;  k<br></td><br></tr><br><br><tr><br><td>   </td><br><td><br></td><br><td><br></td><br></tr><br><br><tr><br><td> add </td><br><td><br>0, 4<br></td><br><td><br>A + <x><br></x></td><br></tr><br><br><tr><br><td> sub </td><br><td><br>0, 4<br></td><br><td><br>A - <x><br></x></td><br></tr><br><br><tr><br><td> mul </td><br><td><br>0, 4<br></td><br><td><br>A * <x><br></x></td><br></tr><br><br><tr><br><td> div </td><br><td><br>0, 4<br></td><br><td><br>A / <x><br></x></td><br></tr><br><br><tr><br><td> mod </td><br><td><br>0, 4<br></td><br><td><br>A % <x><br></x></td><br></tr><br><br><tr><br><td> neg </td><br><td><br><br></td><br><td><br>!A<br></td><br></tr><br><br><tr><br><td> and </td><br><td><br>0, 4<br></td><br><td><br>A &amp; <x><br></x></td><br></tr><br><br><tr><br><td> or </td><br><td><br>0, 4<br></td><br><td><br>A | <x><br></x></td><br></tr><br><br><tr><br><td> xor </td><br><td><br>0, 4<br></td><br><td><br>A ^ <x><br></x></td><br></tr><br><br><tr><br><td> lsh </td><br><td><br>0, 4<br></td><br><td><br>A &lt;&lt; <x><br></x></td><br></tr><br><br><tr><br><td> rsh </td><br><td><br>0, 4<br></td><br><td><br>A &gt;&gt; <x><br></x></td><br></tr><br><br><tr><br><td>   </td><br><td><br></td><br><td><br></td><br></tr><br><br><tr><br><td> tax </td><br><td><br><br></td><br><td><br>Copy A into X<br></td><br></tr><br><br><tr><br><td> txa </td><br><td><br><br></td><br><td><br>Copy X into A<br></td><br></tr><br><br><tr><br><td>   </td><br><td><br></td><br><td><br></td><br></tr><br><br><tr><br><td> ret </td><br><td><br>4, 9<br></td><br><td><br>Return<br></td><br></tr><br><br></table>

<p>下表用来解释第二列的寻址格式：</p>
<table border="1"><br><caption> BPF Addressing mode </caption><br><br><tr><br><th style="width: 200px;">Addressing mode</th><br><th style="width: 200px;">Syntax</th><br><th style="width: 400px;">Description</th><br></tr><br><br><tr><br><td> 0 </td><br><td><br>x/%x<br></td><br><td><br>Register X<br></td><br></tr><br><br><tr><br><td> 1 </td><br><td><br>[k]<br></td><br><td><br>BHW at byte offset k in the packet<br></td><br></tr><br><br><tr><br><td> 2 </td><br><td><br>[x + k]<br></td><br><td><br>BHW at the offset X + k in the packet<br></td><br></tr><br><br><tr><br><td> 3 </td><br><td><br>M[k]<br></td><br><td><br>Word at offset k in M[]<br></td><br></tr><br><br><tr><br><td> 4 </td><br><td><br>#k<br></td><br><td><br>Literal value stored in k<br></td><br></tr><br><br><tr><br><td> 5 </td><br><td><br>4<em>([k]&amp;0xf)<br></em></td><br><td><br>Lower nibble  4 at byte offset k in the packet<br></td><br></tr><br><br><tr><br><td> 6 </td><br><td><br>L<br></td><br><td><br>Jump label L<br></td><br></tr><br><br><tr><br><td> 7 </td><br><td><br>#k,Lt,Lf<br></td><br><td><br>Jump to Lt if true, otherwise jump to Lf<br></td><br></tr><br><br><tr><br><td> 8 </td><br><td><br>#k,Lt<br></td><br><td><br>Jump to Lt if predicate is true<br></td><br></tr><br><br><tr><br><td> 9 </td><br><td><br>a/%a<br></td><br><td><br>Accumulator A<br></td><br></tr><br><br><tr><br><td> 10 </td><br><td><br>extension<br></td><br><td><br>BPF extension<br></td><br></tr><br><br></table>

<p>Linux内核也有一些BPF扩展和load类的指令一起使用，用负偏移量+特定扩展偏移来“重载”k参数。这些BPF扩展的结构被加载到A中。</p>
<p>可能的BPF扩展如下表：</p>
<table border="1"><br><caption> BPF extensions </caption><br><br><tr><br><th style="width: 200px;">Extension</th><br><th style="width: 400px;">Description</th><br></tr><br><br><tr><br><td> len </td><br><td><br>skb-&gt;len<br></td><br></tr><br><br><tr><br><td> proto </td><br><td><br>skb-&gt;protocol<br></td><br></tr><br><br><tr><br><td> type </td><br><td><br>skb-&gt;pkt_type<br></td><br></tr><br><br><tr><br><td> poff </td><br><td><br>Payload start offset<br></td><br></tr><br><br><tr><br><td> ifidx </td><br><td><br>skb-&gt;dev-&gt;ifindex<br></td><br></tr><br><br><tr><br><td> nla </td><br><td><br>Netlink attribute of type X with offset A<br></td><br></tr><br><br><tr><br><td> nlan </td><br><td><br>Nested Netlink attribute of type X with offset A<br></td><br></tr><br><br><tr><br><td> mark </td><br><td><br>skb-&gt;mark<br></td><br></tr><br><br><tr><br><td> queue </td><br><td><br>skb-&gt;queue_mapping<br></td><br></tr><br><br><tr><br><td> hatype </td><br><td><br>skb-&gt;dev-&gt;type<br></td><br></tr><br><br><tr><br><td> rxhash </td><br><td><br>skb-&gt;hash<br></td><br></tr><br><br><tr><br><td> cpu </td><br><td><br>raw_smp_processor_id()<br></td><br></tr><br><br><tr><br><td> vlan_tci </td><br><td><br>skb_vlan_tag_get(skb)<br></td><br></tr><br><br><tr><br><td> vlan_avail </td><br><td><br>skb_vlan_tag_present(skb)<br></td><br></tr><br><br><tr><br><td> vlan_tpid </td><br><td><br>skb-&gt;vlan_proto<br></td><br></tr><br><br><tr><br><td> rand </td><br><td><br>prandom_u32()<br></td><br></tr><br><br></table>

<p>这些扩展也使用’#’前缀。</p>
<p>以下是低层级BPF的实例：</p>
<ul>
<li>ARP packets:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ldh [12]</span><br><span class="line">jne #0x806, drop</span><br><span class="line">ret #-1</span><br><span class="line">drop: ret #0</span><br></pre></td></tr></table></figure>
<ul>
<li>IPv4 TCP packets:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ldh [12]</span><br><span class="line">jne #0x800, drop</span><br><span class="line">ldb [23]</span><br><span class="line">jneq #6, drop</span><br><span class="line">ret #-1</span><br><span class="line">drop: ret #0</span><br></pre></td></tr></table></figure>
<ul>
<li>Accelerated) VLAN w/ id 10:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ld vlan_tci</span><br><span class="line">jneq #10, drop</span><br><span class="line">ret #-1</span><br><span class="line">drop: ret #0</span><br></pre></td></tr></table></figure>
<ul>
<li>icmp random packet sampling, 1 in 4</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ldh [12]</span><br><span class="line">jne #0x800, drop</span><br><span class="line">ldb [23]</span><br><span class="line">jneq #1, drop</span><br><span class="line"># get a random uint32 number</span><br><span class="line">ld rand</span><br><span class="line">mod #4</span><br><span class="line">jneq #1, drop</span><br><span class="line">ret #-1</span><br><span class="line">drop: ret #0</span><br></pre></td></tr></table></figure>
<ul>
<li>SECCOMP filter example:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ld [4]                  /* offsetof(struct seccomp_data, arch) */</span><br><span class="line">jne #0xc000003e, bad    /* AUDIT_ARCH_X86_64 */</span><br><span class="line">ld [0]                  /* offsetof(struct seccomp_data, nr) */</span><br><span class="line">jeq #15, good           /* __NR_rt_sigreturn */</span><br><span class="line">jeq #231, good          /* __NR_exit_group */</span><br><span class="line">jeq #60, good           /* __NR_exit */</span><br><span class="line">jeq #0, good            /* __NR_read */</span><br><span class="line">jeq #1, good            /* __NR_write */</span><br><span class="line">jeq #5, good            /* __NR_fstat */</span><br><span class="line">jeq #9, good            /* __NR_mmap */</span><br><span class="line">jeq #14, good           /* __NR_rt_sigprocmask */</span><br><span class="line">jeq #13, good           /* __NR_rt_sigaction */</span><br><span class="line">jeq #35, good           /* __NR_nanosleep */</span><br><span class="line">bad: ret #0             /* SECCOMP_RET_KILL_THREAD */</span><br><span class="line">good: ret #0x7fff0000   /* SECCOMP_RET_ALLOW */</span><br></pre></td></tr></table></figure>
<p>上述实例代码可以放进一个文件(这里称为“foo”)，然后传递给bpf_asm工具生成操作码，输出xt_bpf和cls_bpf可以理解的并加载。例如上述的ARP代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./bpf_asm foo</span><br><span class="line">4,40 0 0 12,21 0 1 2054,6 0 0 4294967295,6 0 0 0,</span><br></pre></td></tr></table></figure>
<p>拷贝并粘贴成类似C的输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./bpf_asm -c foo</span><br><span class="line">&#123; 0x28,  0,  0, 0x0000000c &#125;,</span><br><span class="line">&#123; 0x15,  0,  1, 0x00000806 &#125;,</span><br><span class="line">&#123; 0x06,  0,  0, 0xffffffff &#125;,</span><br><span class="line">&#123; 0x06,  0,  0, 0000000000 &#125;,</span><br></pre></td></tr></table></figure>
<p>特别是在使用xt_bpf或cls_bpf会导致更复杂的BPF filter，这种起先可能并不明显，在连接到活动系统前先进行测试时非常好的。为此，在tools/bpf路径下有个名为bpd_dbg的小工具。这个调试器运行测试BPF filter针对给定的pcap文件，在pcap包上单步执行BPF代码并且进行BPF虚拟机的寄存器dump。</p>
<p>启动bpf_dbg很简单，只需要发出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ./bpf_dbg</span><br></pre></td></tr></table></figure>
<p>如果输入和输出不等于stdin/stdout, bpf_dbg将一个可选的stdin源作为第一个参数，另一个可选的stdout sink作为第二个参数，例如:<code>./bpf_dbg test_in.txt test_out.txt</code></p>
<p>除此之外，还可以通过文件“~/”设置特定的libreadline配置。命令历史存储在文件~/.bpf_dbg_history中。</p>
<p>bpf_dbg中的交互是通过一个具有自动完成支持的shell进行的(以’&gt;’开头的后续示例命令表示bpf_dbg shell)。</p>
<ul>
<li>通常的工作流程是……</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; load bpf 6,40 0 0 12,21 0 3 2048,48 0 0 23,21 0 1 1,6 0 0 65535,6 0 0 0</span><br></pre></td></tr></table></figure>
<p>加载一个BPF filter通过bpf_asm的标准输出，或者类似<code>tcpdump -iem1 -ddd port 22 | tr &#39;\n&#39; &#39;,&#39;</code>命令的转换。注意对JIT调试来说，该命令创建一个临时socket并且加载BPF代码到内核。因此对JIT开发人员也是很有用的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; load pcap foo.pcap</span><br></pre></td></tr></table></figure>
<p>加载标准的tcpdump pcap文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; run [&lt;n&gt;]</span><br><span class="line">bpf passes:1 fails:9</span><br></pre></td></tr></table></figure>
<p>运行pcap中的所有包，以计算过滤器将生成多少次传递和失败。可以给出要遍历的包的限制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; disassemble</span><br><span class="line">l0:	ldh [12]</span><br><span class="line">l1:	jeq #0x800, l2, l5</span><br><span class="line">l2:	ldb [23]</span><br><span class="line">l3:	jeq #0x1, l4, l5</span><br><span class="line">l4:	ret #0xffff</span><br><span class="line">l5:	ret #0</span><br></pre></td></tr></table></figure>
<p>打印出BPF反汇编代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; dump</span><br><span class="line">/* &#123; op, jt, jf, k &#125;, */</span><br><span class="line">&#123; 0x28,  0,  0, 0x0000000c &#125;,</span><br><span class="line">&#123; 0x15,  0,  3, 0x00000800 &#125;,</span><br><span class="line">&#123; 0x30,  0,  0, 0x00000017 &#125;,</span><br><span class="line">&#123; 0x15,  0,  1, 0x00000001 &#125;,</span><br><span class="line">&#123; 0x06,  0,  0, 0x0000ffff &#125;,</span><br><span class="line">&#123; 0x06,  0,  0, 0000000000 &#125;,</span><br></pre></td></tr></table></figure>
<p>打印出C风格的BPF code dump。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; dump</span><br><span class="line">/* &#123; op, jt, jf, k &#125;, */</span><br><span class="line">&#123; 0x28,  0,  0, 0x0000000c &#125;,</span><br><span class="line">&#123; 0x15,  0,  3, 0x00000800 &#125;,</span><br><span class="line">&#123; 0x30,  0,  0, 0x00000017 &#125;,</span><br><span class="line">&#123; 0x15,  0,  1, 0x00000001 &#125;,</span><br><span class="line">&#123; 0x06,  0,  0, 0x0000ffff &#125;,</span><br><span class="line">&#123; 0x06,  0,  0, 0000000000 &#125;,</span><br></pre></td></tr></table></figure>
<p>在特定BPF指令上设置断点。发出’ run ‘命令将遍历pcap文件，从当前包继续执行，并在断点被击中时中断(另一个’ run ‘将继续从当前活动的断点执行下一条指令):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; run</span><br><span class="line">-- register dump --</span><br><span class="line">pc:       [0]                       &lt;-- program counter</span><br><span class="line">code:     [40] jt[0] jf[0] k[12]    &lt;-- plain BPF code of current instruction</span><br><span class="line">curr:     l0:	ldh [12]              &lt;-- disassembly of current instruction</span><br><span class="line">A:        [00000000][0]             &lt;-- content of A (hex, decimal)</span><br><span class="line">X:        [00000000][0]             &lt;-- content of X (hex, decimal)</span><br><span class="line">M[0,15]:  [00000000][0]             &lt;-- folded content of M (hex, decimal)</span><br><span class="line">-- packet dump --                   &lt;-- Current packet from pcap (hex)</span><br><span class="line">len: 42</span><br><span class="line">  0: 00 19 cb 55 55 a4 00 14 a4 43 78 69 08 06 00 01</span><br><span class="line"> 16: 08 00 06 04 00 01 00 14 a4 43 78 69 0a 3b 01 26</span><br><span class="line"> 32: 00 00 00 00 00 00 0a 3b 01 01</span><br><span class="line">(breakpoint)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; breakpoint</span><br><span class="line">breakpoints: 0 1</span><br></pre></td></tr></table></figure>
<p>打印出当前设置的断点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; step [-&lt;n&gt;, +&lt;n&gt;]</span><br></pre></td></tr></table></figure>
<p>从当前pc偏移量执行单步通过BPF程序。因此，在每个step调用上，都会发出上面的寄存器转储。这可以向前和向后的时间，一个普通的’step’将中断对下一个BPF指令，因此+1。(这里不需要发布‘run’。)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; select &lt;n&gt;</span><br></pre></td></tr></table></figure>
<p>从pcap文件中选择要继续的给定数据包。因此，在下一个“run”或“step”中，BPF程序将根据用户预先选择的包进行评估。编号从Wireshark的索引1开始。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; quit</span><br><span class="line">#</span><br></pre></td></tr></table></figure>
<p>退出bpf_dbg。</p>
<h1 id="4、JIT-compiler"><a href="#4、JIT-compiler" class="headerlink" title="4、JIT compiler"></a>4、JIT compiler</h1><p>Linux内核拥有内建的BPF JIT compiler针对x86_64, SPARC, PowerPC,ARM, ARM64, MIPS and s390架构，可以通过CONFIG_BPF_JIT选项来使能。(对于其他架构，没有提供JIT compiler，只能通过in-kernel interpreter来解析BPF，效率比较低)</p>
<p>JIT compiler会透明的被调用，当用户空间或者内核空间的filter绑定时。如果它事先已经被root使能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 1 &gt; /proc/sys/net/core/bpf_jit_enable</span><br></pre></td></tr></table></figure>
<p>对于JIT开发人员做审核等，每一次编译运行都可以通过以下方式将生成的操作码映像输出到内核日志中:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  echo 2 &gt; /proc/sys/net/core/bpf_jit_enable</span><br><span class="line"></span><br><span class="line">Example output from dmesg:</span><br><span class="line"></span><br><span class="line">[ 3389.935842] flen=6 proglen=70 pass=3 image=ffffffffa0069c8f</span><br><span class="line">[ 3389.935847] JIT code: 00000000: 55 48 89 e5 48 83 ec 60 48 89 5d f8 44 8b 4f 68</span><br><span class="line">[ 3389.935849] JIT code: 00000010: 44 2b 4f 6c 4c 8b 87 d8 00 00 00 be 0c 00 00 00</span><br><span class="line">[ 3389.935850] JIT code: 00000020: e8 1d 94 ff e0 3d 00 08 00 00 75 16 be 17 00 00</span><br><span class="line">[ 3389.935851] JIT code: 00000030: 00 e8 28 94 ff e0 83 f8 01 75 07 b8 ff ff 00 00</span><br><span class="line">[ 3389.935852] JIT code: 00000040: eb 02 31 c0 c9 c3</span><br></pre></td></tr></table></figure>
<p>当启用CONFIG_BPF_JIT_ALWAYS_ON时，bpf_jit_enable被永久设置为1，并设置任何其他值将返回失败。这甚至适用于将bpf_jit_enable设置为2，因为不鼓励将最终的JIT映像转储到内核日志中，而通过bpftool(在tools/bpf/bpftool/下)进行自省是通常推荐的方法。</p>
<p>在tools/bpf/下的内核源代码树中，有bpf_jit_disasm用于从内核日志的hexdump生成反汇编代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># ./bpf_jit_disasm</span><br><span class="line">70 bytes emitted from JIT compiler (pass:3, flen:6)</span><br><span class="line">ffffffffa0069c8f + &lt;x&gt;:</span><br><span class="line">   0:	push   %rbp</span><br><span class="line">   1:	mov    %rsp,%rbp</span><br><span class="line">   4:	sub    $0x60,%rsp</span><br><span class="line">   8:	mov    %rbx,-0x8(%rbp)</span><br><span class="line">   c:	mov    0x68(%rdi),%r9d</span><br><span class="line">  10:	sub    0x6c(%rdi),%r9d</span><br><span class="line">  14:	mov    0xd8(%rdi),%r8</span><br><span class="line">  1b:	mov    $0xc,%esi</span><br><span class="line">  20:	callq  0xffffffffe0ff9442</span><br><span class="line">  25:	cmp    $0x800,%eax</span><br><span class="line">  2a:	jne    0x0000000000000042</span><br><span class="line">  2c:	mov    $0x17,%esi</span><br><span class="line">  31:	callq  0xffffffffe0ff945e</span><br><span class="line">  36:	cmp    $0x1,%eax</span><br><span class="line">  39:	jne    0x0000000000000042</span><br><span class="line">  3b:	mov    $0xffff,%eax</span><br><span class="line">  40:	jmp    0x0000000000000044</span><br><span class="line">  42:	xor    %eax,%eax</span><br><span class="line">  44:	leaveq</span><br><span class="line">  45:	retq</span><br></pre></td></tr></table></figure>
<p>发布选项“-o”将“注释”操作码到生成的汇编指令，这对JIT开发人员非常有用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"># ./bpf_jit_disasm -o</span><br><span class="line">70 bytes emitted from JIT compiler (pass:3, flen:6)</span><br><span class="line">ffffffffa0069c8f + &lt;x&gt;:</span><br><span class="line">   0:	push   %rbp</span><br><span class="line">	55</span><br><span class="line">   1:	mov    %rsp,%rbp</span><br><span class="line">	48 89 e5</span><br><span class="line">   4:	sub    $0x60,%rsp</span><br><span class="line">	48 83 ec 60</span><br><span class="line">   8:	mov    %rbx,-0x8(%rbp)</span><br><span class="line">	48 89 5d f8</span><br><span class="line">   c:	mov    0x68(%rdi),%r9d</span><br><span class="line">	44 8b 4f 68</span><br><span class="line">  10:	sub    0x6c(%rdi),%r9d</span><br><span class="line">	44 2b 4f 6c</span><br><span class="line">  14:	mov    0xd8(%rdi),%r8</span><br><span class="line">	4c 8b 87 d8 00 00 00</span><br><span class="line">  1b:	mov    $0xc,%esi</span><br><span class="line">	be 0c 00 00 00</span><br><span class="line">  20:	callq  0xffffffffe0ff9442</span><br><span class="line">	e8 1d 94 ff e0</span><br><span class="line">  25:	cmp    $0x800,%eax</span><br><span class="line">	3d 00 08 00 00</span><br><span class="line">  2a:	jne    0x0000000000000042</span><br><span class="line">	75 16</span><br><span class="line">  2c:	mov    $0x17,%esi</span><br><span class="line">	be 17 00 00 00</span><br><span class="line">  31:	callq  0xffffffffe0ff945e</span><br><span class="line">	e8 28 94 ff e0</span><br><span class="line">  36:	cmp    $0x1,%eax</span><br><span class="line">	83 f8 01</span><br><span class="line">  39:	jne    0x0000000000000042</span><br><span class="line">	75 07</span><br><span class="line">  3b:	mov    $0xffff,%eax</span><br><span class="line">	b8 ff ff 00 00</span><br><span class="line">  40:	jmp    0x0000000000000044</span><br><span class="line">	eb 02</span><br><span class="line">  42:	xor    %eax,%eax</span><br><span class="line">	31 c0</span><br><span class="line">  44:	leaveq</span><br><span class="line">	c9</span><br><span class="line">  45:	retq</span><br><span class="line">	c3</span><br></pre></td></tr></table></figure>
<p>对于BPF JIT开发人员来说，bpf_jit_disasm、bpf_asm和bpf_dbg为开发和测试内核的JIT编译器提供了一个有用的工具链。</p>
<h1 id="5、BPF在kernel内的实现-eBPF"><a href="#5、BPF在kernel内的实现-eBPF" class="headerlink" title="5、BPF在kernel内的实现(eBPF)"></a>5、BPF在kernel内的实现(eBPF)</h1><p>在kernel内部解析器，使用了一套和BPF不同的指令集，即基本原理和前几段描述的BPF类似。但是这个指令集的模型更加接近底层架构更能模仿原生指令，因此可以获得更好的性能。这种新的ISA(Instruction-Set Architecture)被称作’eBP’F(extened BPF)或’internal BPF’。注意：extened BPF和BPF extension是不一样的，eBPF是一种ISA，而BPF extension指的是classic BPF的BPF_LD | BPF_{B,H,W} | BPF_ABS 指令的重载。</p>
<p>它被设计成可被JITed的一对一映射，这也为GCC/LLVM编译器通过一个eBPF后端生成优化的eBPF代码打开了可能性，它的执行速度几乎与本地编译的代码一样快。</p>
<p>新指令集原始设计可能的目的是使用“受限C”来写程序并且通过“GCC/LLVM”来编译成eBPF，所以它可以在即时(JIT just-in-time)映射的两步C -&gt; eBPF -&gt; native code中获得最小的开销。</p>
<p>目前，新格式用于运行用户BPF程序，其中包括seccomp BPF、classic socket filters, cls_bpf traffic classifier, team driver’s classifier for its load-balancing mode, netfilter’s xt_bpf extension, PTP dissector/classifier，和更多。它们都是由内核内部的转成成新指令，并在eBPF解析器中运行。对于内核内部处理，使用bpf_prog_create()来创建filter和使用bpf_prog_destroy()来销毁filter所有的工作都是透明的。宏BPF_PROG_RUN(filter, ctx)透明的调用eBPF解析器或者JITed代码来运行filter。’filter’指向struct bpf_prog结构的指针由bpf_prog_create()创建，’ctx’给定上下文(例如skb指针)。bpf_check_classic()的所有约束和限制在转换到新布局之前都在幕后执行!</p>
<p>目前，大多数32位体系结构都使用classic  BPF格式，而x86-64、aarch64、s390x、powerpc64、sparc64、arm32则使用eBPF指令集执行JIT编译。</p>
<p>新内部格式的一些核心变化:</p>
<ul>
<li>寄存器数量由2增加到10：</li>
</ul>
<p>旧的格式拥有两个寄存器A和X，以及一个隐藏的堆栈指针(frame pointer)。新的布局10个内部寄存器和一个只读的堆栈指针。由于64位cpu通过寄存器将参数传递给函数，因此从eBPF程序到内核函数的args数量限制为5个，一个寄存器用于接受内核函数的返回值。原生的，x86_64在寄存器中传递前6个参数，aarch64/sparcv9/mips64有7 - 8个寄存器作为参数;x86_64有6个被调用者保存寄存器，aarch64/sparcv9/mips64有11个或更多被调用者保存寄存器。</p>
<p>因此，eBPF调用约定定义为:</p>
<table border="1"><br><caption> BPF calling convention </caption><br><br><tr><br><th style="width: 200px;">Register</th><br><th style="width: 400px;">Description</th><br></tr><br><br><tr><br><td> R0 </td><br><td><br>return value from in-kernel function, and exit value for eBPF program<br></td><br></tr><br><br><tr><br><td> R1 - R5 </td><br><td><br>arguments from eBPF program to in-kernel function<br></td><br></tr><br><br><tr><br><td> R6 - R9 </td><br><td><br>callee saved registers that in-kernel function will preserve<br></td><br></tr><br><br><tr><br><td> R10 </td><br><td><br>read-only frame pointer to access stack<br></td><br></tr><br><br></table>

<p>因此，所有eBPF寄存器都在x86_64、aarch64等架构上可以一比一的映射到HW寄存器，而eBPF调用约定映射直接映射到64位体系结构上内核使用的ABIs。</p>
<p>在32位体系结构上，JIT映射程序只使用32位运算，并可能让更复杂的程序被解释。</p>
<p>R0 - R5是草稿寄存器，eBPF程序需要在调用之间spill/fill它们。注意，只有一个eBPF程序(==一个eBPF主例程)，它不能调用其他eBPF函数，但只能调用预定义的内核函数。</p>
<ul>
<li>寄存器宽度由32bit增加到64bit：</li>
</ul>
<p>尽管如此，最初的32位ALU操作的语义仍然通过32位子寄存器保存。所有eBPF寄存器都是64位的，低32位为子寄存器高32位为零扩展。该行为直接映射到x86_64和arm64子寄存器定义，但使其他架构JITs变得更加困难。</p>
<p>32位体系结构通过解释器运行64位BPF程序。他们的JITs可以将只使用32位子寄存器的BPF程序转换为本机指令集，其余的只能被解释。</p>
<p>操作是64位的,因为在64位架构,指针也64位宽。如果我们想通过64位值来和内核函数交换数据，32位eBPF寄存器需要定义寄存器对ABI，因此它不能使用eBPF寄存器到HW寄存器的直接映射，并且JIT需要使用combine/split/move等操作寄存器来和内核函数交换数据，这是又复杂又容易出bug和缓慢。另一个原因是使用原子64位计数器。</p>
<ul>
<li>条件jt/jf目标替换为jt/fall-through:</li>
</ul>
<p>最初的设计是如下构造”if (cond) jump_true;  else jump_false;”，它们正被替换成类似的构造”if (cond) jump_true; /<em> else fall-through </em>/“。</p>
<ul>
<li>介绍bpf_call指令和寄存器传递约定，用于调用来自/到其他内核函数：</li>
</ul>
<p>在调用一个内核函数之前，内部BPF程序需要将函数参数放入R1到R5寄存器以满足调用约定，然后解释器将从寄存器中取出它们并传递给内核函数。给定体系结构上如果R1 - R5寄存器被映射到CPU寄存器用参数于传递，JIT编译器不需要额外的动作。函数参数将在正确的寄存器中，BPF_CALL指令将被JIT翻译成单个’call’ HW指令。这个调用约定是用来覆盖通用的调用场景而没有性能损失。</p>
<p>在内核函数调用之后，R1 - R5被重置为不可读，R0有函数的返回值。因为R6 - R9是被调用保护，它们的状态在整个调用中需要被保护。</p>
<p>例如，考虑三个C函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">u64 f1() &#123; return (*_f2)(1); &#125;</span><br><span class="line">u64 f2(u64 a) &#123; return f3(a + 1, a); &#125;</span><br><span class="line">u64 f3(u64 a, u64 b) &#123; return a - b; &#125;</span><br></pre></td></tr></table></figure>
<p>GCC可以将f1, f3编译成x86_64:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">f1:</span><br><span class="line">  movl $1, %edi</span><br><span class="line">  movq _f2(%rip), %rax</span><br><span class="line">  jmp  *%rax</span><br><span class="line">f3:</span><br><span class="line">  movq %rdi, %rax</span><br><span class="line">  subq %rsi, %rax</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure>
<p>eBPF中的函数f2如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f2:</span><br><span class="line">  bpf_mov R2, R1</span><br><span class="line">  bpf_add R1, 1</span><br><span class="line">  bpf_call f3</span><br><span class="line">  bpf_exit</span><br></pre></td></tr></table></figure>
<p>如果f2是JITed并且指针存储到’_f2’，调用f1 -&gt; f2 -&gt; f3和返回将是无缝的。如果没有JIT， 需要使用__bpf_prog_run()解释器来调用f2。</p>
<p>出于实际原因，所有eBPF程序只有一个参数“ctx”，该参数已经被放置到R1中(例如在__bpf_prog_run()启动时)，并且程序最多可以调用5个参数的内核函数。目前不支持带有6个或更多参数的调用，但如果将来有必要，可以取消这些限制。</p>
<p>在64位体系结构上，所有到HW的寄存器映射都是一对一的。例如，x86_64 JIT编译器可以将它们映射为…</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">R0 - rax</span><br><span class="line">R1 - rdi</span><br><span class="line">R2 - rsi</span><br><span class="line">R3 - rdx</span><br><span class="line">R4 - rcx</span><br><span class="line">R5 - r8</span><br><span class="line">R6 - rbx</span><br><span class="line">R7 - r13</span><br><span class="line">R8 - r14</span><br><span class="line">R9 - r15</span><br><span class="line">R10 - rbp</span><br></pre></td></tr></table></figure>
<p>因为x86_64 ABI要求rdi、rsi、rdx、rcx、r8、r9作为参数传递，rbx、 r12 - r15作为 被调用保存。</p>
<p>下面BPF伪程序:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">bpf_mov R6, R1 /* save ctx */</span><br><span class="line">bpf_mov R2, 2</span><br><span class="line">bpf_mov R3, 3</span><br><span class="line">bpf_mov R4, 4</span><br><span class="line">bpf_mov R5, 5</span><br><span class="line">bpf_call foo</span><br><span class="line">bpf_mov R7, R0 /* save foo() return value */</span><br><span class="line">bpf_mov R1, R6 /* restore ctx for next call */</span><br><span class="line">bpf_mov R2, 6</span><br><span class="line">bpf_mov R3, 7</span><br><span class="line">bpf_mov R4, 8</span><br><span class="line">bpf_mov R5, 9</span><br><span class="line">bpf_call bar</span><br><span class="line">bpf_add R0, R7</span><br><span class="line">bpf_exit</span><br></pre></td></tr></table></figure>
<p>经过JIT到x86_64的转换后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">push %rbp</span><br><span class="line">mov %rsp,%rbp</span><br><span class="line">sub $0x228,%rsp</span><br><span class="line">mov %rbx,-0x228(%rbp)</span><br><span class="line">mov %r13,-0x220(%rbp)</span><br><span class="line">mov %rdi,%rbx</span><br><span class="line">mov $0x2,%esi</span><br><span class="line">mov $0x3,%edx</span><br><span class="line">mov $0x4,%ecx</span><br><span class="line">mov $0x5,%r8d</span><br><span class="line">callq foo</span><br><span class="line">mov %rax,%r13</span><br><span class="line">mov %rbx,%rdi</span><br><span class="line">mov $0x2,%esi</span><br><span class="line">mov $0x3,%edx</span><br><span class="line">mov $0x4,%ecx</span><br><span class="line">mov $0x5,%r8d</span><br><span class="line">callq bar</span><br><span class="line">add %r13,%rax</span><br><span class="line">mov -0x228(%rbp),%rbx</span><br><span class="line">mov -0x220(%rbp),%r13</span><br><span class="line">leaveq</span><br><span class="line">retq</span><br></pre></td></tr></table></figure>
<p>该例子等于以下C代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">u64 bpf_filter(u64 ctx)</span><br><span class="line">&#123;</span><br><span class="line">    return foo(ctx, 2, 3, 4, 5) + bar(ctx, 6, 7, 8, 9);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内核函数foo()和bar()的原型为:u64 (*)(u64 arg1, u64 arg2, u64 arg3, u64 arg4, u64 arg5);将在适当的寄存器中接收参数，并将其返回值放入“%rax”，在eBPF中为R0。<br>序言和结语由JIT发出，在解释器中是隐式的。R0-R5是暂存寄存器，所以eBPF程序需要在两次调用之间保护它们。</p>
<p>以下实例程序时无效的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bpf_mov R1, 1</span><br><span class="line">bpf_call foo</span><br><span class="line">bpf_mov R0, R1</span><br><span class="line">bpf_exit</span><br></pre></td></tr></table></figure>
<p>在函数调用之后，寄存器R1-R5包含垃圾值不能读取。一个内部eBPF校验器会用来验证eBPF程序。</p>
<p>在新的设计中，eBPF被限制为4096 指令，这意味着任何程序都会快速终止，并且只调用固定数量的内核函数。原始的BPF和新的格式都是两个操作数指令，这有助于在JIT期间在eBPF insn和x86 insn之间进行一对一的映射。</p>
<p>输入的上下文指针对调用解释器函数来说是同一的，其内容由特定的用例决定。对于seccomp寄存器R1指向seccomp_data，对于转换后的BPF filter寄存器R1指向skb。</p>
<p>程序的内部翻译由以下元素组成:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">op:16, jt:8, jf:8, k:32    ==&gt;    op:8, dst_reg:4, src_reg:4, off:16, imm:32</span><br></pre></td></tr></table></figure>
<p>到目前为止，已经实现了87条内部BPF指令。8位“op”操作码字段有新的指令空间。其中一些可能使用16/24/32字节编码。新指令必须是8字节的倍数，以保持向后兼容性。</p>
<p>内部BPF是一个通用的RISC指令集，并不是所有的寄存器和指令都在从原始BPF转换到新格式的过程中被使用。<br>例如，socket filter不使用’exclusive add’指令，但是tracing filter可以用来维护事件计数器。socket filter也不使用寄存器R9，但是更复杂的过滤器可能会耗尽寄存器，并且不得不求助于 spill/fill到堆栈中。</p>
<p>Internal BPF可以作为通用汇编器用于最后一步的性能优化，socket filter和seccomp使用它作为汇编程序。tracing filter可以使用它作为汇编程序从内核生成代码。在内核使用中，可能不会受到安全考虑的限制，因为生成的内部BPF代码可能会优化内部代码路径，而不会暴露给用户空间。<br>内部BPF的安全性可以通过验证器(TBD)来实现。在这样的用例中所述，可作为安全指令集使用。</p>
<p>就像最初的BPF一样，新的格式在受控环境中运行，是确定性的，内核可以很容易地证明这一点。程序的安全性可以通过两个步骤确定:第一步是深度优先搜索，禁止循环和其他CFG验证;第二步从第一个insn开始，向下延伸所有可能的路径。它模拟了每个insn的执行，并观察了寄存器和堆栈的状态变化。</p>
<h2 id="5-1、eBPF-opcode编码"><a href="#5-1、eBPF-opcode编码" class="headerlink" title="5.1、eBPF opcode编码"></a>5.1、eBPF opcode编码</h2><p>eBPF重用了大部分经典操作码编码，简化了经典BPF到eBPF的转换。</p>
<p>1、对于arithmetic 和jump指令，8位“code”字段分为三个部分:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----------------+--------+--------------------+</span><br><span class="line">|   4 bits       |  1 bit |   3 bits           |</span><br><span class="line">| operation code | source | instruction class  |</span><br><span class="line">+----------------+--------+--------------------+</span><br><span class="line">(MSB)                                      (LSB)</span><br></pre></td></tr></table></figure>
<p>最后3bit的LSB存储指令类别如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Classic BPF classes:    eBPF classes:</span><br><span class="line"></span><br><span class="line">BPF_LD    0x00          BPF_LD    0x00</span><br><span class="line">BPF_LDX   0x01          BPF_LDX   0x01</span><br><span class="line">BPF_ST    0x02          BPF_ST    0x02</span><br><span class="line">BPF_STX   0x03          BPF_STX   0x03</span><br><span class="line">BPF_ALU   0x04          BPF_ALU   0x04</span><br><span class="line">BPF_JMP   0x05          BPF_JMP   0x05</span><br><span class="line">BPF_RET   0x06          [ class 6 unused, for future if needed ]</span><br><span class="line">BPF_MISC  0x07          BPF_ALU64 0x07</span><br></pre></td></tr></table></figure>
<p>当BPF_CLASS(code) == BPF_ALU or BPF_JMP，第4bit表示源操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BPF_K     0x00</span><br><span class="line">BPF_X     0x08</span><br></pre></td></tr></table></figure>
<p>在classic BPF中表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BPF_SRC(code) == BPF_X - use register X as source operand</span><br><span class="line">BPF_SRC(code) == BPF_K - use 32-bit immediate as source operand</span><br></pre></td></tr></table></figure>
<p>在eBPF中表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BPF_SRC(code) == BPF_X - use &apos;src_reg&apos; register as source operand</span><br><span class="line">BPF_SRC(code) == BPF_K - use 32-bit immediate as source operand</span><br></pre></td></tr></table></figure>
<p>4bit的MSB用来存储操作码。</p>
<ul>
<li>如果BPF_CLASS(code) == BPF_ALU or BPF_ALU64 [ in eBPF ], BPF_OP(code) is one of:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">BPF_ADD   0x00</span><br><span class="line">BPF_SUB   0x10</span><br><span class="line">BPF_MUL   0x20</span><br><span class="line">BPF_DIV   0x30</span><br><span class="line">BPF_OR    0x40</span><br><span class="line">BPF_AND   0x50</span><br><span class="line">BPF_LSH   0x60</span><br><span class="line">BPF_RSH   0x70</span><br><span class="line">BPF_NEG   0x80</span><br><span class="line">BPF_MOD   0x90</span><br><span class="line">BPF_XOR   0xa0</span><br><span class="line">BPF_MOV   0xb0  /* eBPF only: mov reg to reg */</span><br><span class="line">BPF_ARSH  0xc0  /* eBPF only: sign extending shift right */</span><br><span class="line">BPF_END   0xd0  /* eBPF only: endianness conversion */</span><br></pre></td></tr></table></figure>
<ul>
<li>如果BPF_CLASS(code) == BPF_JMP, BPF_OP(code) is one of:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">BPF_JA    0x00</span><br><span class="line">BPF_JEQ   0x10</span><br><span class="line">BPF_JGT   0x20</span><br><span class="line">BPF_JGE   0x30</span><br><span class="line">BPF_JSET  0x40</span><br><span class="line">BPF_JNE   0x50  /* eBPF only: jump != */</span><br><span class="line">BPF_JSGT  0x60  /* eBPF only: signed &apos;&gt;&apos; */</span><br><span class="line">BPF_JSGE  0x70  /* eBPF only: signed &apos;&gt;=&apos; */</span><br><span class="line">BPF_CALL  0x80  /* eBPF only: function call */</span><br><span class="line">BPF_EXIT  0x90  /* eBPF only: function return */</span><br><span class="line">BPF_JLT   0xa0  /* eBPF only: unsigned &apos;&lt;&apos; */</span><br><span class="line">BPF_JLE   0xb0  /* eBPF only: unsigned &apos;&lt;=&apos; */</span><br><span class="line">BPF_JSLT  0xc0  /* eBPF only: signed &apos;&lt;&apos; */</span><br><span class="line">BPF_JSLE  0xd0  /* eBPF only: signed &apos;&lt;=&apos; */</span><br></pre></td></tr></table></figure>
<p>所以指令’BPF_ADD | BPF_X | BPF_ALU’意味着32bit的加法在cBPF和eBPF中都是。在cBPF中只有两个寄存器，意味着A += X。在eBPF中意味着dst_reg = (u32) dst_reg + (u32) src_reg；类似’BPF_XOR | BPF_K | BPF_ALU’在cBPF中意味着A ^= imm32，在eBPF中src_reg = (u32) src_reg ^ (u32) imm32。</p>
<p>cBPF使用BPF_MISC类来表示移动指令A = X and X = A。eBPF使用’BPF_MOV | BPF_X | BPF_ALU’来替代。因为在eBPF中没有BPF_MISC这个类，对应的class 7用作BPF_ALU64，表示与BPF_ALU操作完全相同，但是使用64位操作数。所以’BPF_ADD | BPF_X | BPF_ALU64’意味着64bit的加例如：dst_reg = dst_reg + src_reg。</p>
<p>cBPF浪费了整个BPF_RET类来表示单个’ret’指令，典型的’BPF_RET | BPF_K’表示拷贝imm32到返回寄存器并进行函数退出。eBPF的模型更匹配CPU，所以’BPF_JMP | BPF_EXIT’在eBPF中仅表示函数退出。eBPF程序需要在BPF_EXIT之前把返回值存入到R0寄存器。eBPF中的class 6当前没有使用保留到将来使用。</p>
<p>2、load和store指令，8位“code”字段分为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+--------+--------+-------------------+</span><br><span class="line">| 3 bits | 2 bits |   3 bits          |</span><br><span class="line">|  mode  |  size  | instruction class |</span><br><span class="line">+--------+--------+-------------------+</span><br><span class="line">(MSB)                             (LSB)</span><br></pre></td></tr></table></figure>
<p>size字段含义如以下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BPF_W   0x00    /* word */</span><br><span class="line">BPF_H   0x08    /* half word */</span><br><span class="line">BPF_B   0x10    /* byte */</span><br><span class="line">BPF_DW  0x18    /* eBPF only, double word */</span><br></pre></td></tr></table></figure>
<p>在load/store操作中的size如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">B  - 1 byte</span><br><span class="line">H  - 2 byte</span><br><span class="line">W  - 4 byte</span><br><span class="line">DW - 8 byte (eBPF only)</span><br></pre></td></tr></table></figure>
<p>mode字段含义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BPF_IMM  0x00  /* used for 32-bit mov in classic BPF and 64-bit in eBPF */</span><br><span class="line">BPF_ABS  0x20</span><br><span class="line">BPF_IND  0x40</span><br><span class="line">BPF_MEM  0x60</span><br><span class="line">BPF_LEN  0x80  /* classic BPF only, reserved in eBPF */</span><br><span class="line">BPF_MSH  0xa0  /* classic BPF only, reserved in eBPF */</span><br><span class="line">BPF_XADD 0xc0  /* eBPF only, exclusive add */</span><br></pre></td></tr></table></figure>
<p>eBPF有两个不通用的指令： (BPF_ABS | <size> | BPF_LD) and (BPF_IND | <size> | BPF_LD) 其用来存取包数据。</size></size></p>
<p>为了在eBPF解释器中具有强大的socket filter性能，它们必须从classic版本中继承下来。只有当解释器上下文是指向’struct sk_buff’的指针，并且具有7个隐式操作数时，才能使用这些指令。寄存器R6是一个隐式输入，必须包含指向sk_buff的指针。寄存器R0是一个隐式输出，它包含从数据包中获取的数据。寄存器R1-R5是暂存寄存器，不能用于BPF_ABS | BPF_LD或BPF_IND | BPF_LD指令存储数据。</p>
<p>这些指令也有隐式程序退出条件。当eBPF程序试图访问数据包边界以外的数据时，解释器将中止程序的执行。因此，JIT编译器必须保留这个属性。src_reg和imm32字段是这些指令的显式输入。</p>
<p>举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BPF_IND | BPF_W | BPF_LD means:</span><br><span class="line"></span><br><span class="line">  R0 = ntohl(*(u32 *) (((struct sk_buff *) R6)-&gt;data + src_reg + imm32))</span><br><span class="line">  and R1 - R5 were scratched.</span><br></pre></td></tr></table></figure>
<p>与cBPF不同，eBPF拥有通用的load/store操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BPF_MEM | &lt;size&gt; | BPF_STX:  *(size *) (dst_reg + off) = src_reg</span><br><span class="line">BPF_MEM | &lt;size&gt; | BPF_ST:   *(size *) (dst_reg + off) = imm32</span><br><span class="line">BPF_MEM | &lt;size&gt; | BPF_LDX:  dst_reg = *(size *) (src_reg + off)</span><br><span class="line">BPF_XADD | BPF_W  | BPF_STX: lock xadd *(u32 *)(dst_reg + off16) += src_reg</span><br><span class="line">BPF_XADD | BPF_DW | BPF_STX: lock xadd *(u64 *)(dst_reg + off16) += src_reg</span><br></pre></td></tr></table></figure>
<p>其中size为:BPF_B或BPF_H或BPF_W或BPF_DW。注意，不支持1和2字节原子增量。</p>
<p>eBPF拥有一个16字节的指令：’BPF_LD | BPF_DW | BPF_IMM’，它由两个连续的“struct bpf_insn”8字节块组成，解释为将64位立即值加载到dst_reg的单个指令。<br>cBPF有类似的指令:BPF_LD | BPF_W | BPF_IMM，它将32位立即值加载到寄存器中。</p>
<h2 id="5-2、eBPF-verifier"><a href="#5-2、eBPF-verifier" class="headerlink" title="5.2、eBPF verifier"></a>5.2、eBPF verifier</h2><p>eBPF程序的安全性由两个步骤决定：</p>
<p>第一步做DAG检查以禁止循环和其他CFG验证。特别它将检测程序，有不可到达的指令。(虽然经典的BPF检查器允许这样做)</p>
<p>第二步从第一个insn开始，向下延伸所有可能的路径。它模拟了每一个insn的执行过程，观察寄存器和堆栈的状态变化。</p>
<ul>
<li><p>rule 1、在程序的开始R1包含指向context的指针类型为PTR_TO_CTX。如果verifier看到的指令为R2=R1，那么R2现有也有了类型PTR_TO_CTX，并且可以在表达式右侧使用。如果是 R1=PTR_TO_CTX and R2=R1+R1, 那么R2=SCALAR_VALUE，因为两个指针相加导致无效指针。(在’secure’模式verifier拒绝任何类型的指针算术计算以确保内核地址不会泄露给没有权限的用户)</p>
</li>
<li><p>rule 2、如果寄存器从来没被写过，那它是不可读的：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bpf_mov R0 = R2</span><br><span class="line">bpf_exit</span><br></pre></td></tr></table></figure>
<p>将被拒绝，因为R2在程序开始时不可读。</p>
<ul>
<li>rule 3、在内核函数调用以后，R1-R5重置成不可读状态，R0拥有一个函数的返回类型。</li>
</ul>
<p>因为R6-R9是对被调用者保护的，所以它们的状态在函数调用后不变。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bpf_mov R6 = 1</span><br><span class="line">bpf_call foo</span><br><span class="line">bpf_mov R0 = R6</span><br><span class="line">bpf_exit</span><br></pre></td></tr></table></figure>
<p>上述是一个正确的例子。如果把R6替换成R1，将会被拒绝。</p>
<ul>
<li>rule 4、load/store指令只有在寄存器类型有效时才被运行，包含PTR_TO_CTX, PTR_TO_MAP, PTR_TO_STACK类型。它们还有边界和对齐检查。例如：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bpf_mov R1 = 1</span><br><span class="line">bpf_mov R2 = 2</span><br><span class="line">bpf_xadd *(u32 *)(R1 + 3) += R2</span><br><span class="line">bpf_exit</span><br></pre></td></tr></table></figure>
<p>将会被拒绝，因为在执行指令bpf_xadd时R1没有有效的指针类型。</p>
<ul>
<li>rule 5、在开始R1类型是PTR_TO_CTX(一个指向’struct bpf_context’的指针)。一个回调用于自定义验证程序，以限制eBPF程序仅对具有指定大小和对齐方式的ctx结构中的某些字段进行访问。</li>
</ul>
<p>举例，以下的指令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bpf_ld R0 = *(u32 *)(R6 + 8)</span><br></pre></td></tr></table></figure>
<p>打算从地址R6 + 8加载一个word并将其存储到R0中。<br>如果R6=PTR_TO_CTX，通过is_valid_access()回调，验证者将知道偏移量为8的4字节成员是否可读，否则验证者将拒绝程序。<br>如果R6=PTR_TO_STACK，那么访问应该对齐并在堆栈边界内，即[-MAX_BPF_STACK, 0] 。在这个例子中偏移量是8，因此验证失败，因为它超出了界限。</p>
<ul>
<li>rule 6、只有在已经被写入的情况下verifier才允许eBPF程序从堆栈中读数据。<br>cBPF verifier对M[0-15]也有类似的检查。例如：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bpf_ld R0 = *(u32 *)(R10 - 4)</span><br><span class="line">bpf_exit</span><br></pre></td></tr></table></figure>
<p>是一段无效的程序。<br>景观R0是正确PTR_TO_STACK类型的只读寄存器，并且R10 - 4也在堆栈范围内，但是那个位置没有被存储过。</p>
<ul>
<li><p>rule 7、指针寄存器spill/fill也被被追踪(spill/fill就是寄存器push/pop堆栈)，因为4个被调用者保护寄存器(R6-R9)对某些程序来说不够用。</p>
</li>
<li><p>rule 8、使用pf_verifier_ops-&gt;get_func_proto()来决定是否允许函数调用，eBPF  verifier将检查寄存器是否匹配参数约束。在函数调用以后寄存器R0江北设置为函数返回类型。</p>
</li>
<li><p>rule 9、函数调用是扩展eBPF程序功能的主要机制。Socket filter可以让程序调用同一系列的函数，然而tracing filter可以运行调用完全不同系列的函数。</p>
</li>
<li><p>rule 10、如果一个函数可以被eBPF程序访问，它需要从安全的角度考虑。verifier将确保使用有效的参数调用函数。</p>
</li>
<li><p>rule 11、cBPF中seccomp和socket filters拥有不同的安全限制。seccomp使用两个阶段的verifier来保证：cBPF verifier、随后是seccomp verifier。对于eBPF，所有情况共享一个可配置的verifier。</p>
</li>
</ul>
<p>请参阅内核/bpf/verifier.c中关于eBPF verifier的更多细节。</p>
<h2 id="5-3、Register-value-tracking"><a href="#5-3、Register-value-tracking" class="headerlink" title="5.3、Register value tracking"></a>5.3、Register value tracking</h2><p>为了确定eBPF程序的安全性verifier必须跟踪每个寄存器和每个堆栈槽中可能的值的范围。<br>这是通过在include/linux/bpf_verifier.h中定义的’struct bpf_reg_state’来完成的，它统一了跟踪的标量和指针值。<br>寄存器状态有一个类型，它要么是NOT_INIT(寄存器还没有被写入)，要么是SCALAR_VALUE(一些不能用作指针的值)，要么是指针类型。指针类型描述它们的基址，如下所示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PTR_TO_CTX          Pointer to bpf_context.</span><br><span class="line">CONST_PTR_TO_MAP    Pointer to struct bpf_map.  &quot;Const&quot; because arithmetic</span><br><span class="line">                    on these pointers is forbidden.</span><br><span class="line">PTR_TO_MAP_VALUE    Pointer to the value stored in a map element.</span><br><span class="line">PTR_TO_MAP_VALUE_OR_NULL</span><br><span class="line">                    Either a pointer to a map value, or NULL; map accesses</span><br><span class="line">                    (see section &apos;eBPF maps&apos;, below) return this type,</span><br><span class="line">                    which becomes a PTR_TO_MAP_VALUE when checked != NULL.</span><br><span class="line">                    Arithmetic on these pointers is forbidden.</span><br><span class="line">PTR_TO_STACK        Frame pointer.</span><br><span class="line">PTR_TO_PACKET       skb-&gt;data.</span><br><span class="line">PTR_TO_PACKET_END   skb-&gt;data + headlen; arithmetic forbidden.</span><br></pre></td></tr></table></figure>
<p>然而，一个指针可以从这个基址上偏移(作为指针运算的结果)，跟踪分为两部分:’fixed offset’ and ‘variable offset’。前者是一个确切知道的值(例如一个立即数)，后者使用的值没有明确知道。variable offset也用于SCALAR_VALUEs，用于跟踪寄存器中可能的值的范围。</p>
<p>verifier关于variable offset的知识包括:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* minimum and maximum values as unsigned</span><br><span class="line">* minimum and maximum values as signed</span><br><span class="line">* 每个独立bit值的信息，以&apos;tnum&apos;的形式表示：a u64 &apos;mask&apos; and a u64 &apos;value&apos;。</span><br><span class="line">在mask中为1的bit的值为unknown，在value中为1的bit为已知1，bit已知为0则在mask和value中都为0，没有bit在mask和value中同时为1。</span><br><span class="line">例如，如果一个字节从内存读到寄存器中，寄存器的前56位已知为零，而低8位未知，它表示为tnum (0x0;0 xff)。如果是0x40，就得到(0x40;0xbf)，如果我们加上1，就得到(0x0;0x1ff),因为潜在的进位。这个格式应该是(value:mask)。</span><br></pre></td></tr></table></figure>
<p>除了算术运算，寄存器状态还可以通过条件分支来更新。例如，如果对SCALAR_VALUE进行比较&gt; 8，那么在’true’分支中，它将有一个 minimum值(unsigned minimum value)为9，而在’false’分支中，它将有一个umax_值为8。一个有符号的比较(使用BPF_JSGT或BPF_JSGE)将更新有符号的最小/最大值。来自有符号和无符号边界的信息可以组合;例如，如果首先测试一个值&lt; 8，然后测试s&gt; 4，verifier将得出这个值也是&gt; 4和s&lt; 8的结论，因为边界防止越过符号边界。</p>
<p>PTR_TO_PACKET的 variable offset部分拥有一个’id’，它对于共享同一个变量偏移的所有指针都是通用的。这是一个重要的包范围检查：在加上一个变量到包指针寄存器A以后，如果你然后拷贝A到另一寄存器B，然后再加上一个常量4到A，这两个寄存器有同样的变量’id’，但A还有一个固定的偏移量+4。然后如果A的边界检查小于PTR_TO_PACKET_END，那么寄存器B的安全范围至少为4字节。<br>有关PTR_TO_PACKET范围的更多信息，请参阅下面的“Direct packet access”。</p>
<p>“id”字段也用于PTR_TO_MAP_VALUE_OR_NULL，对于map查找返回的指针的所有副本都是通用的。这意味着当检查一个副本并发现它是非null时，所有副本都可以变成PTR_TO_MAP_VALUEs。<br>除了范围检查之外，跟踪信息还用于强制指针访问的对齐。例如，在大多数系统中，包指针是4字节对齐后的2字节。如果一个程序增加了14个字节跳过以太网报头,然后读取IHL并加上(IHL * 4),其结果指向一个变量等于4n+2对于n，所以添加2字节(NET_IP_ALIGN)给出了一个4字节对齐,所以word-sized通过该指针来访问是安全的。</p>
<h2 id="5-4、Direct-packet-access"><a href="#5-4、Direct-packet-access" class="headerlink" title="5.4、Direct packet access"></a>5.4、Direct packet access</h2><p>在cls_bpf和act_bpf程序中verifier允许直接访问包数据通过skb-&gt;data和 skb-&gt;data_end指针。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1:  r4 = *(u32 *)(r1 +80)  /* load skb-&gt;data_end */</span><br><span class="line">2:  r3 = *(u32 *)(r1 +76)  /* load skb-&gt;data */</span><br><span class="line">3:  r5 = r3</span><br><span class="line">4:  r5 += 14</span><br><span class="line">5:  if r5 &gt; r4 goto pc+16</span><br><span class="line">R1=ctx R3=pkt(id=0,off=0,r=14) R4=pkt_end R5=pkt(id=0,off=14,r=14) R10=fp</span><br><span class="line">6:  r0 = *(u16 *)(r3 +12) /* access 12 and 13 bytes of the packet */</span><br></pre></td></tr></table></figure>
<p>这个从包中load 2字节是安全的，因为程序作者在第5行指令’if (skb-&gt;data + 14 &gt; skb-&gt;data_end) goto err’中做了检查，意味着在失败的条件下寄存器R3(指向skb-&gt;data)拥有至少14字节的可访问空间。<br>verifier将其标记为R3=pkt(id=0,off=0,r=14)。<br>id=0表示没有向寄存器添加额外的变量偏移。<br>off=0表示没有添加额外的常量偏移。<br>r=14是安全访问的范围，这意味着字节[R3, R3 + 14]是可以的。<br>注意，R5被标记为R5=pkt(id=0,off=14,r=14)。它也指向包数据，但是常量偏移14被添加到寄存器中，所以它现在指向’skb-&gt;data + 14’，可访问范围是[R5, R5 + 14 - 14]即0字节。</p>
<p>更复杂的包存取如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> R0=inv1 R1=ctx R3=pkt(id=0,off=0,r=14) R4=pkt_end R5=pkt(id=0,off=14,r=14) R10=fp</span><br><span class="line"> 6:  r0 = *(u8 *)(r3 +7) /* load 7th byte from the packet */</span><br><span class="line"> 7:  r4 = *(u8 *)(r3 +12)</span><br><span class="line"> 8:  r4 *= 14</span><br><span class="line"> 9:  r3 = *(u32 *)(r1 +76) /* load skb-&gt;data */</span><br><span class="line">10:  r3 += r4</span><br><span class="line">11:  r2 = r1</span><br><span class="line">12:  r2 &lt;&lt;= 48</span><br><span class="line">13:  r2 &gt;&gt;= 48</span><br><span class="line">14:  r3 += r2</span><br><span class="line">15:  r2 = r3</span><br><span class="line">16:  r2 += 8</span><br><span class="line">17:  r1 = *(u32 *)(r1 +80) /* load skb-&gt;data_end */</span><br><span class="line">18:  if r2 &gt; r1 goto pc+2</span><br><span class="line"> R0=inv(id=0,umax_value=255,var_off=(0x0; 0xff)) R1=pkt_end R2=pkt(id=2,off=8,r=8) R3=pkt(id=2,off=0,r=8) R4=inv(id=0,umax_value=3570,var_off=(0x0; 0xfffe)) R5=pkt(id=0,off=14,r=14) R10=fp</span><br><span class="line">19:  r1 = *(u8 *)(r3 +4)</span><br></pre></td></tr></table></figure>
<p>寄存器R3的状态为R3=pkt(id=2,off=0,r=8)，id=2意味着看到两个’r3 += rX’这样的指令，所以r3指向包内的某个偏移量，因为程序作者在18行指令做了’if (r3 + 8 &gt; r1) goto err’的判断所以安全范围为[r3, r3 + 8]。<br>verifier值运行对包寄存器进行’add’/‘sub’操作，任何其他的操作将会把寄存器状态设置成’SCALAR_VALUE’将不能进行包的存取。<br>操作’r3 += rX’将可能会溢出并变得比原来的skb-&gt;数据少，因此验证者必须防止这种情况发生。因此，当它看到‘r3 += rX’指令，并且rX大于16-bit值时，任何后续的对skb-&gt;data_end的限制检查都不会给我们‘范围’信息，所以试图读取指针将会给出‘无效访问包’错误。<br>例如：在指令’r4 = <em>(u8 </em>)(r3 +12)’(上述第7行指令)以后，r4的状态为R4=R4=inv(id=0,umax_value=255,var_off=(0x0; 0xff))，这意味着寄存器的上56位被保证为0，对于下8位则一无所知。<br>在’r4 *= 14’ 指令以后状态变为R4=inv(id=0,umax_value=3570,var_off=(0x0; 0xfffe))，因为将一个8位的值乘以常数14将使上面的52位保持为零，并且最小有效位也将为零，因为14是偶数。<br>类似的 ‘r2 &gt;&gt;= 48’使R2=inv(id=0,umax_value=65535,var_off=(0x0; 0xffff))，因为移位不是符号扩展。这个逻辑是在adjust_reg_min_max_vals()函数中实现，它调用adjust_ptr_min_max_vals()来加指针到scalar(反之亦然)，以及使用adjust_scalar_min_max_vals()函数操作两个scalar。</p>
<p>最终的结果是bpf程序的作者可以直接使用正常的C代码访问包，为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void *data = (void *)(long)skb-&gt;data;</span><br><span class="line">void *data_end = (void *)(long)skb-&gt;data_end;</span><br><span class="line">struct eth_hdr *eth = data;</span><br><span class="line">struct iphdr *iph = data + sizeof(*eth);</span><br><span class="line">struct udphdr *udp = data + sizeof(*eth) + sizeof(*iph);</span><br><span class="line"></span><br><span class="line">if (data + sizeof(*eth) + sizeof(*iph) + sizeof(*udp) &gt; data_end)</span><br><span class="line">        return 0;</span><br><span class="line">if (eth-&gt;h_proto != htons(ETH_P_IP))</span><br><span class="line">        return 0;</span><br><span class="line">if (iph-&gt;protocol != IPPROTO_UDP || iph-&gt;ihl != 5)</span><br><span class="line">        return 0;</span><br><span class="line">if (udp-&gt;dest == 53 || udp-&gt;source == 9)</span><br><span class="line">        ...;</span><br></pre></td></tr></table></figure>
<p>这和直接写LD_ABS指令比较起来更容易、速度快得多。</p>
<h2 id="5-5、eBPF-maps"><a href="#5-5、eBPF-maps" class="headerlink" title="5.5、eBPF maps"></a>5.5、eBPF maps</h2><p>“map”是用于在内核和用户空间之间共享不同类型数据的通用存储机制。</p>
<p>map的存取通过BPF系统调用，它拥有以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- create a map with given type and attributes</span><br><span class="line">  map_fd = bpf(BPF_MAP_CREATE, union bpf_attr *attr, u32 size)</span><br><span class="line">  using attr-&gt;map_type, attr-&gt;key_size, attr-&gt;value_size, attr-&gt;max_entries</span><br><span class="line">  returns process-local file descriptor or negative error</span><br><span class="line"></span><br><span class="line">- lookup key in a given map</span><br><span class="line">  err = bpf(BPF_MAP_LOOKUP_ELEM, union bpf_attr *attr, u32 size)</span><br><span class="line">  using attr-&gt;map_fd, attr-&gt;key, attr-&gt;value</span><br><span class="line">  returns zero and stores found elem into value or negative error</span><br><span class="line"></span><br><span class="line">- create or update key/value pair in a given map</span><br><span class="line">  err = bpf(BPF_MAP_UPDATE_ELEM, union bpf_attr *attr, u32 size)</span><br><span class="line">  using attr-&gt;map_fd, attr-&gt;key, attr-&gt;value</span><br><span class="line">  returns zero or negative error</span><br><span class="line"></span><br><span class="line">- find and delete element by key in a given map</span><br><span class="line">  err = bpf(BPF_MAP_DELETE_ELEM, union bpf_attr *attr, u32 size)</span><br><span class="line">  using attr-&gt;map_fd, attr-&gt;key</span><br><span class="line"></span><br><span class="line">- to delete map: close(fd)</span><br><span class="line">  Exiting process will delete maps automatically</span><br></pre></td></tr></table></figure>
<p>用户空间程序使用这个syscall create/access map，eBPF程序也可以并发的更新map。</p>
<p>map拥有以下不同的类型：hash, array, bloom filter, radix-tree, etc。</p>
<p>map的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">. type</span><br><span class="line">. max number of elements</span><br><span class="line">. key size in bytes</span><br><span class="line">. value size in bytes</span><br></pre></td></tr></table></figure>
<h2 id="5-6、Pruning-修剪"><a href="#5-6、Pruning-修剪" class="headerlink" title="5.6、Pruning(修剪)"></a>5.6、Pruning(修剪)</h2><p>verifier实际上并没有遍历程序中所有可能的路径。对于要分析的每个新分支，verifier将查看在此指令下它以前所处的所有状态。如果它们中的任何一个包含当前状态作为一个子集，分支就被“修剪”了——也就是说，之前的状态被接受的事实意味着当前状态也是如此。<br>例如，如果在以前的状态中，r1持有一个包指针，而在当前状态中，r1持有一个包指针，它的范围是一样长或更长，并且至少有一样严格的对齐，那么r1是安全的。<br>类似地，如果r2之前是NOT_INIT，则从此点开始的任何路径都不能使用它，因此r2中的任何值(包括另一个NOT_INIT)都是安全的。实现在函数regsafe()中。<br>修剪不仅考虑寄存器，而且考虑堆栈(以及它可能包含的任何溢出寄存器)。要把树枝修剪掉，它们都必须是安全的。这是在states_equal()中实现的。</p>
<h2 id="5-7、Understanding-eBPF-verifier-messages"><a href="#5-7、Understanding-eBPF-verifier-messages" class="headerlink" title="5.7、Understanding eBPF verifier messages"></a>5.7、Understanding eBPF verifier messages</h2><p>以下是一些eBPF程序无效和验证错误消息的示例，如日志所示:</p>
<p>Program with unreachable instructions:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static struct bpf_insn prog[] = &#123;</span><br><span class="line">  BPF_EXIT_INSN(),</span><br><span class="line">  BPF_EXIT_INSN(),</span><br><span class="line">&#125;;</span><br><span class="line">Error:</span><br><span class="line">  unreachable insn 1</span><br></pre></td></tr></table></figure>
<p>Program that reads uninitialized register:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  BPF_MOV64_REG(BPF_REG_0, BPF_REG_2),</span><br><span class="line">  BPF_EXIT_INSN(),</span><br><span class="line">Error:</span><br><span class="line">  0: (bf) r0 = r2</span><br><span class="line">  R2 !read_ok</span><br></pre></td></tr></table></figure>
<p>Program that doesn’t initialize R0 before exiting:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  BPF_MOV64_REG(BPF_REG_2, BPF_REG_1),</span><br><span class="line">  BPF_EXIT_INSN(),</span><br><span class="line">Error:</span><br><span class="line">  0: (bf) r2 = r1</span><br><span class="line">  1: (95) exit</span><br><span class="line">  R0 !read_ok</span><br></pre></td></tr></table></figure>
<p>Program that accesses stack out of bounds:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  BPF_ST_MEM(BPF_DW, BPF_REG_10, 8, 0),</span><br><span class="line">  BPF_EXIT_INSN(),</span><br><span class="line">Error:</span><br><span class="line">  0: (7a) *(u64 *)(r10 +8) = 0</span><br><span class="line">  invalid stack off=8 size=8</span><br></pre></td></tr></table></figure>
<p>Program that doesn’t initialize stack before passing its address into function:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),</span><br><span class="line">  BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8),</span><br><span class="line">  BPF_LD_MAP_FD(BPF_REG_1, 0),</span><br><span class="line">  BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),</span><br><span class="line">  BPF_EXIT_INSN(),</span><br><span class="line">Error:</span><br><span class="line">  0: (bf) r2 = r10</span><br><span class="line">  1: (07) r2 += -8</span><br><span class="line">  2: (b7) r1 = 0x0</span><br><span class="line">  3: (85) call 1</span><br><span class="line">  invalid indirect read from stack off -8+0 size 8</span><br></pre></td></tr></table></figure>
<p>Program that uses invalid map_fd=0 while calling to map_lookup_elem() function:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  BPF_ST_MEM(BPF_DW, BPF_REG_10, -8, 0),</span><br><span class="line">  BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),</span><br><span class="line">  BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8),</span><br><span class="line">  BPF_LD_MAP_FD(BPF_REG_1, 0),</span><br><span class="line">  BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),</span><br><span class="line">  BPF_EXIT_INSN(),</span><br><span class="line">Error:</span><br><span class="line">  0: (7a) *(u64 *)(r10 -8) = 0</span><br><span class="line">  1: (bf) r2 = r10</span><br><span class="line">  2: (07) r2 += -8</span><br><span class="line">  3: (b7) r1 = 0x0</span><br><span class="line">  4: (85) call 1</span><br><span class="line">  fd 0 is not pointing to valid bpf_map</span><br></pre></td></tr></table></figure>
<p>Program that doesn’t check return value of map_lookup_elem() before accessing map element:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  BPF_ST_MEM(BPF_DW, BPF_REG_10, -8, 0),</span><br><span class="line">  BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),</span><br><span class="line">  BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8),</span><br><span class="line">  BPF_LD_MAP_FD(BPF_REG_1, 0),</span><br><span class="line">  BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),</span><br><span class="line">  BPF_ST_MEM(BPF_DW, BPF_REG_0, 0, 0),</span><br><span class="line">  BPF_EXIT_INSN(),</span><br><span class="line">Error:</span><br><span class="line">  0: (7a) *(u64 *)(r10 -8) = 0</span><br><span class="line">  1: (bf) r2 = r10</span><br><span class="line">  2: (07) r2 += -8</span><br><span class="line">  3: (b7) r1 = 0x0</span><br><span class="line">  4: (85) call 1</span><br><span class="line">  5: (7a) *(u64 *)(r0 +0) = 0</span><br><span class="line">  R0 invalid mem access &apos;map_value_or_null&apos;</span><br></pre></td></tr></table></figure>
<p>Program that correctly checks map_lookup_elem() returned value for NULL, but accesses the memory with incorrect alignment:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  BPF_ST_MEM(BPF_DW, BPF_REG_10, -8, 0),</span><br><span class="line">  BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),</span><br><span class="line">  BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8),</span><br><span class="line">  BPF_LD_MAP_FD(BPF_REG_1, 0),</span><br><span class="line">  BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),</span><br><span class="line">  BPF_JMP_IMM(BPF_JEQ, BPF_REG_0, 0, 1),</span><br><span class="line">  BPF_ST_MEM(BPF_DW, BPF_REG_0, 4, 0),</span><br><span class="line">  BPF_EXIT_INSN(),</span><br><span class="line">Error:</span><br><span class="line">  0: (7a) *(u64 *)(r10 -8) = 0</span><br><span class="line">  1: (bf) r2 = r10</span><br><span class="line">  2: (07) r2 += -8</span><br><span class="line">  3: (b7) r1 = 1</span><br><span class="line">  4: (85) call 1</span><br><span class="line">  5: (15) if r0 == 0x0 goto pc+1</span><br><span class="line">   R0=map_ptr R10=fp</span><br><span class="line">  6: (7a) *(u64 *)(r0 +4) = 0</span><br><span class="line">  misaligned access off 4 size 8</span><br></pre></td></tr></table></figure>
<p>Program that correctly checks map_lookup_elem() returned value for NULL and accesses memory with correct alignment in one side of ‘if’ branch, but fails to do so in the other side of ‘if’ branch:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  BPF_ST_MEM(BPF_DW, BPF_REG_10, -8, 0),</span><br><span class="line">  BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),</span><br><span class="line">  BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8),</span><br><span class="line">  BPF_LD_MAP_FD(BPF_REG_1, 0),</span><br><span class="line">  BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),</span><br><span class="line">  BPF_JMP_IMM(BPF_JEQ, BPF_REG_0, 0, 2),</span><br><span class="line">  BPF_ST_MEM(BPF_DW, BPF_REG_0, 0, 0),</span><br><span class="line">  BPF_EXIT_INSN(),</span><br><span class="line">  BPF_ST_MEM(BPF_DW, BPF_REG_0, 0, 1),</span><br><span class="line">  BPF_EXIT_INSN(),</span><br><span class="line">Error:</span><br><span class="line">  0: (7a) *(u64 *)(r10 -8) = 0</span><br><span class="line">  1: (bf) r2 = r10</span><br><span class="line">  2: (07) r2 += -8</span><br><span class="line">  3: (b7) r1 = 1</span><br><span class="line">  4: (85) call 1</span><br><span class="line">  5: (15) if r0 == 0x0 goto pc+2</span><br><span class="line">   R0=map_ptr R10=fp</span><br><span class="line">  6: (7a) *(u64 *)(r0 +0) = 0</span><br><span class="line">  7: (95) exit</span><br><span class="line"></span><br><span class="line">  from 5 to 8: R0=imm0 R10=fp</span><br><span class="line">  8: (7a) *(u64 *)(r0 +0) = 1</span><br><span class="line">  R0 invalid mem access &apos;imm&apos;</span><br></pre></td></tr></table></figure>
<h2 id="5-8、Testing"><a href="#5-8、Testing" class="headerlink" title="5.8、Testing"></a>5.8、Testing</h2><p>在BPF工具链旁边，内核还附带了一个测试模块，该模块包含用于classic和internal BPF的各种测试用例，可针对BPF解释器和JIT编译器执行。它可以在lib/test_bpf.c中找到。通过Kconfig启用:</p>
<p>CONFIG_TEST_BPF = m</p>
<p>在构建和安装模块之后，测试套件执行可以通过insmod或modprobe“test_bpf”模块。测试用例的结果包含nsec计时在内可以在内核日志(dmesg)中找到。</p>
<h2 id="5-9、Misc"><a href="#5-9、Misc" class="headerlink" title="5.9、Misc"></a>5.9、Misc</h2><p>此外，linux系统调用fuzzer，也内建支持BPF and SECCOMP-BPF kernel fuzzing。</p>
<h1 id="6、Written-by"><a href="#6、Written-by" class="headerlink" title="6、Written by"></a>6、Written by</h1><p>编写该文档的目的是希望它有用，并为潜在的BPF黑客或安全审核员更好地概述底层架构。</p>
<p>Jay Schulist <a href="mailto:&#x6a;&#115;&#99;&#104;&#108;&#115;&#116;&#x40;&#115;&#97;&#x6d;&#x62;&#97;&#46;&#111;&#x72;&#103;" target="_blank" rel="noopener">&#x6a;&#115;&#99;&#104;&#108;&#115;&#116;&#x40;&#115;&#97;&#x6d;&#x62;&#97;&#46;&#111;&#x72;&#103;</a><br>Daniel Borkmann <a href="mailto:&#x64;&#97;&#x6e;&#105;&#x65;&#108;&#64;&#105;&#111;&#103;&#101;&#x61;&#114;&#98;&#x6f;&#120;&#x2e;&#110;&#x65;&#x74;" target="_blank" rel="noopener">&#x64;&#97;&#x6e;&#105;&#x65;&#108;&#64;&#105;&#111;&#103;&#101;&#x61;&#114;&#98;&#x6f;&#120;&#x2e;&#110;&#x65;&#x74;</a><br>Alexei Starovoitov <a href="mailto:&#97;&#115;&#116;&#x40;&#x6b;&#101;&#x72;&#110;&#101;&#108;&#46;&#111;&#114;&#103;" target="_blank" rel="noopener">&#97;&#115;&#116;&#x40;&#x6b;&#101;&#x72;&#110;&#101;&#108;&#46;&#111;&#114;&#103;</a></p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/BPF/" rel="tag"># BPF</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/12/21/android_binder/" rel="next" title="Android Binder">
                <i class="fa fa-chevron-left"></i> Android Binder
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/12/21/perf_simpleperf/" rel="prev" title="Linux Perf 2.1、simpleperf">
                Linux Perf 2.1、simpleperf <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/touxiang/ycqs.jpg" alt="pwl999">
            
              <p class="site-author-name" itemprop="name">pwl999</p>
              <p class="site-description motion-element" itemprop="description">RTFSC(Read The Fucking Source Code)</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives">
                
                    <span class="site-state-item-count">30</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">3</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">22</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1、简介："><span class="nav-number">1.</span> <span class="nav-text">1、简介：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2、filter-code结构"><span class="nav-number">2.</span> <span class="nav-text">2、filter code结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1、filter实例"><span class="nav-number">2.1.</span> <span class="nav-text">2.1、filter实例</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3、BPF引擎和指令集"><span class="nav-number">3.</span> <span class="nav-text">3、BPF引擎和指令集</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4、JIT-compiler"><span class="nav-number">4.</span> <span class="nav-text">4、JIT compiler</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5、BPF在kernel内的实现-eBPF"><span class="nav-number">5.</span> <span class="nav-text">5、BPF在kernel内的实现(eBPF)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1、eBPF-opcode编码"><span class="nav-number">5.1.</span> <span class="nav-text">5.1、eBPF opcode编码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2、eBPF-verifier"><span class="nav-number">5.2.</span> <span class="nav-text">5.2、eBPF verifier</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3、Register-value-tracking"><span class="nav-number">5.3.</span> <span class="nav-text">5.3、Register value tracking</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-4、Direct-packet-access"><span class="nav-number">5.4.</span> <span class="nav-text">5.4、Direct packet access</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-5、eBPF-maps"><span class="nav-number">5.5.</span> <span class="nav-text">5.5、eBPF maps</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-6、Pruning-修剪"><span class="nav-number">5.6.</span> <span class="nav-text">5.6、Pruning(修剪)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-7、Understanding-eBPF-verifier-messages"><span class="nav-number">5.7.</span> <span class="nav-text">5.7、Understanding eBPF verifier messages</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-8、Testing"><span class="nav-number">5.8.</span> <span class="nav-text">5.8、Testing</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-9、Misc"><span class="nav-number">5.9.</span> <span class="nav-text">5.9、Misc</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6、Written-by"><span class="nav-number">6.</span> <span class="nav-text">6、Written by</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">pwl999</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v6.6.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script src="/js/src/utils.js?v=6.6.0"></script>

  <script src="/js/src/motion.js?v=6.6.0"></script>



  
  


  <script src="/js/src/affix.js?v=6.6.0"></script>

  <script src="/js/src/schemes/pisces.js?v=6.6.0"></script>



  
  <script src="/js/src/scrollspy.js?v=6.6.0"></script>
<script src="/js/src/post-details.js?v=6.6.0"></script>



  


  <script src="/js/src/bootstrap.js?v=6.6.0"></script>



  

  
    <script id="dsq-count-scr" src="https://.disqus.com/count.js" async></script>
  

  





  











  





  

  

  

  

  

  
  

  

  

  

  

  

  

</body>
</html>
