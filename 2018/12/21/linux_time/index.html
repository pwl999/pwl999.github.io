<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
































<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.6.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.6.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.6.0" color="#222">









<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.6.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="1、Linux时钟框架[^DroidPhoneo] 上图是linux时钟框架一个经典的描述。本质上linux各种时钟架构和服务是基于硬件提供的两种timer而构建的。 1、定时Timer  这类timer每个cpu都有一个独立的，称为local timer。这类timer的中断一般都是PPI（Private Peripheral Interrupt）类型，即每个cpu都有独立一份中断。 与PPI对">
<meta name="keywords" content="hrtimer, nohz">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux Time">
<meta property="og:url" content="http://yoursite.com/2018/12/21/linux_time/index.html">
<meta property="og:site_name" content="pwl999&#39;s blog">
<meta property="og:description" content="1、Linux时钟框架[^DroidPhoneo] 上图是linux时钟框架一个经典的描述。本质上linux各种时钟架构和服务是基于硬件提供的两种timer而构建的。 1、定时Timer  这类timer每个cpu都有一个独立的，称为local timer。这类timer的中断一般都是PPI（Private Peripheral Interrupt）类型，即每个cpu都有独立一份中断。 与PPI对">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/images/time/linux_time_profile.png">
<meta property="og:image" content="http://yoursite.com/images/time/exynos_timer.png">
<meta property="og:image" content="http://yoursite.com/images/time/exynos_mct_initflow.png">
<meta property="og:image" content="http://yoursite.com/images/time/clocksource_timekeeper.png">
<meta property="og:image" content="http://yoursite.com/images/time/clockevent.png">
<meta property="og:image" content="http://yoursite.com/images/time/clockevent_NOHZ_MODE_INACTIVE.png">
<meta property="og:image" content="http://yoursite.com/images/time/clockevent_NOHZ_MODE_LOWRES.png">
<meta property="og:image" content="http://yoursite.com/images/time/clockevent_NOHZ_MODE_HIGHRES.png">
<meta property="og:image" content="http://yoursite.com/images/time/ftrace_NOHZ_MODE_HIGHRES.png">
<meta property="og:image" content="http://yoursite.com/images/time/hrtimer.png">
<meta property="og:image" content="http://yoursite.com/images/time/lowres_timer.png">
<meta property="og:updated_time" content="2018-12-21T03:09:22.348Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Linux Time">
<meta name="twitter:description" content="1、Linux时钟框架[^DroidPhoneo] 上图是linux时钟框架一个经典的描述。本质上linux各种时钟架构和服务是基于硬件提供的两种timer而构建的。 1、定时Timer  这类timer每个cpu都有一个独立的，称为local timer。这类timer的中断一般都是PPI（Private Peripheral Interrupt）类型，即每个cpu都有独立一份中断。 与PPI对">
<meta name="twitter:image" content="http://yoursite.com/images/time/linux_time_profile.png">






  <link rel="canonical" href="http://yoursite.com/2018/12/21/linux_time/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Linux Time | pwl999's blog</title>
  












  <noscript>
  <style>
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion .logo-line-before i { left: initial; }
    .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">pwl999's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/21/linux_time/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="pwl999">
      <meta itemprop="description" content="RTFSC(Read The Fucking Source Code)">
      <meta itemprop="image" content="/images/touxiang/ycqs.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="pwl999's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Linux Time

              
            
          </h1>
        

        <div class="post-meta">

          
            <i class="fa fa-thumb-tack"></i>
            <font color="7D26CD">置顶</font>
            <span class="post-meta-divider">|</span>
          

        <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-21 10:18:21 / 修改时间：11:09:22" itemprop="dateCreated datePublished" datetime="2018-12-21T10:18:21+08:00">2018-12-21</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/12/21/linux_time/#comments" itemprop="discussionUrl">
                
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/12/21/linux_time/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="1、Linux时钟框架"><a href="#1、Linux时钟框架" class="headerlink" title="1、Linux时钟框架"></a>1、Linux时钟框架</h1><p><img src="/images/time/linux_time_profile.png" alt="linux_time_profile">[^DroidPhoneo]</p>
<p>上图是linux时钟框架一个经典的描述。本质上linux各种时钟架构和服务是基于硬件提供的两种timer而构建的。</p>
<p>1、定时Timer</p>
<ul>
<li>这类timer每个cpu都有一个独立的，称为local timer。这类timer的中断一般都是PPI（Private Peripheral Interrupt）类型，即每个cpu都有独立一份中断。 与PPI对应的是SPI（Shared Peripheral Interrupt，即多个cpu共享同一个中断。</li>
<li>这类timer一般是32bit宽度count，最重要的它会频繁的溢出并产生timer到期中断。</li>
<li>这类timer服务于tick timer(低精度)或者hrtimer(高精度)。</li>
<li>低精度模式，local timer工作在PERIODIC模式。即timer以tick时间(1/HZ)周期性的产生中断。在tick timer中处理任务调度tick、低精度timer、其他时间更新和统计profile。在这种模式下，所有利用时间的进行的运算，精度都是以tick(1/HZ)为单位的，精度较低。比如HZ=1000，那么tick=1ms。</li>
<li>高精度模式，local timer工作在ONESHOT模式。即系统可以支持hrtimer(high resolution)高精度timer，精度为local timer的计数clk达到ns级别。这种情况下把tick timer也转换成一种hrtimer。</li>
</ul>
<p>2、时间戳Timer</p>
<ul>
<li>这类timer一个系统多个cpu共享一个，称为global timer。</li>
<li>这类timer一般是32bit/64bit宽度count，一般不会溢出产生中断，系统实时的去读取count的值来计算当前的时间戳。</li>
<li>这类timer服务于clocksource/timekeeper。</li>
</ul>
<blockquote>
<p>本文的代码分析基于linux kernel 4.4.22，最好的学习方法还是”RTFSC”</p>
</blockquote>
<h2 id="1-1、Exynos-MCT-Multi-Core-Timer"><a href="#1-1、Exynos-MCT-Multi-Core-Timer" class="headerlink" title="1.1、Exynos MCT(Multi-Core Timer)"></a>1.1、Exynos MCT(Multi-Core Timer)</h2><p>我们以samsung exynos架构为例来说明linux对timer的使用。<br><img src="/images/time/exynos_timer.png" alt="exynos_timer"></p>
<p>从上图可以看到，exynos有1个64bit global timer用来做时间戳timer，有8个31bit localtimer用来做定时timer，每个cpu拥有一个localtimer。</p>
<p><img src="/images/time/exynos_mct_initflow.png" alt="exynos_mct_initflow"></p>
<p>上图是exynos driver的初始化流程，mct_init_dt()中包含了主要的初始化流程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static void __init mct_init_dt(struct device_node *np, unsigned int int_type)</span><br><span class="line">&#123;</span><br><span class="line">	exynos4_timer_resources(np, of_iomap(np, 0)); //(1)初始化localtimer，并将其注册成clockevent</span><br><span class="line">	exynos4_clocksource_init(); //(2)初始化globaltimer，并将其注册成clocksource</span><br><span class="line">	exynos4_clockevent_init(); //(3)将globaltimer的comparator 0注册成一个clockevent，一般不会使用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后面结合clocksource和clockevent的子系统的解析，再来详细描述exynos系统的具体实现。</p>
<h1 id="2、clocksource-amp-timekeeper"><a href="#2、clocksource-amp-timekeeper" class="headerlink" title="2、clocksource &amp; timekeeper"></a>2、clocksource &amp; timekeeper</h1><p><img src="/images/time/clocksource_timekeeper.png" alt="clocksource_timekeeper"></p>
<p>上图描述的是clocksource和timekeeper的关系：</p>
<ul>
<li>一个global timer对应注册一个clocksource。</li>
<li>一个系统中可以有多个clocksource，timekeeper选择精度最高的那个来使用。</li>
<li>用户使用timekeeper提供的接口来获取系统的时间戳。</li>
<li>为了避免无人主动获取时间clocksource定时器的溢出，timekeeper需要定期的去获取clocksource的值来更新系统时间，一般是在tick处理中更新。</li>
</ul>
<h2 id="2-1、clocksource"><a href="#2-1、clocksource" class="headerlink" title="2.1、clocksource"></a>2.1、clocksource</h2><p>下面来看一看clocksource的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static struct clocksource mct_frc = &#123;</span><br><span class="line">	.name		= &quot;mct-frc&quot;,</span><br><span class="line">	/* (1) .rating = 精度，数值越大越好，</span><br><span class="line">       select_best会选择精度最大的clocksource给timekeeper使用 */</span><br><span class="line">	.rating		= 400,  </span><br><span class="line">	/* (2) .read = 读取clocksource的timer当前计数 */</span><br><span class="line">	.read		= exynos4_frc_read,</span><br><span class="line">	/* (3) .mask = timer的位宽 */</span><br><span class="line">	.mask		= CLOCKSOURCE_MASK(32),</span><br><span class="line">	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,</span><br><span class="line">	.resume		= exynos4_frc_resume,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>看一下clocksource的注册过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line">static void __init exynos4_clocksource_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    // 启动global timer</span><br><span class="line">	exynos4_mct_frc_start();</span><br><span class="line"></span><br><span class="line">    // 注册timer_delay</span><br><span class="line">	exynos4_delay_timer.read_current_timer = &amp;exynos4_read_current_timer;</span><br><span class="line">	exynos4_delay_timer.freq = clk_rate;</span><br><span class="line">	register_current_timer_delay(&amp;exynos4_delay_timer);</span><br><span class="line"></span><br><span class="line">    // (1) 注册clocksource</span><br><span class="line">	if (clocksource_register_hz(&amp;mct_frc, clk_rate))</span><br><span class="line">		panic(&quot;%s: can&apos;t register clocksource\n&quot;, mct_frc.name);</span><br><span class="line"></span><br><span class="line">    // 注册sched_clock</span><br><span class="line">	sched_clock_register(exynos4_read_sched_clock, 32, clk_rate);</span><br><span class="line">&#125;</span><br><span class="line">|→</span><br><span class="line">static inline int clocksource_register_hz(struct clocksource *cs, u32 hz)</span><br><span class="line">&#123;</span><br><span class="line">	return __clocksource_register_scale(cs, 1, hz);</span><br><span class="line">&#125;</span><br><span class="line">||→</span><br><span class="line">int __clocksource_register_scale(struct clocksource *cs, u32 scale, u32 freq)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	/* Initialize mult/shift and max_idle_ns */</span><br><span class="line">	/* (1.1) 根据timer的频率freq，计算cs-&gt;mult、cs-&gt;shift</span><br><span class="line">	    这两个字段是用来把timer的计数转换成实际时间单位ns</span><br><span class="line">	    ns = (count * cs-&gt;mult) &gt;&gt; cs-&gt;shift */</span><br><span class="line">	__clocksource_update_freq_scale(cs, scale, freq);</span><br><span class="line"></span><br><span class="line">	/* Add clocksource to the clocksource list */</span><br><span class="line">	mutex_lock(&amp;clocksource_mutex);</span><br><span class="line">	/* (1.2) 将新的clocksource加入全局链表 */</span><br><span class="line">	clocksource_enqueue(cs);</span><br><span class="line">	clocksource_enqueue_watchdog(cs);</span><br><span class="line">	/* (1.3) 从全局链表中重新选择一个best</span><br><span class="line">	    clocksource给timekeeper使用 */</span><br><span class="line">	clocksource_select();</span><br><span class="line">	clocksource_select_watchdog(false);</span><br><span class="line">	mutex_unlock(&amp;clocksource_mutex);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">|||→</span><br><span class="line">void __clocksource_update_freq_scale(struct clocksource *cs, u32 scale, u32 freq)</span><br><span class="line">&#123;</span><br><span class="line">	u64 sec;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Default clocksources are *special* and self-define their mult/shift.</span><br><span class="line">	 * But, you&apos;re not special, so you should specify a freq value.</span><br><span class="line">	 */</span><br><span class="line">	if (freq) &#123;</span><br><span class="line">		/*</span><br><span class="line">		 * Calc the maximum number of seconds which we can run before</span><br><span class="line">		 * wrapping around. For clocksources which have a mask &gt; 32-bit</span><br><span class="line">		 * we need to limit the max sleep time to have a good</span><br><span class="line">		 * conversion precision. 10 minutes is still a reasonable</span><br><span class="line">		 * amount. That results in a shift value of 24 for a</span><br><span class="line">		 * clocksource with mask &gt;= 40-bit and f &gt;= 4GHz. That maps to</span><br><span class="line">		 * ~ 0.06ppm granularity for NTP.</span><br><span class="line">		 */</span><br><span class="line">		/* (1.1.1) 计算timer计数器到溢出，</span><br><span class="line">		    最大能计数多少秒 = sec */</span><br><span class="line">		sec = cs-&gt;mask;</span><br><span class="line">		do_div(sec, freq);</span><br><span class="line">		do_div(sec, scale);</span><br><span class="line">		if (!sec)</span><br><span class="line">			sec = 1;</span><br><span class="line">		else if (sec &gt; 600 &amp;&amp; cs-&gt;mask &gt; UINT_MAX)</span><br><span class="line">			sec = 600;</span><br><span class="line"></span><br><span class="line">        /* (1.1.2) 根据1s内的频率数freq，和1s内的ns数NSEC_PER_SEC</span><br><span class="line">            计算freq和ns之间的转换公式：</span><br><span class="line">            ns = (freq * cs-&gt;mult) &gt;&gt; cs-&gt;shift </span><br><span class="line">            目的是把mult和shift算到最大值，最大可能的保留精度 */</span><br><span class="line">		clocks_calc_mult_shift(&amp;cs-&gt;mult, &amp;cs-&gt;shift, freq,</span><br><span class="line">				       NSEC_PER_SEC / scale, sec * scale);</span><br><span class="line">	&#125;</span><br><span class="line">	/*</span><br><span class="line">	 * Ensure clocksources that have large &apos;mult&apos; values don&apos;t overflow</span><br><span class="line">	 * when adjusted.</span><br><span class="line">	 */</span><br><span class="line">	cs-&gt;maxadj = clocksource_max_adjustment(cs);</span><br><span class="line">	while (freq &amp;&amp; ((cs-&gt;mult + cs-&gt;maxadj &lt; cs-&gt;mult)</span><br><span class="line">		|| (cs-&gt;mult - cs-&gt;maxadj &gt; cs-&gt;mult))) &#123;</span><br><span class="line">		cs-&gt;mult &gt;&gt;= 1;</span><br><span class="line">		cs-&gt;shift--;</span><br><span class="line">		cs-&gt;maxadj = clocksource_max_adjustment(cs);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Only warn for *special* clocksources that self-define</span><br><span class="line">	 * their mult/shift values and don&apos;t specify a freq.</span><br><span class="line">	 */</span><br><span class="line">	WARN_ONCE(cs-&gt;mult + cs-&gt;maxadj &lt; cs-&gt;mult,</span><br><span class="line">		&quot;timekeeping: Clocksource %s might overflow on 11%% adjustment\n&quot;,</span><br><span class="line">		cs-&gt;name);</span><br><span class="line"></span><br><span class="line">    /* (1.1.3) 根据mult和shift的值，计算最大能进入idle的时间max_idle_ns</span><br><span class="line">        才能保证idle时timer不会溢出*/</span><br><span class="line">	clocksource_update_max_deferment(cs);</span><br><span class="line"></span><br><span class="line">	pr_info(&quot;%s: mask: 0x%llx max_cycles: 0x%llx, max_idle_ns: %lld ns\n&quot;,</span><br><span class="line">		cs-&gt;name, cs-&gt;mask, cs-&gt;max_cycles, cs-&gt;max_idle_ns);</span><br><span class="line">&#125;</span><br><span class="line">|||→</span><br><span class="line">static void clocksource_select(void)</span><br><span class="line">&#123;</span><br><span class="line">	__clocksource_select(false);</span><br><span class="line">&#125;</span><br><span class="line">static void __clocksource_select(bool skipcur)</span><br><span class="line">&#123;</span><br><span class="line">	bool oneshot = tick_oneshot_mode_active();</span><br><span class="line">	struct clocksource *best, *cs;</span><br><span class="line"></span><br><span class="line">	/* Find the best suitable clocksource */</span><br><span class="line">	/* (1.3.1) 选择best clocksource */</span><br><span class="line">	best = clocksource_find_best(oneshot, skipcur);</span><br><span class="line">	if (!best)</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	/* Check for the override clocksource. */</span><br><span class="line">	list_for_each_entry(cs, &amp;clocksource_list, list) &#123;</span><br><span class="line">		if (skipcur &amp;&amp; cs == curr_clocksource)</span><br><span class="line">			continue;</span><br><span class="line">		if (strcmp(cs-&gt;name, override_name) != 0)</span><br><span class="line">			continue;</span><br><span class="line">		/*</span><br><span class="line">		 * Check to make sure we don&apos;t switch to a non-highres</span><br><span class="line">		 * capable clocksource if the tick code is in oneshot</span><br><span class="line">		 * mode (highres or nohz)</span><br><span class="line">		 */</span><br><span class="line">		if (!(cs-&gt;flags &amp; CLOCK_SOURCE_VALID_FOR_HRES) &amp;&amp; oneshot) &#123;</span><br><span class="line">			/* Override clocksource cannot be used. */</span><br><span class="line">			pr_warn(&quot;Override clocksource %s is not HRT compatible - cannot switch while in HRT/NOHZ mode\n&quot;,</span><br><span class="line">				cs-&gt;name);</span><br><span class="line">			override_name[0] = 0;</span><br><span class="line">		&#125; else</span><br><span class="line">			/* Override clocksource can be used. */</span><br><span class="line">			best = cs;</span><br><span class="line">		break;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (1.3.2) 通知timekeeper更新clocksource，tick-sched更新 */</span><br><span class="line">	if (curr_clocksource != best &amp;&amp; !timekeeping_notify(best)) &#123;</span><br><span class="line">		pr_info(&quot;Switched to clocksource %s\n&quot;, best-&gt;name);</span><br><span class="line">		curr_clocksource = best;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">||||→</span><br><span class="line">int timekeeping_notify(struct clocksource *clock)</span><br><span class="line">&#123;</span><br><span class="line">	struct timekeeper *tk = &amp;tk_core.timekeeper;</span><br><span class="line"></span><br><span class="line">	if (tk-&gt;tkr_mono.clock == clock)</span><br><span class="line">		return 0;</span><br><span class="line">	stop_machine(change_clocksource, clock, NULL);</span><br><span class="line">	tick_clock_notify();</span><br><span class="line">	return tk-&gt;tkr_mono.clock == clock ? 0 : -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-1-1、exynos4-clocksource-init"><a href="#2-1-1、exynos4-clocksource-init" class="headerlink" title="2.1.1、exynos4_clocksource_init()"></a>2.1.1、exynos4_clocksource_init()</h3><p>exynos将global timer注册成clocksource，虽然global timer拥有64bit的位宽，但是注册的时候把其当成32bit的clocksource注册。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">static u32 notrace exynos4_read_count_32(void)</span><br><span class="line">&#123;</span><br><span class="line">	return readl_relaxed(reg_base + EXYNOS4_MCT_G_CNT_L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static cycle_t exynos4_frc_read(struct clocksource *cs)</span><br><span class="line">&#123;</span><br><span class="line">	return exynos4_read_count_32();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static struct clocksource mct_frc = &#123;</span><br><span class="line">	.name		= &quot;mct-frc&quot;,</span><br><span class="line">	.rating		= 400,</span><br><span class="line">	.read		= exynos4_frc_read,</span><br><span class="line">	.mask		= CLOCKSOURCE_MASK(32),</span><br><span class="line">	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,</span><br><span class="line">	.resume		= exynos4_frc_resume,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void __init exynos4_clocksource_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	exynos4_mct_frc_start();</span><br><span class="line"></span><br><span class="line">	exynos4_delay_timer.read_current_timer = &amp;exynos4_read_current_timer;</span><br><span class="line">	exynos4_delay_timer.freq = clk_rate;</span><br><span class="line">	register_current_timer_delay(&amp;exynos4_delay_timer);</span><br><span class="line"></span><br><span class="line">    /* (1) exynos将global timer注册成clocksource */</span><br><span class="line">	if (clocksource_register_hz(&amp;mct_frc, clk_rate))</span><br><span class="line">		panic(&quot;%s: can&apos;t register clocksource\n&quot;, mct_frc.name);</span><br><span class="line"></span><br><span class="line">	sched_clock_register(exynos4_read_sched_clock, 32, clk_rate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2、timekeeper"><a href="#2-2、timekeeper" class="headerlink" title="2.2、timekeeper"></a>2.2、timekeeper</h2><p>timerkeeper提供了几种时间：xtime、monotonic time、raw monotonic time、boot time。</p>
<ul>
<li><strong>xtime</strong> 即是wall time，和RTC时间一样可以表示当前的时刻，它的起始时间是公元0世纪0秒，精度大于RTC时间；</li>
<li><strong>monotonic time</strong> 从系统开机后到现在的累计时间，不过不计算系统休眠的时间；</li>
<li><strong>raw monotonic time</strong> 和monotonic time含义一样，不过更纯粹，不会受到NTP时间调整的影响；</li>
<li><strong>boot time</strong> 在monotonic time的基础上加上了系统休眠的时间，它代表着系统上电后的总时间。</li>
</ul>
<table>
<thead>
<tr>
<th>时间种类</th>
<th>精度（统计单位）</th>
<th>访问速度</th>
<th>累计休眠时间</th>
<th>受NTP调整的影响</th>
<th>获取函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>RTC</td>
<td>低</td>
<td>慢</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>xtime</td>
<td>高</td>
<td>快</td>
<td>Yes</td>
<td>Yes</td>
<td>do_gettimeofday()、ktime_get_real_ts()、ktime_get_real()</td>
</tr>
<tr>
<td>monotonic</td>
<td>高</td>
<td>快</td>
<td>No</td>
<td>Yes</td>
<td>ktime_get()、ktime_get_ts64()</td>
</tr>
<tr>
<td>raw monotonic</td>
<td>高</td>
<td>快</td>
<td>No</td>
<td>No</td>
<td>ktime_get_raw()、getrawmonotonic64()</td>
</tr>
<tr>
<td>boot time</td>
<td>高</td>
<td>快</td>
<td>Yes</td>
<td>Yes</td>
<td>ktime_get_boottime()</td>
</tr>
</tbody>
</table>
<h3 id="2-2-1、timekeeper的定义"><a href="#2-2-1、timekeeper的定义" class="headerlink" title="2.2.1、timekeeper的定义"></a>2.2.1、timekeeper的定义</h3><p>虽然clocksource定时器只有一个，但是timekeeper提供了xtime、monotonic time、raw time、boot time等几种时间，所以timekeeper结构体中定义了多个变量来记住这些差值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * struct timekeeper - Structure holding internal timekeeping values.</span><br><span class="line"> * @tkr_mono:		The readout base structure for CLOCK_MONOTONIC</span><br><span class="line"> * @tkr_raw:		The readout base structure for CLOCK_MONOTONIC_RAW</span><br><span class="line"> * @xtime_sec:		Current CLOCK_REALTIME time in seconds</span><br><span class="line"> * @ktime_sec:		Current CLOCK_MONOTONIC time in seconds</span><br><span class="line"> * @wall_to_monotonic:	CLOCK_REALTIME to CLOCK_MONOTONIC offset</span><br><span class="line"> * @offs_real:		Offset clock monotonic -&gt; clock realtime</span><br><span class="line"> * @offs_boot:		Offset clock monotonic -&gt; clock boottime</span><br><span class="line"> * @offs_tai:		Offset clock monotonic -&gt; clock tai</span><br><span class="line"> * @tai_offset:		The current UTC to TAI offset in seconds</span><br><span class="line"> * @clock_was_set_seq:	The sequence number of clock was set events</span><br><span class="line"> * @next_leap_ktime:	CLOCK_MONOTONIC time value of a pending leap-second</span><br><span class="line"> * @raw_time:		Monotonic raw base time in timespec64 format</span><br><span class="line"> * @cycle_interval:	Number of clock cycles in one NTP interval</span><br><span class="line"> * @xtime_interval:	Number of clock shifted nano seconds in one NTP</span><br><span class="line"> *			interval.</span><br><span class="line"> * @xtime_remainder:	Shifted nano seconds left over when rounding</span><br><span class="line"> *			@cycle_interval</span><br><span class="line"> * @raw_interval:	Raw nano seconds accumulated per NTP interval.</span><br><span class="line"> * @ntp_error:		Difference between accumulated time and NTP time in ntp</span><br><span class="line"> *			shifted nano seconds.</span><br><span class="line"> * @ntp_error_shift:	Shift conversion between clock shifted nano seconds and</span><br><span class="line"> *			ntp shifted nano seconds.</span><br><span class="line"> * @last_warning:	Warning ratelimiter (DEBUG_TIMEKEEPING)</span><br><span class="line"> * @underflow_seen:	Underflow warning flag (DEBUG_TIMEKEEPING)</span><br><span class="line"> * @overflow_seen:	Overflow warning flag (DEBUG_TIMEKEEPING)</span><br><span class="line"> *</span><br><span class="line"> * Note: For timespec(64) based interfaces wall_to_monotonic is what</span><br><span class="line"> * we need to add to xtime (or xtime corrected for sub jiffie times)</span><br><span class="line"> * to get to monotonic time.  Monotonic is pegged at zero at system</span><br><span class="line"> * boot time, so wall_to_monotonic will be negative, however, we will</span><br><span class="line"> * ALWAYS keep the tv_nsec part positive so we can use the usual</span><br><span class="line"> * normalization.</span><br><span class="line"> *</span><br><span class="line"> * wall_to_monotonic is moved after resume from suspend for the</span><br><span class="line"> * monotonic time not to jump. We need to add total_sleep_time to</span><br><span class="line"> * wall_to_monotonic to get the real boot based time offset.</span><br><span class="line"> *</span><br><span class="line"> * wall_to_monotonic is no longer the boot time, getboottime must be</span><br><span class="line"> * used instead.</span><br><span class="line"> */</span><br><span class="line">struct timekeeper &#123;</span><br><span class="line">	struct tk_read_base	tkr_mono;   </span><br><span class="line">                // tkr_mono.xtime_nsec：xtime/monotonic time 的ns</span><br><span class="line">                // tkr_mono.base：monotonic time的base部分</span><br><span class="line">	struct tk_read_base	tkr_raw;</span><br><span class="line">                // tkr_mono.base：raw time的base部分</span><br><span class="line">	u64			xtime_sec;              // xtime的sec</span><br><span class="line">	unsigned long		ktime_sec;      // monotonic time 的整sec</span><br><span class="line">	struct timespec64	wall_to_monotonic;  // xtime + wall_to_monotonic = monotonic time</span><br><span class="line">	ktime_t			offs_real;  //  monotonic time + offs_real = xtime，</span><br><span class="line">                                // 和wall_to_monotonic是相反的值</span><br><span class="line">	ktime_t			offs_boot;  //  monotonic time + offs_boot = boot time</span><br><span class="line">	ktime_t			offs_tai;</span><br><span class="line">	s32			tai_offset;</span><br><span class="line">	unsigned int		clock_was_set_seq;</span><br><span class="line">	ktime_t			next_leap_ktime;</span><br><span class="line">	struct timespec64	raw_time;   // raw time</span><br><span class="line"></span><br><span class="line">	/* The following members are for timekeeping internal use */</span><br><span class="line">	cycle_t			cycle_interval;</span><br><span class="line">	u64			xtime_interval;</span><br><span class="line">	s64			xtime_remainder;</span><br><span class="line">	u32			raw_interval;</span><br><span class="line">	/* The ntp_tick_length() value currently being used.</span><br><span class="line">	 * This cached copy ensures we consistently apply the tick</span><br><span class="line">	 * length for an entire tick, as ntp_tick_length may change</span><br><span class="line">	 * mid-tick, and we don&apos;t want to apply that new value to</span><br><span class="line">	 * the tick in progress.</span><br><span class="line">	 */</span><br><span class="line">	u64			ntp_tick;</span><br><span class="line">	/* Difference between accumulated time and NTP time in ntp</span><br><span class="line">	 * shifted nano seconds. */</span><br><span class="line">	s64			ntp_error;</span><br><span class="line">	u32			ntp_error_shift;</span><br><span class="line">	u32			ntp_err_mult;</span><br><span class="line">#ifdef CONFIG_DEBUG_TIMEKEEPING</span><br><span class="line">	long			last_warning;</span><br><span class="line">	/*</span><br><span class="line">	 * These simple flag variables are managed</span><br><span class="line">	 * without locks, which is racy, but they are</span><br><span class="line">	 * ok since we don&apos;t really care about being</span><br><span class="line">	 * super precise about how many events were</span><br><span class="line">	 * seen, just that a problem was observed.</span><br><span class="line">	 */</span><br><span class="line">	int			underflow_seen;</span><br><span class="line">	int			overflow_seen;</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-2、timekeeper的初始化"><a href="#2-2-2、timekeeper的初始化" class="headerlink" title="2.2.2、timekeeper的初始化"></a>2.2.2、timekeeper的初始化</h3><p>timekeeper在初始化的过程中，读取当前的RTC值和clocksource的值，来初始化xtime、monotonic time、raw time、boot time，以及各种offset。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">void __init timekeeping_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	struct timekeeper *tk = &amp;tk_core.timekeeper;</span><br><span class="line">	struct clocksource *clock;</span><br><span class="line">	unsigned long flags;</span><br><span class="line">	struct timespec64 now, boot, tmp;</span><br><span class="line"></span><br><span class="line">	read_persistent_clock64(&amp;now);</span><br><span class="line">	if (!timespec64_valid_strict(&amp;now)) &#123;</span><br><span class="line">		pr_warn(&quot;WARNING: Persistent clock returned invalid value!\n&quot;</span><br><span class="line">			&quot;         Check your CMOS/BIOS settings.\n&quot;);</span><br><span class="line">		now.tv_sec = 0;</span><br><span class="line">		now.tv_nsec = 0;</span><br><span class="line">	&#125; else if (now.tv_sec || now.tv_nsec)</span><br><span class="line">		persistent_clock_exists = true;</span><br><span class="line"></span><br><span class="line">	read_boot_clock64(&amp;boot);</span><br><span class="line">	if (!timespec64_valid_strict(&amp;boot)) &#123;</span><br><span class="line">		pr_warn(&quot;WARNING: Boot clock returned invalid value!\n&quot;</span><br><span class="line">			&quot;         Check your CMOS/BIOS settings.\n&quot;);</span><br><span class="line">		boot.tv_sec = 0;</span><br><span class="line">		boot.tv_nsec = 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	raw_spin_lock_irqsave(&amp;timekeeper_lock, flags);</span><br><span class="line">	write_seqcount_begin(&amp;tk_core.seq);</span><br><span class="line">	ntp_init();</span><br><span class="line"></span><br><span class="line">	clock = clocksource_default_clock();</span><br><span class="line">	if (clock-&gt;enable)</span><br><span class="line">		clock-&gt;enable(clock);</span><br><span class="line">	tk_setup_internals(tk, clock);</span><br><span class="line"></span><br><span class="line">	tk_set_xtime(tk, &amp;now);</span><br><span class="line">	tk-&gt;raw_time.tv_sec = 0;</span><br><span class="line">	tk-&gt;raw_time.tv_nsec = 0;</span><br><span class="line">	if (boot.tv_sec == 0 &amp;&amp; boot.tv_nsec == 0)</span><br><span class="line">		boot = tk_xtime(tk);</span><br><span class="line"></span><br><span class="line">	set_normalized_timespec64(&amp;tmp, -boot.tv_sec, -boot.tv_nsec);</span><br><span class="line">	tk_set_wall_to_mono(tk, tmp);</span><br><span class="line"></span><br><span class="line">	timekeeping_update(tk, TK_MIRROR | TK_CLOCK_WAS_SET);</span><br><span class="line"></span><br><span class="line">	write_seqcount_end(&amp;tk_core.seq);</span><br><span class="line">	raw_spin_unlock_irqrestore(&amp;timekeeper_lock, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>timekeeper原理上的初始化是在timekeeping_init()函数中完成的，但是read_persistent_clock64()、read_boot_clock64()都是空函数，所以实际上的初始化是另外的路径：rtc_hctosys() -&gt; do_settimeofday64()，rtc初始化的时候重新配置timekeeper。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">static int __init rtc_hctosys(void)</span><br><span class="line">&#123;</span><br><span class="line">	int err = -ENODEV;</span><br><span class="line">	struct rtc_time tm;</span><br><span class="line">	struct timespec64 tv64 = &#123;</span><br><span class="line">		.tv_nsec = NSEC_PER_SEC &gt;&gt; 1,</span><br><span class="line">	&#125;;</span><br><span class="line">	struct rtc_device *rtc = rtc_class_open(CONFIG_RTC_HCTOSYS_DEVICE);</span><br><span class="line"></span><br><span class="line">	if (rtc == NULL) &#123;</span><br><span class="line">		pr_info(&quot;unable to open rtc device (%s)\n&quot;,</span><br><span class="line">			CONFIG_RTC_HCTOSYS_DEVICE);</span><br><span class="line">		goto err_open;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (1) 读取当前的rtc时间 */</span><br><span class="line">	err = rtc_read_time(rtc, &amp;tm);</span><br><span class="line">	if (err) &#123;</span><br><span class="line">		dev_err(rtc-&gt;dev.parent,</span><br><span class="line">			&quot;hctosys: unable to read the hardware clock\n&quot;);</span><br><span class="line">		goto err_read;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	tv64.tv_sec = rtc_tm_to_time64(&amp;tm);</span><br><span class="line">	tv64.tv_nsec = tm.tm_cnt * (1000000000 / 32768);</span><br><span class="line">	</span><br><span class="line">	/* (2) 根据rtc时间配置xtime */</span><br><span class="line">	err = do_settimeofday64(&amp;tv64);</span><br><span class="line"></span><br><span class="line">	dev_info(rtc-&gt;dev.parent,</span><br><span class="line">		&quot;setting system clock to &quot;</span><br><span class="line">		&quot;%d-%02d-%02d %02d:%02d:%02d UTC (%lld)\n&quot;,</span><br><span class="line">		tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,</span><br><span class="line">		tm.tm_hour, tm.tm_min, tm.tm_sec,</span><br><span class="line">		(long long) tv64.tv_sec);</span><br><span class="line"></span><br><span class="line">err_read:</span><br><span class="line">	rtc_class_close(rtc);</span><br><span class="line"></span><br><span class="line">err_open:</span><br><span class="line">	rtc_hctosys_ret = err;</span><br><span class="line"></span><br><span class="line">	return err;</span><br><span class="line">&#125;</span><br><span class="line">|→</span><br><span class="line">int do_settimeofday64(const struct timespec64 *ts)</span><br><span class="line">&#123;</span><br><span class="line">	struct timekeeper *tk = &amp;tk_core.timekeeper;</span><br><span class="line">	struct timespec64 ts_delta, xt;</span><br><span class="line">	unsigned long flags;</span><br><span class="line">	int ret = 0;</span><br><span class="line"></span><br><span class="line">	if (!timespec64_valid_strict(ts))</span><br><span class="line">		return -EINVAL;</span><br><span class="line"></span><br><span class="line">	raw_spin_lock_irqsave(&amp;timekeeper_lock, flags);</span><br><span class="line">	write_seqcount_begin(&amp;tk_core.seq);</span><br><span class="line"></span><br><span class="line">	timekeeping_forward_now(tk);</span><br><span class="line"></span><br><span class="line">    /* (2.1) 读取当前的xtime，计算rtc time和xtime之间的差值  */</span><br><span class="line">	xt = tk_xtime(tk);</span><br><span class="line">	ts_delta.tv_sec = ts-&gt;tv_sec - xt.tv_sec;</span><br><span class="line">	ts_delta.tv_nsec = ts-&gt;tv_nsec - xt.tv_nsec;</span><br><span class="line"></span><br><span class="line">	if (timespec64_compare(&amp;tk-&gt;wall_to_monotonic, &amp;ts_delta) &gt; 0) &#123;</span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">		goto out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (2.2) 将差值追加到offset；tk-&gt;wall_to_monotonic、tk-&gt;offs_real */</span><br><span class="line">	tk_set_wall_to_mono(tk, timespec64_sub(tk-&gt;wall_to_monotonic, ts_delta));</span><br><span class="line"></span><br><span class="line">    /* (2.3) 更新xtime */</span><br><span class="line">	tk_set_xtime(tk, ts);</span><br><span class="line">out:</span><br><span class="line">	timekeeping_update(tk, TK_CLEAR_NTP | TK_MIRROR | TK_CLOCK_WAS_SET);</span><br><span class="line"></span><br><span class="line">	write_seqcount_end(&amp;tk_core.seq);</span><br><span class="line">	raw_spin_unlock_irqrestore(&amp;timekeeper_lock, flags);</span><br><span class="line"></span><br><span class="line">	/* signal hrtimers about time change */</span><br><span class="line">	clock_was_set();</span><br><span class="line">	notify_time_update();</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-3、timekeeper的update"><a href="#2-2-3、timekeeper的update" class="headerlink" title="2.2.3、timekeeper的update"></a>2.2.3、timekeeper的update</h3><p>clocksource定时器的值要定时的读出来，并且把增量加到timekeeper中，不然clocksource定时器会溢出。这个定时更新的时间一般是1 tick，调用的函数是update_wall_time()：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line">void update_wall_time(void)</span><br><span class="line">&#123;</span><br><span class="line">	struct timekeeper *real_tk = &amp;tk_core.timekeeper;</span><br><span class="line">	struct timekeeper *tk = &amp;shadow_timekeeper;</span><br><span class="line">	cycle_t offset;</span><br><span class="line">	int shift = 0, maxshift;</span><br><span class="line">	unsigned int clock_set = 0;</span><br><span class="line">	unsigned long flags;</span><br><span class="line"></span><br><span class="line">	raw_spin_lock_irqsave(&amp;timekeeper_lock, flags);</span><br><span class="line"></span><br><span class="line">	/* Make sure we&apos;re fully resumed: */</span><br><span class="line">	if (unlikely(timekeeping_suspended))</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_ARCH_USES_GETTIMEOFFSET</span><br><span class="line">	offset = real_tk-&gt;cycle_interval;</span><br><span class="line">#else</span><br><span class="line">    /* (1) 获取clocksource和上一次update之间的offset */</span><br><span class="line">	offset = clocksource_delta(tk-&gt;tkr_mono.read(tk-&gt;tkr_mono.clock),</span><br><span class="line">				   tk-&gt;tkr_mono.cycle_last, tk-&gt;tkr_mono.mask);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	/* Check if there&apos;s really nothing to do */</span><br><span class="line">	if (offset &lt; real_tk-&gt;cycle_interval)</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">	/* Do some additional sanity checking */</span><br><span class="line">	timekeeping_check_update(real_tk, offset);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * With NO_HZ we may have to accumulate many cycle_intervals</span><br><span class="line">	 * (think &quot;ticks&quot;) worth of time at once. To do this efficiently,</span><br><span class="line">	 * we calculate the largest doubling multiple of cycle_intervals</span><br><span class="line">	 * that is smaller than the offset.  We then accumulate that</span><br><span class="line">	 * chunk in one go, and then try to consume the next smaller</span><br><span class="line">	 * doubled multiple.</span><br><span class="line">	 */</span><br><span class="line">	shift = ilog2(offset) - ilog2(tk-&gt;cycle_interval);</span><br><span class="line">	shift = max(0, shift);</span><br><span class="line">	/* Bound shift to one less than what overflows tick_length */</span><br><span class="line">	maxshift = (64 - (ilog2(ntp_tick_length())+1)) - 1;</span><br><span class="line">	shift = min(shift, maxshift);</span><br><span class="line">	/* (2) 如果offset的值是多个cycle_interval，</span><br><span class="line">	    不要一次update，使用2的n次方cycle_interval的方式逐个update。</span><br><span class="line">	    tk-&gt;cycle_interval的值在tk_setup_internals()时被赋值，默认为1 tick */</span><br><span class="line">	while (offset &gt;= tk-&gt;cycle_interval) &#123;</span><br><span class="line">	    /* (3) 将offset更新到timekeeper中 */</span><br><span class="line">		offset = logarithmic_accumulation(tk, offset, shift,</span><br><span class="line">							&amp;clock_set);</span><br><span class="line">		if (offset &lt; tk-&gt;cycle_interval&lt;&lt;shift)</span><br><span class="line">			shift--;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* correct the clock when NTP error is too big */</span><br><span class="line">	timekeeping_adjust(tk, offset);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * XXX This can be killed once everyone converts</span><br><span class="line">	 * to the new update_vsyscall.</span><br><span class="line">	 */</span><br><span class="line">	old_vsyscall_fixup(tk);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Finally, make sure that after the rounding</span><br><span class="line">	 * xtime_nsec isn&apos;t larger than NSEC_PER_SEC</span><br><span class="line">	 */</span><br><span class="line">	clock_set |= accumulate_nsecs_to_secs(tk);</span><br><span class="line"></span><br><span class="line">	write_seqcount_begin(&amp;tk_core.seq);</span><br><span class="line">	/*</span><br><span class="line">	 * Update the real timekeeper.</span><br><span class="line">	 *</span><br><span class="line">	 * We could avoid this memcpy by switching pointers, but that</span><br><span class="line">	 * requires changes to all other timekeeper usage sites as</span><br><span class="line">	 * well, i.e. move the timekeeper pointer getter into the</span><br><span class="line">	 * spinlocked/seqcount protected sections. And we trade this</span><br><span class="line">	 * memcpy under the tk_core.seq against one before we start</span><br><span class="line">	 * updating.</span><br><span class="line">	 */</span><br><span class="line">	/* (4)  */</span><br><span class="line">	timekeeping_update(tk, clock_set);</span><br><span class="line">	memcpy(real_tk, tk, sizeof(*tk));</span><br><span class="line">	/* The memcpy must come last. Do not put anything here! */</span><br><span class="line">	write_seqcount_end(&amp;tk_core.seq);</span><br><span class="line">out:</span><br><span class="line">	raw_spin_unlock_irqrestore(&amp;timekeeper_lock, flags);</span><br><span class="line">	if (clock_set)</span><br><span class="line">		/* Have to call _delayed version, since in irq context*/</span><br><span class="line">		clock_was_set_delayed();</span><br><span class="line">&#125;</span><br><span class="line">|→</span><br><span class="line">static cycle_t logarithmic_accumulation(struct timekeeper *tk, cycle_t offset,</span><br><span class="line">						u32 shift,</span><br><span class="line">						unsigned int *clock_set)</span><br><span class="line">&#123;</span><br><span class="line">	cycle_t interval = tk-&gt;cycle_interval &lt;&lt; shift;</span><br><span class="line">	u64 raw_nsecs;</span><br><span class="line"></span><br><span class="line">	/* If the offset is smaller than a shifted interval, do nothing */</span><br><span class="line">	if (offset &lt; interval)</span><br><span class="line">		return offset;</span><br><span class="line"></span><br><span class="line">	/* Accumulate one shifted interval */</span><br><span class="line">	offset -= interval;</span><br><span class="line">	/* (3.1) 更新cycle_last */</span><br><span class="line">	tk-&gt;tkr_mono.cycle_last += interval;</span><br><span class="line">	tk-&gt;tkr_raw.cycle_last  += interval;</span><br><span class="line"></span><br><span class="line">    /* (3.2) 更新xtime：</span><br><span class="line">        tk-&gt;tkr_mono.xtime_nsec</span><br><span class="line">        tk-&gt;xtime_sec   */</span><br><span class="line">	tk-&gt;tkr_mono.xtime_nsec += tk-&gt;xtime_interval &lt;&lt; shift;</span><br><span class="line">	*clock_set |= accumulate_nsecs_to_secs(tk);</span><br><span class="line"></span><br><span class="line">	/* Accumulate raw time */</span><br><span class="line">	/* (3.3) 更新raw time：</span><br><span class="line">	   tk-&gt;raw_time.tv_nsec</span><br><span class="line">	   tk-&gt;raw_time.tv_sec */</span><br><span class="line">	raw_nsecs = (u64)tk-&gt;raw_interval &lt;&lt; shift;</span><br><span class="line">	raw_nsecs += tk-&gt;raw_time.tv_nsec;</span><br><span class="line">	if (raw_nsecs &gt;= NSEC_PER_SEC) &#123;</span><br><span class="line">		u64 raw_secs = raw_nsecs;</span><br><span class="line">		raw_nsecs = do_div(raw_secs, NSEC_PER_SEC);</span><br><span class="line">		tk-&gt;raw_time.tv_sec += raw_secs;</span><br><span class="line">	&#125;</span><br><span class="line">	tk-&gt;raw_time.tv_nsec = raw_nsecs;</span><br><span class="line"></span><br><span class="line">	/* Accumulate error between NTP and clock interval */</span><br><span class="line">	tk-&gt;ntp_error += tk-&gt;ntp_tick &lt;&lt; shift;</span><br><span class="line">	tk-&gt;ntp_error -= (tk-&gt;xtime_interval + tk-&gt;xtime_remainder) &lt;&lt;</span><br><span class="line">						(tk-&gt;ntp_error_shift + shift);</span><br><span class="line"></span><br><span class="line">	return offset;</span><br><span class="line">&#125;</span><br><span class="line">|→</span><br><span class="line">static void timekeeping_update(struct timekeeper *tk, unsigned int action)</span><br><span class="line">&#123;</span><br><span class="line">	if (action &amp; TK_CLEAR_NTP) &#123;</span><br><span class="line">		tk-&gt;ntp_error = 0;</span><br><span class="line">		ntp_clear();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	tk_update_leap_state(tk);</span><br><span class="line">	/* (4.1) update monotonic time */</span><br><span class="line">	tk_update_ktime_data(tk);</span><br><span class="line"></span><br><span class="line">	update_vsyscall(tk);</span><br><span class="line">	update_pvclock_gtod(tk, action &amp; TK_CLOCK_WAS_SET);</span><br><span class="line"></span><br><span class="line">	update_fast_timekeeper(&amp;tk-&gt;tkr_mono, &amp;tk_fast_mono);</span><br><span class="line">	update_fast_timekeeper(&amp;tk-&gt;tkr_raw,  &amp;tk_fast_raw);</span><br><span class="line"></span><br><span class="line">	if (action &amp; TK_CLOCK_WAS_SET)</span><br><span class="line">		tk-&gt;clock_was_set_seq++;</span><br><span class="line">	/*</span><br><span class="line">	 * The mirroring of the data to the shadow-timekeeper needs</span><br><span class="line">	 * to happen last here to ensure we don&apos;t over-write the</span><br><span class="line">	 * timekeeper structure on the next update with stale data</span><br><span class="line">	 */</span><br><span class="line">	if (action &amp; TK_MIRROR)</span><br><span class="line">		memcpy(&amp;shadow_timekeeper, &amp;tk_core.timekeeper,</span><br><span class="line">		       sizeof(tk_core.timekeeper));</span><br><span class="line">&#125;</span><br><span class="line">||→</span><br><span class="line">static inline void tk_update_ktime_data(struct timekeeper *tk)</span><br><span class="line">&#123;</span><br><span class="line">	u64 seconds;</span><br><span class="line">	u32 nsec;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * The xtime based monotonic readout is:</span><br><span class="line">	 *	nsec = (xtime_sec + wtm_sec) * 1e9 + wtm_nsec + now();</span><br><span class="line">	 * The ktime based monotonic readout is:</span><br><span class="line">	 *	nsec = base_mono + now();</span><br><span class="line">	 * ==&gt; base_mono = (xtime_sec + wtm_sec) * 1e9 + wtm_nsec</span><br><span class="line">	 */</span><br><span class="line">	/* (4.1.1) update tk-&gt;tkr_mono.base的值，</span><br><span class="line">	   = tk-&gt;xtime_sec +  tk-&gt;wall_to_monotonic,</span><br><span class="line">	   tk-&gt;tkr_mono.xtime_nsec 没有计算到base中 */</span><br><span class="line">	seconds = (u64)(tk-&gt;xtime_sec + tk-&gt;wall_to_monotonic.tv_sec);</span><br><span class="line">	nsec = (u32) tk-&gt;wall_to_monotonic.tv_nsec;</span><br><span class="line">	tk-&gt;tkr_mono.base = ns_to_ktime(seconds * NSEC_PER_SEC + nsec);</span><br><span class="line"></span><br><span class="line">	/* Update the monotonic raw base */</span><br><span class="line">	/* (4.1.2) update tk-&gt;tkr_raw.base的值，</span><br><span class="line">	   直接转换tk-&gt;raw_time */</span><br><span class="line">	tk-&gt;tkr_raw.base = timespec64_to_ktime(tk-&gt;raw_time);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * The sum of the nanoseconds portions of xtime and</span><br><span class="line">	 * wall_to_monotonic can be greater/equal one second. Take</span><br><span class="line">	 * this into account before updating tk-&gt;ktime_sec.</span><br><span class="line">	 */</span><br><span class="line">	/* (4.1.3) update tk-&gt;ktime_sec的值</span><br><span class="line">	nsec += (u32)(tk-&gt;tkr_mono.xtime_nsec &gt;&gt; tk-&gt;tkr_mono.shift);</span><br><span class="line">	if (nsec &gt;= NSEC_PER_SEC)</span><br><span class="line">		seconds++;</span><br><span class="line">	tk-&gt;ktime_sec = seconds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-4、timekeeper的获取"><a href="#2-2-4、timekeeper的获取" class="headerlink" title="2.2.4、timekeeper的获取"></a>2.2.4、timekeeper的获取</h3><ul>
<li><strong>xtime/wall time 的获取:</strong></li>
</ul>
<p>do_gettimeofday()、ktime_get_real_ts()最后调用的getnstimeofday64() -&gt; __getnstimeofday64()获取到xtime：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">int __getnstimeofday64(struct timespec64 *ts)</span><br><span class="line">&#123;</span><br><span class="line">	struct timekeeper *tk = &amp;tk_core.timekeeper;</span><br><span class="line">	unsigned long seq;</span><br><span class="line">	s64 nsecs = 0;</span><br><span class="line"></span><br><span class="line">	do &#123;</span><br><span class="line">		seq = read_seqcount_begin(&amp;tk_core.seq);</span><br><span class="line"></span><br><span class="line">        /* (1) sec直接从变量tk-&gt;xtime_sec获取到，</span><br><span class="line">            即上一tick更新的值 */</span><br><span class="line">		ts-&gt;tv_sec = tk-&gt;xtime_sec;</span><br><span class="line">		</span><br><span class="line">		/* (2) nsec需要更新最新的值：tk-&gt;tkr_mono.xtime_nsec + delta</span><br><span class="line">		    delta是距离上一次tick更新的差值 */</span><br><span class="line">		nsecs = timekeeping_get_ns(&amp;tk-&gt;tkr_mono);</span><br><span class="line"></span><br><span class="line">	&#125; while (read_seqcount_retry(&amp;tk_core.seq, seq));</span><br><span class="line"></span><br><span class="line">	ts-&gt;tv_nsec = 0;</span><br><span class="line">	timespec64_add_ns(ts, nsecs);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Do not bail out early, in case there were callers still using</span><br><span class="line">	 * the value, even in the face of the WARN_ON.</span><br><span class="line">	 */</span><br><span class="line">	if (unlikely(timekeeping_suspended))</span><br><span class="line">		return -EAGAIN;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">|→</span><br><span class="line">static inline s64 timekeeping_get_ns(struct tk_read_base *tkr)</span><br><span class="line">&#123;</span><br><span class="line">	cycle_t delta;</span><br><span class="line">	s64 nsec;</span><br><span class="line"></span><br><span class="line">    /* (2.1) 获取距离上一次tick更新，timer的delta值  */</span><br><span class="line">	delta = timekeeping_get_delta(tkr);</span><br><span class="line"></span><br><span class="line">    /* (2.2) delta加上上一次的nsec tkr-&gt;xtime_nsec，</span><br><span class="line">        即为最新的ns值 */</span><br><span class="line">	nsec = (delta * tkr-&gt;mult + tkr-&gt;xtime_nsec) &gt;&gt; tkr-&gt;shift;</span><br><span class="line"></span><br><span class="line">	/* If arch requires, add in get_arch_timeoffset() */</span><br><span class="line">	return nsec + arch_gettimeoffset();</span><br><span class="line">&#125;</span><br><span class="line">||→</span><br><span class="line">static inline cycle_t timekeeping_get_delta(struct tk_read_base *tkr)</span><br><span class="line">&#123;</span><br><span class="line">	struct timekeeper *tk = &amp;tk_core.timekeeper;</span><br><span class="line">	cycle_t now, last, mask, max, delta;</span><br><span class="line">	unsigned int seq;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Since we&apos;re called holding a seqlock, the data may shift</span><br><span class="line">	 * under us while we&apos;re doing the calculation. This can cause</span><br><span class="line">	 * false positives, since we&apos;d note a problem but throw the</span><br><span class="line">	 * results away. So nest another seqlock here to atomically</span><br><span class="line">	 * grab the points we are checking with.</span><br><span class="line">	 */</span><br><span class="line">	do &#123;</span><br><span class="line">		seq = read_seqcount_begin(&amp;tk_core.seq);</span><br><span class="line">		/* (2.1.1) 使用read函数读取当前timer的计数 */</span><br><span class="line">		now = tkr-&gt;read(tkr-&gt;clock);</span><br><span class="line">		last = tkr-&gt;cycle_last;</span><br><span class="line">		mask = tkr-&gt;mask;</span><br><span class="line">		max = tkr-&gt;clock-&gt;max_cycles;</span><br><span class="line">	&#125; while (read_seqcount_retry(&amp;tk_core.seq, seq));</span><br><span class="line"></span><br><span class="line">    /* (2.1.2) 使用公式：(now - last) &amp; mask，</span><br><span class="line">        计算delta值 */</span><br><span class="line">	delta = clocksource_delta(now, last, mask);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Try to catch underflows by checking if we are seeing small</span><br><span class="line">	 * mask-relative negative values.</span><br><span class="line">	 */</span><br><span class="line">	if (unlikely((~delta &amp; mask) &lt; (mask &gt;&gt; 3))) &#123;</span><br><span class="line">		tk-&gt;underflow_seen = 1;</span><br><span class="line">		delta = 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* Cap delta value to the max_cycles values to avoid mult overflows */</span><br><span class="line">	if (unlikely(delta &gt; max)) &#123;</span><br><span class="line">		tk-&gt;overflow_seen = 1;</span><br><span class="line">		delta = tkr-&gt;clock-&gt;max_cycles;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return delta;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ktime_get_real()使用monotonic time再加上差值timekeeper.offs_real的方法来获取xtime：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">static inline ktime_t ktime_get_real(void)</span><br><span class="line">&#123;</span><br><span class="line">	return ktime_get_with_offset(TK_OFFS_REAL);</span><br><span class="line">&#125;</span><br><span class="line">|→</span><br><span class="line">static ktime_t *offsets[TK_OFFS_MAX] = &#123;</span><br><span class="line">	[TK_OFFS_REAL]	= &amp;tk_core.timekeeper.offs_real,</span><br><span class="line">	[TK_OFFS_BOOT]	= &amp;tk_core.timekeeper.offs_boot,</span><br><span class="line">	[TK_OFFS_TAI]	= &amp;tk_core.timekeeper.offs_tai,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ktime_t ktime_get_with_offset(enum tk_offsets offs)</span><br><span class="line">&#123;</span><br><span class="line">	struct timekeeper *tk = &amp;tk_core.timekeeper;</span><br><span class="line">	unsigned int seq;</span><br><span class="line">	ktime_t base, *offset = offsets[offs];</span><br><span class="line">	s64 nsecs;</span><br><span class="line"></span><br><span class="line">	WARN_ON(timekeeping_suspended);</span><br><span class="line"></span><br><span class="line">	do &#123;</span><br><span class="line">		seq = read_seqcount_begin(&amp;tk_core.seq);</span><br><span class="line">		/* (1) monotonic time = tk-&gt;tkr_mono.base，</span><br><span class="line">		   offset = timekeeper.offs_real */</span><br><span class="line">		base = ktime_add(tk-&gt;tkr_mono.base, *offset);</span><br><span class="line">		/* (2) nsec需要更新最新的值：tk-&gt;tkr_mono.xtime_nsec + delta</span><br><span class="line">		    delta是距离上一次tick更新的差值 */</span><br><span class="line">		nsecs = timekeeping_get_ns(&amp;tk-&gt;tkr_mono);</span><br><span class="line"></span><br><span class="line">	&#125; while (read_seqcount_retry(&amp;tk_core.seq, seq));</span><br><span class="line"></span><br><span class="line">	return ktime_add_ns(base, nsecs);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>monotonic time 的获取；</strong></li>
</ul>
<p>ktime_get()直接获取monotonic time：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ktime_t ktime_get(void)</span><br><span class="line">&#123;</span><br><span class="line">	struct timekeeper *tk = &amp;tk_core.timekeeper;</span><br><span class="line">	unsigned int seq;</span><br><span class="line">	ktime_t base;</span><br><span class="line">	s64 nsecs;</span><br><span class="line"></span><br><span class="line">	WARN_ON(timekeeping_suspended);</span><br><span class="line"></span><br><span class="line">	do &#123;</span><br><span class="line">		seq = read_seqcount_begin(&amp;tk_core.seq);</span><br><span class="line">		/* (1) monotonic time = tk-&gt;tkr_mono.base */</span><br><span class="line">		base = tk-&gt;tkr_mono.base;</span><br><span class="line">		/* (2) nsec需要更新最新的值：tk-&gt;tkr_mono.xtime_nsec + delta</span><br><span class="line">		    delta是距离上一次tick更新的差值 */</span><br><span class="line">		nsecs = timekeeping_get_ns(&amp;tk-&gt;tkr_mono);</span><br><span class="line"></span><br><span class="line">	&#125; while (read_seqcount_retry(&amp;tk_core.seq, seq));</span><br><span class="line"></span><br><span class="line">	return ktime_add_ns(base, nsecs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ktime_get_ts64()通过xtime加上差值tk-&gt;wall_to_monotonic的方法来获取monotonic time：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void ktime_get_ts64(struct timespec64 *ts)</span><br><span class="line">&#123;</span><br><span class="line">	struct timekeeper *tk = &amp;tk_core.timekeeper;</span><br><span class="line">	struct timespec64 tomono;</span><br><span class="line">	s64 nsec;</span><br><span class="line">	unsigned int seq;</span><br><span class="line"></span><br><span class="line">	WARN_ON(timekeeping_suspended);</span><br><span class="line"></span><br><span class="line">	do &#123;</span><br><span class="line">		seq = read_seqcount_begin(&amp;tk_core.seq);</span><br><span class="line">		/* (1) 获取xtime */</span><br><span class="line">		ts-&gt;tv_sec = tk-&gt;xtime_sec;</span><br><span class="line">		nsec = timekeeping_get_ns(&amp;tk-&gt;tkr_mono);</span><br><span class="line">		/* (2) 加上xtime和monotonic之间的差值tk-&gt;wall_to_monotonic */</span><br><span class="line">		tomono = tk-&gt;wall_to_monotonic;</span><br><span class="line"></span><br><span class="line">	&#125; while (read_seqcount_retry(&amp;tk_core.seq, seq));</span><br><span class="line"></span><br><span class="line">	ts-&gt;tv_sec += tomono.tv_sec;</span><br><span class="line">	ts-&gt;tv_nsec = 0;</span><br><span class="line">	timespec64_add_ns(ts, nsec + tomono.tv_nsec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>raw monotonic time 的获取；</strong></li>
</ul>
<p>ktime_get_raw()通过tk-&gt;tkr_raw.base获取raw monotonic time：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ktime_t ktime_get_raw(void)</span><br><span class="line">&#123;</span><br><span class="line">	struct timekeeper *tk = &amp;tk_core.timekeeper;</span><br><span class="line">	unsigned int seq;</span><br><span class="line">	ktime_t base;</span><br><span class="line">	s64 nsecs;</span><br><span class="line"></span><br><span class="line">	do &#123;</span><br><span class="line">		seq = read_seqcount_begin(&amp;tk_core.seq);</span><br><span class="line">		/* (1) raw monotonic time = tk-&gt;tkr_raw.base */</span><br><span class="line">		base = tk-&gt;tkr_raw.base;</span><br><span class="line">		/* (2) nsec需要更新最新的值：tk-&gt;tkr_raw.xtime_nsec + delta</span><br><span class="line">		    delta是距离上一次tick更新的差值 */</span><br><span class="line">		nsecs = timekeeping_get_ns(&amp;tk-&gt;tkr_raw);</span><br><span class="line"></span><br><span class="line">	&#125; while (read_seqcount_retry(&amp;tk_core.seq, seq));</span><br><span class="line"></span><br><span class="line">	return ktime_add_ns(base, nsecs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getrawmonotonic64()通过tk-&gt;raw_time获取raw monotonic time：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void getrawmonotonic64(struct timespec64 *ts)</span><br><span class="line">&#123;</span><br><span class="line">	struct timekeeper *tk = &amp;tk_core.timekeeper;</span><br><span class="line">	struct timespec64 ts64;</span><br><span class="line">	unsigned long seq;</span><br><span class="line">	s64 nsecs;</span><br><span class="line"></span><br><span class="line">	do &#123;</span><br><span class="line">		seq = read_seqcount_begin(&amp;tk_core.seq);</span><br><span class="line">		nsecs = timekeeping_get_ns(&amp;tk-&gt;tkr_raw);</span><br><span class="line">		ts64 = tk-&gt;raw_time;</span><br><span class="line"></span><br><span class="line">	&#125; while (read_seqcount_retry(&amp;tk_core.seq, seq));</span><br><span class="line"></span><br><span class="line">	timespec64_add_ns(&amp;ts64, nsecs);</span><br><span class="line">	*ts = ts64;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>boot time 的获取；</strong></li>
</ul>
<p>ktime_get_boottime()使用monotonic time再加上差值timekeeper.offs_boot的方法来获取boot time：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">static inline ktime_t ktime_get_boottime(void)</span><br><span class="line">&#123;</span><br><span class="line">	return ktime_get_with_offset(TK_OFFS_BOOT);</span><br><span class="line">&#125;</span><br><span class="line">|→</span><br><span class="line">static ktime_t *offsets[TK_OFFS_MAX] = &#123;</span><br><span class="line">	[TK_OFFS_REAL]	= &amp;tk_core.timekeeper.offs_real,</span><br><span class="line">	[TK_OFFS_BOOT]	= &amp;tk_core.timekeeper.offs_boot,</span><br><span class="line">	[TK_OFFS_TAI]	= &amp;tk_core.timekeeper.offs_tai,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ktime_t ktime_get_with_offset(enum tk_offsets offs)</span><br><span class="line">&#123;</span><br><span class="line">	struct timekeeper *tk = &amp;tk_core.timekeeper;</span><br><span class="line">	unsigned int seq;</span><br><span class="line">	ktime_t base, *offset = offsets[offs];</span><br><span class="line">	s64 nsecs;</span><br><span class="line"></span><br><span class="line">	WARN_ON(timekeeping_suspended);</span><br><span class="line"></span><br><span class="line">	do &#123;</span><br><span class="line">		seq = read_seqcount_begin(&amp;tk_core.seq);</span><br><span class="line">		/* (1) monotonic time = tk-&gt;tkr_mono.base，</span><br><span class="line">		   offset = timekeeper.offs_boot */</span><br><span class="line">		base = ktime_add(tk-&gt;tkr_mono.base, *offset);</span><br><span class="line">		/* (2) nsec需要更新最新的值：tk-&gt;tkr_mono.xtime_nsec + delta</span><br><span class="line">		    delta是距离上一次tick更新的差值 */</span><br><span class="line">		nsecs = timekeeping_get_ns(&amp;tk-&gt;tkr_mono);</span><br><span class="line"></span><br><span class="line">	&#125; while (read_seqcount_retry(&amp;tk_core.seq, seq));</span><br><span class="line"></span><br><span class="line">	return ktime_add_ns(base, nsecs);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-5、timekeeper-suspend"><a href="#2-2-5、timekeeper-suspend" class="headerlink" title="2.2.5、timekeeper suspend"></a>2.2.5、timekeeper suspend</h3><p>系统在进入suspend以后，clocksource不会再工作，这部分时间会计入xtime和boot time，但是不会计入monotonic time。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line">void timekeeping_resume(void)</span><br><span class="line">&#123;</span><br><span class="line">	struct timekeeper *tk = &amp;tk_core.timekeeper;</span><br><span class="line">	struct clocksource *clock = tk-&gt;tkr_mono.clock;</span><br><span class="line">	unsigned long flags;</span><br><span class="line">	struct timespec64 ts_new, ts_delta;</span><br><span class="line">	cycle_t cycle_now, cycle_delta;</span><br><span class="line"></span><br><span class="line">	sleeptime_injected = false;</span><br><span class="line">	read_persistent_clock64(&amp;ts_new);</span><br><span class="line"></span><br><span class="line">	clockevents_resume();</span><br><span class="line">	clocksource_resume();</span><br><span class="line"></span><br><span class="line">	raw_spin_lock_irqsave(&amp;timekeeper_lock, flags);</span><br><span class="line">	write_seqcount_begin(&amp;tk_core.seq);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * After system resumes, we need to calculate the suspended time and</span><br><span class="line">	 * compensate it for the OS time. There are 3 sources that could be</span><br><span class="line">	 * used: Nonstop clocksource during suspend, persistent clock and rtc</span><br><span class="line">	 * device.</span><br><span class="line">	 *</span><br><span class="line">	 * One specific platform may have 1 or 2 or all of them, and the</span><br><span class="line">	 * preference will be:</span><br><span class="line">	 *	suspend-nonstop clocksource -&gt; persistent clock -&gt; rtc</span><br><span class="line">	 * The less preferred source will only be tried if there is no better</span><br><span class="line">	 * usable source. The rtc part is handled separately in rtc core code.</span><br><span class="line">	 */</span><br><span class="line">	cycle_now = tk-&gt;tkr_mono.read(clock);</span><br><span class="line">	if ((clock-&gt;flags &amp; CLOCK_SOURCE_SUSPEND_NONSTOP) &amp;&amp;</span><br><span class="line">		cycle_now &gt; tk-&gt;tkr_mono.cycle_last) &#123;</span><br><span class="line">		u64 num, max = ULLONG_MAX;</span><br><span class="line">		u32 mult = clock-&gt;mult;</span><br><span class="line">		u32 shift = clock-&gt;shift;</span><br><span class="line">		s64 nsec = 0;</span><br><span class="line"></span><br><span class="line">		cycle_delta = clocksource_delta(cycle_now, tk-&gt;tkr_mono.cycle_last,</span><br><span class="line">						tk-&gt;tkr_mono.mask);</span><br><span class="line"></span><br><span class="line">		/*</span><br><span class="line">		 * &quot;cycle_delta * mutl&quot; may cause 64 bits overflow, if the</span><br><span class="line">		 * suspended time is too long. In that case we need do the</span><br><span class="line">		 * 64 bits math carefully</span><br><span class="line">		 */</span><br><span class="line">		do_div(max, mult);</span><br><span class="line">		if (cycle_delta &gt; max) &#123;</span><br><span class="line">			num = div64_u64(cycle_delta, max);</span><br><span class="line">			nsec = (((u64) max * mult) &gt;&gt; shift) * num;</span><br><span class="line">			cycle_delta -= num * max;</span><br><span class="line">		&#125;</span><br><span class="line">		nsec += ((u64) cycle_delta * mult) &gt;&gt; shift;</span><br><span class="line"></span><br><span class="line">		ts_delta = ns_to_timespec64(nsec);</span><br><span class="line">		sleeptime_injected = true;</span><br><span class="line">	&#125; else if (timespec64_compare(&amp;ts_new, &amp;timekeeping_suspend_time) &gt; 0) &#123;</span><br><span class="line">		ts_delta = timespec64_sub(ts_new, timekeeping_suspend_time);</span><br><span class="line">		sleeptime_injected = true;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (sleeptime_injected)</span><br><span class="line">		__timekeeping_inject_sleeptime(tk, &amp;ts_delta);</span><br><span class="line"></span><br><span class="line">	/* Re-base the last cycle value */</span><br><span class="line">	tk-&gt;tkr_mono.cycle_last = cycle_now;</span><br><span class="line">	tk-&gt;tkr_raw.cycle_last  = cycle_now;</span><br><span class="line"></span><br><span class="line">	tk-&gt;ntp_error = 0;</span><br><span class="line">	timekeeping_suspended = 0;</span><br><span class="line">	timekeeping_update(tk, TK_MIRROR | TK_CLOCK_WAS_SET);</span><br><span class="line">	write_seqcount_end(&amp;tk_core.seq);</span><br><span class="line">	raw_spin_unlock_irqrestore(&amp;timekeeper_lock, flags);</span><br><span class="line"></span><br><span class="line">	touch_softlockup_watchdog();</span><br><span class="line"></span><br><span class="line">	tick_resume();</span><br><span class="line">	hrtimers_resume();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int timekeeping_suspend(void)</span><br><span class="line">&#123;</span><br><span class="line">	struct timekeeper *tk = &amp;tk_core.timekeeper;</span><br><span class="line">	unsigned long flags;</span><br><span class="line">	struct timespec64		delta, delta_delta;</span><br><span class="line">	static struct timespec64	old_delta;</span><br><span class="line"></span><br><span class="line">	read_persistent_clock64(&amp;timekeeping_suspend_time);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * On some systems the persistent_clock can not be detected at</span><br><span class="line">	 * timekeeping_init by its return value, so if we see a valid</span><br><span class="line">	 * value returned, update the persistent_clock_exists flag.</span><br><span class="line">	 */</span><br><span class="line">	if (timekeeping_suspend_time.tv_sec || timekeeping_suspend_time.tv_nsec)</span><br><span class="line">		persistent_clock_exists = true;</span><br><span class="line"></span><br><span class="line">	raw_spin_lock_irqsave(&amp;timekeeper_lock, flags);</span><br><span class="line">	write_seqcount_begin(&amp;tk_core.seq);</span><br><span class="line">	timekeeping_forward_now(tk);</span><br><span class="line">	timekeeping_suspended = 1;</span><br><span class="line"></span><br><span class="line">	if (persistent_clock_exists) &#123;</span><br><span class="line">		/*</span><br><span class="line">		 * To avoid drift caused by repeated suspend/resumes,</span><br><span class="line">		 * which each can add ~1 second drift error,</span><br><span class="line">		 * try to compensate so the difference in system time</span><br><span class="line">		 * and persistent_clock time stays close to constant.</span><br><span class="line">		 */</span><br><span class="line">		delta = timespec64_sub(tk_xtime(tk), timekeeping_suspend_time);</span><br><span class="line">		delta_delta = timespec64_sub(delta, old_delta);</span><br><span class="line">		if (abs(delta_delta.tv_sec) &gt;= 2) &#123;</span><br><span class="line">			/*</span><br><span class="line">			 * if delta_delta is too large, assume time correction</span><br><span class="line">			 * has occurred and set old_delta to the current delta.</span><br><span class="line">			 */</span><br><span class="line">			old_delta = delta;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			/* Otherwise try to adjust old_system to compensate */</span><br><span class="line">			timekeeping_suspend_time =</span><br><span class="line">				timespec64_add(timekeeping_suspend_time, delta_delta);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	timekeeping_update(tk, TK_MIRROR);</span><br><span class="line">	halt_fast_timekeeper(tk);</span><br><span class="line">	write_seqcount_end(&amp;tk_core.seq);</span><br><span class="line">	raw_spin_unlock_irqrestore(&amp;timekeeper_lock, flags);</span><br><span class="line"></span><br><span class="line">	tick_suspend();</span><br><span class="line">	clocksource_suspend();</span><br><span class="line">	clockevents_suspend();</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* sysfs resume/suspend bits for timekeeping */</span><br><span class="line">static struct syscore_ops timekeeping_syscore_ops = &#123;</span><br><span class="line">	.resume		= timekeeping_resume,</span><br><span class="line">	.suspend	= timekeeping_suspend,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>和初始化一样的原因，理论上timekeeper的操作在timekeeping_resume()、timekeeping_suspend()，但是实际上在rtc的操作中执行rtc_suspend()、rtc_resume()。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">static int rtc_suspend(struct device *dev)</span><br><span class="line">&#123;</span><br><span class="line">	struct rtc_device	*rtc = to_rtc_device(dev);</span><br><span class="line">	struct rtc_time		tm;</span><br><span class="line">	struct timespec64	delta, delta_delta;</span><br><span class="line">	int err;</span><br><span class="line"></span><br><span class="line">	if (timekeeping_rtc_skipsuspend())</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">	if (strcmp(dev_name(&amp;rtc-&gt;dev), CONFIG_RTC_HCTOSYS_DEVICE) != 0)</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">	/* snapshot the current RTC and system time at suspend*/</span><br><span class="line">	/* (1.1) 读取suspend时候的rtc时间 */</span><br><span class="line">	err = rtc_read_time(rtc, &amp;tm);</span><br><span class="line">	if (err &lt; 0) &#123;</span><br><span class="line">		pr_debug(&quot;%s:  fail to read rtc time\n&quot;, dev_name(&amp;rtc-&gt;dev));</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (1.2) 读取当前xtime */</span><br><span class="line">	getnstimeofday64(&amp;old_system);</span><br><span class="line">	old_rtc.tv_sec = rtc_tm_to_time64(&amp;tm);</span><br><span class="line">	old_rtc.tv_nsec = tm.tm_cnt*(1000000000/32768);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * To avoid drift caused by repeated suspend/resumes,</span><br><span class="line">	 * which each can add ~1 second drift error,</span><br><span class="line">	 * try to compensate so the difference in system time</span><br><span class="line">	 * and rtc time stays close to constant.</span><br><span class="line">	 */</span><br><span class="line">	/* (1.3) 如果rtc时间和xtime有偏差，尝试纠正xtime */</span><br><span class="line">	delta = timespec64_sub(old_system, old_rtc);</span><br><span class="line">	delta_delta = timespec64_sub(delta, old_delta);</span><br><span class="line">	if (delta_delta.tv_sec &lt; -2 || delta_delta.tv_sec &gt;= 2) &#123;</span><br><span class="line">		/*</span><br><span class="line">		 * if delta_delta is too large, assume time correction</span><br><span class="line">		 * has occured and set old_delta to the current delta.</span><br><span class="line">		 */</span><br><span class="line">		old_delta = delta;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		/* Otherwise try to adjust old_system to compensate */</span><br><span class="line">		old_system = timespec64_sub(old_system, delta_delta);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int rtc_resume(struct device *dev)</span><br><span class="line">&#123;</span><br><span class="line">	struct rtc_device	*rtc = to_rtc_device(dev);</span><br><span class="line">	struct rtc_time		tm;</span><br><span class="line">	struct timespec64	new_system, new_rtc;</span><br><span class="line">	struct timespec64	sleep_time;</span><br><span class="line">	int err;</span><br><span class="line"></span><br><span class="line">	if (timekeeping_rtc_skipresume())</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">	rtc_hctosys_ret = -ENODEV;</span><br><span class="line">	if (strcmp(dev_name(&amp;rtc-&gt;dev), CONFIG_RTC_HCTOSYS_DEVICE) != 0)</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">	/* snapshot the current rtc and system time at resume */</span><br><span class="line">	/* (2.1) 读取resume后的rtc时间和xtime */</span><br><span class="line">	getnstimeofday64(&amp;new_system);</span><br><span class="line">	err = rtc_read_time(rtc, &amp;tm);</span><br><span class="line">	if (err &lt; 0) &#123;</span><br><span class="line">		pr_debug(&quot;%s:  fail to read rtc time\n&quot;, dev_name(&amp;rtc-&gt;dev));</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	new_rtc.tv_sec = rtc_tm_to_time64(&amp;tm);</span><br><span class="line">	new_rtc.tv_nsec = tm.tm_cnt*(1000000000/32768);</span><br><span class="line"></span><br><span class="line">	if (new_rtc.tv_sec &lt; old_rtc.tv_sec) &#123;</span><br><span class="line">		pr_debug(&quot;%s:  time travel!\n&quot;, dev_name(&amp;rtc-&gt;dev));</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* calculate the RTC time delta (sleep time)*/</span><br><span class="line">	/* (2.2) 计算suspend和resume之间rtc的差值 */</span><br><span class="line">	sleep_time = timespec64_sub(new_rtc, old_rtc);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Since these RTC suspend/resume handlers are not called</span><br><span class="line">	 * at the very end of suspend or the start of resume,</span><br><span class="line">	 * some run-time may pass on either sides of the sleep time</span><br><span class="line">	 * so subtract kernel run-time between rtc_suspend to rtc_resume</span><br><span class="line">	 * to keep things accurate.</span><br><span class="line">	 */</span><br><span class="line">	/* (2.3) 使用上一步的差值，再减去，suspend和resume之间xtime的差值</span><br><span class="line">	        得到实际的sleep时间*/</span><br><span class="line">	sleep_time = timespec64_sub(sleep_time,</span><br><span class="line">			timespec64_sub(new_system, old_system));</span><br><span class="line"></span><br><span class="line">	if (sleep_time.tv_sec &gt;= 0)</span><br><span class="line">	    /* (2.4) 将计算得到的sleep时间，加入到timekeeper中 */</span><br><span class="line">		timekeeping_inject_sleeptime64(&amp;sleep_time);</span><br><span class="line">	rtc_hctosys_ret = 0;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">|→</span><br><span class="line">void timekeeping_inject_sleeptime64(struct timespec64 *delta)</span><br><span class="line">&#123;</span><br><span class="line">	struct timekeeper *tk = &amp;tk_core.timekeeper;</span><br><span class="line">	unsigned long flags;</span><br><span class="line"></span><br><span class="line">	raw_spin_lock_irqsave(&amp;timekeeper_lock, flags);</span><br><span class="line">	write_seqcount_begin(&amp;tk_core.seq);</span><br><span class="line"></span><br><span class="line">	timekeeping_forward_now(tk);</span><br><span class="line"></span><br><span class="line">	__timekeeping_inject_sleeptime(tk, delta);</span><br><span class="line"></span><br><span class="line">	timekeeping_update(tk, TK_CLEAR_NTP | TK_MIRROR | TK_CLOCK_WAS_SET);</span><br><span class="line"></span><br><span class="line">	write_seqcount_end(&amp;tk_core.seq);</span><br><span class="line">	raw_spin_unlock_irqrestore(&amp;timekeeper_lock, flags);</span><br><span class="line"></span><br><span class="line">	/* signal hrtimers about time change */</span><br><span class="line">	clock_was_set();</span><br><span class="line">&#125;</span><br><span class="line">||→</span><br><span class="line">static void __timekeeping_inject_sleeptime(struct timekeeper *tk,</span><br><span class="line">					   struct timespec64 *delta)</span><br><span class="line">&#123;</span><br><span class="line">	if (!timespec64_valid_strict(delta)) &#123;</span><br><span class="line">		printk_deferred(KERN_WARNING</span><br><span class="line">				&quot;__timekeeping_inject_sleeptime: Invalid &quot;</span><br><span class="line">				&quot;sleep delta value!\n&quot;);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	/* (2.4.1) 更新xtime */</span><br><span class="line">	tk_xtime_add(tk, delta);</span><br><span class="line">	/* (2.4.2) 更新tk-&gt;wall_to_monotonic、tk-&gt;offs_real */</span><br><span class="line">	tk_set_wall_to_mono(tk, timespec64_sub(tk-&gt;wall_to_monotonic, *delta));</span><br><span class="line">	/* (2.4.3) 更新tk-&gt;offs_boot */</span><br><span class="line">	tk_update_sleep_time(tk, timespec64_to_ktime(*delta));</span><br><span class="line">	tk_debug_account_sleep_time(delta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3、clock-event"><a href="#3、clock-event" class="headerlink" title="3、clock_event"></a>3、clock_event</h1><p><img src="/images/time/clockevent.png" alt="clockevent"></p>
<p>clock_event其实就是对local timer的使用，每个cpu对应一个本地local timer。global timer启动后不需要主动做任何事情，只需要等待timekepper的读取就可以了。而local timer需要触发中断，它的主要价值就体现在定时中断处理了，中断的时间可以是固定的(period mode)也或者是不固定的(oneshot mode)。</p>
<h2 id="3-1、clock-event的注册"><a href="#3-1、clock-event的注册" class="headerlink" title="3.1、clock_event的注册"></a>3.1、clock_event的注册</h2><h3 id="3-1-1、exynos-clock-event的注册"><a href="#3-1-1、exynos-clock-event的注册" class="headerlink" title="3.1.1、exynos clock_event的注册"></a>3.1.1、exynos clock_event的注册</h3><p>exynos clock_event的注册分为两部分：</p>
<ul>
<li>第一部分：localtimer中断的注册：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">static void __init exynos4_timer_resources(struct device_node *np, void __iomem *base)</span><br><span class="line">&#123;</span><br><span class="line">	int err, cpu;</span><br><span class="line">	struct mct_clock_event_device *mevt = this_cpu_ptr(&amp;percpu_mct_tick);</span><br><span class="line">	struct clk *mct_clk, *tick_clk;</span><br><span class="line"></span><br><span class="line">	tick_clk = np ? of_clk_get_by_name(np, &quot;fin_pll&quot;) :</span><br><span class="line">				clk_get(NULL, &quot;fin_pll&quot;);</span><br><span class="line">	if (IS_ERR(tick_clk))</span><br><span class="line">		panic(&quot;%s: unable to determine tick clock rate\n&quot;, __func__);</span><br><span class="line">	clk_rate = clk_get_rate(tick_clk);</span><br><span class="line"></span><br><span class="line">	mct_clk = np ? of_clk_get_by_name(np, &quot;mct&quot;) : clk_get(NULL, &quot;mct&quot;);</span><br><span class="line">	if (IS_ERR(mct_clk))</span><br><span class="line">		panic(&quot;%s: unable to retrieve mct clock instance\n&quot;, __func__);</span><br><span class="line">	clk_prepare_enable(mct_clk);</span><br><span class="line"></span><br><span class="line">	reg_base = base;</span><br><span class="line">	if (!reg_base)</span><br><span class="line">		panic(&quot;%s: unable to ioremap mct address space\n&quot;, __func__);</span><br><span class="line"></span><br><span class="line">	if (mct_int_type == MCT_INT_PPI) &#123;</span><br><span class="line"></span><br><span class="line">        /* (1) 大部分的localtimer是PPI模式，</span><br><span class="line">            注册中断处理函数：exynos4_mct_tick_isr() */</span><br><span class="line">		err = request_percpu_irq(mct_irqs[MCT_L0_IRQ],</span><br><span class="line">					 exynos4_mct_tick_isr, &quot;MCT&quot;,</span><br><span class="line">					 &amp;percpu_mct_tick);</span><br><span class="line">		WARN(err, &quot;MCT: can&apos;t request IRQ %d (%d)\n&quot;,</span><br><span class="line">		     mct_irqs[MCT_L0_IRQ], err);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		for_each_possible_cpu(cpu) &#123;</span><br><span class="line">			int mct_irq = mct_irqs[MCT_L0_IRQ + cpu];</span><br><span class="line">			struct mct_clock_event_device *pcpu_mevt =</span><br><span class="line">				per_cpu_ptr(&amp;percpu_mct_tick, cpu);</span><br><span class="line"></span><br><span class="line">			pcpu_mevt-&gt;evt.irq = -1;</span><br><span class="line"></span><br><span class="line">			irq_set_status_flags(mct_irq, IRQ_NOAUTOEN);</span><br><span class="line">			if (request_irq(mct_irq,</span><br><span class="line">					exynos4_mct_tick_isr,</span><br><span class="line">					IRQF_TIMER | IRQF_NOBALANCING,</span><br><span class="line">					pcpu_mevt-&gt;name, pcpu_mevt)) &#123;</span><br><span class="line">				pr_err(&quot;exynos-mct: cannot register IRQ (cpu%d)\n&quot;,</span><br><span class="line">									cpu);</span><br><span class="line"></span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line">			pcpu_mevt-&gt;evt.irq = mct_irq;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (2) 注册cpu hotplug的notifier，</span><br><span class="line">        在其他cpu up时调用exynos4_local_timer_setup()注册clock_event */</span><br><span class="line">	err = register_cpu_notifier(&amp;exynos4_mct_cpu_nb);</span><br><span class="line">	if (err)</span><br><span class="line">		goto out_irq;</span><br><span class="line"></span><br><span class="line">	/* Immediately configure the timer on the boot CPU */</span><br><span class="line">	/* (3) 注册本cpu的clock_event */</span><br><span class="line">	exynos4_local_timer_setup(mevt);</span><br><span class="line">	return;</span><br><span class="line"></span><br><span class="line">out_irq:</span><br><span class="line">	free_percpu_irq(mct_irqs[MCT_L0_IRQ], &amp;percpu_mct_tick);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static irqreturn_t exynos4_mct_tick_isr(int irq, void *dev_id)</span><br><span class="line">&#123;</span><br><span class="line">	struct mct_clock_event_device *mevt = dev_id;</span><br><span class="line">	struct clock_event_device *evt = &amp;mevt-&gt;evt;</span><br><span class="line"></span><br><span class="line">	exynos4_mct_tick_clear(mevt);</span><br><span class="line"></span><br><span class="line">    /* (4) localtimer中断处理函数是固定的也是非常简单的，</span><br><span class="line">        调用本cpu clock_event_device的handler函数：evt-&gt;event_handler(evt) */</span><br><span class="line">	evt-&gt;event_handler(evt);</span><br><span class="line"></span><br><span class="line">	return IRQ_HANDLED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第二部分：clock_event_device注册：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">static int exynos4_local_timer_setup(struct mct_clock_event_device *mevt)</span><br><span class="line">&#123;</span><br><span class="line">	struct clock_event_device *evt = &amp;mevt-&gt;evt;</span><br><span class="line">	unsigned int cpu = smp_processor_id();</span><br><span class="line"></span><br><span class="line">	mevt-&gt;base = EXYNOS4_MCT_L_BASE(cpu);</span><br><span class="line">	snprintf(mevt-&gt;name, sizeof(mevt-&gt;name), &quot;mct_tick%d&quot;, cpu);</span><br><span class="line"></span><br><span class="line">    /* (1) 初始化clock_event_device */</span><br><span class="line">	evt-&gt;name = mevt-&gt;name;</span><br><span class="line">	evt-&gt;cpumask = cpumask_of(cpu);         // 本clock_event_device只服务于一个cpu</span><br><span class="line">	evt-&gt;set_next_event = exynos4_tick_set_next_event;</span><br><span class="line">	evt-&gt;set_state_periodic = set_state_periodic;</span><br><span class="line">	evt-&gt;set_state_shutdown = set_state_shutdown;</span><br><span class="line">	evt-&gt;set_state_oneshot = set_state_shutdown;</span><br><span class="line">	evt-&gt;tick_resume = set_state_shutdown;</span><br><span class="line">	evt-&gt;features = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT;</span><br><span class="line">	evt-&gt;rating = 450;</span><br><span class="line"></span><br><span class="line">	exynos4_mct_write(TICK_BASE_CNT, mevt-&gt;base + MCT_L_TCNTB_OFFSET);</span><br><span class="line"></span><br><span class="line">	if (mct_int_type == MCT_INT_SPI) &#123;</span><br><span class="line"></span><br><span class="line">		if (evt-&gt;irq == -1)</span><br><span class="line">			return -EIO;</span><br><span class="line"></span><br><span class="line">		irq_force_affinity(evt-&gt;irq, cpumask_of(cpu));</span><br><span class="line">		enable_irq(evt-&gt;irq);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		enable_percpu_irq(mct_irqs[MCT_L0_IRQ], 0);</span><br><span class="line">	&#125;</span><br><span class="line">	/* (2) 配置并注册clockevent */</span><br><span class="line">	clockevents_config_and_register(evt, clk_rate / (TICK_BASE_CNT + 1),</span><br><span class="line">					0xf, 0x7fffffff);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-1-2、clock-event-device的注册"><a href="#3-1-2、clock-event-device的注册" class="headerlink" title="3.1.2、clock_event_device的注册"></a>3.1.2、clock_event_device的注册</h3><p>我们来分析一下clock_event_device的注册过程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line">void clockevents_config_and_register(struct clock_event_device *dev,</span><br><span class="line">				     u32 freq, unsigned long min_delta,</span><br><span class="line">				     unsigned long max_delta)</span><br><span class="line">&#123;</span><br><span class="line">	dev-&gt;min_delta_ticks = min_delta;   // localtimer可配置的最小定时值</span><br><span class="line">	dev-&gt;max_delta_ticks = max_delta;   // localtimer可配置的最大定时值，</span><br><span class="line">	                                    // 比如exynos是31bit的localtimer，最大值就是0x7fffffff</span><br><span class="line">	/* (1) 根据localtimer的freq，计算clock_event_device对应的mult、shift，</span><br><span class="line">	    mult、shift的作用是用来做ns到localtimer cycle之间的转换，</span><br><span class="line">	    与之相反的是，在clocksource中mult、shift用来转换localtimer cycle到ns */</span><br><span class="line">	clockevents_config(dev, freq);</span><br><span class="line">	/* (2) 继续注册clock_event_device */</span><br><span class="line">	clockevents_register_device(dev);</span><br><span class="line">&#125;</span><br><span class="line">|→</span><br><span class="line">void clockevents_config(struct clock_event_device *dev, u32 freq)</span><br><span class="line">&#123;</span><br><span class="line">	u64 sec;</span><br><span class="line"></span><br><span class="line">    /* (1.1) 如果不支持oneshot模式，只是period模式，</span><br><span class="line">        定时周期是固定的，不需要动态计算ns到cycle的转换 */</span><br><span class="line">	if (!(dev-&gt;features &amp; CLOCK_EVT_FEAT_ONESHOT))</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Calculate the maximum number of seconds we can sleep. Limit</span><br><span class="line">	 * to 10 minutes for hardware which can program more than</span><br><span class="line">	 * 32bit ticks so we still get reasonable conversion values.</span><br><span class="line">	 */</span><br><span class="line">	sec = dev-&gt;max_delta_ticks;</span><br><span class="line">	do_div(sec, freq);</span><br><span class="line">	if (!sec)</span><br><span class="line">		sec = 1;</span><br><span class="line">	else if (sec &gt; 600 &amp;&amp; dev-&gt;max_delta_ticks &gt; UINT_MAX)</span><br><span class="line">		sec = 600;</span><br><span class="line"></span><br><span class="line">    /* (1.2) 根据localtimer的freq，计算clock_event_device对应的mult、shift */</span><br><span class="line">	clockevents_calc_mult_shift(dev, freq, sec);</span><br><span class="line">	/* (1.3) 转换min、max的cycle到ns */</span><br><span class="line">	dev-&gt;min_delta_ns = cev_delta2ns(dev-&gt;min_delta_ticks, dev, false);</span><br><span class="line">	dev-&gt;max_delta_ns = cev_delta2ns(dev-&gt;max_delta_ticks, dev, true);</span><br><span class="line">&#125;</span><br><span class="line">|→</span><br><span class="line">void clockevents_register_device(struct clock_event_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned long flags;</span><br><span class="line"></span><br><span class="line">	/* Initialize state to DETACHED */</span><br><span class="line">	clockevent_set_state(dev, CLOCK_EVT_STATE_DETACHED);</span><br><span class="line"></span><br><span class="line">	if (!dev-&gt;cpumask) &#123;</span><br><span class="line">		WARN_ON(num_possible_cpus() &gt; 1);</span><br><span class="line">		dev-&gt;cpumask = cpumask_of(smp_processor_id());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	raw_spin_lock_irqsave(&amp;clockevents_lock, flags);</span><br><span class="line"></span><br><span class="line">    /* (2.1) 将clock_event_device加入到全局链表clockevent_devices中 */</span><br><span class="line">	list_add(&amp;dev-&gt;list, &amp;clockevent_devices);</span><br><span class="line">	/* (2.2) 继续尝试向本cpu的tick_device中注册clock_event_device */</span><br><span class="line">	tick_check_new_device(dev);</span><br><span class="line">	clockevents_notify_released();</span><br><span class="line"></span><br><span class="line">	raw_spin_unlock_irqrestore(&amp;clockevents_lock, flags);</span><br><span class="line">&#125;</span><br><span class="line">||→</span><br><span class="line">void tick_check_new_device(struct clock_event_device *newdev)</span><br><span class="line">&#123;</span><br><span class="line">	struct clock_event_device *curdev;</span><br><span class="line">	struct tick_device *td;</span><br><span class="line">	int cpu;</span><br><span class="line"></span><br><span class="line">	cpu = smp_processor_id();</span><br><span class="line">	td = &amp;per_cpu(tick_cpu_device, cpu);</span><br><span class="line">	curdev = td-&gt;evtdev;</span><br><span class="line"></span><br><span class="line">	/* cpu local device ? */</span><br><span class="line">	/* (2.2.1) 新的clock_event_device是否支持本cpu？  */</span><br><span class="line">	if (!tick_check_percpu(curdev, newdev, cpu))</span><br><span class="line">		goto out_bc;</span><br><span class="line"></span><br><span class="line">	/* Preference decision */</span><br><span class="line">	/* (2.2.2) 新的clock_event_device是否比当前clock_event_device更适合？</span><br><span class="line">	   1.如果curdev已经是oneshot模式，而newdev不支持oneshot，则切换</span><br><span class="line">	   2.newdev的精度要大于curdev，精度 = dev-&gt;rating */</span><br><span class="line">	if (!tick_check_preferred(curdev, newdev))</span><br><span class="line">		goto out_bc;</span><br><span class="line"></span><br><span class="line">	if (!try_module_get(newdev-&gt;owner))</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Replace the eventually existing device by the new</span><br><span class="line">	 * device. If the current device is the broadcast device, do</span><br><span class="line">	 * not give it back to the clockevents layer !</span><br><span class="line">	 */</span><br><span class="line">	if (tick_is_broadcast_device(curdev)) &#123;</span><br><span class="line">		clockevents_shutdown(curdev);</span><br><span class="line">		curdev = NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	/* (2.2.3) 关闭curdev、newdev */</span><br><span class="line">	clockevents_exchange_device(curdev, newdev);</span><br><span class="line">	/* (2.2.4) 继续clock_event_device注册 */</span><br><span class="line">	tick_setup_device(td, newdev, cpu, cpumask_of(cpu));</span><br><span class="line">	if (newdev-&gt;features &amp; CLOCK_EVT_FEAT_ONESHOT)</span><br><span class="line">		tick_oneshot_notify();</span><br><span class="line">	return;</span><br><span class="line"></span><br><span class="line">out_bc:</span><br><span class="line">	/*</span><br><span class="line">	 * Can the new device be used as a broadcast device ?</span><br><span class="line">	 */</span><br><span class="line">	/* (2.2.5) 如果newdev不适合注册成本cpu的td-&gt;evtdev,</span><br><span class="line">	    尝试将其注册成broadcast clockevent */</span><br><span class="line">	tick_install_broadcast_device(newdev);</span><br><span class="line">&#125;</span><br><span class="line">|||→</span><br><span class="line">static void tick_setup_device(struct tick_device *td,</span><br><span class="line">			      struct clock_event_device *newdev, int cpu,</span><br><span class="line">			      const struct cpumask *cpumask)</span><br><span class="line">&#123;</span><br><span class="line">	ktime_t next_event;</span><br><span class="line">	void (*handler)(struct clock_event_device *) = NULL;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * First device setup ?</span><br><span class="line">	 */</span><br><span class="line">	if (!td-&gt;evtdev) &#123;</span><br><span class="line">	    /* (2.2.4.1) 如果是tick_do_timer_cpu没有被设置，且没有使能tick_nohz_full_cpu</span><br><span class="line">	        把tick_do_timer_cpu设置成本cpu，</span><br><span class="line">	        tick_do_timer_cpu负责在tick中update jiffies、update_wall_time  */</span><br><span class="line">		/*</span><br><span class="line">		 * If no cpu took the do_timer update, assign it to</span><br><span class="line">		 * this cpu:</span><br><span class="line">		 */</span><br><span class="line">		if (tick_do_timer_cpu == TICK_DO_TIMER_BOOT) &#123;</span><br><span class="line">			if (!tick_nohz_full_cpu(cpu))</span><br><span class="line">				tick_do_timer_cpu = cpu;</span><br><span class="line">			else</span><br><span class="line">				tick_do_timer_cpu = TICK_DO_TIMER_NONE;</span><br><span class="line">			tick_next_period = ktime_get();</span><br><span class="line">			tick_period = ktime_set(0, NSEC_PER_SEC / HZ);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		/*</span><br><span class="line">		 * Startup in periodic mode first.</span><br><span class="line">		 */</span><br><span class="line">		/* (2.2.4.2) 如果tick_device是第一次设置clock_event_device,</span><br><span class="line">		    把tick_device设置成period模式 */</span><br><span class="line">		td-&gt;mode = TICKDEV_MODE_PERIODIC;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">	    /* (2.2.4.3) 如果tick_device不是第一次设置clock_event_device,</span><br><span class="line">		    备份原clock_event_deviced的event_handler和next_event */</span><br><span class="line">		handler = td-&gt;evtdev-&gt;event_handler;</span><br><span class="line">		next_event = td-&gt;evtdev-&gt;next_event;</span><br><span class="line">		td-&gt;evtdev-&gt;event_handler = clockevents_handle_noop;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (2.2.4.4) 更新tick_device-&gt;evtdev到new clock_event_deviced  */</span><br><span class="line">	td-&gt;evtdev = newdev;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * When the device is not per cpu, pin the interrupt to the</span><br><span class="line">	 * current cpu:</span><br><span class="line">	 */</span><br><span class="line">	if (!cpumask_equal(newdev-&gt;cpumask, cpumask))</span><br><span class="line">		irq_set_affinity(newdev-&gt;irq, cpumask);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * When global broadcasting is active, check if the current</span><br><span class="line">	 * device is registered as a placeholder for broadcast mode.</span><br><span class="line">	 * This allows us to handle this x86 misfeature in a generic</span><br><span class="line">	 * way. This function also returns !=0 when we keep the</span><br><span class="line">	 * current active broadcast state for this CPU.</span><br><span class="line">	 */</span><br><span class="line">	/* (2.2.4.5) 如果全局的brodcast clockevent服务已经启动，</span><br><span class="line">	    本cpu的clockevent注册需要向brodcas服务，</span><br><span class="line">	    这是为了解决x86的一个失误(misfeature)，其他架构不需要？ */</span><br><span class="line">	if (tick_device_uses_broadcast(newdev, cpu))</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">    /* (2.2.4.6) 根据td-&gt;mode安装clock_event_deviced的event_handler,并启动 */</span><br><span class="line">	if (td-&gt;mode == TICKDEV_MODE_PERIODIC)</span><br><span class="line">	    /* (2.2.4.7) period模式 */</span><br><span class="line">		tick_setup_periodic(newdev, 0);</span><br><span class="line">	else</span><br><span class="line">	    /* (2.2.4.8) oneshot模式 */</span><br><span class="line">		tick_setup_oneshot(newdev, handler, next_event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-2、tick-device的period-mode"><a href="#3-2、tick-device的period-mode" class="headerlink" title="3.2、tick_device的period mode"></a>3.2、tick_device的period mode</h2><p>接上节，在cpu第一次注册clock_event_deviced的时候，td-&gt;mode默认被设置成period模式。event_handler会被初始化成tick_handle_periodic：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">void tick_setup_periodic(struct clock_event_device *dev, int broadcast)</span><br><span class="line">&#123;</span><br><span class="line">    /* (1) 设置period模式下的event_handler */</span><br><span class="line">	tick_set_periodic_handler(dev, broadcast);</span><br><span class="line"></span><br><span class="line">	/* Broadcast setup ? */</span><br><span class="line">	if (!tick_device_is_functional(dev))</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">    /* (2) 如果dev支持period模式，则硬件上启动period模式:</span><br><span class="line">        tick_device-&gt;mode = TICKDEV_MODE_PERIODIC</span><br><span class="line">        clock_event_device-&gt;state_use_accessors = CLOCK_EVT_STATE_PERIODIC */</span><br><span class="line">	if ((dev-&gt;features &amp; CLOCK_EVT_FEAT_PERIODIC) &amp;&amp;</span><br><span class="line">	    !tick_broadcast_oneshot_active()) &#123;</span><br><span class="line">		clockevents_switch_state(dev, CLOCK_EVT_STATE_PERIODIC);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		unsigned long seq;</span><br><span class="line">		ktime_t next;</span><br><span class="line"></span><br><span class="line">		do &#123;</span><br><span class="line">			seq = read_seqbegin(&amp;jiffies_lock);</span><br><span class="line">			next = tick_next_period;</span><br><span class="line">		&#125; while (read_seqretry(&amp;jiffies_lock, seq));</span><br><span class="line"></span><br><span class="line">        /* (3) 如果dev不支持period模式只支持oneshot模式，则硬件上启动one shot模式，</span><br><span class="line">            使用oneshot模式来模拟period模式：</span><br><span class="line">            tick_device-&gt;mode = TICKDEV_MODE_PERIODIC</span><br><span class="line">            clock_event_device-&gt;state_use_accessors = CLOCK_EVT_STATE_ONESHOT */</span><br><span class="line">		clockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);</span><br><span class="line"></span><br><span class="line">		for (;;) &#123;</span><br><span class="line">			if (!clockevents_program_event(dev, next, false))</span><br><span class="line">				return;</span><br><span class="line">			next = ktime_add(next, tick_period);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">|→</span><br><span class="line">void tick_set_periodic_handler(struct clock_event_device *dev, int broadcast)</span><br><span class="line">&#123;</span><br><span class="line">	if (!broadcast)</span><br><span class="line">	    /* (1.1) 设置period模式下的event_handler */</span><br><span class="line">		dev-&gt;event_handler = tick_handle_periodic;</span><br><span class="line">	else</span><br><span class="line">		dev-&gt;event_handler = tick_handle_periodic_broadcast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>仔细分析一下tick_handle_periodic：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">void tick_handle_periodic(struct clock_event_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">	int cpu = smp_processor_id();</span><br><span class="line">	ktime_t next = dev-&gt;next_event;</span><br><span class="line"></span><br><span class="line">    /* (1) 周期性的tick任务 */</span><br><span class="line">	tick_periodic(cpu);</span><br><span class="line"></span><br><span class="line">#if defined(CONFIG_HIGH_RES_TIMERS) || defined(CONFIG_NO_HZ_COMMON)</span><br><span class="line">	/*</span><br><span class="line">	 * The cpu might have transitioned to HIGHRES or NOHZ mode via</span><br><span class="line">	 * update_process_times() -&gt; run_local_timers() -&gt;</span><br><span class="line">	 * hrtimer_run_queues().</span><br><span class="line">	 */</span><br><span class="line">	if (dev-&gt;event_handler != tick_handle_periodic)</span><br><span class="line">		return;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	if (!clockevent_state_oneshot(dev))</span><br><span class="line">		return;</span><br><span class="line">	/* (2) 如果tick_device是period mode，而clockevent是oneshot模式,</span><br><span class="line">	    编程oneshot模式clockevent在下一周期触发：</span><br><span class="line">        tick_device-&gt;mode = TICKDEV_MODE_PERIODIC</span><br><span class="line">        clock_event_device-&gt;state_use_accessors = CLOCK_EVT_STATE_ONESHOT */</span><br><span class="line">	for (;;) &#123;</span><br><span class="line">		/*</span><br><span class="line">		 * Setup the next period for devices, which do not have</span><br><span class="line">		 * periodic mode:</span><br><span class="line">		 */</span><br><span class="line">		next = ktime_add(next, tick_period);</span><br><span class="line"></span><br><span class="line">		if (!clockevents_program_event(dev, next, false))</span><br><span class="line">			return;</span><br><span class="line">		/*</span><br><span class="line">		 * Have to be careful here. If we&apos;re in oneshot mode,</span><br><span class="line">		 * before we call tick_periodic() in a loop, we need</span><br><span class="line">		 * to be sure we&apos;re using a real hardware clocksource.</span><br><span class="line">		 * Otherwise we could get trapped in an infinite</span><br><span class="line">		 * loop, as the tick_periodic() increments jiffies,</span><br><span class="line">		 * which then will increment time, possibly causing</span><br><span class="line">		 * the loop to trigger again and again.</span><br><span class="line">		 */</span><br><span class="line">		if (timekeeping_valid_for_hres())</span><br><span class="line">			tick_periodic(cpu);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">|→</span><br><span class="line">static void tick_periodic(int cpu)</span><br><span class="line">&#123;</span><br><span class="line">    /* (1.1) 如果本cpu是tick_do_timer_cpu，更新全局时间戳类型的任务，</span><br><span class="line">	        包括update jiffies、update_wall_time  */</span><br><span class="line">	if (tick_do_timer_cpu == cpu) &#123;</span><br><span class="line">		write_seqlock(&amp;jiffies_lock);</span><br><span class="line"></span><br><span class="line">		/* Keep track of the next tick event */</span><br><span class="line">		tick_next_period = ktime_add(tick_next_period, tick_period);</span><br><span class="line"></span><br><span class="line">        /* (1.1.1) 更新jiffies */</span><br><span class="line">		do_timer(1);</span><br><span class="line">		write_sequnlock(&amp;jiffies_lock);</span><br><span class="line">		/* (1.1.2) 读取clocksource来更新timekeeper */</span><br><span class="line">		update_wall_time();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (1.2) 运行软件timer(run_local_timers())和运行调度tick任务(scheduler_tick()) */</span><br><span class="line">	update_process_times(user_mode(get_irq_regs()));</span><br><span class="line">	profile_tick(CPU_PROFILING);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-3、运行Mode"><a href="#3-3、运行Mode" class="headerlink" title="3.3、运行Mode"></a>3.3、运行Mode</h2><p>关于mode，有几个结构涉及到：tick_device、clock_event_device、tick_sched、hrtimer_cpu_base、。组合起来有以下几种情况：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>tick_device</th>
<th>clock_event_device</th>
<th>tick_sched</th>
<th>hrtimer_cpu_base</th>
<th>模式说明</th>
<th>切换路径</th>
<th>handler处理路径</th>
</tr>
</thead>
<tbody>
<tr>
<td>成员</td>
<td>-&gt;mode</td>
<td>-&gt;state_use_accessors</td>
<td>-&gt;nohz_mode</td>
<td>-&gt;hres_active</td>
<td>—</td>
<td>—</td>
<td>—</td>
<td></td>
</tr>
<tr>
<td>情况1</td>
<td>TICKDEV_MODE_PERIODIC</td>
<td>CLOCK_EVT_STATE_PERIODIC</td>
<td>NOHZ_MODE_INACTIVE</td>
<td>0</td>
<td>td=period模式, dev=period模式, hrtimer=low res, noHz=dis</td>
<td>初始状态</td>
<td>tick_handle_periodic() -&gt; tick_periodic() -&gt; update_process_times() -&gt; run_local_timers()、scheduler_tick()</td>
<td></td>
</tr>
<tr>
<td>情况2</td>
<td>TICKDEV_MODE_PERIODIC</td>
<td>CLOCK_EVT_STATE_ONESHOT</td>
<td>NOHZ_MODE_INACTIVE</td>
<td>0</td>
<td>td=period模式, dev=oneshot模式, hrtimer=low res, noHz=dis</td>
<td>初始状态</td>
<td>tick_handle_periodic() -&gt; tick_periodic() -&gt; update_process_times() -&gt; run_local_timers()、scheduler_tick()</td>
<td></td>
</tr>
<tr>
<td>情况3</td>
<td>TICKDEV_MODE_ONESHOT</td>
<td>CLOCK_EVT_STATE_ONESHOT</td>
<td>NOHZ_MODE_LOWRES</td>
<td>0</td>
<td>td=oneshot模式, dev=oneshot模式, hrtimer=low res, noHz=en</td>
<td>tick_handle_periodic() -&gt; tick_periodic() -&gt; update_process_times() -&gt; run_local_timers() -&gt; hrtimer_run_queues() -&gt; tick_check_oneshot_change() -&gt; tick_nohz_switch_to_nohz()</td>
<td>tick_nohz_handler() -&gt; tick_sched_handle() -&gt; update_process_times()</td>
<td></td>
</tr>
<tr>
<td>情况4</td>
<td>TICKDEV_MODE_ONESHOT</td>
<td>CLOCK_EVT_STATE_ONESHOT</td>
<td>NOHZ_MODE_HIGHRES</td>
<td>1</td>
<td>td=oneshot模式, dev=oneshot模式, hrtimer=high res, noHz=en</td>
<td>update_process_times() -&gt; run_local_timers() -&gt; hrtimer_run_queues() -&gt; hrtimer_switch_to_hres()</td>
<td>hrtimer_interrupt() -&gt; __hrtimer_run_queues() -&gt; ts-&gt;sched_timer() -&gt; tick_sched_timer() -&gt; tick_sched_handle() -&gt; update_process_times()</td>
<td></td>
</tr>
</tbody>
</table>
<blockquote>
</blockquote>
<p><html></html></p>
<p><table><br>    <tr><br>        <td> </td><br>        <td style="width: 100px;"> tick_device </td><br>        <td style="width: 100px;"> clock_event_device </td><br>        <td style="width: 100px;"> tick_sched </td><br>        <td style="width: 100px;"> hrtimer_cpu_base </td><br>        <td style="width: 200px;"> 模式说明 </td><br>        <td> 切换路径 </td><br>        <td> handler处理路径 </td><br>    </tr><br>    <tr><br>        <td> 成员 </td><br>        <td> -&gt;mode </td><br>        <td> -&gt;state_use_accessors </td><br>        <td> -&gt;nohz_mode </td><br>        <td> -&gt;hres_active </td><br>        <td>  </td><br>        <td>  </td><br>        <td>  </td><br>    </tr><br>    <tr><br>        <td> 情况1 </td><br>        <td> TICKDEV_MODE_PERIODIC </td><br>        <td> CLOCK_EVT_STATE_PERIODIC </td><br>        <td> NOHZ_MODE_INACTIVE </td><br>        <td> 0 </td><br>        <td> td=period模式, dev=period模式, hrtimer=low res, noHz=dis </td><br>        <td> 初始状态 </td><br>        <td> tick_handle_periodic() -&gt; tick_periodic() -&gt; update_process_times() -&gt; run_local_timers()、scheduler_tick() </td><br>    </tr><br>    <tr><br>        <td> 情况2 </td><br>        <td> TICKDEV_MODE_PERIODIC </td><br>        <td> CLOCK_EVT_STATE_ONESHOT </td><br>        <td> NOHZ_MODE_INACTIVE </td><br>        <td> 0 </td><br>        <td> td=period模式, dev=oneshot模式, hrtimer=low res, noHz=dis </td><br>        <td> 初始状态 </td><br>        <td> tick_handle_periodic() -&gt; tick_periodic() -&gt; update_process_times() -&gt; run_local_timers()、scheduler_tick() </td><br>    </tr><br>    <tr><br>        <td> 情况3 </td><br>        <td> TICKDEV_MODE_ONESHOT </td><br>        <td> CLOCK_EVT_STATE_ONESHOT </td><br>        <td> NOHZ_MODE_LOWRES </td><br>        <td> 0 </td><br>        <td> td=period模式, dev=oneshot模式, hrtimer=low res, noHz=en </td><br>        <td> tick_handle_periodic() -&gt; tick_periodic() -&gt; update_process_times() -&gt; run_local_timers() -&gt; hrtimer_run_queues() -&gt; tick_check_oneshot_change() -&gt; tick_nohz_switch_to_nohz() </td><br>        <td> tick_nohz_handler() -&gt; tick_sched_handle() -&gt; update_process_times() </td><br>    </tr><br>    <tr><br>        <td> 情况4 </td><br>        <td> TICKDEV_MODE_ONESHOT </td><br>        <td> CLOCK_EVT_STATE_ONESHOT </td><br>        <td> NOHZ_MODE_HIGHRES </td><br>        <td> 1 </td><br>        <td> td=period模式, dev=oneshot模式, hrtimer=high res, noHz=en </td><br>        <td> update_process_times() -&gt; run_local_timers() -&gt; hrtimer_run_queues() -&gt; hrtimer_switch_to_hres() </td><br>        <td> hrtimer_interrupt() -&gt; __hrtimer_run_queues() -&gt; ts-&gt;sched_timer() -&gt; tick_sched_timer() -&gt; tick_sched_handle() -&gt; update_process_times() </td><br>    </tr><br></table><br></p>
<blockquote>
</blockquote>
<p>其实归结起来就3种mode：NOHZ_MODE_INACTIVE、NOHZ_MODE_LOWRES、NOHZ_MODE_HIGHRES。下面来逐个解析一下。</p>
<h3 id="3-3-1、NOHZ-MODE-INACTIVE"><a href="#3-3-1、NOHZ-MODE-INACTIVE" class="headerlink" title="3.3.1、NOHZ_MODE_INACTIVE"></a>3.3.1、NOHZ_MODE_INACTIVE</h3><p>NOHZ_MODE_INACTIVE就是系统初始化时的状态：“td=period模式, dev=period/oneshot模式, hrtimer=low res, noHz=dis”。</p>
<p><img src="/images/time/clockevent_NOHZ_MODE_INACTIVE.png" alt="clockevent_NOHZ_MODE_INACTIVE"></p>
<p>NOHZ_MODE_INACTIVE模式：</p>
<ul>
<li>tick_device工作在period模式，HW local timer工作在period/oneshot模式；</li>
<li>noHZ没有使能，进入idle会被tick timer中断打断；</li>
<li>hrtimer工作在低精度模式，和低精度定时器(SW local timer)的精度一样，都是基于tick的；</li>
</ul>
<h3 id="3-3-2、NOHZ-MODE-LOWRES"><a href="#3-3-2、NOHZ-MODE-LOWRES" class="headerlink" title="3.3.2、NOHZ_MODE_LOWRES"></a>3.3.2、NOHZ_MODE_LOWRES</h3><p>在系统的运行过程中系统尝试进入精度更高的模式，如果noHZ可以使能，但是hrtimer高精度不能使能，即进入NOHZ_MODE_LOWRES模式：“td=period模式, dev=oneshot模式, hrtimer=low res, noHz=en”。</p>
<p><img src="/images/time/clockevent_NOHZ_MODE_LOWRES.png" alt="clockevent_NOHZ_MODE_LOWRES"></p>
<p>NOHZ_MODE_LOWRES模式：</p>
<ul>
<li>tick_device工作在oneshot模式，HW local timer工作在oneshot模式；</li>
<li>noHZ使能，进入idle不会被tick timer中断打断；</li>
<li>hrtimer工作在低精度模式，和低精度定时器(SW local timer)的精度一样，都是基于tick的；</li>
</ul>
<p>为了支持noHZ，tick_device必须切换成oneshot模式，在进入idle时停掉tick timer(tick_nohz_idle_enter() -&gt;　__tick_nohz_idle_enter() -&gt; tick_nohz_stop_sched_tick())，在离开idle时恢复tick timer(tick_nohz_idle_exit() -&gt; tick_nohz_restart_sched_tick())，这样idle过程就不会被tick中断。就实现了noHZ模式(tickless)。</p>
<p>NOHZ_MODE_LOWRES模式下，没有进入idle时tick_device还是以固定周期工作的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static void tick_nohz_handler(struct clock_event_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">	struct tick_sched *ts = this_cpu_ptr(&amp;tick_cpu_sched);</span><br><span class="line">	struct pt_regs *regs = get_irq_regs();</span><br><span class="line">	ktime_t now = ktime_get();</span><br><span class="line"></span><br><span class="line">	dev-&gt;next_event.tv64 = KTIME_MAX;</span><br><span class="line"></span><br><span class="line">	tick_sched_do_timer(now);</span><br><span class="line">	tick_sched_handle(ts, regs);</span><br><span class="line"></span><br><span class="line">	/* No need to reprogram if we are running tickless  */</span><br><span class="line">	if (unlikely(ts-&gt;tick_stopped))</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">    /* (1) HW local timer还是以固定周期发生中断 */</span><br><span class="line">	hrtimer_forward(&amp;ts-&gt;sched_timer, now, tick_period);</span><br><span class="line">	tick_program_event(hrtimer_get_expires(&amp;ts-&gt;sched_timer), 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-3、NOHZ-MODE-HIGHRES"><a href="#3-3-3、NOHZ-MODE-HIGHRES" class="headerlink" title="3.3.3、NOHZ_MODE_HIGHRES"></a>3.3.3、NOHZ_MODE_HIGHRES</h3><p>在系统的运行过程中系统尝试进入精度更高的模式，如果noHZ可以使能，hrtimer高精度可以使能，即进入NOHZ_MODE_HIGHRES模式：“td=period模式, dev=oneshot模式, hrtimer=high res, noHz=en”。</p>
<p><img src="/images/time/clockevent_NOHZ_MODE_HIGHRES.png" alt="clockevent_NOHZ_MODE_HIGHRES"></p>
<p>NOHZ_MODE_HIGHRES：</p>
<ul>
<li>tick_device工作在oneshot模式，HW local timer工作在oneshot模式；</li>
<li>noHZ使能，进入idle不会被tick timer中断打断；</li>
<li>hrtimer工作在高精度模式，和硬件定时器(HWlocal timer)的精度一样，远大于低精度定时器tick精度；</li>
</ul>
<p>为了支持hrtimer的高精度模式，hrtimer必须直接使用tick_device的oneshot模式，而常规的tick timer转换成hrtimer的一个子timer。</p>
<p><img src="/images/time/ftrace_NOHZ_MODE_HIGHRES.png" alt="ftrace_NOHZ_MODE_HIGHRES"></p>
<p>上图是NOHZ_MODE_HIGHRES模式下，用ftrace抓取HW timer硬件中断和tick任务的执行情况：</p>
<ul>
<li>tick任务是以固定周期4ms固定执行的；</li>
<li>遇到tick任务超过4ms的间隔，这时就是进入了idle状态，且发生了noHZ(tickless)；</li>
<li>硬件timer中断的发生周期是不固定的，是和hrtimer绑定的；</li>
<li>发生tick的时候肯定发生了timer硬中断，因为tick是其中一个hrtimer；</li>
</ul>
<h3 id="3-3-4、Mode切换"><a href="#3-3-4、Mode切换" class="headerlink" title="3.3.4、Mode切换"></a>3.3.4、Mode切换</h3><p>系统初始状态工作在NOHZ_MODE_INACTIVE模式时，会动态检测是否可以进入更高级别的模式NOHZ_MODE_LOWRES、NOHZ_MODE_HIGHRES。这个检测工作是在这个路径中做的：tick_device工作在period模式：tick_handle_periodic() -&gt; tick_periodic() -&gt; update_process_times() -&gt; run_local_timers() -&gt; hrtimer_run_queues()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">void hrtimer_run_queues(void)</span><br><span class="line">&#123;</span><br><span class="line">	struct hrtimer_cpu_base *cpu_base = this_cpu_ptr(&amp;hrtimer_bases);</span><br><span class="line">	ktime_t now;</span><br><span class="line"></span><br><span class="line">    /* (3) 如果hrtimer已经切换到高精度模式，</span><br><span class="line">        则不会从run_local_timers()低精度定时器路径来运行hrtimer */</span><br><span class="line">	if (__hrtimer_hres_active(cpu_base))</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * This _is_ ugly: We have to check periodically, whether we</span><br><span class="line">	 * can switch to highres and / or nohz mode. The clocksource</span><br><span class="line">	 * switch happens with xtime_lock held. Notification from</span><br><span class="line">	 * there only sets the check bit in the tick_oneshot code,</span><br><span class="line">	 * otherwise we might deadlock vs. xtime_lock.</span><br><span class="line">	 */</span><br><span class="line">	</span><br><span class="line">	/* (1) 如果hrtimer没有使能、noHZ使能，</span><br><span class="line">	    则调用：tick_check_oneshot_change() -&gt; tick_nohz_switch_to_nohz()，</span><br><span class="line">	    切换到NOHZ_MODE_LOWRES模式 */</span><br><span class="line">	if (tick_check_oneshot_change(!hrtimer_is_hres_enabled())) &#123;</span><br><span class="line">	</span><br><span class="line">	    /* (2) 如果hrtimer使能、noHZ使能，</span><br><span class="line">    	    则调用：hrtimer_switch_to_hres()，</span><br><span class="line">    	    切换到NOHZ_MODE_HIGHRES模式 */</span><br><span class="line">		hrtimer_switch_to_hres();</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	raw_spin_lock(&amp;cpu_base-&gt;lock);</span><br><span class="line">	now = hrtimer_update_base(cpu_base);</span><br><span class="line">	/* (4) 低精度hrtimer的运行函数 */</span><br><span class="line">	__hrtimer_run_queues(cpu_base, now);</span><br><span class="line">	raw_spin_unlock(&amp;cpu_base-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4、noHZ"><a href="#4、noHZ" class="headerlink" title="4、noHZ"></a>4、noHZ</h1><p>系统在NOHZ_MODE_LOWRES、NOHZ_MODE_HIGHRES两种模式下支持noHZ。noHZ是一个功耗优化的feature，在系统负载比较轻的时候没有任务需要调度cpu会进入idle状态，但是系统的tick任务(update_process_times())默认会以固定周期执行，这种固定周期会打断idle状态让系统恢复成正常耗电状态。</p>
<p>tick任务这种不管有没有任务都是固定周期运行的特性是需要改进的，noHZ就是为了解决这一问题而产生的：如果在idle状态的过程中tick任务没有到期需要处理的低精度timer和高精度timer，tick任务可以继续保持睡眠，直到真正有timer到期。</p>
<p>idle进程的主要执行序列如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">static void cpu_idle_loop(void)</span><br><span class="line">&#123;</span><br><span class="line">	while (1) &#123;</span><br><span class="line"></span><br><span class="line">        /* (1) 进入idle前,noHZ的处理 */</span><br><span class="line">		tick_nohz_idle_enter();</span><br><span class="line"></span><br><span class="line">		while (!need_resched()) &#123;</span><br><span class="line">			check_pgt_cache();</span><br><span class="line">			rmb();</span><br><span class="line"></span><br><span class="line">            /* (2) cpu hotplug之cpu_down()的处理 */</span><br><span class="line">			if (cpu_is_offline(smp_processor_id())) &#123;</span><br><span class="line"></span><br><span class="line">				arch_cpu_idle_dead();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			local_irq_disable();</span><br><span class="line">			arch_cpu_idle_enter();</span><br><span class="line"></span><br><span class="line">            /* (3) cpu idle的进入 */</span><br><span class="line">			if (cpu_idle_force_poll || tick_check_broadcast_expired())</span><br><span class="line">				cpu_idle_poll();</span><br><span class="line">			else</span><br><span class="line">				cpuidle_idle_call();</span><br><span class="line"></span><br><span class="line">			arch_cpu_idle_exit();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        /* (4) 退出idle后,noHZ的处理 */</span><br><span class="line">		tick_nohz_idle_exit();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，其中的关键在tick_nohz_idle_enter()/tick_nohz_idle_exit()函数。</p>
<h2 id="4-1、tick-nohz-idle-enter-exit"><a href="#4-1、tick-nohz-idle-enter-exit" class="headerlink" title="4.1、tick_nohz_idle_enter/exit()"></a>4.1、tick_nohz_idle_enter/exit()</h2><p>tick_nohz_idle_enter()的解析：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line">void tick_nohz_idle_enter(void)</span><br><span class="line">&#123;</span><br><span class="line">	struct tick_sched *ts;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	ts = this_cpu_ptr(&amp;tick_cpu_sched);</span><br><span class="line">	ts-&gt;inidle = 1;</span><br><span class="line">	__tick_nohz_idle_enter(ts);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">|→</span><br><span class="line">static void __tick_nohz_idle_enter(struct tick_sched *ts)</span><br><span class="line">&#123;</span><br><span class="line">	ktime_t now, expires;</span><br><span class="line">	int cpu = smp_processor_id();</span><br><span class="line"></span><br><span class="line">	now = tick_nohz_start_idle(ts);</span><br><span class="line"></span><br><span class="line">    /* (1) 判断当前能否stop tick任务 */</span><br><span class="line">	if (can_stop_idle_tick(cpu, ts)) &#123;</span><br><span class="line">		int was_stopped = ts-&gt;tick_stopped;</span><br><span class="line"></span><br><span class="line">		ts-&gt;idle_calls++;</span><br><span class="line"></span><br><span class="line">        /* (2) 尝试stop tick任务 */</span><br><span class="line">		expires = tick_nohz_stop_sched_tick(ts, now, cpu);</span><br><span class="line">		if (expires.tv64 &gt; 0LL) &#123;</span><br><span class="line">			ts-&gt;idle_sleeps++;</span><br><span class="line">			ts-&gt;idle_expires = expires;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (!was_stopped &amp;&amp; ts-&gt;tick_stopped)</span><br><span class="line">			ts-&gt;idle_jiffies = ts-&gt;last_jiffies;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">||→</span><br><span class="line">static ktime_t tick_nohz_stop_sched_tick(struct tick_sched *ts,</span><br><span class="line">					 ktime_t now, int cpu)</span><br><span class="line">&#123;</span><br><span class="line">	struct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);</span><br><span class="line">	u64 basemono, next_tick, next_tmr, next_rcu, delta, expires;</span><br><span class="line">	unsigned long seq, basejiff;</span><br><span class="line">	ktime_t	tick;</span><br><span class="line"></span><br><span class="line">	/* Read jiffies and the time when jiffies were updated last */</span><br><span class="line">	do &#123;</span><br><span class="line">		seq = read_seqbegin(&amp;jiffies_lock);</span><br><span class="line">		basemono = last_jiffies_update.tv64;</span><br><span class="line">		basejiff = jiffies;</span><br><span class="line">	&#125; while (read_seqretry(&amp;jiffies_lock, seq));</span><br><span class="line">	ts-&gt;last_jiffies = basejiff;</span><br><span class="line"></span><br><span class="line">	if (rcu_needs_cpu(basemono, &amp;next_rcu) ||</span><br><span class="line">	    arch_needs_cpu() || irq_work_needs_cpu()) &#123;</span><br><span class="line">		next_tick = basemono + TICK_NSEC;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		/*</span><br><span class="line">		 * Get the next pending timer. If high resolution</span><br><span class="line">		 * timers are enabled this only takes the timer wheel</span><br><span class="line">		 * timers into account. If high resolution timers are</span><br><span class="line">		 * disabled this also looks at the next expiring</span><br><span class="line">		 * hrtimer.</span><br><span class="line">		 */</span><br><span class="line">		/* (2.1) 获取下一个timer的到期时间(包括低精度和高精度timer) */</span><br><span class="line">		next_tmr = get_next_timer_interrupt(basejiff, basemono);</span><br><span class="line">		ts-&gt;next_timer = next_tmr;</span><br><span class="line">		/* Take the next rcu event into account */</span><br><span class="line">		next_tick = next_rcu &lt; next_tmr ? next_rcu : next_tmr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * If the tick is due in the next period, keep it ticking or</span><br><span class="line">	 * restart it proper.</span><br><span class="line">	 */</span><br><span class="line">	/* (2.2) 如果差距小于一个tick，不需要进入noHZ模式 */</span><br><span class="line">	delta = next_tick - basemono;</span><br><span class="line">	if (delta &lt;= (u64)TICK_NSEC) &#123;</span><br><span class="line">		tick.tv64 = 0;</span><br><span class="line">		if (!ts-&gt;tick_stopped)</span><br><span class="line">			goto out;</span><br><span class="line">		if (delta == 0) &#123;</span><br><span class="line">			/* Tick is stopped, but required now. Enforce it */</span><br><span class="line">			tick_nohz_restart(ts, now);</span><br><span class="line">			goto out;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * If this cpu is the one which updates jiffies, then give up</span><br><span class="line">	 * the assignment and let it be taken by the cpu which runs</span><br><span class="line">	 * the tick timer next, which might be this cpu as well. If we</span><br><span class="line">	 * don&apos;t drop this here the jiffies might be stale and</span><br><span class="line">	 * do_timer() never invoked. Keep track of the fact that it</span><br><span class="line">	 * was the one which had the do_timer() duty last. If this cpu</span><br><span class="line">	 * is the one which had the do_timer() duty last, we limit the</span><br><span class="line">	 * sleep time to the timekeeping max_deferement value.</span><br><span class="line">	 * Otherwise we can sleep as long as we want.</span><br><span class="line">	 */</span><br><span class="line">	/* (2.3) 根据timekeeper的可能溢出的位宽，得到的idle最大值 */</span><br><span class="line">	delta = timekeeping_max_deferment();</span><br><span class="line">	if (cpu == tick_do_timer_cpu) &#123;</span><br><span class="line">		tick_do_timer_cpu = TICK_DO_TIMER_NONE;</span><br><span class="line">		ts-&gt;do_timer_last = 1;</span><br><span class="line">	&#125; else if (tick_do_timer_cpu != TICK_DO_TIMER_NONE) &#123;</span><br><span class="line">		delta = KTIME_MAX;</span><br><span class="line">		ts-&gt;do_timer_last = 0;</span><br><span class="line">	&#125; else if (!ts-&gt;do_timer_last) &#123;</span><br><span class="line">		delta = KTIME_MAX;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_NO_HZ_FULL</span><br><span class="line">	/* Limit the tick delta to the maximum scheduler deferment */</span><br><span class="line">	if (!ts-&gt;inidle)</span><br><span class="line">		delta = min(delta, scheduler_tick_max_deferment());</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	/* Calculate the next expiry time */</span><br><span class="line">	if (delta &lt; (KTIME_MAX - basemono))</span><br><span class="line">		expires = basemono + delta;</span><br><span class="line">	else</span><br><span class="line">		expires = KTIME_MAX;</span><br><span class="line"></span><br><span class="line">    /* (2.4) 综合上面条件，得到合理的stop tick的时间 */</span><br><span class="line">	expires = min_t(u64, expires, next_tick);</span><br><span class="line">	tick.tv64 = expires;</span><br><span class="line"></span><br><span class="line">	/* Skip reprogram of event if its not changed */</span><br><span class="line">	if (ts-&gt;tick_stopped &amp;&amp; (expires == dev-&gt;next_event.tv64))</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * nohz_stop_sched_tick can be called several times before</span><br><span class="line">	 * the nohz_restart_sched_tick is called. This happens when</span><br><span class="line">	 * interrupts arrive which do not cause a reschedule. In the</span><br><span class="line">	 * first call we save the current tick time, so we can restart</span><br><span class="line">	 * the scheduler tick in nohz_restart_sched_tick.</span><br><span class="line">	 */</span><br><span class="line">	if (!ts-&gt;tick_stopped) &#123;</span><br><span class="line">		nohz_balance_enter_idle(cpu);</span><br><span class="line">		calc_load_enter_idle();</span><br><span class="line"></span><br><span class="line">		ts-&gt;last_tick = hrtimer_get_expires(&amp;ts-&gt;sched_timer);</span><br><span class="line">		ts-&gt;tick_stopped = 1;</span><br><span class="line">		trace_tick_stop(1, &quot; &quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * If the expiration time == KTIME_MAX, then we simply stop</span><br><span class="line">	 * the tick timer.</span><br><span class="line">	 */</span><br><span class="line">	if (unlikely(expires == KTIME_MAX)) &#123;</span><br><span class="line">		if (ts-&gt;nohz_mode == NOHZ_MODE_HIGHRES)</span><br><span class="line">			hrtimer_cancel(&amp;ts-&gt;sched_timer);</span><br><span class="line">		goto out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (2.5) 实际的stop tick动作：</span><br><span class="line">      将local timer的周期改为大于一个tick的时间，将idle时间延长  */</span><br><span class="line">	if (ts-&gt;nohz_mode == NOHZ_MODE_HIGHRES)</span><br><span class="line">		hrtimer_start(&amp;ts-&gt;sched_timer, tick, HRTIMER_MODE_ABS_PINNED);</span><br><span class="line">	else</span><br><span class="line">		tick_program_event(tick, 1);</span><br><span class="line">out:</span><br><span class="line">	/* Update the estimated sleep length */</span><br><span class="line">	ts-&gt;sleep_length = ktime_sub(dev-&gt;next_event, now);</span><br><span class="line">	return tick;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tick_nohz_idle_exit()的解析：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">void tick_nohz_idle_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">	struct tick_sched *ts = this_cpu_ptr(&amp;tick_cpu_sched);</span><br><span class="line">	ktime_t now;</span><br><span class="line"></span><br><span class="line">	local_irq_disable();</span><br><span class="line"></span><br><span class="line">	WARN_ON_ONCE(!ts-&gt;inidle);</span><br><span class="line"></span><br><span class="line">	ts-&gt;inidle = 0;</span><br><span class="line"></span><br><span class="line">	if (ts-&gt;idle_active || ts-&gt;tick_stopped)</span><br><span class="line">		now = ktime_get();</span><br><span class="line"></span><br><span class="line">	if (ts-&gt;idle_active)</span><br><span class="line">		tick_nohz_stop_idle(ts, now);</span><br><span class="line"></span><br><span class="line">	if (ts-&gt;tick_stopped) &#123;</span><br><span class="line">	    /* (1) 重启tick任务 */</span><br><span class="line">		tick_nohz_restart_sched_tick(ts, now);</span><br><span class="line">		tick_nohz_account_idle_ticks(ts);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	local_irq_enable();</span><br><span class="line">&#125;</span><br><span class="line">|→</span><br><span class="line">static void tick_nohz_restart_sched_tick(struct tick_sched *ts, ktime_t now)</span><br><span class="line">&#123;</span><br><span class="line">	/* Update jiffies first */</span><br><span class="line">	tick_do_update_jiffies64(now);</span><br><span class="line">	update_cpu_load_nohz();</span><br><span class="line"></span><br><span class="line">	calc_load_exit_idle();</span><br><span class="line">	touch_softlockup_watchdog();</span><br><span class="line">	/*</span><br><span class="line">	 * Cancel the scheduled timer and restore the tick</span><br><span class="line">	 */</span><br><span class="line">	ts-&gt;tick_stopped  = 0;</span><br><span class="line">	ts-&gt;idle_exittime = now;</span><br><span class="line"></span><br><span class="line">    /* (1.1) 重启local timer */</span><br><span class="line">	tick_nohz_restart(ts, now);</span><br><span class="line">&#125;</span><br><span class="line">||→</span><br><span class="line">static void tick_nohz_restart(struct tick_sched *ts, ktime_t now)</span><br><span class="line">&#123;</span><br><span class="line">	hrtimer_cancel(&amp;ts-&gt;sched_timer);</span><br><span class="line">	hrtimer_set_expires(&amp;ts-&gt;sched_timer, ts-&gt;last_tick);</span><br><span class="line"></span><br><span class="line">	/* Forward the time to expire in the future */</span><br><span class="line">	hrtimer_forward(&amp;ts-&gt;sched_timer, now, tick_period);</span><br><span class="line"></span><br><span class="line">	if (ts-&gt;nohz_mode == NOHZ_MODE_HIGHRES)</span><br><span class="line">		hrtimer_start_expires(&amp;ts-&gt;sched_timer, HRTIMER_MODE_ABS_PINNED);</span><br><span class="line">	else</span><br><span class="line">		tick_program_event(hrtimer_get_expires(&amp;ts-&gt;sched_timer), 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-2-tick-nohz-irq-enter-exit"><a href="#4-2-tick-nohz-irq-enter-exit" class="headerlink" title="4.2 tick_nohz_irq_enter/exit()"></a>4.2 tick_nohz_irq_enter/exit()</h2><p>因为在idle退出执行完本tick需要处理的timer后又需要重新关闭tick，系统设计了tick_nohz_irq_enter()/tick_nohz_irq_exit()来处理这种操作。在本次中断处理完timer后，在tick_nohz_irq_exit()中判断是否重新关闭tick任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">static void cpu_idle_loop(void)</span><br><span class="line">&#123;</span><br><span class="line">	while (1) &#123;</span><br><span class="line"></span><br><span class="line">        /* (1) 关闭tick */</span><br><span class="line">		tick_nohz_idle_enter();</span><br><span class="line"></span><br><span class="line">		while (!need_resched()) &#123;</span><br><span class="line">			check_pgt_cache();</span><br><span class="line">			rmb();</span><br><span class="line"></span><br><span class="line">            /* (2) cpu hotplug之cpu_down()的处理 */</span><br><span class="line">			if (cpu_is_offline(smp_processor_id())) &#123;</span><br><span class="line"></span><br><span class="line">				arch_cpu_idle_dead();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">            /* (3) 关中断 */</span><br><span class="line">			local_irq_disable();</span><br><span class="line">			arch_cpu_idle_enter();</span><br><span class="line"></span><br><span class="line">            /* (4) 进入idle，</span><br><span class="line">                cpu进入暂停状态 */</span><br><span class="line">			if (cpu_idle_force_poll || tick_check_broadcast_expired())</span><br><span class="line">				cpu_idle_poll();</span><br><span class="line">			else</span><br><span class="line">				cpuidle_idle_call();</span><br><span class="line">		    /* (5) cpu被local timer中断唤醒退出idle状态，继续执行；</span><br><span class="line">		        但是因为irq是disable状态，中断服务程序并不能马上得到执行*/</span><br><span class="line">			/* (5.1) 退出idle，并且开中断 */	</span><br><span class="line">			</span><br><span class="line">                    /* (6) 中断打开后，被阻塞的local timer中断服务得到执行，到期的软件timer得到执行；*/</span><br><span class="line">                    /* (6.1) 退出中断时调用tick_nohz_irq_exit()，重新计算一个tick可以被stop的值 */</span><br><span class="line">            </span><br><span class="line">			arch_cpu_idle_exit();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        /* (7) 重启tick */</span><br><span class="line">		tick_nohz_idle_exit();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tick_nohz_irq_enter()/tick_nohz_irq_exit()的代码解析：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">static inline void tick_nohz_irq_enter(void)</span><br><span class="line">&#123;</span><br><span class="line">	struct tick_sched *ts = this_cpu_ptr(&amp;tick_cpu_sched);</span><br><span class="line">	ktime_t now;</span><br><span class="line"></span><br><span class="line">	if (!ts-&gt;idle_active &amp;&amp; !ts-&gt;tick_stopped)</span><br><span class="line">		return;</span><br><span class="line">	now = ktime_get();</span><br><span class="line">	if (ts-&gt;idle_active)</span><br><span class="line">		tick_nohz_stop_idle(ts, now);</span><br><span class="line">		</span><br><span class="line">	/* (1) 基本就是空操作 */</span><br><span class="line">	if (ts-&gt;tick_stopped) &#123;</span><br><span class="line">		tick_nohz_update_jiffies(now);</span><br><span class="line">		tick_nohz_kick_tick(ts, now);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void tick_nohz_irq_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">	struct tick_sched *ts = this_cpu_ptr(&amp;tick_cpu_sched);</span><br><span class="line"></span><br><span class="line">	if (ts-&gt;inidle)</span><br><span class="line">	    /* (2) 重新判断stop tick任务 */</span><br><span class="line">		__tick_nohz_idle_enter(ts);</span><br><span class="line">	else</span><br><span class="line">		tick_nohz_full_update_tick(ts);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-3、local-timer时钟被关闭时的处理"><a href="#4-3、local-timer时钟被关闭时的处理" class="headerlink" title="4.3、local timer时钟被关闭时的处理"></a>4.3、local timer时钟被关闭时的处理</h2><p>还有一种情况需要考虑，在系统进入深层次的idle状态时，local timer本身的时钟可能会被关闭。比如MTK平台进入soidle状态时，local timer本身会被停止，这时会用一个GPT timer来替代local timer继续工作。</p>
<p>核心函数是timer_setting_before_wfi()/timer_setting_after_wfi()：</p>
<ul>
<li>timer_setting_before_wfi()在进入idle前被调用，读出local timer的剩余值并配置到GPT timer中；</li>
<li>timer_setting_after_wfi()在退出idle后被调用，读出GPT timer的值来重新恢复local timer；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">static void timer_setting_before_wfi(bool f26m_off)</span><br><span class="line">&#123;</span><br><span class="line">#ifndef USING_STD_TIMER_OPS</span><br><span class="line">#ifdef CONFIG_SMP</span><br><span class="line">	unsigned int timer_left = 0;</span><br><span class="line"></span><br><span class="line">    /* (1) 读出local timer的剩余值 */</span><br><span class="line">	timer_left = localtimer_get_counter();</span><br><span class="line"></span><br><span class="line">    /* (2) 根据GPT timer在不同状态下的频率，把剩余值配置到GPT中 */</span><br><span class="line">	if ((int)timer_left &lt;= 0)</span><br><span class="line">		gpt_set_cmp(IDLE_GPT, 1); /* Trigger idle_gpt Timeout imediately */</span><br><span class="line">	else &#123;</span><br><span class="line">		if (f26m_off)</span><br><span class="line">			gpt_set_cmp(IDLE_GPT, div_u64(timer_left, 406.25));</span><br><span class="line">	else</span><br><span class="line">		gpt_set_cmp(IDLE_GPT, timer_left);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (f26m_off)</span><br><span class="line">		gpt_set_clk(IDLE_GPT, GPT_CLK_SRC_RTC, GPT_CLK_DIV_1);</span><br><span class="line"></span><br><span class="line">	start_gpt(IDLE_GPT);</span><br><span class="line">#else</span><br><span class="line">	gpt_get_cnt(GPT1, &amp;timer_left);</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void timer_setting_after_wfi(bool f26m_off)</span><br><span class="line">&#123;</span><br><span class="line">#ifndef USING_STD_TIMER_OPS</span><br><span class="line">#ifdef CONFIG_SMP</span><br><span class="line">    /* (3) 判断当前退出idle状态是否是因为GPT到期引起的 */</span><br><span class="line">	if (gpt_check_and_ack_irq(IDLE_GPT)) &#123;</span><br><span class="line">	    /* (3.1) 如果GPT时间已经到期，证明local timer也已经到期，</span><br><span class="line">	        触发local timer在下一时钟执行 */</span><br><span class="line">		localtimer_set_next_event(1);</span><br><span class="line">		if (f26m_off)</span><br><span class="line">			gpt_set_clk(IDLE_GPT, GPT_CLK_SRC_SYS, GPT_CLK_DIV_1);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">	/* (4) 退出idle是因为GPT以外的中断源唤醒的 */</span><br><span class="line">		/* waked up by other wakeup source */</span><br><span class="line">		unsigned int cnt, cmp;</span><br><span class="line"></span><br><span class="line">        /* (4.1) 读出GPT中的剩余到期值，重新配置到local timer中 */</span><br><span class="line">		idle_gpt_get_cnt(IDLE_GPT, &amp;cnt);</span><br><span class="line">		idle_gpt_get_cmp(IDLE_GPT, &amp;cmp);</span><br><span class="line">		if (unlikely(cmp &lt; cnt)) &#123;</span><br><span class="line">			idle_err(&quot;[%s]GPT%d: counter = %10u, compare = %10u\n&quot;,</span><br><span class="line">					__func__, IDLE_GPT + 1, cnt, cmp);</span><br><span class="line">			/* BUG(); */</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (f26m_off) &#123;</span><br><span class="line">			localtimer_set_next_event((cmp - cnt) * 1625 / 4);</span><br><span class="line">			gpt_set_clk(IDLE_GPT, GPT_CLK_SRC_SYS, GPT_CLK_DIV_1);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">		localtimer_set_next_event(cmp - cnt);</span><br><span class="line">		&#125;</span><br><span class="line">		stop_gpt(IDLE_GPT);</span><br><span class="line">	&#125;</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要特别说明的是，这种GPT timer全局只有一个，进入soidle的状态时cpu也只有一个在线，所以能正常的工作。</p>
<h1 id="5、hrtimer"><a href="#5、hrtimer" class="headerlink" title="5、hrtimer"></a>5、hrtimer</h1><h2 id="5-1、hrtimer的组织"><a href="#5-1、hrtimer的组织" class="headerlink" title="5.1、hrtimer的组织"></a>5.1、hrtimer的组织</h2><p>hrtimer的组织相对来说还是比较简单的，每个cpu对应一个hrtimer_cpu_base，每个hrtimer_cpu_base中有4类clock_base代表4种时间类型(HRTIMER_BASE_REALTIME、HRTIMER_BASE_MONOTONIC、HRTIMER_BASE_BOOTTIME、HRTIMER_BASE_TAI)的hrtimer，每个clock_base是以红黑树来组织同一类型的hrtimer的：</p>
<p><img src="/images/time/hrtimer.png" alt="hrtimer"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =</span><br><span class="line">&#123;</span><br><span class="line">	.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),</span><br><span class="line">	.seq = SEQCNT_ZERO(hrtimer_bases.seq),</span><br><span class="line">	.clock_base =</span><br><span class="line">	&#123;</span><br><span class="line">		&#123;</span><br><span class="line">			.index = HRTIMER_BASE_MONOTONIC,</span><br><span class="line">			.clockid = CLOCK_MONOTONIC,</span><br><span class="line">			.get_time = &amp;ktime_get,</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			.index = HRTIMER_BASE_REALTIME,</span><br><span class="line">			.clockid = CLOCK_REALTIME,</span><br><span class="line">			.get_time = &amp;ktime_get_real,</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			.index = HRTIMER_BASE_BOOTTIME,</span><br><span class="line">			.clockid = CLOCK_BOOTTIME,</span><br><span class="line">			.get_time = &amp;ktime_get_boottime,</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			.index = HRTIMER_BASE_TAI,</span><br><span class="line">			.clockid = CLOCK_TAI,</span><br><span class="line">			.get_time = &amp;ktime_get_clocktai,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="5-2、低精度模式-NOHZ-MODE-INACTIVE-NOHZ-MODE-LOWRES"><a href="#5-2、低精度模式-NOHZ-MODE-INACTIVE-NOHZ-MODE-LOWRES" class="headerlink" title="5.2、低精度模式(NOHZ_MODE_INACTIVE/NOHZ_MODE_LOWRES)"></a>5.2、低精度模式(NOHZ_MODE_INACTIVE/NOHZ_MODE_LOWRES)</h2><p>前面几章已经详细描述了执行路径，在低精度模式下hrtimer的实际精度和低精度定时器是一样的，都是基于tick精度的。他的执行路径如下。</p>
<p>NOHZ_MODE_INACTIVE模式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tick_handle_periodic()</span><br><span class="line">    ↓</span><br><span class="line">tick_periodic()</span><br><span class="line">    ↓</span><br><span class="line">update_process_times()</span><br><span class="line">    ↓</span><br><span class="line">run_local_timers()</span><br><span class="line">    ↓</span><br><span class="line">hrtimer_run_queues()</span><br><span class="line">    ↓</span><br><span class="line">__hrtimer_run_queues()</span><br></pre></td></tr></table></figure>
<p>NOHZ_MODE_LOWRES模式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tick_nohz_handler()</span><br><span class="line">    ↓</span><br><span class="line">tick_sched_handle()</span><br><span class="line">    ↓</span><br><span class="line">update_process_times()</span><br><span class="line">    ↓</span><br><span class="line">run_local_timers()</span><br><span class="line">    ↓</span><br><span class="line">hrtimer_run_queues()</span><br><span class="line">    ↓</span><br><span class="line">__hrtimer_run_queues()</span><br></pre></td></tr></table></figure>
<h2 id="5-3、高精度模式-NOHZ-MODE-HIGHRES"><a href="#5-3、高精度模式-NOHZ-MODE-HIGHRES" class="headerlink" title="5.3、高精度模式(NOHZ_MODE_HIGHRES)"></a>5.3、高精度模式(NOHZ_MODE_HIGHRES)</h2><p>在高精度模式下hrtimer才能发挥出真正的精度，他的可以精确定时到小于一个tick，精度依赖于硬件local timer。</p>
<p>NOHZ_MODE_LOWRES模式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hrtimer_interrupt()</span><br><span class="line">    ↓</span><br><span class="line">__hrtimer_run_queues()</span><br></pre></td></tr></table></figure>
<h1 id="6、低精度timer-lowres-timer"><a href="#6、低精度timer-lowres-timer" class="headerlink" title="6、低精度timer(lowres timer)"></a>6、低精度timer(lowres timer)</h1><p>低精度timer在系统中的应用范围更广，若非特别声明是hrtimer其他都是使用低精度timer，类如schedule_timeout()、msleep()。他有以下特点：</p>
<ul>
<li>精度低，以tick为单位计时；</li>
<li>执行上下文，低精度timer执行时是在softirq中，而hrtimer的实际执行是在中断当中。所以低精度的执行精度更小于hrtimer；</li>
<li>对系统的实时影响小，softirq比irq对系统的实时性影响更小；</li>
</ul>
<h2 id="6-1、低精度timer的组织"><a href="#6-1、低精度timer的组织" class="headerlink" title="6.1、低精度timer的组织"></a>6.1、低精度timer的组织</h2><p>低精度timer的组织形式和hrtimer类似，只是timer的链接不是采用红黑树，而是采用tv1 - tv5等一系列的链表。</p>
<p><img src="/images/time/lowres_timer.png" alt="lowres_timer"></p>
<p>tv1 - tv5中保留着一系列槽位，每个槽位代表一个超时时间，把相同超时时间的低精度timer链接到同一槽位当中。</p>
<h2 id="6-2、低精度timer的执行路径"><a href="#6-2、低精度timer的执行路径" class="headerlink" title="6.2、低精度timer的执行路径"></a>6.2、低精度timer的执行路径</h2><p>低精度timer的实际执行时在softirq中执行的，在中断中的动作只是简单触发softirq。</p>
<p>中断中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tick_handle_periodic()/tick_nohz_handler()/hrtimer_interrupt()</span><br><span class="line">    ↓</span><br><span class="line">run_local_timers()</span><br><span class="line">    ↓</span><br><span class="line">raise_softirq(TIMER_SOFTIRQ);</span><br></pre></td></tr></table></figure>
<p>软中断中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">run_timer_softirq()</span><br><span class="line">    ↓</span><br><span class="line">__run_timers()</span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[^DroidPhoneo]: <a href="http://blog.csdn.net/DroidPhone/article/category/1263459" target="_blank" rel="noopener">Linux 时间子系统</a></p>
<p>[^wowo]: <a href="http://www.wowotech.net/timer_subsystem/time_subsystem_index.html" target="_blank" rel="noopener">wowotech time subsystem</a></p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/hrtimer-nohz/" rel="tag"># hrtimer, nohz</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/12/21/perf_event_architecture/" rel="next" title="Linux Perf 1.1、perf_event内核框架">
                <i class="fa fa-chevron-left"></i> Linux Perf 1.1、perf_event内核框架
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/12/21/ftrace_ringbuffer/" rel="prev" title="Linux Ftrace 1.1、ring buffer">
                Linux Ftrace 1.1、ring buffer <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/touxiang/ycqs.jpg" alt="pwl999">
            
              <p class="site-author-name" itemprop="name">pwl999</p>
              <p class="site-description motion-element" itemprop="description">RTFSC(Read The Fucking Source Code)</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives">
                
                    <span class="site-state-item-count">30</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">3</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">22</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1、Linux时钟框架"><span class="nav-number">1.</span> <span class="nav-text">1、Linux时钟框架</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1、Exynos-MCT-Multi-Core-Timer"><span class="nav-number">1.1.</span> <span class="nav-text">1.1、Exynos MCT(Multi-Core Timer)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2、clocksource-amp-timekeeper"><span class="nav-number">2.</span> <span class="nav-text">2、clocksource &amp; timekeeper</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1、clocksource"><span class="nav-number">2.1.</span> <span class="nav-text">2.1、clocksource</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-1、exynos4-clocksource-init"><span class="nav-number">2.1.1.</span> <span class="nav-text">2.1.1、exynos4_clocksource_init()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2、timekeeper"><span class="nav-number">2.2.</span> <span class="nav-text">2.2、timekeeper</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-1、timekeeper的定义"><span class="nav-number">2.2.1.</span> <span class="nav-text">2.2.1、timekeeper的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-2、timekeeper的初始化"><span class="nav-number">2.2.2.</span> <span class="nav-text">2.2.2、timekeeper的初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-3、timekeeper的update"><span class="nav-number">2.2.3.</span> <span class="nav-text">2.2.3、timekeeper的update</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-4、timekeeper的获取"><span class="nav-number">2.2.4.</span> <span class="nav-text">2.2.4、timekeeper的获取</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-5、timekeeper-suspend"><span class="nav-number">2.2.5.</span> <span class="nav-text">2.2.5、timekeeper suspend</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3、clock-event"><span class="nav-number">3.</span> <span class="nav-text">3、clock_event</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1、clock-event的注册"><span class="nav-number">3.1.</span> <span class="nav-text">3.1、clock_event的注册</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-1、exynos-clock-event的注册"><span class="nav-number">3.1.1.</span> <span class="nav-text">3.1.1、exynos clock_event的注册</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-2、clock-event-device的注册"><span class="nav-number">3.1.2.</span> <span class="nav-text">3.1.2、clock_event_device的注册</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2、tick-device的period-mode"><span class="nav-number">3.2.</span> <span class="nav-text">3.2、tick_device的period mode</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3、运行Mode"><span class="nav-number">3.3.</span> <span class="nav-text">3.3、运行Mode</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-1、NOHZ-MODE-INACTIVE"><span class="nav-number">3.3.1.</span> <span class="nav-text">3.3.1、NOHZ_MODE_INACTIVE</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-2、NOHZ-MODE-LOWRES"><span class="nav-number">3.3.2.</span> <span class="nav-text">3.3.2、NOHZ_MODE_LOWRES</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-3、NOHZ-MODE-HIGHRES"><span class="nav-number">3.3.3.</span> <span class="nav-text">3.3.3、NOHZ_MODE_HIGHRES</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-4、Mode切换"><span class="nav-number">3.3.4.</span> <span class="nav-text">3.3.4、Mode切换</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4、noHZ"><span class="nav-number">4.</span> <span class="nav-text">4、noHZ</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1、tick-nohz-idle-enter-exit"><span class="nav-number">4.1.</span> <span class="nav-text">4.1、tick_nohz_idle_enter/exit()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-tick-nohz-irq-enter-exit"><span class="nav-number">4.2.</span> <span class="nav-text">4.2 tick_nohz_irq_enter/exit()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3、local-timer时钟被关闭时的处理"><span class="nav-number">4.3.</span> <span class="nav-text">4.3、local timer时钟被关闭时的处理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5、hrtimer"><span class="nav-number">5.</span> <span class="nav-text">5、hrtimer</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1、hrtimer的组织"><span class="nav-number">5.1.</span> <span class="nav-text">5.1、hrtimer的组织</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2、低精度模式-NOHZ-MODE-INACTIVE-NOHZ-MODE-LOWRES"><span class="nav-number">5.2.</span> <span class="nav-text">5.2、低精度模式(NOHZ_MODE_INACTIVE/NOHZ_MODE_LOWRES)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3、高精度模式-NOHZ-MODE-HIGHRES"><span class="nav-number">5.3.</span> <span class="nav-text">5.3、高精度模式(NOHZ_MODE_HIGHRES)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6、低精度timer-lowres-timer"><span class="nav-number">6.</span> <span class="nav-text">6、低精度timer(lowres timer)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1、低精度timer的组织"><span class="nav-number">6.1.</span> <span class="nav-text">6.1、低精度timer的组织</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2、低精度timer的执行路径"><span class="nav-number">6.2.</span> <span class="nav-text">6.2、低精度timer的执行路径</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考资料"><span class="nav-number">7.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">pwl999</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v6.6.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script src="/js/src/utils.js?v=6.6.0"></script>

  <script src="/js/src/motion.js?v=6.6.0"></script>



  
  


  <script src="/js/src/affix.js?v=6.6.0"></script>

  <script src="/js/src/schemes/pisces.js?v=6.6.0"></script>



  
  <script src="/js/src/scrollspy.js?v=6.6.0"></script>
<script src="/js/src/post-details.js?v=6.6.0"></script>



  


  <script src="/js/src/bootstrap.js?v=6.6.0"></script>



  

  
    <script id="dsq-count-scr" src="https://.disqus.com/count.js" async></script>
  

  
    <script>
      var disqus_config = function () {
        this.page.url = "http://yoursite.com/2018/12/21/linux_time/";
        this.page.identifier = "2018/12/21/linux_time/";
        this.page.title = 'Linux Time';
        };
      function loadComments () {
        var d = document, s = d.createElement('script');
        s.src = 'https://.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      }
      
        loadComments();
      
    </script>
  





  











  





  

  

  

  

  

  
  

  

  

  

  

  

  

</body>
</html>
