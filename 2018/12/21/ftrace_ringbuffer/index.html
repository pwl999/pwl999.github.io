<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
































<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.6.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.6.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.6.0" color="#222">









<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.6.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="1、简介ringbuffer是trace框架的一个基础，所有的trace原始数据都是通过ringbuffer记录的。ringbuffer的作用主要有几个：  1、存储在内存中，速度非常快，对系统性能的影响降到了最低； 2、ring结构，循环写。可以很安全的使用又不浪费内存，能够get到最新的trace信息；  但是，难点并不在这。真正的难点是系统会在常规上下文、中断(NMI、IRQ、SOFTIRQ">
<meta name="keywords" content="ringbuffer">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux Ftrace 1.1、ring buffer">
<meta property="og:url" content="http://yoursite.com/2018/12/21/ftrace_ringbuffer/index.html">
<meta property="og:site_name" content="pwl999&#39;s blog">
<meta property="og:description" content="1、简介ringbuffer是trace框架的一个基础，所有的trace原始数据都是通过ringbuffer记录的。ringbuffer的作用主要有几个：  1、存储在内存中，速度非常快，对系统性能的影响降到了最低； 2、ring结构，循环写。可以很安全的使用又不浪费内存，能够get到最新的trace信息；  但是，难点并不在这。真正的难点是系统会在常规上下文、中断(NMI、IRQ、SOFTIRQ">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/images/ftrace_ringbuffer/ringbuffer_frame.png">
<meta property="og:image" content="http://yoursite.com/images/ftrace_ringbuffer/ringbuffer_calc_event_timestamp.png">
<meta property="og:image" content="http://yoursite.com/images/ftrace_ringbuffer/ringbuffer_event_timestamp_nestwrite.png">
<meta property="og:updated_time" content="2018-12-21T03:25:21.572Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Linux Ftrace 1.1、ring buffer">
<meta name="twitter:description" content="1、简介ringbuffer是trace框架的一个基础，所有的trace原始数据都是通过ringbuffer记录的。ringbuffer的作用主要有几个：  1、存储在内存中，速度非常快，对系统性能的影响降到了最低； 2、ring结构，循环写。可以很安全的使用又不浪费内存，能够get到最新的trace信息；  但是，难点并不在这。真正的难点是系统会在常规上下文、中断(NMI、IRQ、SOFTIRQ">
<meta name="twitter:image" content="http://yoursite.com/images/ftrace_ringbuffer/ringbuffer_frame.png">






  <link rel="canonical" href="http://yoursite.com/2018/12/21/ftrace_ringbuffer/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Linux Ftrace 1.1、ring buffer | pwl999's blog</title>
  












  <noscript>
  <style>
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion .logo-line-before i { left: initial; }
    .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">pwl999's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/21/ftrace_ringbuffer/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="pwl999">
      <meta itemprop="description" content="RTFSC(Read The Fucking Source Code)">
      <meta itemprop="image" content="/images/touxiang/ycqs.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="pwl999's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Linux Ftrace 1.1、ring buffer

              
            
          </h1>
        

        <div class="post-meta">

          

        <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-21 10:18:21 / 修改时间：11:25:21" itemprop="dateCreated datePublished" datetime="2018-12-21T10:18:21+08:00">2018-12-21</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/Trace/" itemprop="url" rel="index"><span itemprop="name">Trace</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h1><p>ringbuffer是trace框架的一个基础，所有的trace原始数据都是通过ringbuffer记录的。ringbuffer的作用主要有几个：</p>
<ul>
<li>1、存储在内存中，速度非常快，对系统性能的影响降到了最低；</li>
<li>2、ring结构，循环写。可以很安全的使用又不浪费内存，能够get到最新的trace信息；</li>
</ul>
<p>但是，难点并不在这。<strong>真正的难点</strong>是系统会在常规上下文、中断(NMI、IRQ、SOFTIRQ)等各种场景下都会发生trace，怎么样能既不影响系统的逻辑，又能处理好相互之间的互斥把trace的架构组织好。如果对这部分非常感兴趣可以直接跳转到 <a href="#设计思想">第5章 ringbuffer的设计思想</a> 进行学习。</p>
<h1 id="2、ringbuffer初始化"><a href="#2、ringbuffer初始化" class="headerlink" title="2、ringbuffer初始化"></a>2、ringbuffer初始化</h1><p><img src="/images/ftrace_ringbuffer/ringbuffer_frame.png" alt="image"></p>
<p>上图是ringbuffer的组织结构顶级视图，可以看到以下信息：</p>
<ul>
<li>1、struct ring_buffer在每个cpu上有独立的struct ring_buffer_per_cpu数据结构；</li>
<li>2、struct ring_buffer_per_cpu根据定义size的大小，分配page空间，并把page链成环形结构，这就是“ring”的概念；</li>
<li>3、struct buffer_page是一个控制结构；struct buffer_data_page才是一个实际的page，除了开头的两个控制字段time_stamp、commit，其他空间都是用来存储数据的；数据使用struct ring_buffer_event来存储，其在包头中还存储了时间戳、长度/类型信息；</li>
<li>4、struct ring_buffer_per_cpu中使用head_page(读)、commit_page(写确认)、tail_page(写)三种指针来管理page ring；同理buffer_page-&gt;read(读)、buffer_page-&gt;write(写)、buffer_data_page-&gt;commit(写确认)用来描述page内的偏移指针；</li>
<li>5、ring_buffer_per_cpu-&gt;reader_page中还包含了一个独立的page，用来支持reader方式的读操作；</li>
</ul>
<p>初始化的主要工作就是分配page空间，并且初始化各个控制字段。</p>
<p>start_kernel() -&gt; trace_init() -&gt; tracer_alloc_buffers() -&gt; allocate_trace_buffers() -&gt; allocate_trace_buffer() -&gt; ring_buffer_alloc() -&gt; __ring_buffer_alloc()：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line">struct ring_buffer *__ring_buffer_alloc(unsigned long size, unsigned flags,</span><br><span class="line">					struct lock_class_key *key)</span><br><span class="line">&#123;</span><br><span class="line">	struct ring_buffer *buffer;</span><br><span class="line">	long nr_pages;</span><br><span class="line">	int bsize;</span><br><span class="line">	int cpu;</span><br><span class="line"></span><br><span class="line">    /* (1) 分配ring_buffer数据结构 */</span><br><span class="line">	/* keep it in its own cache line */</span><br><span class="line">	buffer = kzalloc(ALIGN(sizeof(*buffer), cache_line_size()),</span><br><span class="line">			 GFP_KERNEL);</span><br><span class="line">	if (!buffer)</span><br><span class="line">		return NULL;</span><br><span class="line"></span><br><span class="line">	if (!alloc_cpumask_var(&amp;buffer-&gt;cpumask, GFP_KERNEL))</span><br><span class="line">		goto fail_free_buffer;</span><br><span class="line"></span><br><span class="line">	nr_pages = DIV_ROUND_UP(size, BUF_PAGE_SIZE);</span><br><span class="line">	</span><br><span class="line">	/* (1.1) 初始化ring_buffer的控制成员：</span><br><span class="line">	 -&gt;flags = flags</span><br><span class="line">	 -&gt;clock = 时间戳的时钟源</span><br><span class="line">	*/</span><br><span class="line">	buffer-&gt;flags = flags;</span><br><span class="line">	buffer-&gt;clock = trace_clock_local;</span><br><span class="line">	buffer-&gt;reader_lock_key = key;</span><br><span class="line"></span><br><span class="line">	init_irq_work(&amp;buffer-&gt;irq_work.work, rb_wake_up_waiters);</span><br><span class="line">	init_waitqueue_head(&amp;buffer-&gt;irq_work.waiters);</span><br><span class="line"></span><br><span class="line">	/* need at least two pages */</span><br><span class="line">	if (nr_pages &lt; 2)</span><br><span class="line">		nr_pages = 2;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * In case of non-hotplug cpu, if the ring-buffer is allocated</span><br><span class="line">	 * in early initcall, it will not be notified of secondary cpus.</span><br><span class="line">	 * In that off case, we need to allocate for all possible cpus.</span><br><span class="line">	 */</span><br><span class="line">	/* (1.2) 初始化ring_buffer的控制成员：</span><br><span class="line">	 -&gt;cpumask = online cpu的map</span><br><span class="line">	 -&gt;cpus = cpu个数</span><br><span class="line">	*/</span><br><span class="line">#ifdef CONFIG_HOTPLUG_CPU</span><br><span class="line">	cpu_notifier_register_begin();</span><br><span class="line">	cpumask_copy(buffer-&gt;cpumask, cpu_online_mask);</span><br><span class="line">#else</span><br><span class="line">	cpumask_copy(buffer-&gt;cpumask, cpu_possible_mask);</span><br><span class="line">#endif</span><br><span class="line">	buffer-&gt;cpus = nr_cpu_ids;</span><br><span class="line"></span><br><span class="line">	bsize = sizeof(void *) * nr_cpu_ids;</span><br><span class="line">	buffer-&gt;buffers = kzalloc(ALIGN(bsize, cache_line_size()),</span><br><span class="line">				  GFP_KERNEL);</span><br><span class="line">	if (!buffer-&gt;buffers)</span><br><span class="line">		goto fail_free_cpumask;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /* (2) 分配每cpu的ring_buffer_per_cpu结构 */</span><br><span class="line">	for_each_buffer_cpu(buffer, cpu) &#123;</span><br><span class="line">		buffer-&gt;buffers[cpu] =</span><br><span class="line">			rb_allocate_cpu_buffer(buffer, nr_pages, cpu);</span><br><span class="line">		if (!buffer-&gt;buffers[cpu])</span><br><span class="line">			goto fail_free_buffers;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (3) 注册cpu的hotplug回调函数：</span><br><span class="line">        主要作用是在cpu up时，如果没有分配ring_buffer_per_cpu，则重新分配</span><br><span class="line">        在cpu down时并不会释放ring_buffer_per_cpu空间</span><br><span class="line">     */</span><br><span class="line">#ifdef CONFIG_HOTPLUG_CPU</span><br><span class="line">	buffer-&gt;cpu_notify.notifier_call = rb_cpu_notify;</span><br><span class="line">	buffer-&gt;cpu_notify.priority = 0;</span><br><span class="line">	__register_cpu_notifier(&amp;buffer-&gt;cpu_notify);</span><br><span class="line">	cpu_notifier_register_done();</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	mutex_init(&amp;buffer-&gt;mutex);</span><br><span class="line"></span><br><span class="line">	return buffer;</span><br><span class="line"></span><br><span class="line"> fail_free_buffers:</span><br><span class="line">	for_each_buffer_cpu(buffer, cpu) &#123;</span><br><span class="line">		if (buffer-&gt;buffers[cpu])</span><br><span class="line">			rb_free_cpu_buffer(buffer-&gt;buffers[cpu]);</span><br><span class="line">	&#125;</span><br><span class="line">	kfree(buffer-&gt;buffers);</span><br><span class="line"></span><br><span class="line"> fail_free_cpumask:</span><br><span class="line">	free_cpumask_var(buffer-&gt;cpumask);</span><br><span class="line">#ifdef CONFIG_HOTPLUG_CPU</span><br><span class="line">	cpu_notifier_register_done();</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"> fail_free_buffer:</span><br><span class="line">	kfree(buffer);</span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">static struct ring_buffer_per_cpu *</span><br><span class="line">rb_allocate_cpu_buffer(struct ring_buffer *buffer, long nr_pages, int cpu)</span><br><span class="line">&#123;</span><br><span class="line">	struct ring_buffer_per_cpu *cpu_buffer;</span><br><span class="line">	struct buffer_page *bpage;</span><br><span class="line">	struct page *page;</span><br><span class="line">	int ret;</span><br><span class="line"></span><br><span class="line">    /* (2.1) 分配ring_buffer_per_cpu的结构空间 */</span><br><span class="line">	cpu_buffer = kzalloc_node(ALIGN(sizeof(*cpu_buffer), cache_line_size()),</span><br><span class="line">				  GFP_KERNEL, cpu_to_node(cpu));</span><br><span class="line">	if (!cpu_buffer)</span><br><span class="line">		return NULL;</span><br><span class="line"></span><br><span class="line">	cpu_buffer-&gt;cpu = cpu;</span><br><span class="line">	cpu_buffer-&gt;buffer = buffer;</span><br><span class="line">	raw_spin_lock_init(&amp;cpu_buffer-&gt;reader_lock);</span><br><span class="line">	lockdep_set_class(&amp;cpu_buffer-&gt;reader_lock, buffer-&gt;reader_lock_key);</span><br><span class="line">	cpu_buffer-&gt;lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;</span><br><span class="line">	INIT_WORK(&amp;cpu_buffer-&gt;update_pages_work, update_pages_handler);</span><br><span class="line">	init_completion(&amp;cpu_buffer-&gt;update_done);</span><br><span class="line">	init_irq_work(&amp;cpu_buffer-&gt;irq_work.work, rb_wake_up_waiters);</span><br><span class="line">	init_waitqueue_head(&amp;cpu_buffer-&gt;irq_work.waiters);</span><br><span class="line">	init_waitqueue_head(&amp;cpu_buffer-&gt;irq_work.full_waiters);</span><br><span class="line"></span><br><span class="line">	bpage = kzalloc_node(ALIGN(sizeof(*bpage), cache_line_size()),</span><br><span class="line">			    GFP_KERNEL, cpu_to_node(cpu));</span><br><span class="line">	if (!bpage)</span><br><span class="line">		goto fail_free_buffer;</span><br><span class="line"></span><br><span class="line">	rb_check_bpage(cpu_buffer, bpage);</span><br><span class="line"></span><br><span class="line">    /* (2.2) 分配reader_page对应的buffer_page和buffer_data_page */</span><br><span class="line">	cpu_buffer-&gt;reader_page = bpage;</span><br><span class="line">	page = alloc_pages_node(cpu_to_node(cpu), GFP_KERNEL, 0);</span><br><span class="line">	if (!page)</span><br><span class="line">		goto fail_free_reader;</span><br><span class="line">	bpage-&gt;page = page_address(page);</span><br><span class="line">	rb_init_page(bpage-&gt;page);</span><br><span class="line"></span><br><span class="line">	INIT_LIST_HEAD(&amp;cpu_buffer-&gt;reader_page-&gt;list);</span><br><span class="line">	INIT_LIST_HEAD(&amp;cpu_buffer-&gt;new_pages);</span><br><span class="line"></span><br><span class="line">    /* (2.3) 分配核心的ring buffer对应的page空间 */</span><br><span class="line">	ret = rb_allocate_pages(cpu_buffer, nr_pages);</span><br><span class="line">	if (ret &lt; 0)</span><br><span class="line">		goto fail_free_reader;</span><br><span class="line"></span><br><span class="line">    /* (2.4) 初始化ring page的三大指针：head_page、commit_page、tail_page </span><br><span class="line">        都指向起始page</span><br><span class="line">     */</span><br><span class="line">	cpu_buffer-&gt;head_page</span><br><span class="line">		= list_entry(cpu_buffer-&gt;pages, struct buffer_page, list);</span><br><span class="line">	cpu_buffer-&gt;tail_page = cpu_buffer-&gt;commit_page = cpu_buffer-&gt;head_page;</span><br><span class="line"></span><br><span class="line">    /* (2.5) 初始化ring page中指向head page的上一个page，指向head page的指针</span><br><span class="line">        将指针设置RB_PAGE_HEAD标志，标明head page的位置</span><br><span class="line">     */</span><br><span class="line">	rb_head_page_activate(cpu_buffer);</span><br><span class="line"></span><br><span class="line">	return cpu_buffer;</span><br><span class="line"></span><br><span class="line"> fail_free_reader:</span><br><span class="line">	free_buffer_page(cpu_buffer-&gt;reader_page);</span><br><span class="line"></span><br><span class="line"> fail_free_buffer:</span><br><span class="line">	kfree(cpu_buffer);</span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3、ringbuffer的写操作"><a href="#3、ringbuffer的写操作" class="headerlink" title="3、ringbuffer的写操作"></a>3、ringbuffer的写操作</h1><p>从ring buffer的设计思想上看，为了支持“nested-write”嵌套写的免锁操作，引入了commit的概念。原理见<a href="#commit_page">commit page</a> 一节的描述。</p>
<p>所以ringbuffer的写操作分成以下几步：</p>
<ul>
<li>1、writer使用ring_buffer_lock_reserve()函数移动tail指针，得到需要的空间；</li>
<li>2、writer操作得到的ring buffer空间，写数据；</li>
<li>3、writer使用ring_buffer_unlock_commit()函数确认数据的写入完成，如果是高优先级抢占其他人的writer会成为pending_commit，只有优先级最低的writer完成full commit并且移动comit指针；</li>
<li>4、writer使用ring_buffer_discard_commit()函数丢弃数据。丢弃的方法有两种：1、首先尝试回滚tail指针回收空间；2、如果无法回滚则把数据类型设置为padding再正常的commit，这种空间相当于浪费掉。</li>
</ul>
<p>这些操作当中，有两件事需要注意：一是ring_buffer_event的存储格式，二是ring_buffer_event时间戳的计算；</p>
<h2 id="3-1、ring-buffer-event的存储格式"><a href="#3-1、ring-buffer-event的存储格式" class="headerlink" title="3.1、ring_buffer_event的存储格式"></a>3.1、ring_buffer_event的存储格式</h2><p>writer在ring buffer的page中分配空间，在用户数据之前加了一个ring_buffer_event来进行管理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct ring_buffer_event &#123;</span><br><span class="line">	kmemcheck_bitfield_begin(bitfield);</span><br><span class="line">	u32		type_len:5, time_delta:27;</span><br><span class="line">	kmemcheck_bitfield_end(bitfield);</span><br><span class="line"></span><br><span class="line">	u32		array[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>“type_len:5, time_delta:27”为控制结构，在最小情况下占用32bit的空间，表示type、len、time_delta三种信息。</p>
<p>其中前5bit type_len，在不同情况下表示type或者len：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">enum ring_buffer_type &#123;</span><br><span class="line">	RINGBUF_TYPE_DATA_TYPE_LEN_MAX = 28,</span><br><span class="line">	RINGBUF_TYPE_PADDING,</span><br><span class="line">	RINGBUF_TYPE_TIME_EXTEND,</span><br><span class="line">	/* FIXME: RINGBUF_TYPE_TIME_STAMP not implemented */</span><br><span class="line">	RINGBUF_TYPE_TIME_STAMP,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>综合不同情况的列表如下：</p>
<table border="1"><br><caption> type_len解析 </caption><br><br><tr><br><th style="width: 50px;">type_len(5bit)</th><br><th style="width: 50px;">time_delta(27bit)</th><br><th style="width: 50px;">array<a href="32bit">0</a></th><br><th style="width: 50px;">type</th><br><th style="width: 50px;">len</th><br><th style="width: 50px;">time_delta</th><br><th style="width: 400px;">说明</th><br></tr><br><br><tr><br><td> 0 </td><br><td> - </td><br><td> 存放len </td><br><td> Data record </td><br><td><br>len = sizeof(array[])，存放在array[0]中<br></td><br><td><br>-<br></td><br><td><br>因为type_len只有5bit，其中分配给表示数据长度的数值只有(0-28)，数据默认是4byte对齐的，所以type_len能表示的最大数据长度为28<em>4=112bytes。<br><br>即：#define RB_MAX_SMALL_DATA    (RB_ALIGNMENT </em> RINGBUF_TYPE_DATA_TYPE_LEN_MAX)<br><br><br>在len &gt; RB_MAX_SMALL_DATA的情况下，使用array[0]来存放长度，这种情况下type_len=0。<br></td><br></tr><br><br><tr><br><td> 1 - 28 </td><br><td> - </td><br><td> - </td><br><td> Data record </td><br><td><br>len = sizeof(array[])，存放在type_len中，len = type_len &lt;&lt; 2<br></td><br><td><br>-<br></td><br><td><br>在len &lt;= RB_MAX_SMALL_DATA的情况下，使用type_len来存放长度。<br></td><br></tr><br><br><tr><br><td> 29(RINGBUF_TYPE_PADDING) </td><br><td> 0 </td><br><td> - </td><br><td> Padding </td><br><td><br>len variable<br></td><br><td><br>-<br></td><br><td><br>Padding类型指的是ringbuffer数据空间分配以后，没有使用被废弃了。<br><br><br>If time_delta is 0: <br><br>    array is ignored，size is variable depending on how much padding is needed<br></td><br></tr><br><br><tr><br><td> 29(RINGBUF_TYPE_PADDING) </td><br><td> &gt;0 </td><br><td> 存放len </td><br><td> Padding </td><br><td><br>len = sizeof(array[])，存放在array[0]中<br></td><br><td><br>-<br></td><br><td><br>Padding类型指的是ringbuffer数据空间分配以后，没有使用被废弃了。<br><br><br>If time_delta is non zero: <br><br>    array[0] holds the actual length<br></td><br></tr><br><br><tr><br><td> 30(RINGBUF_TYPE_TIME_EXTEND) </td><br><td> 存放time_delta的0-27bit </td><br><td> 存放time_delta的28-59bit </td><br><td> Time Extened </td><br><td><br>len = sizeof(array[])。只有一个array[0]，array[]长度固定为4。<br></td><br><td><br>delta = (array[0] &lt;&lt; 28) + time_delta<br></td><br><td><br>因为time_delta只有27bit，所以普通“Data record”类型event能表达的最大时间差为2^27ns。<br><br><br>如果时间差超过2^27ns，需要定义一个专门的“Time Extened”event来记录时间差，其利用array[0]来记录time_delta的28-59bit，总共60bit能满足用户时间差的需求。<br><br>该event固定长度为8.<br><br></td><br></tr><br><br></table>


<h2 id="3-2、ring-buffer-event时间戳"><a href="#3-2、ring-buffer-event时间戳" class="headerlink" title="3.2、ring_buffer_event时间戳"></a>3.2、ring_buffer_event时间戳</h2><p>ring buffer不但记录了event数据，默认他还给每个event记录加上了时间戳信息。同时为了节约空间，没有记录绝对时间戳，而只是记录相对上一个event的时间差。在每个struct buffer_data_page的开头，都记录了该page第一个commit的绝对时间戳。</p>
<p>那么计算page中event(n)的绝对时间戳 = page-&gt;time_stamp + event0-&gt;time_delta +  event1-&gt;time_delta + … +  event(n-1)-&gt;time_delta:</p>
<p><img src="/images/ftrace_ringbuffer/ringbuffer_calc_event_timestamp.png" alt="image"></p>
<p>在计算event时间差时，是以一次full commit为单位的。如果发生了“nested-write”，那么这次full commit中多次write分配的event的时间差，最后都为0：</p>
<p><img src="/images/ftrace_ringbuffer/ringbuffer_event_timestamp_nestwrite.png" alt="image"></p>
<h2 id="3-3、ring-buffer-event写入流程"><a href="#3-3、ring-buffer-event写入流程" class="headerlink" title="3.3、ring_buffer_event写入流程"></a>3.3、ring_buffer_event写入流程</h2><h3 id="3-3-1、ring-buffer-lock-reserve"><a href="#3-3-1、ring-buffer-lock-reserve" class="headerlink" title="3.3.1、ring_buffer_lock_reserve()"></a>3.3.1、ring_buffer_lock_reserve()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br></pre></td><td class="code"><pre><span class="line">struct ring_buffer_event *</span><br><span class="line">ring_buffer_lock_reserve(struct ring_buffer *buffer, unsigned long length)</span><br><span class="line">&#123;</span><br><span class="line">	struct ring_buffer_per_cpu *cpu_buffer;</span><br><span class="line">	struct ring_buffer_event *event;</span><br><span class="line">	int cpu;</span><br><span class="line"></span><br><span class="line">    /* (1) 关闭抢占，那么接下来的操作只有中断才能打断了 */</span><br><span class="line">	/* If we are tracing schedule, we don&apos;t want to recurse */</span><br><span class="line">	preempt_disable_notrace();</span><br><span class="line"></span><br><span class="line">    /* (2) 如果ring_buffer被disable，出错返回 */</span><br><span class="line">	if (unlikely(atomic_read(&amp;buffer-&gt;record_disabled)))</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">	cpu = raw_smp_processor_id();</span><br><span class="line"></span><br><span class="line">	if (unlikely(!cpumask_test_cpu(cpu, buffer-&gt;cpumask)))</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">    /* (3) 得到本cpu对应的ring_buffer_per_cpu结构 */</span><br><span class="line">	cpu_buffer = buffer-&gt;buffers[cpu];</span><br><span class="line"></span><br><span class="line">    /* (4) 如果ring_buffer_per_cpu被disable，出错返回 */</span><br><span class="line">	if (unlikely(atomic_read(&amp;cpu_buffer-&gt;record_disabled)))</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">    /* (5) 如果申请的空间长度大于一个ringbuffer底层的一个page，出错返回 */</span><br><span class="line">	if (unlikely(length &gt; BUF_MAX_DATA_SIZE))</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">    /* (6) 禁止同优先级运行环境的递归重入 */</span><br><span class="line">	if (unlikely(trace_recursive_lock(cpu_buffer)))</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">    /* (7) 从per_cpubuffer中申请数据 */</span><br><span class="line">	event = rb_reserve_next_event(buffer, cpu_buffer, length);</span><br><span class="line">	if (!event)</span><br><span class="line">		goto out_unlock;</span><br><span class="line"></span><br><span class="line">	return event;</span><br><span class="line"></span><br><span class="line"> out_unlock:</span><br><span class="line">	trace_recursive_unlock(cpu_buffer);</span><br><span class="line"> out:</span><br><span class="line">	preempt_enable_notrace();</span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">static struct ring_buffer_event *</span><br><span class="line">rb_reserve_next_event(struct ring_buffer *buffer,</span><br><span class="line">		      struct ring_buffer_per_cpu *cpu_buffer,</span><br><span class="line">		      unsigned long length)</span><br><span class="line">&#123;</span><br><span class="line">	struct ring_buffer_event *event;</span><br><span class="line">	struct rb_event_info info;</span><br><span class="line">	int nr_loops = 0;</span><br><span class="line">	u64 diff;</span><br><span class="line"></span><br><span class="line">    /* (7.1) 增加cpu_buffer-&gt;commits、cpu_buffer-&gt;committing的计数 </span><br><span class="line">        在commit的时候用committing计数来判断：</span><br><span class="line">        ==1，当前是最外层的writer，做full commit移动commit指针到tail</span><br><span class="line">        &gt;1，当前是抢占writer，只能pending commit，同时把committing计数减一</span><br><span class="line">     */</span><br><span class="line">	rb_start_commit(cpu_buffer);</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_RING_BUFFER_ALLOW_SWAP</span><br><span class="line">	/*</span><br><span class="line">	 * Due to the ability to swap a cpu buffer from a buffer</span><br><span class="line">	 * it is possible it was swapped before we committed.</span><br><span class="line">	 * (committing stops a swap). We check for it here and</span><br><span class="line">	 * if it happened, we have to fail the write.</span><br><span class="line">	 */</span><br><span class="line">	barrier();</span><br><span class="line">	if (unlikely(ACCESS_ONCE(cpu_buffer-&gt;buffer) != buffer)) &#123;</span><br><span class="line">		local_dec(&amp;cpu_buffer-&gt;committing);</span><br><span class="line">		local_dec(&amp;cpu_buffer-&gt;commits);</span><br><span class="line">		return NULL;</span><br><span class="line">	&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    /* (7.2) 计算加上ring_buffer_event控制结构以后，数据的总长度 */</span><br><span class="line">	info.length = rb_calculate_event_length(length);</span><br><span class="line"> again:</span><br><span class="line">	info.add_timestamp = 0;</span><br><span class="line">	info.delta = 0;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * We allow for interrupts to reenter here and do a trace.</span><br><span class="line">	 * If one does, it will cause this original code to loop</span><br><span class="line">	 * back here. Even with heavy interrupts happening, this</span><br><span class="line">	 * should only happen a few times in a row. If this happens</span><br><span class="line">	 * 1000 times in a row, there must be either an interrupt</span><br><span class="line">	 * storm or we have something buggy.</span><br><span class="line">	 * Bail!</span><br><span class="line">	 */</span><br><span class="line">	if (RB_WARN_ON(cpu_buffer, ++nr_loops &gt; 1000))</span><br><span class="line">		goto out_fail;</span><br><span class="line"></span><br><span class="line">    /* (7.3) 获取当前event的时间戳，并计算和write_stamp之间的时间差值，</span><br><span class="line">        write_stamp是上一个full commit的时间戳。</span><br><span class="line">        系统是以full commit作为一个时间戳的，如果一次nested-write分配了多个event，</span><br><span class="line">        那么这些event共享同一个时间戳，除了第一个event，后面event的time_delta都为0。</span><br><span class="line">     */</span><br><span class="line">	info.ts = rb_time_stamp(cpu_buffer-&gt;buffer);</span><br><span class="line">	diff = info.ts - cpu_buffer-&gt;write_stamp;</span><br><span class="line"></span><br><span class="line">	/* make sure this diff is calculated here */</span><br><span class="line">	barrier();</span><br><span class="line"></span><br><span class="line">	/* Did the write stamp get updated already? */</span><br><span class="line">	if (likely(info.ts &gt;= cpu_buffer-&gt;write_stamp)) &#123;</span><br><span class="line">		info.delta = diff;</span><br><span class="line">		/* (7.4) 如果时间差大于2^27ns，需要增加一个time extend类型的event来存储时间差 </span><br><span class="line">		    设置info.add_timestamp = 1</span><br><span class="line">		 */</span><br><span class="line">		if (unlikely(test_time_stamp(info.delta)))</span><br><span class="line">			rb_handle_timestamp(cpu_buffer, &amp;info);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (7.5) 继续尝试分配event空间 */</span><br><span class="line">	event = __rb_reserve_next(cpu_buffer, &amp;info);</span><br><span class="line"></span><br><span class="line">	if (unlikely(PTR_ERR(event) == -EAGAIN)) &#123;</span><br><span class="line">		if (info.add_timestamp)</span><br><span class="line">			info.length -= RB_LEN_TIME_EXTEND;</span><br><span class="line">		goto again;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (!event)</span><br><span class="line">		goto out_fail;</span><br><span class="line"></span><br><span class="line">	return event;</span><br><span class="line"></span><br><span class="line"> out_fail:</span><br><span class="line">	rb_end_commit(cpu_buffer);</span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">||→</span><br><span class="line"></span><br><span class="line">static unsigned rb_calculate_event_length(unsigned length)</span><br><span class="line">&#123;</span><br><span class="line">	struct ring_buffer_event event; /* Used only for sizeof array */</span><br><span class="line"></span><br><span class="line">	/* zero length can cause confusions */</span><br><span class="line">	if (!length)</span><br><span class="line">		length++;</span><br><span class="line"></span><br><span class="line">    /* (7.2.1) 如果len大于(28&lt;&lt;2)，需要使用array[0]来存储长度 */</span><br><span class="line">	if (length &gt; RB_MAX_SMALL_DATA || RB_FORCE_8BYTE_ALIGNMENT)</span><br><span class="line">		length += sizeof(event.array[0]);</span><br><span class="line"></span><br><span class="line">    /* (7.2.2) 增加event常规header的长度 */</span><br><span class="line">	length += RB_EVNT_HDR_SIZE;</span><br><span class="line">	/* (7.2.3) 默认4字节长度对齐 */</span><br><span class="line">	length = ALIGN(length, RB_ARCH_ALIGNMENT);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * In case the time delta is larger than the 27 bits for it</span><br><span class="line">	 * in the header, we need to add a timestamp. If another</span><br><span class="line">	 * event comes in when trying to discard this one to increase</span><br><span class="line">	 * the length, then the timestamp will be added in the allocated</span><br><span class="line">	 * space of this event. If length is bigger than the size needed</span><br><span class="line">	 * for the TIME_EXTEND, then padding has to be used. The events</span><br><span class="line">	 * length must be either RB_LEN_TIME_EXTEND, or greater than or equal</span><br><span class="line">	 * to RB_LEN_TIME_EXTEND + 8, as 8 is the minimum size for padding.</span><br><span class="line">	 * As length is a multiple of 4, we only need to worry if it</span><br><span class="line">	 * is 12 (RB_LEN_TIME_EXTEND + 4).</span><br><span class="line">	 */</span><br><span class="line">	if (length == RB_LEN_TIME_EXTEND + RB_ALIGNMENT)</span><br><span class="line">		length += RB_ALIGNMENT;</span><br><span class="line"></span><br><span class="line">	return length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">||→</span><br><span class="line"></span><br><span class="line">static struct ring_buffer_event *</span><br><span class="line">__rb_reserve_next(struct ring_buffer_per_cpu *cpu_buffer,</span><br><span class="line">		  struct rb_event_info *info)</span><br><span class="line">&#123;</span><br><span class="line">	struct ring_buffer_event *event;</span><br><span class="line">	struct buffer_page *tail_page;</span><br><span class="line">	unsigned long tail, write;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * If the time delta since the last event is too big to</span><br><span class="line">	 * hold in the time field of the event, then we append a</span><br><span class="line">	 * TIME EXTEND event ahead of the data event.</span><br><span class="line">	 */</span><br><span class="line">	/* (7.5.1) 如果需要增加time extend event，增加8字节长度 */</span><br><span class="line">	if (unlikely(info-&gt;add_timestamp))</span><br><span class="line">		info-&gt;length += RB_LEN_TIME_EXTEND;</span><br><span class="line"></span><br><span class="line">    /* (7.5.2) 使用原子操作，快速从tail指针中保留出需要的长度 </span><br><span class="line">        这里有个异常需要处理，如果本page空间不够，需要向后找新的page，这里&gt;BUF_PAGE_SIZE的tail指针需要回滚</span><br><span class="line">     */</span><br><span class="line">	tail_page = info-&gt;tail_page = cpu_buffer-&gt;tail_page;</span><br><span class="line">	write = local_add_return(info-&gt;length, &amp;tail_page-&gt;write);</span><br><span class="line"></span><br><span class="line">	/* set write to only the index of the write */</span><br><span class="line">	write &amp;= RB_WRITE_MASK;</span><br><span class="line">	tail = write - info-&gt;length;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * If this is the first commit on the page, then it has the same</span><br><span class="line">	 * timestamp as the page itself.</span><br><span class="line">	 */</span><br><span class="line">	/* (7.5.3) page中第一个event的time_delta赋值为0，</span><br><span class="line">	    直接使用page-&gt;time_stamp</span><br><span class="line">	 */</span><br><span class="line">	if (!tail)</span><br><span class="line">		info-&gt;delta = 0;</span><br><span class="line"></span><br><span class="line">	/* See if we shot pass the end of this buffer page */</span><br><span class="line">	/* (7.5.4) 不允许分配的空间跨越两个page， </span><br><span class="line">	    如果本page的空间不足，向后寻找新的page</span><br><span class="line">	 */</span><br><span class="line">	if (unlikely(write &gt; BUF_PAGE_SIZE))</span><br><span class="line">		return rb_move_tail(cpu_buffer, tail, info);</span><br><span class="line"></span><br><span class="line">	/* We reserved something on the buffer */</span><br><span class="line">    </span><br><span class="line">    /* (7.5.5) 成功获取到event空间 */</span><br><span class="line">	event = __rb_page_index(tail_page, tail);</span><br><span class="line">	kmemcheck_annotate_bitfield(event, bitfield);</span><br><span class="line">	</span><br><span class="line">	/* (7.5.6) 更新ring_buffer_event中的type_len、time_delta字段 */</span><br><span class="line">	rb_update_event(cpu_buffer, event, info);</span><br><span class="line"></span><br><span class="line">    /* (7.5.7) 增加page中的event技术 */</span><br><span class="line">	local_inc(&amp;tail_page-&gt;entries);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * If this is the first commit on the page, then update</span><br><span class="line">	 * its timestamp.</span><br><span class="line">	 */</span><br><span class="line">	/* (7.5.8) 如果是page中第一个event， </span><br><span class="line">	    使用event-&gt;time_stamp更新page-&gt;time_stamp</span><br><span class="line">	 */</span><br><span class="line">	if (!tail)</span><br><span class="line">		tail_page-&gt;page-&gt;time_stamp = info-&gt;ts;</span><br><span class="line"></span><br><span class="line">	/* account for these added bytes */</span><br><span class="line">	/* (7.5.9) 更新ring_buffer_per_cpu中的有效event数据计数 */</span><br><span class="line">	local_add(info-&gt;length, &amp;cpu_buffer-&gt;entries_bytes);</span><br><span class="line"></span><br><span class="line">	return event;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|||→</span><br></pre></td></tr></table></figure>
<p>rb_move_tail()是理解复杂无锁指针操作的核心函数，但是已经没有兴趣和心情继续仔细分析了。大的原理上已无问题，后面有需要再仔细分析吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">static noinline struct ring_buffer_event *</span><br><span class="line">rb_move_tail(struct ring_buffer_per_cpu *cpu_buffer,</span><br><span class="line">	     unsigned long tail, struct rb_event_info *info)</span><br><span class="line">&#123;</span><br><span class="line">	struct buffer_page *tail_page = info-&gt;tail_page;</span><br><span class="line">	struct buffer_page *commit_page = cpu_buffer-&gt;commit_page;</span><br><span class="line">	struct ring_buffer *buffer = cpu_buffer-&gt;buffer;</span><br><span class="line">	struct buffer_page *next_page;</span><br><span class="line">	int ret;</span><br><span class="line">	u64 ts;</span><br><span class="line"></span><br><span class="line">	next_page = tail_page;</span><br><span class="line"></span><br><span class="line">	rb_inc_page(cpu_buffer, &amp;next_page);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * If for some reason, we had an interrupt storm that made</span><br><span class="line">	 * it all the way around the buffer, bail, and warn</span><br><span class="line">	 * about it.</span><br><span class="line">	 */</span><br><span class="line">	if (unlikely(next_page == commit_page)) &#123;</span><br><span class="line">		local_inc(&amp;cpu_buffer-&gt;commit_overrun);</span><br><span class="line">		goto out_reset;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * This is where the fun begins!</span><br><span class="line">	 *</span><br><span class="line">	 * We are fighting against races between a reader that</span><br><span class="line">	 * could be on another CPU trying to swap its reader</span><br><span class="line">	 * page with the buffer head.</span><br><span class="line">	 *</span><br><span class="line">	 * We are also fighting against interrupts coming in and</span><br><span class="line">	 * moving the head or tail on us as well.</span><br><span class="line">	 *</span><br><span class="line">	 * If the next page is the head page then we have filled</span><br><span class="line">	 * the buffer, unless the commit page is still on the</span><br><span class="line">	 * reader page.</span><br><span class="line">	 */</span><br><span class="line">	if (rb_is_head_page(cpu_buffer, next_page, &amp;tail_page-&gt;list)) &#123;</span><br><span class="line"></span><br><span class="line">		/*</span><br><span class="line">		 * If the commit is not on the reader page, then</span><br><span class="line">		 * move the header page.</span><br><span class="line">		 */</span><br><span class="line">		if (!rb_is_reader_page(cpu_buffer-&gt;commit_page)) &#123;</span><br><span class="line">			/*</span><br><span class="line">			 * If we are not in overwrite mode,</span><br><span class="line">			 * this is easy, just stop here.</span><br><span class="line">			 */</span><br><span class="line">			if (!(buffer-&gt;flags &amp; RB_FL_OVERWRITE)) &#123;</span><br><span class="line">				local_inc(&amp;cpu_buffer-&gt;dropped_events);</span><br><span class="line">				goto out_reset;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ret = rb_handle_head_page(cpu_buffer,</span><br><span class="line">						  tail_page,</span><br><span class="line">						  next_page);</span><br><span class="line">			if (ret &lt; 0)</span><br><span class="line">				goto out_reset;</span><br><span class="line">			if (ret)</span><br><span class="line">				goto out_again;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			/*</span><br><span class="line">			 * We need to be careful here too. The</span><br><span class="line">			 * commit page could still be on the reader</span><br><span class="line">			 * page. We could have a small buffer, and</span><br><span class="line">			 * have filled up the buffer with events</span><br><span class="line">			 * from interrupts and such, and wrapped.</span><br><span class="line">			 *</span><br><span class="line">			 * Note, if the tail page is also the on the</span><br><span class="line">			 * reader_page, we let it move out.</span><br><span class="line">			 */</span><br><span class="line">			if (unlikely((cpu_buffer-&gt;commit_page !=</span><br><span class="line">				      cpu_buffer-&gt;tail_page) &amp;&amp;</span><br><span class="line">				     (cpu_buffer-&gt;commit_page ==</span><br><span class="line">				      cpu_buffer-&gt;reader_page))) &#123;</span><br><span class="line">				local_inc(&amp;cpu_buffer-&gt;commit_overrun);</span><br><span class="line">				goto out_reset;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = rb_tail_page_update(cpu_buffer, tail_page, next_page);</span><br><span class="line">	if (ret) &#123;</span><br><span class="line">		/*</span><br><span class="line">		 * Nested commits always have zero deltas, so</span><br><span class="line">		 * just reread the time stamp</span><br><span class="line">		 */</span><br><span class="line">		ts = rb_time_stamp(buffer);</span><br><span class="line">		next_page-&gt;page-&gt;time_stamp = ts;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"> out_again:</span><br><span class="line"></span><br><span class="line">	rb_reset_tail(cpu_buffer, tail, info);</span><br><span class="line"></span><br><span class="line">	/* fail and let the caller try again */</span><br><span class="line">	return ERR_PTR(-EAGAIN);</span><br><span class="line"></span><br><span class="line"> out_reset:</span><br><span class="line">	/* reset write */</span><br><span class="line">	rb_reset_tail(cpu_buffer, tail, info);</span><br><span class="line"></span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-2、ring-buffer-unlock-commit"><a href="#3-3-2、ring-buffer-unlock-commit" class="headerlink" title="3.3.2、ring_buffer_unlock_commit()"></a>3.3.2、ring_buffer_unlock_commit()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line">int ring_buffer_unlock_commit(struct ring_buffer *buffer,</span><br><span class="line">			      struct ring_buffer_event *event)</span><br><span class="line">&#123;</span><br><span class="line">	struct ring_buffer_per_cpu *cpu_buffer;</span><br><span class="line">	int cpu = raw_smp_processor_id();</span><br><span class="line"></span><br><span class="line">	cpu_buffer = buffer-&gt;buffers[cpu];</span><br><span class="line"></span><br><span class="line">	rb_commit(cpu_buffer, event);</span><br><span class="line"></span><br><span class="line">	rb_wakeups(buffer, cpu_buffer);</span><br><span class="line"></span><br><span class="line">	trace_recursive_unlock(cpu_buffer);</span><br><span class="line"></span><br><span class="line">	preempt_enable_notrace();</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">static void rb_commit(struct ring_buffer_per_cpu *cpu_buffer,</span><br><span class="line">		      struct ring_buffer_event *event)</span><br><span class="line">&#123;</span><br><span class="line">	local_inc(&amp;cpu_buffer-&gt;entries);</span><br><span class="line">	/* (1) 只有full commit，才会更新write_stamp时间戳  */</span><br><span class="line">	rb_update_write_stamp(cpu_buffer, event);</span><br><span class="line">	/* (2) 只有full commit，才会更新commit指针  */</span><br><span class="line">	rb_end_commit(cpu_buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">||→</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">rb_update_write_stamp(struct ring_buffer_per_cpu *cpu_buffer,</span><br><span class="line">		      struct ring_buffer_event *event)</span><br><span class="line">&#123;</span><br><span class="line">	u64 delta;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * The event first in the commit queue updates the</span><br><span class="line">	 * time stamp.</span><br><span class="line">	 */</span><br><span class="line">	/* (1.1) 只有full commit才会更新write_stamp时间戳，</span><br><span class="line">	    中间抢占的write提交的pending commit，不会更新</span><br><span class="line">	 */</span><br><span class="line">	if (rb_event_is_commit(cpu_buffer, event)) &#123;</span><br><span class="line">		/*</span><br><span class="line">		 * A commit event that is first on a page</span><br><span class="line">		 * updates the write timestamp with the page stamp</span><br><span class="line">		 */</span><br><span class="line">		if (!rb_event_index(event))</span><br><span class="line">			cpu_buffer-&gt;write_stamp =</span><br><span class="line">				cpu_buffer-&gt;commit_page-&gt;page-&gt;time_stamp;</span><br><span class="line">		else if (event-&gt;type_len == RINGBUF_TYPE_TIME_EXTEND) &#123;</span><br><span class="line">			delta = event-&gt;array[0];</span><br><span class="line">			delta &lt;&lt;= TS_SHIFT;</span><br><span class="line">			delta += event-&gt;time_delta;</span><br><span class="line">			cpu_buffer-&gt;write_stamp += delta;</span><br><span class="line">		&#125; else</span><br><span class="line">			cpu_buffer-&gt;write_stamp += event-&gt;time_delta;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">||→</span><br><span class="line"></span><br><span class="line">static inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned long commits;</span><br><span class="line"></span><br><span class="line">	if (RB_WARN_ON(cpu_buffer,</span><br><span class="line">		       !local_read(&amp;cpu_buffer-&gt;committing)))</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line"> again:</span><br><span class="line">	commits = local_read(&amp;cpu_buffer-&gt;commits);</span><br><span class="line">	/* synchronize with interrupts */</span><br><span class="line">	barrier();</span><br><span class="line">	/* (2.1) 如果(committing==1)，说明当前是full commit</span><br><span class="line">	    只有full commit才会更新commit指针，</span><br><span class="line">	    中间抢占的write提交的pending commit，不会更新</span><br><span class="line">	 */</span><br><span class="line">	if (local_read(&amp;cpu_buffer-&gt;committing) == 1)</span><br><span class="line">		rb_set_commit_to_write(cpu_buffer);</span><br><span class="line"></span><br><span class="line">    /* (2.2) 任何一次commit都会给committing减1 */</span><br><span class="line">	local_dec(&amp;cpu_buffer-&gt;committing);</span><br><span class="line"></span><br><span class="line">	/* synchronize with interrupts */</span><br><span class="line">	barrier();</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Need to account for interrupts coming in between the</span><br><span class="line">	 * updating of the commit page and the clearing of the</span><br><span class="line">	 * committing counter.</span><br><span class="line">	 */</span><br><span class="line">	if (unlikely(local_read(&amp;cpu_buffer-&gt;commits) != commits) &amp;&amp;</span><br><span class="line">	    !local_read(&amp;cpu_buffer-&gt;committing)) &#123;</span><br><span class="line">		local_inc(&amp;cpu_buffer-&gt;committing);</span><br><span class="line">		goto again;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|||→</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">rb_set_commit_to_write(struct ring_buffer_per_cpu *cpu_buffer)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned long max_count;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * We only race with interrupts and NMIs on this CPU.</span><br><span class="line">	 * If we own the commit event, then we can commit</span><br><span class="line">	 * all others that interrupted us, since the interruptions</span><br><span class="line">	 * are in stack format (they finish before they come</span><br><span class="line">	 * back to us). This allows us to do a simple loop to</span><br><span class="line">	 * assign the commit to the tail.</span><br><span class="line">	 */</span><br><span class="line"> again:</span><br><span class="line">	max_count = cpu_buffer-&gt;nr_pages * 100;</span><br><span class="line"></span><br><span class="line">    /* (2.1.1) 逐个移动commit_page直到等于tail_page </span><br><span class="line">        把每个commit_page中的commit指针设置为和write指针一致</span><br><span class="line">     */</span><br><span class="line">	while (cpu_buffer-&gt;commit_page != cpu_buffer-&gt;tail_page) &#123;</span><br><span class="line">		if (RB_WARN_ON(cpu_buffer, !(--max_count)))</span><br><span class="line">			return;</span><br><span class="line">		if (RB_WARN_ON(cpu_buffer,</span><br><span class="line">			       rb_is_reader_page(cpu_buffer-&gt;tail_page)))</span><br><span class="line">			return;</span><br><span class="line">		local_set(&amp;cpu_buffer-&gt;commit_page-&gt;page-&gt;commit,</span><br><span class="line">			  rb_page_write(cpu_buffer-&gt;commit_page));</span><br><span class="line">		rb_inc_page(cpu_buffer, &amp;cpu_buffer-&gt;commit_page);</span><br><span class="line">		cpu_buffer-&gt;write_stamp =</span><br><span class="line">			cpu_buffer-&gt;commit_page-&gt;page-&gt;time_stamp;</span><br><span class="line">		/* add barrier to keep gcc from optimizing too much */</span><br><span class="line">		barrier();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	/* (2.1.2) 把最后一个commit_page中的commit指针设置为和write指针一致 */</span><br><span class="line">	while (rb_commit_index(cpu_buffer) !=</span><br><span class="line">	       rb_page_write(cpu_buffer-&gt;commit_page)) &#123;</span><br><span class="line"></span><br><span class="line">		local_set(&amp;cpu_buffer-&gt;commit_page-&gt;page-&gt;commit,</span><br><span class="line">			  rb_page_write(cpu_buffer-&gt;commit_page));</span><br><span class="line">		RB_WARN_ON(cpu_buffer,</span><br><span class="line">			   local_read(&amp;cpu_buffer-&gt;commit_page-&gt;page-&gt;commit) &amp;</span><br><span class="line">			   ~RB_WRITE_MASK);</span><br><span class="line">		barrier();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* again, keep gcc from optimizing */</span><br><span class="line">	barrier();</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * If an interrupt came in just after the first while loop</span><br><span class="line">	 * and pushed the tail page forward, we will be left with</span><br><span class="line">	 * a dangling commit that will never go forward.</span><br><span class="line">	 */</span><br><span class="line">	if (unlikely(cpu_buffer-&gt;commit_page != cpu_buffer-&gt;tail_page))</span><br><span class="line">		goto again;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-3、ring-buffer-discard-commit"><a href="#3-3-3、ring-buffer-discard-commit" class="headerlink" title="3.3.3、ring_buffer_discard_commit()"></a>3.3.3、ring_buffer_discard_commit()</h3><p>如果不需要分配的空间了，需要明确做丢弃操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">void ring_buffer_discard_commit(struct ring_buffer *buffer,</span><br><span class="line">				struct ring_buffer_event *event)</span><br><span class="line">&#123;</span><br><span class="line">	struct ring_buffer_per_cpu *cpu_buffer;</span><br><span class="line">	int cpu;</span><br><span class="line"></span><br><span class="line">	/* The event is discarded regardless */</span><br><span class="line">	/* (1) 将event中的数据type设置为padding */</span><br><span class="line">	rb_event_discard(event);</span><br><span class="line"></span><br><span class="line">	cpu = smp_processor_id();</span><br><span class="line">	cpu_buffer = buffer-&gt;buffers[cpu];</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * This must only be called if the event has not been</span><br><span class="line">	 * committed yet. Thus we can assume that preemption</span><br><span class="line">	 * is still disabled.</span><br><span class="line">	 */</span><br><span class="line">	RB_WARN_ON(buffer, !local_read(&amp;cpu_buffer-&gt;committing));</span><br><span class="line"></span><br><span class="line">    /* (2) 如果tail指针还没有被新用户使用，尝试回滚tail指针来进行丢弃， </span><br><span class="line">        这种方法可以节约空间</span><br><span class="line">     */</span><br><span class="line">	rb_decrement_entry(cpu_buffer, event);</span><br><span class="line">	if (rb_try_to_discard(cpu_buffer, event))</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * The commit is still visible by the reader, so we</span><br><span class="line">	 * must still update the timestamp.</span><br><span class="line">	 */</span><br><span class="line">	/* (3) 只有full commit，才会更新write_stamp时间戳  */</span><br><span class="line">	rb_update_write_stamp(cpu_buffer, event);</span><br><span class="line"> out:</span><br><span class="line">    /* (4) 只有full commit，才会更新commit指针  */</span><br><span class="line">	rb_end_commit(cpu_buffer);</span><br><span class="line"></span><br><span class="line">	trace_recursive_unlock(cpu_buffer);</span><br><span class="line"></span><br><span class="line">	preempt_enable_notrace();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4、ringbuffer的读操作"><a href="#4、ringbuffer的读操作" class="headerlink" title="4、ringbuffer的读操作"></a>4、ringbuffer的读操作</h1><p>ringbuffer支持两种形式的读操作：</p>
<ul>
<li>iterator读。这个时候会把写入操作关闭，且iterator读不会破坏ringbuffer中原有的内容，重复多次读取内容还在。这个典型的例子就是”/sys/kernel/debug/tracing/trace”文件，我们多次“cat trace”文件来读取trace，内容保持不变。这种方式的缺点也是显而易见的，会disable写入操作，只适合trace完成后，一次性读出所有trace信息；</li>
<li>reader_page swap读。在ring buffer的设计原理中，多次看到reader_page的swap操作。这个读方式本质上是为了让ring  buffer的读写能够同步进行，互不阻塞，但是缺点就是读完会破坏原有buffer中的内容。这个典型的例子就是”/sys/kernel/debug/tracing/trace_pipe”，监控程序可以在抓取trace时并行的来读取ringbuffer中的数据；</li>
</ul>
<p>关于这部分的原理也可以参考<a href="#reader">ring buffer 读</a> 这一节。</p>
<h2 id="4-1、iterator读"><a href="#4-1、iterator读" class="headerlink" title="4.1、iterator读"></a>4.1、iterator读</h2><p>参考”/sys/kernel/debug/tracing/trace”文件的读操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">	trace_create_file(&quot;trace&quot;, 0644, d_tracer,</span><br><span class="line">			  tr, &amp;tracing_fops);</span><br><span class="line">			  </span><br><span class="line">static const struct file_operations tracing_fops = &#123;</span><br><span class="line">	.open		= tracing_open,</span><br><span class="line">	.read		= seq_read,</span><br><span class="line">	.write		= tracing_write_stub,</span><br><span class="line">	.llseek		= tracing_lseek,</span><br><span class="line">	.release	= tracing_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/* (1) 初始化iterator控制结构 */</span><br><span class="line">static int tracing_open(struct inode *inode, struct file *file)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    /* (1.1) 分配iter */</span><br><span class="line">	iter = __seq_open_private(file, &amp;tracer_seq_ops, sizeof(*iter));</span><br><span class="line">	if (!iter)</span><br><span class="line">		return ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">    /* (1.2) 给每个cpu的ring_buffer_per_cpu分配对应的ring_buffer_iter */</span><br><span class="line">	iter-&gt;buffer_iter = kcalloc(nr_cpu_ids, sizeof(*iter-&gt;buffer_iter),</span><br><span class="line">				    GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">    /* (1.3) 初始化ring_buffer_iter */</span><br><span class="line">    if (iter-&gt;cpu_file == RING_BUFFER_ALL_CPUS) &#123;</span><br><span class="line">		for_each_tracing_cpu(cpu) &#123;</span><br><span class="line">			iter-&gt;buffer_iter[cpu] =</span><br><span class="line">				ring_buffer_read_prepare(iter-&gt;trace_buffer-&gt;buffer, cpu);</span><br><span class="line">		&#125;</span><br><span class="line">		ring_buffer_read_prepare_sync();</span><br><span class="line">		for_each_tracing_cpu(cpu) &#123;</span><br><span class="line">			ring_buffer_read_start(iter-&gt;buffer_iter[cpu]);</span><br><span class="line">			tracing_iter_reset(iter, cpu);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		cpu = iter-&gt;cpu_file;</span><br><span class="line">		iter-&gt;buffer_iter[cpu] =</span><br><span class="line">			ring_buffer_read_prepare(iter-&gt;trace_buffer-&gt;buffer, cpu);</span><br><span class="line">		ring_buffer_read_prepare_sync();</span><br><span class="line">		ring_buffer_read_start(iter-&gt;buffer_iter[cpu]);</span><br><span class="line">		tracing_iter_reset(iter, cpu);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* (2) 从ringbuffer中读取数据，解析到trace文件中 */</span><br><span class="line">ssize_t seq_read(struct file *file, char __user *buf, size_t size, loff_t *ppos)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    Fill:</span><br><span class="line">	/* they want more? let&apos;s try to get some more */</span><br><span class="line">	while (m-&gt;count &lt; size) &#123;</span><br><span class="line">		size_t offs = m-&gt;count;</span><br><span class="line">		loff_t next = pos;</span><br><span class="line">		</span><br><span class="line">		/* (2.1) seq的next 操作 */</span><br><span class="line">		p = m-&gt;op-&gt;next(m, p, &amp;next);</span><br><span class="line">		if (!p || IS_ERR(p)) &#123;</span><br><span class="line">			err = PTR_ERR(p);</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		/* (2.2) seq的show 操作 */</span><br><span class="line">		err = m-&gt;op-&gt;show(m, p);</span><br><span class="line">		if (seq_has_overflowed(m) || err) &#123;</span><br><span class="line">			m-&gt;count = offs;</span><br><span class="line">			if (likely(err &lt;= 0))</span><br><span class="line">				break;</span><br><span class="line">		&#125;</span><br><span class="line">		pos = next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>next()函数最后调用到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br></pre></td><td class="code"><pre><span class="line">static const struct seq_operations tracer_seq_ops = &#123;</span><br><span class="line">	.start		= s_start,</span><br><span class="line">	.next		= s_next,</span><br><span class="line">	.stop		= s_stop,</span><br><span class="line">	.show		= s_show,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static void *s_next(struct seq_file *m, void *v, loff_t *pos)</span><br><span class="line">&#123;</span><br><span class="line">	struct trace_iterator *iter = m-&gt;private;</span><br><span class="line">	int i = (int)*pos;</span><br><span class="line">	void *ent;</span><br><span class="line"></span><br><span class="line">	WARN_ON_ONCE(iter-&gt;leftover);</span><br><span class="line"></span><br><span class="line">	(*pos)++;</span><br><span class="line"></span><br><span class="line">	/* can&apos;t go backwards */</span><br><span class="line">	if (iter-&gt;idx &gt; i)</span><br><span class="line">		return NULL;</span><br><span class="line"></span><br><span class="line">	if (iter-&gt;idx &lt; 0)</span><br><span class="line">		ent = trace_find_next_entry_inc(iter);</span><br><span class="line">	else</span><br><span class="line">		ent = iter;</span><br><span class="line"></span><br><span class="line">	while (ent &amp;&amp; iter-&gt;idx &lt; i)</span><br><span class="line">		ent = trace_find_next_entry_inc(iter);</span><br><span class="line"></span><br><span class="line">	iter-&gt;pos = *pos;</span><br><span class="line"></span><br><span class="line">	return ent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">void *trace_find_next_entry_inc(struct trace_iterator *iter)</span><br><span class="line">&#123;</span><br><span class="line">    /* 读出下一个时间戳的event */</span><br><span class="line">	iter-&gt;ent = __find_next_entry(iter, &amp;iter-&gt;cpu,</span><br><span class="line">				      &amp;iter-&gt;lost_events, &amp;iter-&gt;ts);</span><br><span class="line"></span><br><span class="line">    /* 确认对event的使用：</span><br><span class="line">        使用rb_advance_iter()向前移动ring_buffer_iter的读指针 </span><br><span class="line">     */</span><br><span class="line">	if (iter-&gt;ent)</span><br><span class="line">		trace_iterator_increment(iter);</span><br><span class="line"></span><br><span class="line">	return iter-&gt;ent ? iter : NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">||→</span><br><span class="line"></span><br><span class="line">static struct trace_entry *</span><br><span class="line">__find_next_entry(struct trace_iterator *iter, int *ent_cpu,</span><br><span class="line">		  unsigned long *missing_events, u64 *ent_ts)</span><br><span class="line">&#123;</span><br><span class="line">	struct ring_buffer *buffer = iter-&gt;trace_buffer-&gt;buffer;</span><br><span class="line">	struct trace_entry *ent, *next = NULL;</span><br><span class="line">	unsigned long lost_events = 0, next_lost = 0;</span><br><span class="line">	int cpu_file = iter-&gt;cpu_file;</span><br><span class="line">	u64 next_ts = 0, ts;</span><br><span class="line">	int next_cpu = -1;</span><br><span class="line">	int next_size = 0;</span><br><span class="line">	int cpu;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * If we are in a per_cpu trace file, don&apos;t bother by iterating over</span><br><span class="line">	 * all cpu and peek directly.</span><br><span class="line">	 */</span><br><span class="line">	if (cpu_file &gt; RING_BUFFER_ALL_CPUS) &#123;</span><br><span class="line">		if (ring_buffer_empty_cpu(buffer, cpu_file))</span><br><span class="line">			return NULL;</span><br><span class="line">		ent = peek_next_entry(iter, cpu_file, ent_ts, missing_events);</span><br><span class="line">		if (ent_cpu)</span><br><span class="line">			*ent_cpu = cpu_file;</span><br><span class="line"></span><br><span class="line">		return ent;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for_each_tracing_cpu(cpu) &#123;</span><br><span class="line"></span><br><span class="line">		if (ring_buffer_empty_cpu(buffer, cpu))</span><br><span class="line">			continue;</span><br><span class="line"></span><br><span class="line">        /* (1) 根据iter指示从ringbuffer中读出一条event， </span><br><span class="line">            如果iter使用了per cpu的ring_buffer_iter，则使用iterator读方式</span><br><span class="line">            否则，使用全局的reader_page swap式的读方式</span><br><span class="line">         */</span><br><span class="line">		ent = peek_next_entry(iter, cpu, &amp;ts, &amp;lost_events);</span><br><span class="line"></span><br><span class="line">		/*</span><br><span class="line">		 * Pick the entry with the smallest timestamp:</span><br><span class="line">		 */</span><br><span class="line">		/* (2) 多cpu的ring_buffer_per_cpu，怎么做时间戳同步？</span><br><span class="line">		    每个cpu的buffer，读取一条event的，选取时间戳最小的那条event返回</span><br><span class="line">		 */</span><br><span class="line">		if (ent &amp;&amp; (!next || ts &lt; next_ts)) &#123;</span><br><span class="line">			next = ent;</span><br><span class="line">			next_cpu = cpu;</span><br><span class="line">			next_ts = ts;</span><br><span class="line">			next_lost = lost_events;</span><br><span class="line">			next_size = iter-&gt;ent_size;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	iter-&gt;ent_size = next_size;</span><br><span class="line"></span><br><span class="line">	if (ent_cpu)</span><br><span class="line">		*ent_cpu = next_cpu;</span><br><span class="line"></span><br><span class="line">	if (ent_ts)</span><br><span class="line">		*ent_ts = next_ts;</span><br><span class="line"></span><br><span class="line">	if (missing_events)</span><br><span class="line">		*missing_events = next_lost;</span><br><span class="line"></span><br><span class="line">	return next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|||→</span><br><span class="line"></span><br><span class="line">static struct trace_entry *</span><br><span class="line">peek_next_entry(struct trace_iterator *iter, int cpu, u64 *ts,</span><br><span class="line">		unsigned long *lost_events)</span><br><span class="line">&#123;</span><br><span class="line">	struct ring_buffer_event *event;</span><br><span class="line">	struct ring_buffer_iter *buf_iter = trace_buffer_iter(iter, cpu);</span><br><span class="line"></span><br><span class="line">    /* (2.1) 如果定义了ring_buffer_iter，则使用iterator读 */</span><br><span class="line">	if (buf_iter)</span><br><span class="line">		event = ring_buffer_iter_peek(buf_iter, ts);</span><br><span class="line">	/* (2.2) 如果没有定义ring_buffer_iter，则使用reader_page swap读 */</span><br><span class="line">	else</span><br><span class="line">		event = ring_buffer_peek(iter-&gt;trace_buffer-&gt;buffer, cpu, ts,</span><br><span class="line">					 lost_events);</span><br><span class="line"></span><br><span class="line">	if (event) &#123;</span><br><span class="line">		iter-&gt;ent_size = ring_buffer_event_length(event);</span><br><span class="line">		return ring_buffer_event_data(event);</span><br><span class="line">	&#125;</span><br><span class="line">	iter-&gt;ent_size = 0;</span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">||||→</span><br><span class="line"></span><br><span class="line">struct ring_buffer_event *</span><br><span class="line">ring_buffer_iter_peek(struct ring_buffer_iter *iter, u64 *ts)</span><br><span class="line">&#123;</span><br><span class="line">	struct ring_buffer_per_cpu *cpu_buffer = iter-&gt;cpu_buffer;</span><br><span class="line">	struct ring_buffer_event *event;</span><br><span class="line">	unsigned long flags;</span><br><span class="line"></span><br><span class="line"> again:</span><br><span class="line">	raw_spin_lock_irqsave(&amp;cpu_buffer-&gt;reader_lock, flags);</span><br><span class="line">	event = rb_iter_peek(iter, ts);</span><br><span class="line">	raw_spin_unlock_irqrestore(&amp;cpu_buffer-&gt;reader_lock, flags);</span><br><span class="line"></span><br><span class="line">	if (event &amp;&amp; event-&gt;type_len == RINGBUF_TYPE_PADDING)</span><br><span class="line">		goto again;</span><br><span class="line"></span><br><span class="line">	return event;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static struct ring_buffer_event *</span><br><span class="line">rb_iter_peek(struct ring_buffer_iter *iter, u64 *ts)</span><br><span class="line">&#123;</span><br><span class="line">	struct ring_buffer *buffer;</span><br><span class="line">	struct ring_buffer_per_cpu *cpu_buffer;</span><br><span class="line">	struct ring_buffer_event *event;</span><br><span class="line">	int nr_loops = 0;</span><br><span class="line"></span><br><span class="line">	cpu_buffer = iter-&gt;cpu_buffer;</span><br><span class="line">	buffer = cpu_buffer-&gt;buffer;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Check if someone performed a consuming read to</span><br><span class="line">	 * the buffer. A consuming read invalidates the iterator</span><br><span class="line">	 * and we need to reset the iterator in this case.</span><br><span class="line">	 */</span><br><span class="line">	if (unlikely(iter-&gt;cache_read != cpu_buffer-&gt;read ||</span><br><span class="line">		     iter-&gt;cache_reader_page != cpu_buffer-&gt;reader_page))</span><br><span class="line">		rb_iter_reset(iter);</span><br><span class="line"></span><br><span class="line"> again:</span><br><span class="line">	if (ring_buffer_iter_empty(iter))</span><br><span class="line">		return NULL;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * We repeat when a time extend is encountered or we hit</span><br><span class="line">	 * the end of the page. Since the time extend is always attached</span><br><span class="line">	 * to a data event, we should never loop more than three times.</span><br><span class="line">	 * Once for going to next page, once on time extend, and</span><br><span class="line">	 * finally once to get the event.</span><br><span class="line">	 * (We never hit the following condition more than thrice).</span><br><span class="line">	 */</span><br><span class="line">	if (RB_WARN_ON(cpu_buffer, ++nr_loops &gt; 3))</span><br><span class="line">		return NULL;</span><br><span class="line"></span><br><span class="line">	if (rb_per_cpu_empty(cpu_buffer))</span><br><span class="line">		return NULL;</span><br><span class="line"></span><br><span class="line">    /* (2.1.1) 如果ring_buffer_iter中的head指针已经大于commit指针，</span><br><span class="line">        向后移动head_page指针</span><br><span class="line">     */</span><br><span class="line">	if (iter-&gt;head &gt;= rb_page_size(iter-&gt;head_page)) &#123;</span><br><span class="line">		rb_inc_iter(iter);</span><br><span class="line">		goto again;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (2.1.2) 根据ring_buffer_iter中的head和head_page指针， </span><br><span class="line">        读取event数据</span><br><span class="line">     */</span><br><span class="line">	event = rb_iter_head_event(iter);</span><br><span class="line"></span><br><span class="line">    /* (2.1.3) 根据读出event的type，对不是data的event进行处理 */</span><br><span class="line">	switch (event-&gt;type_len) &#123;</span><br><span class="line">	case RINGBUF_TYPE_PADDING:</span><br><span class="line">		if (rb_null_event(event)) &#123;</span><br><span class="line">			rb_inc_iter(iter);</span><br><span class="line">			goto again;</span><br><span class="line">		&#125;</span><br><span class="line">		rb_advance_iter(iter);</span><br><span class="line">		return event;</span><br><span class="line"></span><br><span class="line">	case RINGBUF_TYPE_TIME_EXTEND:</span><br><span class="line">		/* Internal data, OK to advance */</span><br><span class="line">		rb_advance_iter(iter);</span><br><span class="line">		goto again;</span><br><span class="line"></span><br><span class="line">	case RINGBUF_TYPE_TIME_STAMP:</span><br><span class="line">		/* FIXME: not implemented */</span><br><span class="line">		rb_advance_iter(iter);</span><br><span class="line">		goto again;</span><br><span class="line"></span><br><span class="line">	case RINGBUF_TYPE_DATA:</span><br><span class="line">		if (ts) &#123;</span><br><span class="line">			*ts = iter-&gt;read_stamp + event-&gt;time_delta;</span><br><span class="line">			ring_buffer_normalize_time_stamp(buffer,</span><br><span class="line">							 cpu_buffer-&gt;cpu, ts);</span><br><span class="line">		&#125;</span><br><span class="line">		return event;</span><br><span class="line"></span><br><span class="line">	default:</span><br><span class="line">		BUG();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>show()函数最后调用到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">static int s_show(struct seq_file *m, void *v)</span><br><span class="line">&#123;</span><br><span class="line">	struct trace_iterator *iter = v;</span><br><span class="line">	int ret;</span><br><span class="line"></span><br><span class="line">	if (iter-&gt;ent == NULL) &#123;</span><br><span class="line">		if (iter-&gt;tr) &#123;</span><br><span class="line">			seq_printf(m, &quot;# tracer: %s\n&quot;, iter-&gt;trace-&gt;name);</span><br><span class="line">			seq_puts(m, &quot;#\n&quot;);</span><br><span class="line">			test_ftrace_alive(m);</span><br><span class="line">		&#125;</span><br><span class="line">		if (iter-&gt;snapshot &amp;&amp; trace_empty(iter))</span><br><span class="line">			print_snapshot_help(m, iter);</span><br><span class="line">		else if (iter-&gt;trace &amp;&amp; iter-&gt;trace-&gt;print_header)</span><br><span class="line">			iter-&gt;trace-&gt;print_header(m);</span><br><span class="line">		else</span><br><span class="line">			trace_default_header(m);</span><br><span class="line"></span><br><span class="line">	&#125; else if (iter-&gt;leftover) &#123;</span><br><span class="line">		/*</span><br><span class="line">		 * If we filled the seq_file buffer earlier, we</span><br><span class="line">		 * want to just show it now.</span><br><span class="line">		 */</span><br><span class="line">		ret = trace_print_seq(m, &amp;iter-&gt;seq);</span><br><span class="line"></span><br><span class="line">		/* ret should this time be zero, but you never know */</span><br><span class="line">		iter-&gt;leftover = ret;</span><br><span class="line"></span><br><span class="line">	&#125; else &#123;</span><br><span class="line">	    /* (1) 根据ent中数据的type，找到对应的格式化函数</span><br><span class="line">	        把ringbuffer原始数据格式化成方便用户理解的字符串</span><br><span class="line">	        存储在临时变量iter-&gt;seq中</span><br><span class="line">	     */</span><br><span class="line">		print_trace_line(iter);</span><br><span class="line">		/* (2) 把iter-&gt;seq中的字符串，打印到实际的文件buffer中 */</span><br><span class="line">		ret = trace_print_seq(m, &amp;iter-&gt;seq);</span><br><span class="line">		/*</span><br><span class="line">		 * If we overflow the seq_file buffer, then it will</span><br><span class="line">		 * ask us for this data again at start up.</span><br><span class="line">		 * Use that instead.</span><br><span class="line">		 *  ret is 0 if seq_file write succeeded.</span><br><span class="line">		 *        -1 otherwise.</span><br><span class="line">		 */</span><br><span class="line">		iter-&gt;leftover = ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">enum print_line_t print_trace_line(struct trace_iterator *iter)</span><br><span class="line">&#123;</span><br><span class="line">	struct trace_array *tr = iter-&gt;tr;</span><br><span class="line">	unsigned long trace_flags = tr-&gt;trace_flags;</span><br><span class="line">	enum print_line_t ret;</span><br><span class="line"></span><br><span class="line">	if (iter-&gt;lost_events) &#123;</span><br><span class="line">		trace_seq_printf(&amp;iter-&gt;seq, &quot;CPU:%d [LOST %lu EVENTS]\n&quot;,</span><br><span class="line">				 iter-&gt;cpu, iter-&gt;lost_events);</span><br><span class="line">		if (trace_seq_has_overflowed(&amp;iter-&gt;seq))</span><br><span class="line">			return TRACE_TYPE_PARTIAL_LINE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (iter-&gt;trace &amp;&amp; iter-&gt;trace-&gt;print_line) &#123;</span><br><span class="line">		ret = iter-&gt;trace-&gt;print_line(iter);</span><br><span class="line">		if (ret != TRACE_TYPE_UNHANDLED)</span><br><span class="line">			return ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (1.1) 几种系统预制的ent-&gt;type，对应的格式化函数 */</span><br><span class="line">	if (iter-&gt;ent-&gt;type == TRACE_BPUTS &amp;&amp;</span><br><span class="line">			trace_flags &amp; TRACE_ITER_PRINTK &amp;&amp;</span><br><span class="line">			trace_flags &amp; TRACE_ITER_PRINTK_MSGONLY)</span><br><span class="line">		return trace_print_bputs_msg_only(iter);</span><br><span class="line"></span><br><span class="line">	if (iter-&gt;ent-&gt;type == TRACE_BPRINT &amp;&amp;</span><br><span class="line">			trace_flags &amp; TRACE_ITER_PRINTK &amp;&amp;</span><br><span class="line">			trace_flags &amp; TRACE_ITER_PRINTK_MSGONLY)</span><br><span class="line">		return trace_print_bprintk_msg_only(iter);</span><br><span class="line"></span><br><span class="line">	if (iter-&gt;ent-&gt;type == TRACE_PRINT &amp;&amp;</span><br><span class="line">			trace_flags &amp; TRACE_ITER_PRINTK &amp;&amp;</span><br><span class="line">			trace_flags &amp; TRACE_ITER_PRINTK_MSGONLY)</span><br><span class="line">		return trace_print_printk_msg_only(iter);</span><br><span class="line"></span><br><span class="line">	if (trace_flags &amp; TRACE_ITER_BIN)</span><br><span class="line">		return print_bin_fmt(iter);</span><br><span class="line"></span><br><span class="line">	if (trace_flags &amp; TRACE_ITER_HEX)</span><br><span class="line">		return print_hex_fmt(iter);</span><br><span class="line"></span><br><span class="line">	if (trace_flags &amp; TRACE_ITER_RAW)</span><br><span class="line">		return print_raw_fmt(iter);</span><br><span class="line"></span><br><span class="line">    /* (1.2) 用户自定义的ent-&gt;type，对应的格式化函数 */</span><br><span class="line">	return print_trace_fmt(iter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">||→</span><br><span class="line"></span><br><span class="line">static enum print_line_t print_trace_fmt(struct trace_iterator *iter)</span><br><span class="line">&#123;</span><br><span class="line">	struct trace_array *tr = iter-&gt;tr;</span><br><span class="line">	struct trace_seq *s = &amp;iter-&gt;seq;</span><br><span class="line">	unsigned long sym_flags = (tr-&gt;trace_flags &amp; TRACE_ITER_SYM_MASK);</span><br><span class="line">	struct trace_entry *entry;</span><br><span class="line">	struct trace_event *event;</span><br><span class="line"></span><br><span class="line">	entry = iter-&gt;ent;</span><br><span class="line"></span><br><span class="line">	test_cpu_buff_start(iter);</span><br><span class="line"></span><br><span class="line">    /* (1.2.1) 根据ent-&gt;type，找到对应的trace_entry */</span><br><span class="line">	event = ftrace_find_event(entry-&gt;type);</span><br><span class="line"></span><br><span class="line">	if (tr-&gt;trace_flags &amp; TRACE_ITER_CONTEXT_INFO) &#123;</span><br><span class="line">		if (iter-&gt;iter_flags &amp; TRACE_FILE_LAT_FMT)</span><br><span class="line">			trace_print_lat_context(iter);</span><br><span class="line">		else</span><br><span class="line">			trace_print_context(iter);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (trace_seq_has_overflowed(s))</span><br><span class="line">		return TRACE_TYPE_PARTIAL_LINE;</span><br><span class="line"></span><br><span class="line">    /* (1.2.2) 调用trace_entry-&gt;funcs-&gt;trace函数进行数据格式化 */</span><br><span class="line">	if (event)</span><br><span class="line">		return event-&gt;funcs-&gt;trace(iter, sym_flags, event);</span><br><span class="line"></span><br><span class="line">	trace_seq_printf(s, &quot;Unknown type %d\n&quot;, entry-&gt;type);</span><br><span class="line"></span><br><span class="line">	return trace_handle_return(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-2、reader-page-swap读"><a href="#4-2、reader-page-swap读" class="headerlink" title="4.2、reader_page swap读"></a>4.2、reader_page swap读</h2><p>参考”/sys/kernel/debug/tracing/trace_pipe”文件的读操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br></pre></td><td class="code"><pre><span class="line">	trace_create_file(&quot;trace_pipe&quot;, 0444, d_tracer,</span><br><span class="line">			  tr, &amp;tracing_pipe_fops);</span><br><span class="line">			  </span><br><span class="line">static const struct file_operations tracing_pipe_fops = &#123;</span><br><span class="line">	.open		= tracing_open_pipe,</span><br><span class="line">	.poll		= tracing_poll_pipe,</span><br><span class="line">	.read		= tracing_read_pipe,</span><br><span class="line">	.splice_read	= tracing_splice_read_pipe,</span><br><span class="line">	.release	= tracing_release_pipe,</span><br><span class="line">	.llseek		= no_llseek,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/* (1) 和tracing_open最大的区别就是在open中没有定义percpu的ring_buffer_iter，</span><br><span class="line">    所以它在后续的读操作中，不会使用iterator读，而是使用reader_page swap读</span><br><span class="line"> */</span><br><span class="line">static int tracing_open_pipe(struct inode *inode, struct file *filp)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	/* create a buffer to store the information to pass to userspace */</span><br><span class="line">	iter = kzalloc(sizeof(*iter), GFP_KERNEL);</span><br><span class="line">	if (!iter) &#123;</span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		__trace_array_put(tr);</span><br><span class="line">		goto out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* (2) trace_pipe文件的读操作 */</span><br><span class="line">static ssize_t</span><br><span class="line">tracing_read_pipe(struct file *filp, char __user *ubuf,</span><br><span class="line">		  size_t cnt, loff_t *ppos)</span><br><span class="line">&#123;</span><br><span class="line">	struct trace_iterator *iter = filp-&gt;private_data;</span><br><span class="line">	ssize_t sret;</span><br><span class="line"></span><br><span class="line">	/* return any leftover data */</span><br><span class="line">	sret = trace_seq_to_user(&amp;iter-&gt;seq, ubuf, cnt);</span><br><span class="line">	if (sret != -EBUSY)</span><br><span class="line">		return sret;</span><br><span class="line"></span><br><span class="line">	trace_seq_init(&amp;iter-&gt;seq);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Avoid more than one consumer on a single file descriptor</span><br><span class="line">	 * This is just a matter of traces coherency, the ring buffer itself</span><br><span class="line">	 * is protected.</span><br><span class="line">	 */</span><br><span class="line">	mutex_lock(&amp;iter-&gt;mutex);</span><br><span class="line">	if (iter-&gt;trace-&gt;read) &#123;</span><br><span class="line">		sret = iter-&gt;trace-&gt;read(iter, filp, ubuf, cnt, ppos);</span><br><span class="line">		if (sret)</span><br><span class="line">			goto out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">waitagain:</span><br><span class="line">	sret = tracing_wait_pipe(filp);</span><br><span class="line">	if (sret &lt;= 0)</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">	/* stop when tracing is finished */</span><br><span class="line">	if (trace_empty(iter)) &#123;</span><br><span class="line">		sret = 0;</span><br><span class="line">		goto out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (cnt &gt;= PAGE_SIZE)</span><br><span class="line">		cnt = PAGE_SIZE - 1;</span><br><span class="line"></span><br><span class="line">	/* reset all but tr, trace, and overruns */</span><br><span class="line">	memset(&amp;iter-&gt;seq, 0,</span><br><span class="line">	       sizeof(struct trace_iterator) -</span><br><span class="line">	       offsetof(struct trace_iterator, seq));</span><br><span class="line">	cpumask_clear(iter-&gt;started);</span><br><span class="line">	iter-&gt;pos = -1;</span><br><span class="line"></span><br><span class="line">	trace_event_read_lock();</span><br><span class="line">	trace_access_lock(iter-&gt;cpu_file);</span><br><span class="line">	/* (2.1) 使用reader_page swap读，读出下一个event */</span><br><span class="line">	while (trace_find_next_entry_inc(iter) != NULL) &#123;</span><br><span class="line">		enum print_line_t ret;</span><br><span class="line">		int save_len = iter-&gt;seq.seq.len;</span><br><span class="line"></span><br><span class="line">        /* (2.2) 根据ent中数据的type，找到对应的格式化函数</span><br><span class="line">	        把ringbuffer原始数据格式化成方便用户理解的字符串</span><br><span class="line">	        存储在临时变量iter-&gt;seq中</span><br><span class="line">	     */ </span><br><span class="line">		ret = print_trace_line(iter);</span><br><span class="line">		if (ret == TRACE_TYPE_PARTIAL_LINE) &#123;</span><br><span class="line">			/* don&apos;t print partial lines */</span><br><span class="line">			iter-&gt;seq.seq.len = save_len;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		/* (2.3) 对event数据读取进行确认，</span><br><span class="line">		    增加对应reader_page-&gt;read、reader_page指针</span><br><span class="line">		 */</span><br><span class="line">		if (ret != TRACE_TYPE_NO_CONSUME)</span><br><span class="line">			trace_consume(iter);</span><br><span class="line"></span><br><span class="line">        /* (2.4) 如果iter-&gt;seq中的数据长度已经满足，退出循环 */</span><br><span class="line">		if (trace_seq_used(&amp;iter-&gt;seq) &gt;= cnt)</span><br><span class="line">			break;</span><br><span class="line"></span><br><span class="line">		/*</span><br><span class="line">		 * Setting the full flag means we reached the trace_seq buffer</span><br><span class="line">		 * size and we should leave by partial output condition above.</span><br><span class="line">		 * One of the trace_seq_* functions is not used properly.</span><br><span class="line">		 */</span><br><span class="line">		WARN_ONCE(iter-&gt;seq.full, &quot;full flag set for trace type %d&quot;,</span><br><span class="line">			  iter-&gt;ent-&gt;type);</span><br><span class="line">	&#125;</span><br><span class="line">	trace_access_unlock(iter-&gt;cpu_file);</span><br><span class="line">	trace_event_read_unlock();</span><br><span class="line"></span><br><span class="line">	/* Now copy what we have to the user */</span><br><span class="line">	/* (2.5) 拷贝iter-&gt;seq中的字符串数据到文件buffer中 */</span><br><span class="line">	sret = trace_seq_to_user(&amp;iter-&gt;seq, ubuf, cnt);</span><br><span class="line">	if (iter-&gt;seq.seq.readpos &gt;= trace_seq_used(&amp;iter-&gt;seq))</span><br><span class="line">		trace_seq_init(&amp;iter-&gt;seq);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * If there was nothing to send to user, in spite of consuming trace</span><br><span class="line">	 * entries, go back to wait for more entries.</span><br><span class="line">	 */</span><br><span class="line">	if (sret == -EBUSY)</span><br><span class="line">		goto waitagain;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	mutex_unlock(&amp;iter-&gt;mutex);</span><br><span class="line"></span><br><span class="line">	return sret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">trace_find_next_entry_inc() -&gt; __find_next_entry() -&gt; peek_next_entry() -&gt; ring_buffer_peek() -&gt; rb_buffer_peek()：</span><br><span class="line"></span><br><span class="line">static struct ring_buffer_event *</span><br><span class="line">rb_buffer_peek(struct ring_buffer_per_cpu *cpu_buffer, u64 *ts,</span><br><span class="line">	       unsigned long *lost_events)</span><br><span class="line">&#123;</span><br><span class="line">	struct ring_buffer_event *event;</span><br><span class="line">	struct buffer_page *reader;</span><br><span class="line">	int nr_loops = 0;</span><br><span class="line"></span><br><span class="line"> again:</span><br><span class="line">	/*</span><br><span class="line">	 * We repeat when a time extend is encountered.</span><br><span class="line">	 * Since the time extend is always attached to a data event,</span><br><span class="line">	 * we should never loop more than once.</span><br><span class="line">	 * (We never hit the following condition more than twice).</span><br><span class="line">	 */</span><br><span class="line">	if (RB_WARN_ON(cpu_buffer, ++nr_loops &gt; 2))</span><br><span class="line">		return NULL;</span><br><span class="line"></span><br><span class="line">    /* (2.2.1) swap出最新的reader_page */</span><br><span class="line">	reader = rb_get_reader_page(cpu_buffer);</span><br><span class="line">	if (!reader)</span><br><span class="line">		return NULL;</span><br><span class="line"></span><br><span class="line">    /* (2.2.2) 根据reader_page和reader_page-&gt;read指针，得到最新的event */</span><br><span class="line">	event = rb_reader_event(cpu_buffer);</span><br><span class="line"></span><br><span class="line">    /* (2.2.3) 对不是data的event进行处理 */</span><br><span class="line">	switch (event-&gt;type_len) &#123;</span><br><span class="line">	case RINGBUF_TYPE_PADDING:</span><br><span class="line">		if (rb_null_event(event))</span><br><span class="line">			RB_WARN_ON(cpu_buffer, 1);</span><br><span class="line">		/*</span><br><span class="line">		 * Because the writer could be discarding every</span><br><span class="line">		 * event it creates (which would probably be bad)</span><br><span class="line">		 * if we were to go back to &quot;again&quot; then we may never</span><br><span class="line">		 * catch up, and will trigger the warn on, or lock</span><br><span class="line">		 * the box. Return the padding, and we will release</span><br><span class="line">		 * the current locks, and try again.</span><br><span class="line">		 */</span><br><span class="line">		return event;</span><br><span class="line"></span><br><span class="line">	case RINGBUF_TYPE_TIME_EXTEND:</span><br><span class="line">		/* Internal data, OK to advance */</span><br><span class="line">		rb_advance_reader(cpu_buffer);</span><br><span class="line">		goto again;</span><br><span class="line"></span><br><span class="line">	case RINGBUF_TYPE_TIME_STAMP:</span><br><span class="line">		/* FIXME: not implemented */</span><br><span class="line">		rb_advance_reader(cpu_buffer);</span><br><span class="line">		goto again;</span><br><span class="line"></span><br><span class="line">	case RINGBUF_TYPE_DATA:</span><br><span class="line">		if (ts) &#123;</span><br><span class="line">			*ts = cpu_buffer-&gt;read_stamp + event-&gt;time_delta;</span><br><span class="line">			ring_buffer_normalize_time_stamp(cpu_buffer-&gt;buffer,</span><br><span class="line">							 cpu_buffer-&gt;cpu, ts);</span><br><span class="line">		&#125;</span><br><span class="line">		if (lost_events)</span><br><span class="line">			*lost_events = rb_lost_events(cpu_buffer);</span><br><span class="line">		return event;</span><br><span class="line"></span><br><span class="line">	default:</span><br><span class="line">		BUG();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">trace_consume() -&gt; ring_buffer_consume():</span><br><span class="line"></span><br><span class="line">struct ring_buffer_event *</span><br><span class="line">ring_buffer_consume(struct ring_buffer *buffer, int cpu, u64 *ts,</span><br><span class="line">		    unsigned long *lost_events)</span><br><span class="line">&#123;</span><br><span class="line">	struct ring_buffer_per_cpu *cpu_buffer;</span><br><span class="line">	struct ring_buffer_event *event = NULL;</span><br><span class="line">	unsigned long flags;</span><br><span class="line">	bool dolock;</span><br><span class="line"></span><br><span class="line"> again:</span><br><span class="line">	/* might be called in atomic */</span><br><span class="line">	preempt_disable();</span><br><span class="line"></span><br><span class="line">	if (!cpumask_test_cpu(cpu, buffer-&gt;cpumask))</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">	cpu_buffer = buffer-&gt;buffers[cpu];</span><br><span class="line">	local_irq_save(flags);</span><br><span class="line">	dolock = rb_reader_lock(cpu_buffer);</span><br><span class="line"></span><br><span class="line">	event = rb_buffer_peek(cpu_buffer, ts, lost_events);</span><br><span class="line">	if (event) &#123;</span><br><span class="line">		cpu_buffer-&gt;lost_events = 0;</span><br><span class="line">		/* (2.3.1) 增加reader-&gt;read指针 */</span><br><span class="line">		rb_advance_reader(cpu_buffer);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rb_reader_unlock(cpu_buffer, dolock);</span><br><span class="line">	local_irq_restore(flags);</span><br><span class="line"></span><br><span class="line"> out:</span><br><span class="line">	preempt_enable();</span><br><span class="line"></span><br><span class="line">	if (event &amp;&amp; event-&gt;type_len == RINGBUF_TYPE_PADDING)</span><br><span class="line">		goto again;</span><br><span class="line"></span><br><span class="line">	return event;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5、ringbuffer的设计思想"><a href="#5、ringbuffer的设计思想" class="headerlink" title="5、ringbuffer的设计思想  "></a>5、ringbuffer的设计思想 <a id="设计思想"> </a></h1><p>面临的最大问题：</p>
<ul>
<li>ring buffer可能在不同上下文中执行(Normal、NMI、IRQ、SOFTIRQ)，对ring buffer的访问是随时可能被打断的，所以对ring buffer的访问需要互斥保护</li>
<li>ring buffer不能使用常规的lock操作，这样会使不同的上下文之间出现大量的阻塞操作，新增了相互之间的耦合、影响了程序原来的逻辑、影响了性能</li>
</ul>
<p>最终这个设计使用了一系列的技巧解决了这个问题：原子操作、commit page、RB_PAGE_HEAD、reader_page、重试。这些才是整个ring buffer思想的<strong>精华所在</strong>。</p>
<h2 id="5-1、术语"><a href="#5-1、术语" class="headerlink" title="5.1、术语"></a>5.1、术语</h2><table border="1"><br><caption> 术语 </caption><br><br><tr><br><th style="width: 150px;">术语</th><br><th style="width: 600px;">Description</th><br><th style="width: 600px;">解释</th><br></tr><br><br><tr><br><td> tail </td><br><td><br>where new writes happen in the ring buffer.<br></td><br><td><br>ring buffer中下一个写操作的位置<br></td><br></tr><br><br><tr><br><td> head </td><br><td><br>where new reads happen in the ring buffer.<br></td><br><td><br>ring buffer中下一个读操作的位置<br></td><br></tr><br><br><tr><br><td> producer </td><br><td><br>the task that writes into the ring buffer (same as writer)<br></td><br><td><br>生产者：写入数据到ring buffer的任务<br></td><br></tr><br><br><tr><br><td> writer </td><br><td><br>same as producer<br></td><br><td><br>写入者，同生产者<br></td><br></tr><br><br><tr><br><td> consumer </td><br><td><br>the task that reads from the buffer (same as reader)<br></td><br><td><br>消费者：读出ring buffer中数据的任务<br></td><br></tr><br><br><tr><br><td> reader </td><br><td><br>same as consumer.<br></td><br><td><br>读取者，同消费者<br></td><br></tr><br><br><tr><br><td> reader_page </td><br><td><br>A page outside the ring buffer used solely (for the most part) by the reader.<br></td><br><td><br>在ring buffer外部的一个单独的page，专门给reader使用的<br></td><br></tr><br><br><tr><br><td> head_page </td><br><td><br>a pointer to the page that the reader will use next<br></td><br><td><br>指针，指向reader下一个将要使用的page<br></td><br></tr><br><br><tr><br><td> tail_page </td><br><td><br>a pointer to the page that will be written to next<br></td><br><td><br>指针，指向下一个将要被写入的page<br></td><br></tr><br><br><tr><br><td> commit_page </td><br><td><br>a pointer to the page with the last finished non-nested write.<br></td><br><td><br>指针，指向最后一个完成的非嵌套写的位置<br></td><br></tr><br><br><tr><br><td> cmpxchg </td><br><td><br>hardware-assisted atomic transaction that performs the following:<br><br><br>   A = B iff previous A == C<br><br>   R = cmpxchg(A, C, B) is saying that we replace A with B if and only if current A is equal to C, and we put the old (current) A into R<br><br>   R gets the previous A regardless if A is updated with B or not.<br><br>   To see if the update was successful a compare of R == C may be used.<br><br></td><br><td><br>硬件辅助的原子组合操作：<br><br><br>   R = cmpxchg(A, C, B)。如果A=C，则A=B；同时R获得A上一次的值，无关前面A=C条件是否成功。所以判断操作是否成功，需要判断(R == C)?<br></td><br></tr><br><br></table>

<h2 id="5-2-ring-buffer的基本概念"><a href="#5-2-ring-buffer的基本概念" class="headerlink" title="5.2 ring buffer的基本概念"></a>5.2 ring buffer的基本概念</h2><p>1、工作模式</p>
<p>ring buffer可以工作在overwrite模式或者producer/consumer模式：</p>
<ul>
<li>Producer/consumer模式。在producer已经把ring buffer空间写满的情况下，如果没有consumer来读数据free空间，producer会停止写入丢弃新的数据；</li>
<li>Overwrite模式。在producer已经把ring buffer空间写满的情况下，如果没有consumer来读数据free空间，producer会覆盖写入，最老的数据会被覆盖；</li>
</ul>
<p>2、写操作</p>
<p>在同一个per-cpu buffer上，不能同时有两个写入者在进行写操作。但是允许高优先级的写入者中断低优先级的写入者，在返回低优先级之前高优先级写入者必须finish自己的写操作。类似下面例子的“stack写”、“嵌套写操作”。<br>在实际的环境中就是：普通写操作被IRQ写中断、IRQ写被NMI写中断。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">writer1 start</span><br><span class="line">   &lt;preempted&gt; writer2 start</span><br><span class="line">       &lt;preempted&gt; writer3 start</span><br><span class="line">                   writer3 finishes</span><br><span class="line">               writer2 finishes</span><br><span class="line">writer1 finishes</span><br></pre></td></tr></table></figure>
<p>3、读操作 <a id="reader"> </a></p>
<ul>
<li>读操作随时可以发生，但是<strong>同一时刻只有一个reader在工作</strong>，这其中使用了互斥操作。</li>
<li>读操作和写操作会同时发生：本cpu写入对应的per-cpu buffer，其他cpu可以同时读取这个cpu的bbbuffer；</li>
<li>读操作不会中断写操作，但是写操作会中断读操作；</li>
<li>支持两种模式的读操作：简易读，也叫iterator读，在读取时会关闭写入，且读完不会破坏数据可以重复读取，实例见”/sys/kernel/debug/tracing/trace”；并行读，也叫custom读，常用于监控程序实时的进行并行读，其利用了一个reader page交换出ring buffer中的head page，避免了读写的相互阻塞，实例见”/sys/kernel/debug/tracing/trace_pipe”；</li>
</ul>
<p>3.1、reader page的swap：</p>
<p>为了支持并行读，需要使用reader_page交换出head_page。交换过程非常简单易懂，如下图：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">+------+</span><br><span class="line">|reader|          RING BUFFER</span><br><span class="line">|page  |</span><br><span class="line">+------+</span><br><span class="line">                +---+   +---+   +---+</span><br><span class="line">                |   |--&gt;|   |--&gt;|   |</span><br><span class="line">                |   |&lt;--|   |&lt;--|   |</span><br><span class="line">                +---+   +---+   +---+</span><br><span class="line">                 ^ |             ^ |</span><br><span class="line">                 | +-------------+ |</span><br><span class="line">                 +-----------------+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+------+</span><br><span class="line">|reader|          RING BUFFER</span><br><span class="line">|page  |-------------------+</span><br><span class="line">+------+                   v</span><br><span class="line">  |             +---+   +---+   +---+</span><br><span class="line">  |             |   |--&gt;|   |--&gt;|   |</span><br><span class="line">  |             |   |&lt;--|   |&lt;--|   |&lt;-+</span><br><span class="line">  |             +---+   +---+   +---+  |</span><br><span class="line">  |              ^ |             ^ |   |</span><br><span class="line">  |              | +-------------+ |   |</span><br><span class="line">  |              +-----------------+   |</span><br><span class="line">  +------------------------------------+</span><br><span class="line"></span><br><span class="line">+------+</span><br><span class="line">|reader|          RING BUFFER</span><br><span class="line">|page  |-------------------+</span><br><span class="line">+------+ &lt;---------------+ v</span><br><span class="line">  |  ^          +---+   +---+   +---+</span><br><span class="line">  |  |          |   |--&gt;|   |--&gt;|   |</span><br><span class="line">  |  |          |   |   |   |&lt;--|   |&lt;-+</span><br><span class="line">  |  |          +---+   +---+   +---+  |</span><br><span class="line">  |  |             |             ^ |   |</span><br><span class="line">  |  |             +-------------+ |   |</span><br><span class="line">  |  +-----------------------------+   |</span><br><span class="line">  +------------------------------------+</span><br><span class="line"></span><br><span class="line">+------+</span><br><span class="line">|buffer|          RING BUFFER</span><br><span class="line">|page  |-------------------+</span><br><span class="line">+------+ &lt;---------------+ v</span><br><span class="line">  |  ^          +---+   +---+   +---+</span><br><span class="line">  |  |          |   |   |   |--&gt;|   |</span><br><span class="line">  |  |  New     |   |   |   |&lt;--|   |&lt;-+</span><br><span class="line">  |  | Reader   +---+   +---+   +---+  |</span><br><span class="line">  |  |  page ----^                 |   |</span><br><span class="line">  |  |                             |   |</span><br><span class="line">  |  +-----------------------------+   |</span><br><span class="line">  +------------------------------------+</span><br></pre></td></tr></table></figure>
<p>reader_page swap的一种极端情况：把commit_page和tail_page交换到了reader_page，这种情况不会出现异常，因为reader_page的next指针任然指向ring buffer中的下一个page。如下图：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">          reader page    commit page   tail page</span><br><span class="line">              |              |             |</span><br><span class="line">              v              |             |</span><br><span class="line">             +---+           |             |</span><br><span class="line">             |   |&lt;----------+             |</span><br><span class="line">             |   |&lt;------------------------+</span><br><span class="line">             |   |------+</span><br><span class="line">             +---+      |</span><br><span class="line">                        |</span><br><span class="line">                        v</span><br><span class="line">    +---+    +---+    +---+    +---+</span><br><span class="line">&lt;---|   |---&gt;|   |---&gt;|   |---&gt;|   |---&gt;</span><br><span class="line">---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---</span><br><span class="line">    +---+    +---+    +---+    +---+</span><br></pre></td></tr></table></figure>
<p>4、ring buffer的主要指针</p>
<ul>
<li>reader page - The page used solely by the reader and is not part of the ring buffer (may be swapped in)</li>
<li>head page - the next page in the ring buffer that will be swapped with the reader page.</li>
<li>tail page - the page where the next write will take place.</li>
<li>commit page - the page that last finished a write.</li>
</ul>
<p>4.1、commit page <a id="commit_page"> </a></p>
<p>commit page指针只能被“stack写”/“嵌套写”最外层的写入者更新，抢占其他人的写入者不能移动commit page指针。</p>
<p>这个机制也是ringbuffer的核心机制，实现了写入的免锁：</p>
<ul>
<li>在writer需要分配空间的时候，迅速的用原子操作移动tail指针，迅速的保留出空间。这样就算被高优先级的writer抢占，在操作这块空间的时候也不需要持锁，因为writer的空间都是独立的；</li>
<li>使用最外层的writer来commit空间，如果最外层的writer都已经得到操作权限，说明所有高优先级的writer都已经操作完成。commit完成后，这部分空间就可以给reader读取了；</li>
<li>如果需要丢弃空间，可以设置相应的标志，还是同样的commit，在读取过程中判断有丢弃标志则进行丢弃；</li>
</ul>
<p>普通的写操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Write reserve:</span><br><span class="line"></span><br><span class="line">    Buffer page</span><br><span class="line">   +---------+</span><br><span class="line">   |written  |</span><br><span class="line">   +---------+  &lt;--- given back to writer (current commit)</span><br><span class="line">   |reserved |</span><br><span class="line">   +---------+ &lt;--- tail pointer</span><br><span class="line">   | empty   |</span><br><span class="line">   +---------+</span><br><span class="line"></span><br><span class="line">Write commit:</span><br><span class="line"></span><br><span class="line">    Buffer page</span><br><span class="line">   +---------+</span><br><span class="line">   |written  |</span><br><span class="line">   +---------+</span><br><span class="line">   |written  |</span><br><span class="line">   +---------+  &lt;--- next position for write (current commit)</span><br><span class="line">   | empty   |</span><br><span class="line">   +---------+</span><br></pre></td></tr></table></figure>
<p>被抢占的读操作：</p>
<p>抢占者的commit会成为pending commit，只有所有writer数据都写完的commit才是last full commit。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">If a write happens after the first reserve:</span><br><span class="line"></span><br><span class="line">      Buffer page</span><br><span class="line">     +---------+</span><br><span class="line">     |written  |</span><br><span class="line">     +---------+  &lt;-- current commit</span><br><span class="line">     |reserved |</span><br><span class="line">     +---------+  &lt;--- given back to second writer</span><br><span class="line">     |reserved |</span><br><span class="line">     +---------+ &lt;--- tail pointer</span><br><span class="line"></span><br><span class="line"> After second writer commits:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      Buffer page</span><br><span class="line">     +---------+</span><br><span class="line">     |written  |</span><br><span class="line">     +---------+  &lt;--(last full commit)</span><br><span class="line">     |reserved |</span><br><span class="line">     +---------+</span><br><span class="line">     |pending  |</span><br><span class="line">     |commit   |</span><br><span class="line">     +---------+ &lt;--- tail pointer</span><br><span class="line"></span><br><span class="line"> When the first writer commits:</span><br><span class="line"></span><br><span class="line">      Buffer page</span><br><span class="line">     +---------+</span><br><span class="line">     |written  |</span><br><span class="line">     +---------+</span><br><span class="line">     |written  |</span><br><span class="line">     +---------+</span><br><span class="line">     |written  |</span><br><span class="line">     +---------+  &lt;--(last full commit and tail pointer)</span><br></pre></td></tr></table></figure>
<p>4.2、指针的顺序</p>
<p>通常情况下，几种指针的顺序如下：head page、commit page、tail page。如下图：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">                             tail page</span><br><span class="line">  head page         commit page  |</span><br><span class="line">      |                 |        |</span><br><span class="line">      v                 v        v</span><br><span class="line">    +---+    +---+    +---+    +---+</span><br><span class="line">&lt;---|   |---&gt;|   |---&gt;|   |---&gt;|   |---&gt;</span><br><span class="line">---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---</span><br><span class="line">    +---+    +---+    +---+    +---+</span><br></pre></td></tr></table></figure>
<p>tail page一直前于等于commit page，如果tail page环绕快赶上了commit page，ring buffer不能再写入任何数据了，因为没有commit的数据在任何模式下都不能overwrite，这样会引起write的逻辑混乱。</p>
<p>有一种特殊的情况会打断这种顺序，head page会跑到commit page、tail page之后。如下图：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">          reader page    commit page   tail page</span><br><span class="line">              |              |             |</span><br><span class="line">              v              |             |</span><br><span class="line">             +---+           |             |</span><br><span class="line">             |   |&lt;----------+             |</span><br><span class="line">             |   |&lt;------------------------+</span><br><span class="line">             |   |------+</span><br><span class="line">             +---+      |</span><br><span class="line">                        |</span><br><span class="line">                        v</span><br><span class="line">    +---+    +---+    +---+    +---+</span><br><span class="line">&lt;---|   |---&gt;|   |---&gt;|   |---&gt;|   |---&gt;</span><br><span class="line">---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---</span><br><span class="line">    +---+    +---+    +---+    +---+</span><br><span class="line">                        ^</span><br><span class="line">                        |</span><br><span class="line">                    head page</span><br></pre></td></tr></table></figure>
<p>这是并行读时，使用reader page交换出了commit page、tail page。在这种情况下，head page指针不能移动，直到commit page、tail page指针移动回到ring buffer的page当中。同样如果commit指针在reader page中，不能swap出当前reader_page到ring buffer中。</p>
<p>4.3、overwrite时的指针操作</p>
<ul>
<li>tail指针不能overwrite commit指针，因为commit处在写入的中间状态，强行overwrite会发生不可预料的结果；</li>
<li>但是tail指针可以overwrite head指针，因为是已经写入完成的数据，只是丢弃掉一些不被读取；</li>
<li>tail指针会push head指针指向下一个page，然后再移动tail指针；</li>
</ul>
<p>overwrite的过程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">            tail page</span><br><span class="line">               |</span><br><span class="line">               v</span><br><span class="line">    +---+    +---+    +---+    +---+</span><br><span class="line">&lt;---|   |---&gt;|   |---&gt;|   |---&gt;|   |---&gt;</span><br><span class="line">---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---</span><br><span class="line">    +---+    +---+    +---+    +---+</span><br><span class="line">                        ^</span><br><span class="line">                        |</span><br><span class="line">                    head page</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            tail page</span><br><span class="line">               |</span><br><span class="line">               v</span><br><span class="line">    +---+    +---+    +---+    +---+</span><br><span class="line">&lt;---|   |---&gt;|   |---&gt;|   |---&gt;|   |---&gt;</span><br><span class="line">---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---</span><br><span class="line">    +---+    +---+    +---+    +---+</span><br><span class="line">                                 ^</span><br><span class="line">                                 |</span><br><span class="line">                             head page</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    tail page</span><br><span class="line">                        |</span><br><span class="line">                        v</span><br><span class="line">    +---+    +---+    +---+    +---+</span><br><span class="line">&lt;---|   |---&gt;|   |---&gt;|   |---&gt;|   |---&gt;</span><br><span class="line">---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---</span><br><span class="line">    +---+    +---+    +---+    +---+</span><br><span class="line">                                 ^</span><br><span class="line">                                 |</span><br><span class="line">                             head page</span><br></pre></td></tr></table></figure>
<h2 id="5-3-ring-buffer无锁机制的实现"><a href="#5-3-ring-buffer无锁机制的实现" class="headerlink" title="5.3 ring buffer无锁机制的实现"></a>5.3 ring buffer无锁机制的实现</h2><p>任何读操作都会get一系列的锁，确保操作串行；写操作都是无锁操作，写入ring buffer。所有我们在设计机制的时候，只需要考虑“单个读取者”+“多个嵌套写入者”的场景。</p>
<p>在这种设定下，无锁互斥机制包含几部分：</p>
<ul>
<li>“嵌套write”时的无锁机制。这个在上节中已经介绍，使用commit指针来解决；(writer)</li>
<li>reader_page swap时的无锁机制。基本概念在上一节介绍，本节再详细介绍一下过程；(reader)</li>
<li>overwrite操作时的无锁机制。上节已经介绍，如果tail指针要赶上head指针了将要进行overwrite，写入者push head指针向前操作；(writer)</li>
</ul>
<p>1、overwrite操作的无锁</p>
<p>为了支持这个机制，设计者特意制定了两个标志位：</p>
<ul>
<li>HEADER - the page being pointed to is a head page</li>
<li>UPDATE - the page being pointed to is being updated by a writer and was or is about to be a head page.</li>
</ul>
<p>这两个标志，使用指向head page的上一个page的-&gt;next指针的低两bit来存放。“H”和“U”标志是互斥的不会同时置位。</p>
<p>普通overwrite操作时，是这样来操作“H”和“U”标志的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">// step 1: writer判断tail指针已经接近head指针，首先使用原子操作将“H”标志变成“U”标志。</span><br><span class="line">//          在这种情况下，reader也不能交换出ringbuffer的head page，直到writer完成移动操作</span><br><span class="line"></span><br><span class="line">            tail page</span><br><span class="line">               |</span><br><span class="line">               v</span><br><span class="line">    +---+    +---+    +---+    +---+</span><br><span class="line">&lt;---|   |---&gt;|   |-H-&gt;|   |---&gt;|   |---&gt;</span><br><span class="line">---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---</span><br><span class="line">    +---+    +---+    +---+    +---+</span><br><span class="line"></span><br><span class="line">            tail page</span><br><span class="line">               |</span><br><span class="line">               v</span><br><span class="line">    +---+    +---+    +---+    +---+</span><br><span class="line">&lt;---|   |---&gt;|   |-U-&gt;|   |---&gt;|   |---&gt;</span><br><span class="line">---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---</span><br><span class="line">    +---+    +---+    +---+    +---+</span><br><span class="line"></span><br><span class="line">// step 2: 移动head指针，将指向下一个page的指针“H”标志置位</span><br><span class="line"></span><br><span class="line">           tail page</span><br><span class="line">               |</span><br><span class="line">               v</span><br><span class="line">    +---+    +---+    +---+    +---+</span><br><span class="line">&lt;---|   |---&gt;|   |-U-&gt;|   |-H-&gt;|   |---&gt;</span><br><span class="line">---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---</span><br><span class="line">    +---+    +---+    +---+    +---+</span><br><span class="line"></span><br><span class="line">// step 3: 清除掉旧指针中的“U”标志</span><br><span class="line"></span><br><span class="line">           tail page</span><br><span class="line">               |</span><br><span class="line">               v</span><br><span class="line">    +---+    +---+    +---+    +---+</span><br><span class="line">&lt;---|   |---&gt;|   |---&gt;|   |-H-&gt;|   |---&gt;</span><br><span class="line">---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---</span><br><span class="line">    +---+    +---+    +---+    +---+</span><br><span class="line"></span><br><span class="line">// step 4: 移动tail指针</span><br><span class="line"></span><br><span class="line">                    tail page</span><br><span class="line">                        |</span><br><span class="line">                        v</span><br><span class="line">    +---+    +---+    +---+    +---+</span><br><span class="line">&lt;---|   |---&gt;|   |---&gt;|   |-H-&gt;|   |---&gt;</span><br><span class="line">---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---</span><br><span class="line">    +---+    +---+    +---+    +---+</span><br></pre></td></tr></table></figure>
<p>1.1 commit禁止overwrite</p>
<p>如果某个抢占式writer的优先级过高，一直写入，造成了tail指针赶上了commit指针。如下图：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">          reader page    commit page</span><br><span class="line">              |              |</span><br><span class="line">              v              |</span><br><span class="line">             +---+           |</span><br><span class="line">             |   |&lt;----------+</span><br><span class="line">             |   |</span><br><span class="line">             |   |------+</span><br><span class="line">             +---+      |</span><br><span class="line">                        |</span><br><span class="line">                        v</span><br><span class="line">    +---+    +---+    +---+    +---+</span><br><span class="line">&lt;---|   |---&gt;|   |-H-&gt;|   |---&gt;|   |---&gt;</span><br><span class="line">---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---</span><br><span class="line">    +---+    +---+    +---+    +---+</span><br><span class="line">               ^</span><br><span class="line">               |</span><br><span class="line">           tail page</span><br></pre></td></tr></table></figure>
<p>这个时候唯一要做的就是：等待。不能overwrite，只能丢弃掉最新的write数据。</p>
<p>同理，如果reader_page中包含commit page，也不能swap出去，只能等待。</p>
<p>1.2、“overwrite” + “2 Nested write”</p>
<p>处理的过程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// step 1: (first writer)改动标志“H”成“U”</span><br><span class="line"></span><br><span class="line">            tail page</span><br><span class="line">               |</span><br><span class="line">               v</span><br><span class="line">    +---+    +---+    +---+    +---+</span><br><span class="line">&lt;---|   |---&gt;|   |-H-&gt;|   |---&gt;|   |---&gt;</span><br><span class="line">---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---</span><br><span class="line">    +---+    +---+    +---+    +---+</span><br><span class="line">    </span><br><span class="line">            tail page</span><br><span class="line">               |</span><br><span class="line">               v</span><br><span class="line">    +---+    +---+    +---+    +---+</span><br><span class="line">&lt;---|   |---&gt;|   |-U-&gt;|   |---&gt;|   |---&gt;</span><br><span class="line">---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---</span><br><span class="line">    +---+    +---+    +---+    +---+</span><br><span class="line"></span><br><span class="line">// step 2: (second writer)设置新的head page的“H”标志，移动tail指针</span><br><span class="line"></span><br><span class="line">           tail page</span><br><span class="line">               |</span><br><span class="line">               v</span><br><span class="line">    +---+    +---+    +---+    +---+</span><br><span class="line">&lt;---|   |---&gt;|   |-U-&gt;|   |-H-&gt;|   |---&gt;</span><br><span class="line">---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---</span><br><span class="line">    +---+    +---+    +---+    +---+</span><br><span class="line">    </span><br><span class="line">                    tail page</span><br><span class="line">                        |</span><br><span class="line">                        v</span><br><span class="line">    +---+    +---+    +---+    +---+</span><br><span class="line">&lt;---|   |---&gt;|   |-U-&gt;|   |-H-&gt;|   |---&gt;</span><br><span class="line">---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---</span><br><span class="line">    +---+    +---+    +---+    +---+</span><br><span class="line">    </span><br><span class="line">// step 3: (backto first writer)清除旧指针中的“U”标志</span><br><span class="line"></span><br><span class="line">                    tail page</span><br><span class="line">                        |</span><br><span class="line">                        v</span><br><span class="line">    +---+    +---+    +---+    +---+</span><br><span class="line">&lt;---|   |---&gt;|   |---&gt;|   |-H-&gt;|   |---&gt;</span><br><span class="line">---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---</span><br><span class="line">    +---+    +---+    +---+    +---+</span><br></pre></td></tr></table></figure>
<p>1.3、“overwrite” + “3 Nested write”</p>
<p>处理的过程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">// step 1: (first writer)改动标志“H”成“U”</span><br><span class="line"></span><br><span class="line">            tail page</span><br><span class="line">               |</span><br><span class="line">               v</span><br><span class="line">    +---+    +---+    +---+    +---+</span><br><span class="line">&lt;---|   |---&gt;|   |-H-&gt;|   |---&gt;|   |---&gt;</span><br><span class="line">---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---</span><br><span class="line">    +---+    +---+    +---+    +---+</span><br><span class="line">    </span><br><span class="line">            tail page</span><br><span class="line">               |</span><br><span class="line">               v</span><br><span class="line">    +---+    +---+    +---+    +---+</span><br><span class="line">&lt;---|   |---&gt;|   |-U-&gt;|   |---&gt;|   |---&gt;</span><br><span class="line">---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---</span><br><span class="line">    +---+    +---+    +---+    +---+</span><br><span class="line">    </span><br><span class="line">// step 2: (second writer)</span><br><span class="line"></span><br><span class="line">           tail page</span><br><span class="line">               |</span><br><span class="line">               v</span><br><span class="line">    +---+    +---+    +---+    +---+</span><br><span class="line">&lt;---|   |---&gt;|   |-U-&gt;|   |-H-&gt;|   |---&gt;</span><br><span class="line">---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---</span><br><span class="line">    +---+    +---+    +---+    +---+</span><br><span class="line">    </span><br><span class="line">                    tail page</span><br><span class="line">                        |</span><br><span class="line">                        v</span><br><span class="line">    +---+    +---+    +---+    +---+</span><br><span class="line">&lt;---|   |---&gt;|   |-U-&gt;|   |-H-&gt;|   |---&gt;</span><br><span class="line">---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---</span><br><span class="line">    +---+    +---+    +---+    +---+</span><br><span class="line">    </span><br><span class="line">// step 3: (third writer)</span><br><span class="line"></span><br><span class="line">                    tail page</span><br><span class="line">                        |</span><br><span class="line">                        v</span><br><span class="line">    +---+    +---+    +---+    +---+</span><br><span class="line">&lt;---|   |---&gt;|   |-U-&gt;|   |-U-&gt;|   |---&gt;</span><br><span class="line">---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---</span><br><span class="line">    +---+    +---+    +---+    +---+</span><br><span class="line">    </span><br><span class="line">                    tail page</span><br><span class="line">                        |</span><br><span class="line">                        v</span><br><span class="line">    +---+    +---+    +---+    +---+</span><br><span class="line">&lt;---|   |---&gt;|   |-U-&gt;|   |-U-&gt;|   |-H-&gt;</span><br><span class="line">---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---</span><br><span class="line">    +---+    +---+    +---+    +---+</span><br><span class="line">    </span><br><span class="line">                    tail page</span><br><span class="line">                        |</span><br><span class="line">                        v</span><br><span class="line">    +---+    +---+    +---+    +---+</span><br><span class="line">&lt;---|   |---&gt;|   |-U-&gt;|   |---&gt;|   |-H-&gt;</span><br><span class="line">---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---</span><br><span class="line">    +---+    +---+    +---+    +---+</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">                             tail page</span><br><span class="line">                                 |</span><br><span class="line">                                 v</span><br><span class="line">    +---+    +---+    +---+    +---+</span><br><span class="line">&lt;---|   |---&gt;|   |-U-&gt;|   |---&gt;|   |-H-&gt;</span><br><span class="line">---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---</span><br><span class="line">    +---+    +---+    +---+    +---+</span><br><span class="line">    </span><br><span class="line">// step 4: (backto second writer)</span><br><span class="line"></span><br><span class="line">                             tail page</span><br><span class="line">                                 |</span><br><span class="line">                                 v</span><br><span class="line">    +---+    +---+    +---+    +---+</span><br><span class="line">&lt;---|   |---&gt;|   |-U-&gt;|   |---&gt;|   |-H-&gt;</span><br><span class="line">---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---</span><br><span class="line">    +---+    +---+    +---+    +---+</span><br><span class="line">    </span><br><span class="line">// step 5: (backto first writer)</span><br><span class="line"></span><br><span class="line">                             tail page</span><br><span class="line">                                 |</span><br><span class="line">                                 v</span><br><span class="line">    +---+    +---+    +---+    +---+</span><br><span class="line">&lt;---|   |---&gt;|   |-U-&gt;|   |---&gt;|   |-H-&gt;</span><br><span class="line">---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---</span><br><span class="line">    +---+    +---+    +---+    +---+</span><br><span class="line">    </span><br><span class="line">                             tail page</span><br><span class="line">                                 |</span><br><span class="line">                                 v</span><br><span class="line">    +---+    +---+    +---+    +---+</span><br><span class="line">&lt;---|   |---&gt;|   |-U-&gt;|   |-H-&gt;|   |-H-&gt;</span><br><span class="line">---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---</span><br><span class="line">    +---+    +---+    +---+    +---+</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">               A        B    tail page</span><br><span class="line">               |        |        |</span><br><span class="line">               v        v        v</span><br><span class="line">    +---+    +---+    +---+    +---+</span><br><span class="line">&lt;---|   |---&gt;|   |-U-&gt;|   |-H-&gt;|   |-H-&gt;</span><br><span class="line">---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---</span><br><span class="line">    +---+    +---+    +---+    +---+</span><br><span class="line">    </span><br><span class="line">               A        B    tail page</span><br><span class="line">               |        |        |</span><br><span class="line">               v        v        v</span><br><span class="line">    +---+    +---+    +---+    +---+</span><br><span class="line">&lt;---|   |---&gt;|   |-U-&gt;|   |---&gt;|   |-H-&gt;</span><br><span class="line">---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---</span><br><span class="line">    +---+    +---+    +---+    +---+</span><br><span class="line"></span><br><span class="line">               A        B    tail page</span><br><span class="line">               |        |        |</span><br><span class="line">               v        v        v</span><br><span class="line">    +---+    +---+    +---+    +---+</span><br><span class="line">&lt;---|   |---&gt;|   |---&gt;|   |---&gt;|   |-H-&gt;</span><br><span class="line">---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---</span><br><span class="line">    +---+    +---+    +---+    +---+</span><br></pre></td></tr></table></figure>
<p>2、reader_page swap时的无锁</p>
<p>综合“H”、“U”标志，来看看swap时的无锁是怎么实现的。如下图：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">// step 1: 初始状态</span><br><span class="line"></span><br><span class="line">  +------+</span><br><span class="line">  |reader|          RING BUFFER</span><br><span class="line">  |page  |</span><br><span class="line">  +------+</span><br><span class="line">                  +---+    +---+    +---+</span><br><span class="line">                  |   |---&gt;|   |---&gt;|   |</span><br><span class="line">                  |   |&lt;---|   |&lt;---|   |</span><br><span class="line">                  +---+    +---+    +---+</span><br><span class="line">                   ^ |               ^ |</span><br><span class="line">                   | +---------------+ |</span><br><span class="line">                   +-----H-------------+</span><br><span class="line">                   </span><br><span class="line">// step 2: 将reader page的next指针指向head page的下一个page</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  +------+</span><br><span class="line">  |reader|          RING BUFFER</span><br><span class="line">  |page  |-------H-----------+</span><br><span class="line">  +------+                   v</span><br><span class="line">    |             +---+    +---+    +---+</span><br><span class="line">    |             |   |---&gt;|   |---&gt;|   |</span><br><span class="line">    |             |   |&lt;---|   |&lt;---|   |&lt;-+</span><br><span class="line">    |             +---+    +---+    +---+  |</span><br><span class="line">    |              ^ |               ^ |   |</span><br><span class="line">    |              | +---------------+ |   |</span><br><span class="line">    |              +-----H-------------+   |</span><br><span class="line">    +--------------------------------------+</span><br><span class="line"></span><br><span class="line">// step 3: 这一步是免锁的关键，将header page上一page的next指针原子操作换成指向reader page</span><br><span class="line">//          这样reader page已经连接进ring buffer，和前head page swap</span><br><span class="line"></span><br><span class="line">  +------+</span><br><span class="line">  |reader|          RING BUFFER</span><br><span class="line">  |page  |-------H-----------+</span><br><span class="line">  +------+                   v</span><br><span class="line">    |  ^          +---+   +---+   +---+</span><br><span class="line">    |  |          |   |--&gt;|   |--&gt;|   |</span><br><span class="line">    |  |          |   |&lt;--|   |&lt;--|   |&lt;-+</span><br><span class="line">    |  |          +---+   +---+   +---+  |</span><br><span class="line">    |  |             |             ^ |   |</span><br><span class="line">    |  |             +-------------+ |   |</span><br><span class="line">    |  +-----------------------------+   |</span><br><span class="line">    +------------------------------------+</span><br><span class="line"></span><br><span class="line">// step 4: 将新head page的pre指针指向reader page</span><br><span class="line"></span><br><span class="line">  +------+</span><br><span class="line">  |reader|          RING BUFFER</span><br><span class="line">  |page  |-------H-----------+</span><br><span class="line">  +------+ &lt;---------------+ v</span><br><span class="line">    |  ^          +---+   +---+   +---+</span><br><span class="line">    |  |          |   |--&gt;|   |--&gt;|   |</span><br><span class="line">    |  |          |   |   |   |&lt;--|   |&lt;-+</span><br><span class="line">    |  |          +---+   +---+   +---+  |</span><br><span class="line">    |  |             |             ^ |   |</span><br><span class="line">    |  |             +-------------+ |   |</span><br><span class="line">    |  +-----------------------------+   |</span><br><span class="line">    +------------------------------------+</span><br><span class="line"></span><br><span class="line">  +------+</span><br><span class="line">  |buffer|          RING BUFFER</span><br><span class="line">  |page  |-------H-----------+  &lt;--- New head page</span><br><span class="line">  +------+ &lt;---------------+ v</span><br><span class="line">    |  ^          +---+   +---+   +---+</span><br><span class="line">    |  |          |   |   |   |--&gt;|   |</span><br><span class="line">    |  |  New     |   |   |   |&lt;--|   |&lt;-+</span><br><span class="line">    |  | Reader   +---+   +---+   +---+  |</span><br><span class="line">    |  |  page ----^                 |   |</span><br><span class="line">    |  |                             |   |</span><br><span class="line">    |  +-----------------------------+   |</span><br><span class="line">    +------------------------------------+</span><br></pre></td></tr></table></figure>
<p>2.1、判断page是否为reader page的方法</p>
<p>因为reader page被swap出来以后，本身的next、pre指针还指向原ring buffer中的page，但是这些page的指针已经不指向reader page了。</p>
<p>判断page-&gt;pre -&gt;next是否还等于自己，如果不等于page为reader page。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> +--------+</span><br><span class="line"> | reader |  next   +----+</span><br><span class="line"> |  page  |--------&gt;|    |&lt;====== (buffer page)</span><br><span class="line"> +--------+         +----+</span><br><span class="line">     |                | ^</span><br><span class="line">     |                v | next</span><br><span class="line">prev |              +----+</span><br><span class="line">     +-------------&gt;|    |</span><br><span class="line">                    +----+</span><br></pre></td></tr></table></figure>
<h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p><a href="http://blog.chinaunix.net/uid-20543183-id-1930845.html" target="_blank" rel="noopener">1、Linux内核跟踪之ring buffer的实现</a></p>
<p><a href="https://www.kernel.org/doc/Documentation/trace/ring-buffer-design.txt" target="_blank" rel="noopener">2、Lockless Ring Buffer Design</a></p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/ringbuffer/" rel="tag"># ringbuffer</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/12/21/linux_time/" rel="next" title="Linux Time">
                <i class="fa fa-chevron-left"></i> Linux Time
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/12/21/linux_device_tree/" rel="prev" title="Device Tree 详解">
                Device Tree 详解 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/touxiang/ycqs.jpg" alt="pwl999">
            
              <p class="site-author-name" itemprop="name">pwl999</p>
              <p class="site-description motion-element" itemprop="description">RTFSC(Read The Fucking Source Code)</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives">
                
                    <span class="site-state-item-count">30</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">3</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">22</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1、简介"><span class="nav-number">1.</span> <span class="nav-text">1、简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2、ringbuffer初始化"><span class="nav-number">2.</span> <span class="nav-text">2、ringbuffer初始化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3、ringbuffer的写操作"><span class="nav-number">3.</span> <span class="nav-text">3、ringbuffer的写操作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1、ring-buffer-event的存储格式"><span class="nav-number">3.1.</span> <span class="nav-text">3.1、ring_buffer_event的存储格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2、ring-buffer-event时间戳"><span class="nav-number">3.2.</span> <span class="nav-text">3.2、ring_buffer_event时间戳</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3、ring-buffer-event写入流程"><span class="nav-number">3.3.</span> <span class="nav-text">3.3、ring_buffer_event写入流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-1、ring-buffer-lock-reserve"><span class="nav-number">3.3.1.</span> <span class="nav-text">3.3.1、ring_buffer_lock_reserve()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-2、ring-buffer-unlock-commit"><span class="nav-number">3.3.2.</span> <span class="nav-text">3.3.2、ring_buffer_unlock_commit()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-3、ring-buffer-discard-commit"><span class="nav-number">3.3.3.</span> <span class="nav-text">3.3.3、ring_buffer_discard_commit()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4、ringbuffer的读操作"><span class="nav-number">4.</span> <span class="nav-text">4、ringbuffer的读操作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1、iterator读"><span class="nav-number">4.1.</span> <span class="nav-text">4.1、iterator读</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2、reader-page-swap读"><span class="nav-number">4.2.</span> <span class="nav-text">4.2、reader_page swap读</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5、ringbuffer的设计思想"><span class="nav-number">5.</span> <span class="nav-text">5、ringbuffer的设计思想  </span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1、术语"><span class="nav-number">5.1.</span> <span class="nav-text">5.1、术语</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-ring-buffer的基本概念"><span class="nav-number">5.2.</span> <span class="nav-text">5.2 ring buffer的基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-ring-buffer无锁机制的实现"><span class="nav-number">5.3.</span> <span class="nav-text">5.3 ring buffer无锁机制的实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考资料："><span class="nav-number">6.</span> <span class="nav-text">参考资料：</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">pwl999</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v6.6.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script src="/js/src/utils.js?v=6.6.0"></script>

  <script src="/js/src/motion.js?v=6.6.0"></script>



  
  


  <script src="/js/src/affix.js?v=6.6.0"></script>

  <script src="/js/src/schemes/pisces.js?v=6.6.0"></script>



  
  <script src="/js/src/scrollspy.js?v=6.6.0"></script>
<script src="/js/src/post-details.js?v=6.6.0"></script>



  


  <script src="/js/src/bootstrap.js?v=6.6.0"></script>



  

  
    <script id="dsq-count-scr" src="https://.disqus.com/count.js" async></script>
  

  





  











  





  

  

  

  

  

  
  

  

  

  

  

  

  

</body>
</html>
