<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
































<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.6.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.6.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.6.0" color="#222">









<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.6.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="关于Ftrace的使用，最权威的解读就在”Documentation/trace”文件夹下，我们挑选其中最经典的几个文件来进行翻译，加上自己理解的解读。 参考原文：ftrace - Function Tracer 1、背景：Ftrace本来设计作为一个内部的tracer提供给系统的开发者和设计者，帮助他们弄清kernel正在发生的行为。它能够调试分析延迟和性能问题。 Ftrace发展到现在已经不仅">
<meta name="keywords" content="ftrace">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux Ftrace 2.1、ftrace的使用">
<meta property="og:url" content="http://yoursite.com/2018/12/21/ftrace_use_ftrace/index.html">
<meta property="og:site_name" content="pwl999&#39;s blog">
<meta property="og:description" content="关于Ftrace的使用，最权威的解读就在”Documentation/trace”文件夹下，我们挑选其中最经典的几个文件来进行翻译，加上自己理解的解读。 参考原文：ftrace - Function Tracer 1、背景：Ftrace本来设计作为一个内部的tracer提供给系统的开发者和设计者，帮助他们弄清kernel正在发生的行为。它能够调试分析延迟和性能问题。 Ftrace发展到现在已经不仅">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-12-21T03:21:59.597Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Linux Ftrace 2.1、ftrace的使用">
<meta name="twitter:description" content="关于Ftrace的使用，最权威的解读就在”Documentation/trace”文件夹下，我们挑选其中最经典的几个文件来进行翻译，加上自己理解的解读。 参考原文：ftrace - Function Tracer 1、背景：Ftrace本来设计作为一个内部的tracer提供给系统的开发者和设计者，帮助他们弄清kernel正在发生的行为。它能够调试分析延迟和性能问题。 Ftrace发展到现在已经不仅">






  <link rel="canonical" href="http://yoursite.com/2018/12/21/ftrace_use_ftrace/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Linux Ftrace 2.1、ftrace的使用 | pwl999's blog</title>
  












  <noscript>
  <style>
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion .logo-line-before i { left: initial; }
    .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">pwl999's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/21/ftrace_use_ftrace/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="pwl999">
      <meta itemprop="description" content="RTFSC(Read The Fucking Source Code)">
      <meta itemprop="image" content="/images/touxiang/ycqs.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="pwl999's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Linux Ftrace 2.1、ftrace的使用

              
            
          </h1>
        

        <div class="post-meta">

          

        <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-21 10:18:21 / 修改时间：11:21:59" itemprop="dateCreated datePublished" datetime="2018-12-21T10:18:21+08:00">2018-12-21</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/Trace/" itemprop="url" rel="index"><span itemprop="name">Trace</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>关于Ftrace的使用，最权威的解读就在”Documentation/trace”文件夹下，我们挑选其中最经典的几个文件来进行翻译，加上自己理解的解读。</p>
<p>参考原文：<a href="https://www.kernel.org/doc/html/latest/trace/ftrace.html" target="_blank" rel="noopener">ftrace - Function Tracer</a></p>
<h1 id="1、背景："><a href="#1、背景：" class="headerlink" title="1、背景："></a>1、背景：</h1><p>Ftrace本来设计作为一个内部的tracer提供给系统的开发者和设计者，帮助他们弄清kernel正在发生的行为。它能够调试分析延迟和性能问题。</p>
<p>Ftrace发展到现在已经不仅仅是作为一个function tracer了，它实际上成为了一个通用的trace工具框架：</p>
<ul>
<li>一方面tracer已经从function tracer扩展到irqsoff tracer(trace关中断时间)、preemptoff tracer等；</li>
<li>另一方面静态的trace event也成为trace的一个重要组成部分；</li>
</ul>
<h1 id="2、文件接口"><a href="#2、文件接口" class="headerlink" title="2、文件接口"></a>2、文件接口</h1><p>整个trace对应的操作目录增加到/etc/fstab，在系统启动时挂载：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tracefs       /sys/kernel/tracing       tracefs defaults        0       0</span><br></pre></td></tr></table></figure>
<p>或者运行时手工挂载：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t tracefs nodev /sys/kernel/tracing</span><br></pre></td></tr></table></figure>
<p>在4.1版本以前的，trace目录在以下路径：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/sys/kernel/debug/tracing</span><br></pre></td></tr></table></figure>
<p>我们用列表来遍历“tracing/”文件夹下每一个文件的作用和描述：</p>
<table border="1"><br><caption> tracing/ </caption><br><br><br><tr><br><th style="width: 100px;">file</th><br><th style="width: 300px;">Description</th><br><th style="width: 100px;">所属模块</th><br><th style="width: 300px;">说明</th><br></tr><br><br><br><tr><br><td> current_tracer </td><br><td><br>This is used to set or display the current tracer that is configured.<br></td><br><td> tracer_comm </td><br><td><br>显示当前使用的tracer，默认是nop。<br><pre><br> # cat current_tracer<br>nop<br></pre><br></td><br></tr><br><br><br><tr><br><td> available_tracers </td><br><td><br>This holds the different types of tracers that have been compiled into the kernel. The tracers listed here can be configured by echoing their name into current_tracer.<br></td><br><td> tracer_comm </td><br><td><br>列出当前已经注册的tracer<br><pre><br> # cat available_tracers<br>blk function_graph preemptirqsoff preemptoff irqsoff function nop<br></pre><br></td><br></tr><br><br><br><tr><br><td> tracing_on </td><br><td><br>This sets or displays whether writing to the trace ring buffer is enabled. Echo 0 into this file to disable the tracer or 1 to enable it. Note, this only disables writing to the ring buffer, the tracing overhead may still be occurring.<br><br>The kernel function tracing_off() can be used within the kernel to disable writing to the ring buffer, which will set this file to “0”. User space can re-enable tracing by echoing “1” into the file.<br><br>Note, the function and event trigger “traceoff” will also set this file to zero and stop tracing. Which can also be re-enabled by user space using this file.<br></td><br><td> ring buffer </td><br><td><br>0: disable ring buffer<br><br>1: enable ring buffer<br><br>这个仅仅只是禁止数据写入ring buffer，但是各种桩函数还是被调用，trace动作仍然发生，开销依然存在。<br></td><br></tr><br><br><br><tr><br><td> trace </td><br><td><br>This file holds the output of the trace in a human readable format (described below). Note, tracing is temporarily disabled while this file is being read (opened).<br></td><br><td> comm </td><br><td><br>该文件把ringbuffer数据输出成用户可读的格式。<br><br><br>注意：在这个文件open时，ring buffer是临时关闭的。<br><br>读操作并不会清除掉ring buffer中的数据，可以重复读；<br></td><br></tr><br><br><br><tr><br><td> trace_pipe </td><br><td><br>The output is the same as the “trace” file but this file is meant to be streamed with live tracing. Reads from this file will block until new data is retrieved. Unlike the “trace” file, this file is a consumer. This means reading from this file causes sequential reads to display more current data. Once data is read from this file, it is consumed, and will not be read again with a sequential read. The “trace” file is static, and if the tracer is not adding more data, it will display the same information every time it is read. This file will not disable tracing while being read.<br></td><br><td> comm </td><br><td><br>文件内容和“trace”文件是一样的，区别在于：<br><br><br>1、并行读，读操作不会disable写操作；<br><br>2、只支持读一次，该读操作会清除掉ring buffer中的数据，再次去读没有内容了；<br></td><br></tr><br><br><br><tr><br><td> trace_options </td><br><td><br>This file lets the user control the amount of data that is displayed in one of the above output files. Options also exist to modify how a tracer or events work (stack traces, timestamps, etc).<br></td><br><td> comm </td><br><td><br>一些通用的trace相关的option。<br><pre><br> # cat trace_options<br>print-parent<br>nosym-offset<br>nosym-addr<br>noverbose<br>noraw<br>nohex<br>nobin<br>noblock<br>trace_printk<br>annotate<br>nouserstacktrace<br>nosym-userobj<br>noprintk-msg-only<br>context-info<br>nolatency-format<br>record-cmd<br>overwrite<br>nodisable_on_free<br>irq-info<br>markers<br>function-trace<br>nodisplay-graph<br>nostacktrace<br>noprint-tgid<br>notest_nop_accept<br></pre><br>echo xxx &gt; trace_options    // enable xxx option<br><br>echo noxxx &gt; trace_options  // disable xxx option<br><br></td><br></tr><br><br><br><tr><br><td> options </td><br><td><br>This is a directory that has a file for every available trace option (also in trace_options). Options may also be set or cleared by writing a “1” or “0” respectively into the corresponding file with the option name.<br></td><br><td> tracer_comm </td><br><td><br>“options”是一个文件夹，包含了所有注册的tracer可配置的option。<br><pre><br> # ls options/<br>annotate<br>bin<br>blk_classic<br>block<br>context-info<br>disable_on_free<br>display-graph<br>func_stack_trace<br>funcgraph-abstime<br>funcgraph-cpu<br>funcgraph-duration<br>funcgraph-flat<br>funcgraph-irqs<br>funcgraph-overhead<br>funcgraph-overrun<br>funcgraph-proc<br>funcgraph-tail<br>function-trace<br>graph-time<br>hex<br>irq-info<br>latency-format<br>markers<br>overwrite<br>print-parent<br>print-tgid<br>printk-msg-only<br>raw<br>record-cmd<br>sleep-time<br>stacktrace<br>sym-addr<br>sym-offset<br>sym-userobj<br>test_nop_accept<br>test_nop_refuse<br>trace_printk<br>userstacktrace<br>verbose<br></pre><br>echo 1 &gt; options/xxx    // enable xxx tracer option<br><br>echo 0 &gt; options/xxx    // disable xxx tracer option<br><br></td><br></tr><br><br><br><tr><br><td> tracing_max_latency </td><br><td><br>Some of the tracers record the max latency. For example, the maximum time that interrupts are disabled. The maximum time is saved in this file. The max trace will also be stored, and displayed by “trace”. A new max trace will only be recorded if the latency is greater than the value in this file (in microseconds).<br><br><br>By echoing in a time into this file, no latency will be recorded unless it is greater than the time in this file.<br></td><br><td> tracer_comm </td><br><td><br>某些tracer用来记录最大latency。例如，最大中断disable时间。<br><br>最大时间被记录到本文件，对应的trace被记录到“trace”文件。<br><br>新的trace最有大于现在的max latency胡，才会被记录。<br><br><br>echo xxx &gt; tracing_max_latency // 手工设置一个门限，只有大于门限才会被记录。<br><br></td><br></tr><br><br><br><tr><br><td> tracing_thresh </td><br><td><br>Some latency tracers will record a trace whenever the latency is greater than the number in this file. Only active when the file contains a number greater than 0. (in microseconds)<br></td><br><td> tracer_comm </td><br><td><br>有一些latency tracers判断latency大于本文件的标值才会被记录。只有值大于0才会被激活。<br></td><br></tr><br><br><br><tr><br><td> buffer_size_kb </td><br><td><br>This sets or displays the number of kilobytes each CPU buffer holds. By default, the trace buffers are the same size for each CPU. The displayed number is the size of the CPU buffer and not total size of all buffers. The trace buffers are allocated in pages (blocks of memory that the kernel uses for allocation, usually 4 KB in size). If the last page allocated has room for more bytes than requested, the rest of the page will be used, making the actual allocation bigger than requested or shown. ( Note, the size may not be a multiple of the page size due to buffer management meta-data. )<br><br><br><br>Buffer sizes for individual CPUs may vary (see “per_cpu/cpu0/buffer_size_kb” below), and if they do this file will show “X”.<br></td><br><td> ring buffer </td><br><td><br>设置ring buffer在每个cpu上的大小。<br><br><br>默认在每个cpu上大小都是相等的，如果显示“X”，查看“per_cpu/cpu0/buffer_size_kb”具体每个cpu的大小。<br><pre><br> # cat buffer_size_kb<br>1410<br></pre><br></td><br></tr><br><br><br><tr><br><td> buffer_total_size_kb </td><br><td><br>This displays the total combined size of all the trace buffers.<br></td><br><td> ring buffer </td><br><td><br>ring buffer总的的大小<br><pre><br> # cat buffer_total_size_kb<br>11280<br></pre><br></td><br></tr><br><br><br><tr><br><td> free_buffer </td><br><td><br>If a process is performing tracing, and the ring buffer should be shrunk “freed” when the process is finished, even if it were to be killed by a signal, this file can be used for that purpose. On close of this file, the ring buffer will be resized to its minimum size. Having a process that is tracing also open this file, when the process exits its file descriptor for this file will be closed, and in doing so, the ring buffer will be “freed”.<br><br><br><br>It may also stop tracing if disable_on_free option is set.<br></td><br><td> ring buffer </td><br><td><br>本文件用来控制ring buffer的free，当free时ring buffer被resize到它的最小尺寸。<br><br><br>使用方法：<br><br>当进程不需要使用ring buffer了，他open“free_buffer”并且close文件，ring buffer会被resize到最小尺寸。<br></td><br></tr><br><br><br><tr><br><td> tracing_cpumask </td><br><td><br>This is a mask that lets the user only trace on specified CPUs. The format is a hex string representing the CPUs.<br></td><br><td> ring buffer </td><br><td><br>独立控制在每个cpu上是否开trace功能。<br><pre><br> # cat tracing_cpumask<br>ff<br></pre><br></td><br></tr><br><br><br><tr><br><td> set_ftrace_filter </td><br><td><br>When dynamic ftrace is configured in (see the section below “dynamic ftrace”), the code is dynamically modified (code text rewrite) to disable calling of the function profiler (mcount). This lets tracing be configured in with practically no overhead in performance. This also has a side effect of enabling or disabling specific functions to be traced. Echoing names of functions into this file will limit the trace to only those functions.<br><br><br><br>The functions listed in “available_filter_functions” are what can be written into this file.<br><br><br><br>This interface also allows for commands to be used. See the “Filter commands” section for more details.<br><br><br></td><br><td> tracer_function </td><br><td><br>function tracer的filter。<br><br>dynamic ftrace是通过动态修改函数代码来插入桩函数的，这让对没有被trace的函数的影响降到了最低。<br><br><br>需要使用dynamic ftrace跟踪哪些函数：echo 函数名 &gt; set_ftrace_filter<br><pre><br> # cat set_ftrace_filter<br> #### all functions enabled ####<br> # echo schedule &gt; set_ftrace_filter<br> # cat set_ftrace_filter<br>schedule<br> # echo scheduler_tick &gt;&gt; set_ftrace_filter<br> # cat set_ftrace_filter<br>scheduler_tick<br>schedule<br></pre><br></td><br></tr><br><br><br><tr><br><td> set_ftrace_notrace </td><br><td><br>This has an effect opposite to that of set_ftrace_filter. Any function that is added here will not be traced. If a function exists in both set_ftrace_filter and set_ftrace_notrace, the function will <em>not</em> be traced.<br></td><br><td> tracer_function </td><br><td><br>function tracer的filter。<br><br>和“set_ftrace_filter”的作用相反，设置哪些函数不要被trace。<br><br><br>如果同一函数在“set_ftrace_filter”和“set_ftrace_notrace”中同时被设置，效果等同于没有trace。<br><pre><br> # cat set_ftrace_notrace<br> #### no functions disabled ####<br></pre><br></td><br></tr><br><br><br><tr><br><td> set_ftrace_pid </td><br><td><br>Have the function tracer only trace the threads whose PID are listed in this file.<br><br><br><br>If the “function-fork” option is set, then when a task whose PID is listed in this file forks, the child’s PID will automatically be added to this file, and the child will be traced by the function tracer as well. This option will also cause PIDs of tasks that exit to be removed from the file.<br></td><br><td> tracer_function </td><br><td><br>function tracer的filter。<br><br>function tracer只追踪这个文件描述的PID。<br><pre><br> # cat set_ftrace_pid<br>no pid<br></pre><br></td><br></tr><br><br><tr><br><td> set_event_pid </td><br><td><br>Have the events only trace a task with a PID listed in this file. Note, sched_switch and sched_wake_up will also trace events listed in this file.<br><br><br><br>To have the PIDs of children of tasks with their PID in this file added on fork, enable the “event-fork” option. That option will also cause the PIDs of tasks to be removed from this file when the task exits.<br></td><br><td> trace_event </td><br><td><br>trace event的filter。<br><br>只有本文件描述的PID的进程，才会记录其trace event。<br></td><br></tr><br><br><br><tr><br><td> set_graph_function </td><br><td><br>Functions listed in this file will cause the function graph tracer to only trace these functions and the functions that they call. (See the section “dynamic ftrace” for more details).<br></td><br><td> tracer_function_graph </td><br><td><br>function graph tracer的filter。<br><br>function graph tracer仅仅trace在本文件中描述的函数。<br></td><br></tr><br><br><br><tr><br><td> set_graph_notrace </td><br><td><br>Similar to set_graph_function, but will disable function graph tracing when the function is hit until it exits the function. This makes it possible to ignore tracing functions that are called by a specific function.<br></td><br><td> tracer_function_graph </td><br><td><br>function graph tracer的filter。<br><br>和“set_graph_function”功能相反，function graph tracer不trace在本文件中描述的函数。<br></td><br></tr><br><br><br><tr><br><td> available_filter_functions </td><br><td><br>This lists the functions that ftrace has processed and can trace. These are the function names that you can pass to “set_ftrace_filter” or “set_ftrace_notrace”. (See the section “dynamic ftrace” below for more details.)<br></td><br><td> tracer_function、tracer_function_graph </td><br><td><br>有效的可以被设置为filter的函数名。<br></td><br></tr><br><br><br><tr><br><td> dyn_ftrace_total_info </td><br><td><br>This file is for debugging purposes. The number of functions that have been converted to nops and are available to be traced.<br></td><br><td> tracer_function </td><br><td><br>该文件是调试目的，有多少个函数的桩函数被dynamic ftrace转换成nop可以被追踪。<br><pre><br> # cat dyn_ftrace_total_info<br>49099<br></pre><br></td><br></tr><br><br><br><tr><br><td> enabled_functions </td><br><td><br>This file is more for debugging ftrace, but can also be useful in seeing if any function has a callback attached to it. Not only does the trace infrastructure use ftrace function trace utility, but other subsystems might too. This file displays all functions that have a callback attached to them as well as the number of callbacks that have been attached. Note, a callback may also call multiple functions which will not be listed in this count.<br><br><br><br>If the callback registered to be traced by a function with the “save regs” attribute (thus even more overhead), a ‘R’ will be displayed on the same line as the function that is returning registers.<br><br><br><br>If the callback registered to be traced by a function with the “ip modify” attribute (thus the regs-&gt;ip can be changed), an ‘I’ will be displayed on the same line as the function that can be overridden.<br><br><br><br>If the architecture supports it, it will also show what callback is being directly called by the function. If the count is greater than 1 it most likely will be ftrace_ops_list_func().<br><br><br><br>If the callback of the function jumps to a trampoline that is specific to a the callback and not the standard trampoline, its address will be printed as well as the function that the trampoline calls.<br></td><br><td> tracer_function </td><br><td><br>该文件用来调试ftrace的，它可以显示所有attach了回调函数的函数。<br><pre><br> # cat set_ftrace_filter<br>scheduler_tick<br>schedule<br> # echo function &gt; current_tracer<br> # cat enabled_functions<br>scheduler_tick (1)<br>schedule (1)<br></pre><br></td><br></tr><br><br><br><tr><br><td> function_profile_enabled </td><br><td><br>When set it will enable all functions with either the function tracer, or if configured, the function graph tracer. It will keep a histogram of the number of functions that were called and if the function graph tracer was configured, it will also keep track of the time spent in those functions. The histogram content can be displayed in the files:<br><br><br><br>trace_stats/function<cpu> ( function0, function1, etc).<br></cpu></td><br><td> tracer_function、tracer_function_graph </td><br><td><br>开始统计功能<br></td><br></tr><br><br><br><tr><br><td> trace_stats </td><br><td><br>A directory that holds different tracing stats.<br></td><br><td> tracer_function、tracer_function_graph </td><br><td><br><br></td><br></tr><br><br><br><tr><br><td> kprobe_events </td><br><td><br>Enable dynamic trace points. See kprobetrace.txt.<br></td><br><td> trace_event_kprobe </td><br><td><br>通过kprobe动态的创建trace event。而通过TRACE_EVENT()宏定义的都是静态的trace event。<br></td><br></tr><br><br><br><tr><br><td> kprobe_profile </td><br><td><br>Dynamic trace points stats. See kprobetrace.txt.<br></td><br><td> trace_event_kprobe </td><br><td><br>kprobe trace_event的统计。<br></td><br></tr><br><br><br><tr><br><td> max_graph_depth </td><br><td><br>Used with the function graph tracer. This is the max depth it will trace into a function. Setting this to a value of one will show only the first kernel function that is called from user space.<br></td><br><td> tracer_function_graph </td><br><td><br>function graph tracer显示函数调用关系的层级。<br></td><br></tr><br><br><br><tr><br><td> printk_formats </td><br><td><br>This is for tools that read the raw format files. If an event in the ring buffer references a string, only a pointer to the string is recorded into the buffer and not the string itself. This prevents tools from knowing what that string was. This file displays the string and address for the string allowing tools to map the pointers to what the strings were.<br></td><br><td> trace_printk </td><br><td><br>使用trace_printk()打印数据的格式化字符串。<br><br>使用“trace”文件读取ringbuffer中trace_printk()打印的数据时，需要知道解析格式。这个文件保存了所有的trace_printk()的打印格式。<br><pre><br> # more printk_formats<br>0x0 : “%u, %u\n”<br>0x0 : “%u, %u\n”<br></pre><br></td><br></tr><br><br><br><tr><br><td> saved_cmdlines </td><br><td><br>Only the pid of the task is recorded in a trace event unless the event specifically saves the task comm as well. Ftrace makes a cache of pid mappings to comms to try to display comms for events. If a pid for a comm is not listed, then “&lt;…&gt;” is displayed in the output.<br><br><br><br>If the option “record-cmd” is set to “0”, then comms of tasks will not be saved during recording. By default, it is enabled.<br></td><br><td> comm </td><br><td><br>ftrace建立起了一个cache，用来记录进程“pid”和“comms”之间的映射关系，在输出时能根据pid快速查找到进程的comms。如果进程的comms没有缓冲，使用空白填充 “&lt;…&gt;” 。<br><pre><br> # cat saved_cmdlines<br>19464 sensors.qcom<br>14 ksoftirqd/1<br>2164 Thread-6<br>7350 RxSchedulerPur<br>19419 kworker/1:2<br>547 kworker/2:1H<br>420 mmc-cmdqd/0<br>1775 PowerManagerSe<br>4710 HandlerThread[<br>2971 Binder:1569_8<br>1097 rild<br>2564 RILReceiver0<br>19465 rild<br>58 mpss_smem_glin<br>57 smem_native_mp<br></pre><br></td><br></tr><br><br><br><tr><br><td> saved_cmdlines_size </td><br><td><br>By default, 128 comms are saved (see “saved_cmdlines” above). To increase or decrease the amount of comms that are cached, echo in a the number of comms to cache, into this file.<br></td><br><td> comm </td><br><td><br>saved_cmdlines这块cache的大小<br></td><br></tr><br><br><br><tr><br><td> saved_tgids </td><br><td><br>If the option “record-tgid” is set, on each scheduling context switch the Task Group ID of a task is saved in a table mapping the PID of the thread to its TGID. By default, the “record-tgid” option is disabled.<br></td><br><td> comm </td><br><td><br>如果“record-tgid”选项被使能，PID对应的TGID映射也会被记录。<br></td><br></tr><br><br><br><tr><br><td> snapshot </td><br><td><br>This displays the “snapshot” buffer and also lets the user take a snapshot of the current running trace. See the “Snapshot” section below for more details.<br></td><br><td> comm </td><br><td><br>显示“snapshot”缓存中的内存，类似“trace”文件。<br><br><br>snapshot对应一块独立的ring buffer，用来快照ring buffer中的内容。<br></td><br></tr><br><br><br><tr><br><td> stack_max_size </td><br><td><br>When the stack tracer is activated, this will display the maximum stack size it has encountered. See the “Stack Trace” section below.<br></td><br><td> tracer_stack</td><br><td><br>stack tracer遭遇到的最大的堆栈尺寸。<br></td><br></tr><br><br><br><tr><br><td> stack_trace </td><br><td><br>This displays the stack back trace of the largest stack that was encountered when the stack tracer is activated. See the “Stack Trace” section below.<br></td><br><td> tracer_stack </td><br><td><br>stack tracer遭遇到的最大的堆栈的具体的回调情况。<br></td><br></tr><br><br><br><tr><br><td> stack_trace_filter </td><br><td><br>This is similar to “set_ftrace_filter” but it limits what functions the stack tracer will check.<br></td><br><td> tracer_stack </td><br><td><br>stack tracer的filter。<br><br>指示哪些函数可以被stack tracer跟踪。<br></td><br></tr><br><br><br><tr><br><td> trace_clock </td><br><td><br>Whenever an event is recorded into the ring buffer, a “timestamp” is added. This stamp comes from a specified clock. By default, ftrace uses the “local” clock. This clock is very fast and strictly per cpu, but on some systems it may not be monotonic with respect to other CPUs. In other words, the local clocks may not be in sync with local clocks on other CPUs.<br><br><br><br>Usual clocks for tracing:<br><br><br><pre><br> # cat trace_clock<br>[local] global counter x86-tsc<br></pre><br><br>The clock with the square brackets around it is the one in effect.<br><br>local:<br><br>    Default clock, but may not be in sync across CPUs<br><br>global:<br><br>    This clock is in sync with all CPUs but may be a bit slower than the local clock.<br><br>counter:<br><br>    This is not a clock at all, but literally an atomic counter. It counts up one by one, but is in sync with all CPUs. This is useful when you need to know exactly the order events occurred with respect to each other on different CPUs.<br><br>uptime:<br><br>    This uses the jiffies counter and the time stamp is relative to the time since boot up.<br><br>perf:<br><br>    This makes ftrace use the same clock that perf uses. Eventually perf will be able to read ftrace buffers and this will help out in interleaving the data.<br><br>x86-tsc:<br><br>    Architectures may define their own clocks. For example, x86 uses its own TSC cycle clock here.<br><br>ppc-tb:<br><br>    This uses the powerpc timebase register value. This is in sync across CPUs and can also be used to correlate events across hypervisor/guest if tb_offset is known.<br><br>mono:<br><br>    This uses the fast monotonic clock (CLOCK_MONOTONIC) which is monotonic and is subject to NTP rate adjustments.<br><br>mono_raw:<br><br>    This is the raw monotonic clock (CLOCK_MONOTONIC_RAW) which is montonic but is not subject to any rate adjustments and ticks at the same rate as the hardware clocksource.<br><br>boot:<br><br>    This is the boot clock (CLOCK_BOOTTIME) and is based on the fast monotonic clock, but also accounts for time spent in suspend. Since the clock access is designed for use in tracing in the suspend path, some side effects are possible if clock is accessed after the suspend time is accounted before the fast mono clock is updated. In this case, the clock update appears to happen slightly sooner than it normally would have. Also on 32-bit systems, it’s possible that the 64-bit boot offset sees a partial update. These effects are rare and post processing should be able to handle them. See comments in the ktime_get_boot_fast_ns() function for more information.<br><br><br><br>To set a clock, simply echo the clock name into this file:<br><br><br><pre><br> # echo global &gt; trace_clock<br></pre><br></td><br><td> ring buffer </td><br><td><br>ring buffer记录时间戳所使用的时钟源。<br><br><pre><br> # cat trace_clock<br>[local] global counter uptime perf mono mono_raw<br></pre><br></td><br></tr><br><br><br><tr><br><td> trace_marker </td><br><td><br>This is a very useful file for synchronizing user space with events happening in the kernel. Writing strings into this file will be written into the ftrace buffer.<br><br>It is useful in applications to open this file at the start of the application and just reference the file descriptor for the file:<br><br><pre><br>void trace_write(const char *fmt, …)<br>{<br>        va_list ap;<br>        char buf[256];<br>        int n;<br><br>        if (trace_fd &lt; 0)<br>                return;<br><br>        va_start(ap, fmt);<br>        n = vsnprintf(buf, 256, fmt, ap);<br>        va_end(ap);<br><br>        write(trace_fd, buf, n);<br>}<br></pre><br>start:<br><pre><br>trace_fd = open(“trace_marker”, WR_ONLY);<br></pre><br></td><br><td> ring buffer </td><br><td><br>该文件运行用户态直接写内容到ring buffer，通常用来同步用户态和内核态的事件。<br></td><br></tr><br><br><tr><br><td> trace_marker_raw </td><br><td><br>This is similar to trace_marker above, but is meant for for binary data to be written to it, where a tool can be used to parse the data from trace_pipe_raw.<br></td><br><td> ring buffer </td><br><td><br>和“trace_marker”类似，但是写入的是二进制格式。工具可以解析数据通过“trace_pipe_raw”。<br></td><br></tr><br><br><br><tr><br><td> uprobe_events </td><br><td><br>Add dynamic tracepoints in programs. See uprobetracer.txt<br></td><br><td> trace_event_uprobe </td><br><td><br>通过uprobe动态的创建trace event。而通过TRACE_EVENT()宏定义的都是静态的trace event。<br></td><br></tr><br><br><br><tr><br><td> uprobe_profile </td><br><td><br>Uprobe statistics. See uprobetrace.txt<br></td><br><td> trace_event_uprobe </td><br><td><br>Uprobe的统计功能<br></td><br></tr><br><br><br><tr><br><td> instances </td><br><td><br>This is a way to make multiple trace buffers where different events can be recorded in different buffers. See “Instances” section below.<br></td><br><td> ring buffer </td><br><td><br>这是一个创建多个ring buffer的方法，可以让不同的events使用不同的ring buffer。<br></td><br></tr><br><br><br><tr><br><td> events </td><br><td><br>This is the trace event directory. It holds event tracepoints (also known as static tracepoints) that have been compiled into the kernel. It shows what event tracepoints exist and how they are grouped by system. There are “enable” files at various levels that can enable the tracepoints when a “1” is written to them.<br><br><br><br>See events.txt for more information.<br></td><br><td> trace_event </td><br><td><br>trace event的文件夹，包含所有通过TRACE_EVENT()宏定义的静态event 和 通过kprobe、uprobe定义的动态event。<br></td><br></tr><br><br><br><tr><br><td> set_event </td><br><td><br>By echoing in the event into this file, will enable that event.<br><br><br><br>See events.txt for more information.<br></td><br><td> trace_event </td><br><td><br>使能trace event。<br><br><br><br>echo xxxevent &gt; set_event // enbale对应的xxxevent<br></td><br></tr><br><br><br><tr><br><td> available_events </td><br><td><br>A list of events that can be enabled in tracing.<br><br><br><br>See events.txt for more information.<br></td><br><td> trace_event </td><br><td><br>列出所有有效的event。相当于“events”文件夹中所有event名字的集合。<br></td><br></tr><br><br><br><tr><br><td> timestamp_mode </td><br><td><br>Certain tracers may change the timestamp mode used when logging trace events into the event buffer. Events with different modes can coexist within a buffer but the mode in effect when an event is logged determines which timestamp mode is used for that event. The default timestamp mode is ‘delta’.<br><br><br>Usual timestamp modes for tracing:<br><pre><br> # cat timestamp_mode<br>[delta] absolute<br></pre><br>The timestamp mode with the square brackets around it is the one in effect.<br><br>delta: Default timestamp mode - timestamp is a delta against a per-buffer timestamp.<br>absolute: The timestamp is a full timestamp, not a delta against some other value. As such it takes up more space and is less efficient.<br></td><br><td> ring buffer </td><br><td><br>配置ring buffer中的时间戳为delta mode还是absolute 模式。<br><br></td><br></tr><br><br><br><tr><br><td> hwlat_detector </td><br><td><br>Directory for the Hardware Latency Detector. See “Hardware Latency Detector” section below.<br></td><br><td> comm </td><br><td><br>Hardware Latency Detector文件夹<br></td><br></tr><br><br><br><tr><br><td> per_cpu </td><br><td><br>This is a directory that contains the trace per_cpu information.<br></td><br><td> per_cpu </td><br><td><br>per cpu的文件夹<br></td><br></tr><br><br><br><tr><br><td> per_cpu/cpu0/buffer_size_kb </td><br><td><br>The ftrace buffer is defined per_cpu. That is, there’s a separate buffer for each CPU to allow writes to be done atomically, and free from cache bouncing. These buffers may have different size buffers. This file is similar to the buffer_size_kb file, but it only displays or sets the buffer size for the specific CPU. (here cpu0).<br></td><br><td> per_cpu </td><br><td><br><br></td><br></tr><br><br><br><tr><br><td> per_cpu/cpu0/trace </td><br><td><br>This is similar to the “trace” file, but it will only display the data specific for the CPU. If written to, it only clears the specific CPU buffer.<br></td><br><td> per_cpu </td><br><td><br>单个cpu上的trace信息<br></td><br></tr><br><br><br><tr><br><td> per_cpu/cpu0/trace_pipe </td><br><td><br>This is similar to the “trace_pipe” file, and is a consuming read, but it will only display (and consume) the data specific for the CPU.<br></td><br><td> per_cpu </td><br><td><br>单个cpu上的trace_pipe信息<br></td><br></tr><br><br><br><tr><br><td> per_cpu/cpu0/trace_pipe_raw </td><br><td><br>For tools that can parse the ftrace ring buffer binary format, the trace_pipe_raw file can be used to extract the data from the ring buffer directly. With the use of the splice() system call, the buffer data can be quickly transferred to a file or to the network where a server is collecting the data.<br><br><br><br>Like trace_pipe, this is a consuming reader, where multiple reads will always produce different data.<br></td><br><td> per_cpu </td><br><td><br>如果工具可以自己解析二进制数据，那么可以通过“trace_pipe_raw”文件来读取ring buffer数据，这样速度更快。类似于“trace_pipe”，也是一次性读。<br></td><br></tr><br><br><br><tr><br><td> per_cpu/cpu0/snapshot </td><br><td><br>This is similar to the main “snapshot” file, but will only snapshot the current CPU (if supported). It only displays the content of the snapshot for a given CPU, and if written to, only clears this CPU buffer.<br></td><br><td> per_cpu </td><br><td><br>单个cpu上的snapshot<br></td><br></tr><br><br><br><tr><br><td> per_cpu/cpu0/snapshot_raw </td><br><td><br>Similar to the trace_pipe_raw, but will read the binary format from the snapshot buffer for the given CPU.<br></td><br><td> per_cpu </td><br><td><br>单个cpu上的raw snapshot，返回二进制信息，由工具自己解析。<br></td><br></tr><br><br><br><tr><br><td> per_cpu/cpu0/stats </td><br><td><br>This displays certain stats about the ring buffer:<br><br><br><br>entries:<br><br>    The number of events that are still in the buffer.<br><br>overrun:<br><br>    The number of lost events due to overwriting when the buffer was full.<br><br>commit overrun:<br><br>    Should always be zero. This gets set if so many events happened within a nested event (ring buffer is re-entrant), that it fills the buffer and starts dropping events.<br><br>bytes:<br><br>    Bytes actually read (not overwritten).<br><br>oldest event ts:<br><br>    The oldest timestamp in the buffer<br><br>now ts:<br><br>    The current timestamp<br><br>dropped events:<br><br>    Events lost due to overwrite option being off.<br><br>read events:<br><br>    The number of events read.<br><br></td><br><td> per_cpu </td><br><td><br>显示每个cpu的ring buffer统计：<br><pre><br>per_cpu/cpu0 # cat stats<br>entries: 243<br>overrun: 4268740<br>commit overrun: 0<br>bytes: 8144<br>oldest event ts: 94221.885584<br>now ts: 94222.755451<br>dropped events: 0<br>read events: 0<br></pre><br></td><br></tr><br><br></table>


<h1 id="3、Tracers"><a href="#3、Tracers" class="headerlink" title="3、Tracers"></a>3、Tracers</h1><p>目前支持的Tracer有以下这些：</p>
<table border="1"><br><caption> Tracer </caption><br><br><br><tr><br><th style="width: 200px;">Tracer</th><br><th style="width: 400px;">Description</th><br><th style="width: 400px;">说明</th><br></tr><br><br><br><tr><br><td> function </td><br><td><br>Function call tracer to trace all kernel functions.<br></td><br><td><br>追踪所有的内核函数<br></td><br></tr><br><br><br><tr><br><td> function_graph </td><br><td><br>Similar to the function tracer except that the function tracer probes the functions on their entry whereas the function graph tracer traces on both entry and exit of the functions. It then provides the ability to draw a graph of function calls similar to C code source.<br></td><br><td><br>和“function tracer”比较类似，但它除了探测函数的入口还探测函数的出口。它可以画出一个图形化的函数调用，类似于c源代码风格。<br></td><br></tr><br><br><br><tr><br><td> blk </td><br><td><br>The block tracer. The tracer used by the blktrace user application.<br></td><br><td><br>块设备tracer<br></td><br></tr><br><br><br><tr><br><td> hwlat </td><br><td><br>The Hardware Latency tracer is used to detect if the hardware produces any latency. See “Hardware Latency Detector” section below.<br></td><br><td><br>用来侦测硬件产生的延迟。<br></td><br></tr><br><br><br><tr><br><td> irqsoff </td><br><td><br>Traces the areas that disable interrupts and saves the trace with the longest max latency. See tracing_max_latency. When a new max is recorded, it replaces the old trace. It is best to view this trace with the latency-format option enabled, which happens automatically when the tracer is selected.<br></td><br><td><br>追踪最大关闭中断时间。<br></td><br></tr><br><br><br><tr><br><td> preemptoff </td><br><td><br>Similar to irqsoff but traces and records the amount of time for which preemption is disabled.<br></td><br><td><br>追踪最大关闭抢占时间。<br></td><br></tr><br><br><br><tr><br><td> preemptirqsoff </td><br><td><br>Similar to irqsoff and preemptoff, but traces and records the largest time for which irqs and/or preemption is disabled.<br></td><br><td><br>追踪 关闭中断 and/or 关闭抢占 的最大时间。<br></td><br></tr><br><br><br><tr><br><td> wakeup </td><br><td><br>Traces and records the max latency that it takes for the highest priority task to get scheduled after it has been woken up. Traces all tasks as an average developer would expect.<br></td><br><td><br>追踪最高优先级普通任务从获得调度到被唤醒的最大延迟时间。<br></td><br></tr><br><br><br><tr><br><td> wakeup_rt </td><br><td><br>Traces and records the max latency that it takes for just RT tasks (as the current “wakeup” does). This is useful for those interested in wake up timings of RT tasks.<br></td><br><td><br>追踪RT类型的任务从获得调度到被唤醒的最大延迟时间。<br></td><br></tr><br><br><br><tr><br><td> wakeup_dl </td><br><td><br>Traces and records the max latency that it takes for a SCHED_DEADLINE task to be woken (as the “wakeup” and “wakeup_rt” does).<br></td><br><td><br>追踪Deadline类型的任务从获得调度到被唤醒的最大延迟时间。<br></td><br></tr><br><br><br><tr><br><td> mmiotrace </td><br><td><br>A special tracer that is used to trace binary module. It will trace all the calls that a module makes to the hardware. Everything it writes and reads from the I/O as well.<br></td><br><td><br>追踪硬件IO<br></td><br></tr><br><br><br><tr><br><td> branch </td><br><td><br>This tracer can be configured when tracing likely/unlikely calls within the kernel. It will trace when a likely and unlikely branch is hit and if it was correct in its prediction of being correct.<br></td><br><td><br>追踪likely/unlikely的分支预测情况<br></td><br></tr><br><br><br><tr><br><td> nop </td><br><td><br>This is the “trace nothing” tracer. To remove all tracers from tracing simply echo “nop” into current_tracer.<br></td><br><td><br>空的tracer<br></td><br></tr><br><br></table>



<h1 id="4、Examples-of-using-the-tracer"><a href="#4、Examples-of-using-the-tracer" class="headerlink" title="4、Examples of using the tracer"></a>4、Examples of using the tracer</h1><p>接下来使用一系列的例子来演示tracer的使用，仅仅使用tracefs文件接口而不需要使用任何用户侧的工具。</p>
<h2 id="4-1、Output-format"><a href="#4-1、Output-format" class="headerlink" title="4.1、Output format"></a>4.1、Output format</h2><p>以下是一个“trace”文件的输出实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># tracer: function</span><br><span class="line">#</span><br><span class="line"># entries-in-buffer/entries-written: 140080/250280   #P:4</span><br><span class="line">#</span><br><span class="line">#                              _-----=&gt; irqs-off</span><br><span class="line">#                             / _----=&gt; need-resched</span><br><span class="line">#                            | / _---=&gt; hardirq/softirq</span><br><span class="line">#                            || / _--=&gt; preempt-depth</span><br><span class="line">#                            ||| /     delay</span><br><span class="line">#           TASK-PID   CPU#  ||||    TIMESTAMP  FUNCTION</span><br><span class="line">#              | |       |   ||||       |         |</span><br><span class="line">            bash-1977  [000] .... 17284.993652: sys_close &lt;-system_call_fastpath</span><br><span class="line">            bash-1977  [000] .... 17284.993653: __close_fd &lt;-sys_close</span><br><span class="line">            bash-1977  [000] .... 17284.993653: _raw_spin_lock &lt;-__close_fd</span><br><span class="line">            sshd-1974  [003] .... 17284.993653: __srcu_read_unlock &lt;-fsnotify</span><br><span class="line">            bash-1977  [000] .... 17284.993654: add_preempt_count &lt;-_raw_spin_lock</span><br><span class="line">            bash-1977  [000] ...1 17284.993655: _raw_spin_unlock &lt;-__close_fd</span><br><span class="line">            bash-1977  [000] ...1 17284.993656: sub_preempt_count &lt;-_raw_spin_unlock</span><br><span class="line">            bash-1977  [000] .... 17284.993657: filp_close &lt;-__close_fd</span><br><span class="line">            bash-1977  [000] .... 17284.993657: dnotify_flush &lt;-filp_close</span><br><span class="line">            sshd-1974  [003] .... 17284.993658: sys_select &lt;-system_call_fastpath</span><br><span class="line">            ....</span><br></pre></td></tr></table></figure>
<ul>
<li>首先在头部打印当前tracer的名字，这个例子里tracer是“function”；</li>
<li>然后打印”buffer中有多少个event/总共写了多少个entry”，两者的差值是丢失的entry(250280 - 140080 = 110200 events lost)。</li>
<li>每行的信息解析格式：进程名 “bash”, 进程PID “1977”, 运行的cpu “000”, latency format (explained below), 时间戳 <secs>.<usecs> format, 被trace的函数 “sys_close” 父函数 “system_call_fastpath”.。时间戳表示的是函数enter的时刻。</usecs></secs></li>
</ul>
<h2 id="4-2、Latency-trace-format"><a href="#4-2、Latency-trace-format" class="headerlink" title="4.2、Latency trace format"></a>4.2、Latency trace format</h2><p>“latency format”是trace文件的另一种典型的输出格式。当trace_option中“latency-format”选项被设置或者任何一种latency tracers被设置，trace文件输出了更多的信息来解释延迟的发生。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># tracer: irqsoff</span><br><span class="line">#</span><br><span class="line"># irqsoff latency trace v1.1.5 on 3.8.0-test+</span><br><span class="line"># --------------------------------------------------------------------</span><br><span class="line"># latency: 259 us, #4/4, CPU#2 | (M:preempt VP:0, KP:0, SP:0 HP:0 #P:4)</span><br><span class="line">#    -----------------</span><br><span class="line">#    | task: ps-6143 (uid:0 nice:0 policy:0 rt_prio:0)</span><br><span class="line">#    -----------------</span><br><span class="line">#  =&gt; started at: __lock_task_sighand</span><br><span class="line">#  =&gt; ended at:   _raw_spin_unlock_irqrestore</span><br><span class="line">#</span><br><span class="line">#</span><br><span class="line">#                  _------=&gt; CPU#</span><br><span class="line">#                 / _-----=&gt; irqs-off</span><br><span class="line">#                | / _----=&gt; need-resched</span><br><span class="line">#                || / _---=&gt; hardirq/softirq</span><br><span class="line">#                ||| / _--=&gt; preempt-depth</span><br><span class="line">#                |||| /     delay</span><br><span class="line">#  cmd     pid   ||||| time  |   caller</span><br><span class="line">#     \   /      |||||  \    |   /</span><br><span class="line">      ps-6143    2d...    0us!: trace_hardirqs_off &lt;-__lock_task_sighand</span><br><span class="line">      ps-6143    2d..1  259us+: trace_hardirqs_on &lt;-_raw_spin_unlock_irqrestore</span><br><span class="line">      ps-6143    2d..1  263us+: time_hardirqs_on &lt;-_raw_spin_unlock_irqrestore</span><br><span class="line">      ps-6143    2d..1  306us : &lt;stack trace&gt;</span><br><span class="line"> =&gt; trace_hardirqs_on_caller</span><br><span class="line"> =&gt; trace_hardirqs_on</span><br><span class="line"> =&gt; _raw_spin_unlock_irqrestore</span><br><span class="line"> =&gt; do_task_stat</span><br><span class="line"> =&gt; proc_tgid_stat</span><br><span class="line"> =&gt; proc_single_show</span><br><span class="line"> =&gt; seq_read</span><br><span class="line"> =&gt; vfs_read</span><br><span class="line"> =&gt; sys_read</span><br><span class="line"> =&gt; system_call_fastpath</span><br></pre></td></tr></table></figure>
<ul>
<li>当前tracer是“irqsoff”，用来trace最大的中断关闭时间；</li>
<li>trace version，kernel version(3.8)；</li>
<li>最大延迟时间(259 us)，多少条trace entries显示/总共多少条(both are four: #4/4)。VP, KP, SP, and HP一直为0保留使用。#P是多少个online的cpu(#P:4)；</li>
<li>task是最大延迟发生所在的进程(ps pid: 6143)；</li>
<li>start和stop的操作导致了延迟(本例中分布是关中断、开中断)：__lock_task_sighand 关中断，_raw_spin_unlock_irqrestore开中断；</li>
<li>header以下的行是具体trace信息。包含以下字段：</li>
</ul>
<table border="1"><br><caption> Latency trace format </caption><br><br><tr><br><th style="width: 200px;">field</th><br><th style="width: 400px;">Description</th><br><th style="width: 400px;">说明</th><br></tr><br><br><br><tr><br><td> cmd </td><br><td><br>The name of the process in the trace.<br></td><br><td><br>进程名<br></td><br></tr><br><br><tr><br><td> pid </td><br><td><br>The PID of that process.<br></td><br><td><br>进程PID<br></td><br></tr><br><br><tr><br><td> CPU# </td><br><td><br>The CPU which the process was running on.<br></td><br><td><br>运行CPU<br></td><br></tr><br><br><tr><br><td> irqs-off </td><br><td><br><pre><br>‘d’ interrupts are disabled.<br>‘.’ otherwise.<br></pre><br></td><br><td><br>中断是否disable：<br><pre><br>‘d’：中断disable；<br>‘.’：中断没有disable；<br>‘X’：架构不支持读取该信息<br></pre><br></td><br></tr><br><br><tr><br><td> need-resched </td><br><td><br><pre><br>‘N’ both TIF_NEED_RESCHED and PREEMPT_NEED_RESCHED is set,<br>‘n’ only TIF_NEED_RESCHED is set,<br>‘p’ only PREEMPT_NEED_RESCHED is set,<br>‘.’ otherwise.<br></pre><br></td><br><td><br>需要调度标志：<br></td><br></tr><br><br><tr><br><td> hardirq/softirq </td><br><td><br><pre><br>‘Z’ - NMI occurred inside a hardirq<br>‘z’ - NMI is running<br>‘H’ - hard irq occurred inside a softirq.<br>‘h’ - hard irq is running<br>‘s’ - soft irq is running<br>‘.’ - normal context.<br></pre><br></td><br><td><br>当前所处中断环境：<br></td><br></tr><br><br><tr><br><td> preempt-depth </td><br><td><br>The level of preempt_disabled<br></td><br><td><br>禁止抢占的深度，即禁止抢占的计数值。<br></td><br></tr><br><br><tr><br><td> time </td><br><td><br>When the latency-format option is enabled, the trace file output includes a timestamp relative to the start of the trace. This differs from the output when latency-format is disabled, which includes an absolute timestamp.<br></td><br><td><br>从latency开始的相对时间<br></td><br></tr><br><br><tr><br><td> delay </td><br><td><br>This is just to help catch your eye a bit better. And needs to be fixed to be only relative to the same CPU. The marks are determined by the difference between this current trace and the next trace.<br><pre><br>‘$’ - greater than 1 second<br>‘@’ - greater than 100 milisecond<br>‘*’ - greater than 10 milisecond<br>‘#’ - greater than 1000 microsecond<br>‘!’ - greater than 100 microsecond<br>‘+’ - greater than 10 microsecond<br>‘ ‘ - less than or equal to 10 microsecond.<br></pre><br></td><br><td><br>时间间隔大小所处的等级，可以迅速分类出不同的严重程度。<br></td><br></tr><br><br></table>

<ul>
<li>其他的和“trace”文件相同；</li>
<li>最后还有backtrace，能迅速定位latency发生的位置；</li>
</ul>
<h1 id="5、trace-options"><a href="#5、trace-options" class="headerlink" title="5、trace_options"></a>5、trace_options</h1><p>“trace_options”文件(或者“option”文件夹中的文件)用来控制trace文件的输出格式，或者由tracer自动配置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">cat trace_options</span><br><span class="line">      print-parent</span><br><span class="line">      nosym-offset</span><br><span class="line">      nosym-addr</span><br><span class="line">      noverbose</span><br><span class="line">      noraw</span><br><span class="line">      nohex</span><br><span class="line">      nobin</span><br><span class="line">      noblock</span><br><span class="line">      trace_printk</span><br><span class="line">      annotate</span><br><span class="line">      nouserstacktrace</span><br><span class="line">      nosym-userobj</span><br><span class="line">      noprintk-msg-only</span><br><span class="line">      context-info</span><br><span class="line">      nolatency-format</span><br><span class="line">      record-cmd</span><br><span class="line">      norecord-tgid</span><br><span class="line">      overwrite</span><br><span class="line">      nodisable_on_free</span><br><span class="line">      irq-info</span><br><span class="line">      markers</span><br><span class="line">      noevent-fork</span><br><span class="line">      function-trace</span><br><span class="line">      nofunction-fork</span><br><span class="line">      nodisplay-graph</span><br><span class="line">      nostacktrace</span><br><span class="line">      nobranch</span><br></pre></td></tr></table></figure>
<p>Disable某个选项，使用“no”前缀：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo noprint-parent &gt; trace_options</span><br></pre></td></tr></table></figure>
<p>Enable某个选项，去掉“no”前缀：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo sym-offset &gt; trace_options</span><br></pre></td></tr></table></figure>
<ul>
<li>有效的trace optione列表：</li>
</ul>
<table border="1"><br><caption> available trace options </caption><br><br><tr><br><th style="width: 200px;">Option</th><br><th style="width: 400px;">Description</th><br><th style="width: 400px;">说明</th><br></tr><br><br><br><tr><br><td> print-parent </td><br><td><br>On function traces, display the calling (parent) function as well as the function being traced.<br><pre><br>print-parent:<br> bash-4000  [01]  1477.606694: simple_strtoul &lt;-kstrtoul<br><br>noprint-parent:<br> bash-4000  [01]  1477.606694: simple_strtoul<br></pre><br></td><br><td><br>是否打印父进程<br></td><br></tr><br><br><tr><br><td> sym-offset </td><br><td><br>Display not only the function name, but also the offset in the function. For example, instead of seeing just “ktime_get”, you will see “ktime_get+0xb/0x20”.<br><pre><br>sym-offset:<br> bash-4000  [01]  1477.606694: simple_strtoul+0x6/0xa0<br></pre><br></td><br><td><br>是否打印符号的offset<br></td><br></tr><br><br><tr><br><td> sym-addr </td><br><td><br>This will also display the function address as well as the function name.<br><pre><br>sym-addr:<br> bash-4000  [01]  1477.606694: simple_strtoul &lt;c0339346&gt;<br></pre><br></td><br><td><br>是否打印符号地址<br></td><br></tr><br><br><tr><br><td> verbose </td><br><td><br>This deals with the trace file when the latency-format option is enabled.<br><pre><br>bash  4000 1 0 00000000 00010a95 [58127d26] 1720.415ms \<br>(+0.000ms): simple_strtoul (kstrtoul)<br></pre><br></td><br><td><br>显示详细信息<br></td><br></tr><br><br><tr><br><td> raw </td><br><td><br>This will display raw numbers. This option is best for use with user applications that can translate the raw numbers better than having it done in the kernel.<br></td><br><td><br>显示裸数据。如果用户应用知道裸数据的解析方法，可以在用户态解析，优于在内核解析。<br></td><br></tr><br><br><tr><br><td> hex </td><br><td><br>Similar to raw, but the numbers will be in a hexadecimal format.<br></td><br><td><br>使用hex格式解析裸数据。<br></td><br></tr><br><br><tr><br><td> bin </td><br><td><br>This will print out the formats in raw binary.<br></td><br><td><br>使用bin格式解析裸数据。<br></td><br></tr><br><br><tr><br><td> block </td><br><td><br>When set, reading trace_pipe will not block when polled.<br></td><br><td><br>如果设置，读trace_pipe文件不会在轮询时阻塞。<br></td><br></tr><br><br><tr><br><td> trace_printk </td><br><td><br>Can disable trace_printk() from writing into the buffer.<br></td><br><td><br>禁止trace_printk写入数据到ring buffer。<br></td><br></tr><br><br><tr><br><td> annotate </td><br><td><br>It is sometimes confusing when the CPU buffers are full and one CPU buffer had a lot of events recently, thus a shorter time frame, were another CPU may have only had a few events, which lets it have older events. When the trace is reported, it shows the oldest events first, and it may look like only one CPU ran (the one with the oldest events). When the annotate option is set, it will display when a new CPU buffer started:<br><pre><br>    <idle>-0     [001] dNs4 21169.031481: wake_up_idle_cpu &lt;-add_timer_on<br>    <idle>-0     [001] dNs4 21169.031482: _raw_spin_unlock_irqrestore &lt;-add_timer_on<br>    <idle>-0     [001] .Ns4 21169.031484: sub_preempt_count &lt;-_raw_spin_unlock_irqrestore<br> ##### CPU 2 buffer started ####<br>    <idle>-0     [002] .N.1 21169.031484: rcu_idle_exit &lt;-cpu_idle<br>    <idle>-0     [001] .Ns3 21169.031484: _raw_spin_unlock &lt;-clocksource_watchdog<br>    <idle>-0     [001] .Ns3 21169.031485: sub_preempt_count &lt;-_raw_spin_unlock<br></idle></idle></idle></idle></idle></idle></pre><br></td><br><td><br>提示，内容的切换<br></td><br></tr><br><br><tr><br><td> userstacktrace </td><br><td><br>This option changes the trace. It records a stacktrace of the current user space thread after each trace event.<br></td><br><td><br>记录用户空间的堆栈回调<br></td><br></tr><br><br><tr><br><td> sym-userobj </td><br><td><br>when user stacktrace are enabled, look up which object the address belongs to, and print a relative address. This is especially useful when ASLR is on, otherwise you don’t get a chance to resolve the address to object/file/line after the app is no longer running<br><br>The lookup is performed when you read trace,trace_pipe. Example:<br><pre><br>a.out-1623  [000] 40874.465068: /root/a.out[+0x480] &lt;-/root/a.out[+0<br>x494] &lt;- /root/a.out[+0x4a8] &lt;- /lib/libc-2.7.so[+0x1e1a6]<br></pre><br></td><br><td><br>记录用户空间的堆栈回调，并且解析出对应符号。这在ASLR使能时非常有用，因为ASLR是随机加载库地址，事后根据堆栈可能恢复不出原来的调用关系。<br></td><br></tr><br><br><tr><br><td> printk-msg-only </td><br><td><br>When set, trace_printk()s will only show the format and not their parameters (if trace_bprintk() or trace_bputs() was used to save the trace_printk()).<br></td><br><td><br>trace_printk()仅仅打印格式不打印参数<br></td><br></tr><br><br><tr><br><td> context-info </td><br><td><br>Show only the event data. Hides the comm, PID, timestamp, CPU, and other useful data.<br></td><br><td><br>是否打印trace event的头部通用信息：comm, PID, timestamp, CPU, and other useful data.<br></td><br></tr><br><br><tr><br><td> latency-format </td><br><td><br>This option changes the trace output. When it is enabled, the trace displays additional information about the latency, as described in “Latency trace format”.<br></td><br><td><br>是否使用“Latency trace format”打印<br></td><br></tr><br><br><tr><br><td> record-cmd </td><br><td><br>When any event or tracer is enabled, a hook is enabled in the sched_switch trace point to fill comm cache with mapped pids and comms. But this may cause some overhead, and if you only care about pids, and not the name of the task, disabling this option can lower the impact of tracing. See “saved_cmdlines”.<br></td><br><td><br>是否在sched_switch时间点来创建pid到comm的转换cache。<br></td><br></tr><br><br><tr><br><td> record-tgid </td><br><td><br>When any event or tracer is enabled, a hook is enabled in the sched_switch trace point to fill the cache of mapped Thread Group IDs (TGID) mapping to pids. See “saved_tgids”.<br></td><br><td><br>是否创建pid到tgid的cache。<br></td><br></tr><br><br><tr><br><td> overwrite </td><br><td><br>This controls what happens when the trace buffer is full. If “1” (default), the oldest events are discarded and overwritten. If “0”, then the newest events are discarded. (see per_cpu/cpu0/stats for overrun and dropped)<br></td><br><td><br>控制ringbuffer满后的行为是，overwrite旧数据，还是discard新数据。<br></td><br></tr><br><br><tr><br><td> disable_on_free </td><br><td><br>When the free_buffer is closed, tracing will stop (tracing_on set to 0).<br></td><br><td><br>当使用“set_free_buffer”释放ringbuffer空间时，是否停止tracing。<br></td><br></tr><br><br><tr><br><td> irq-info </td><br><td><br>Shows the interrupt, preempt count, need resched data. When disabled, the trace looks like:<br><pre><br> # tracer: function<br> #<br> # entries-in-buffer/entries-written: 144405/9452052   #P:4<br> #<br> #           TASK-PID   CPU#      TIMESTAMP  FUNCTION<br> #              | |       |          |         |<br>           <idle>-0     [002]  23636.756054: ttwu_do_activate.constprop.89 &lt;-try_to_wake_up<br>           <idle>-0     [002]  23636.756054: activate_task &lt;-ttwu_do_activate.constprop.89<br>           <idle>-0     [002]  23636.756055: enqueue_task &lt;-activate_task<br></idle></idle></idle></pre><br></td><br><td><br>是否打印相关flag信息：interrupt, preempt count, need resched<br></td><br></tr><br><br><tr><br><td> markers </td><br><td><br>When set, the trace_marker is writable (only by root). When disabled, the trace_marker will error with EINVAL on write.<br></td><br><td><br>是否允许用户态直接通过trace_marker接口往ringbuffer中写数据<br></td><br></tr><br><br><tr><br><td> event-fork </td><br><td><br>When set, tasks with PIDs listed in set_event_pid will have the PIDs of their children added to set_event_pid when those tasks fork. Also, when tasks with PIDs in set_event_pid exit, their PIDs will be removed from the file.<br></td><br><td><br>对于trace_event，如果进程在pid filter列表中，fork创建的子进程是否自动加入到filter列表中。<br></td><br></tr><br><br><tr><br><td> function-trace </td><br><td><br>The latency tracers will enable function tracing if this option is enabled (default it is). When it is disabled, the latency tracers do not trace functions. This keeps the overhead of the tracer down when performing latency tests.<br></td><br><td><br>在latency tracers是可以同时使能function tracing。<br></td><br></tr><br><br><tr><br><td> function-fork </td><br><td><br>When set, tasks with PIDs listed in set_ftrace_pid will have the PIDs of their children added to set_ftrace_pid when those tasks fork. Also, when tasks with PIDs in set_ftrace_pid exit, their PIDs will be removed from the file.<br></td><br><td><br>对于ftrace，如果进程在pid filter列表中，fork创建的子进程是否自动加入到filter列表中。<br></td><br></tr><br><br><tr><br><td> display-graph </td><br><td><br>When set, the latency tracers (irqsoff, wakeup, etc) will use function graph tracing instead of function tracing.<br></td><br><td><br>“function graph tracing”风格的显示<br></td><br></tr><br><br><tr><br><td> stacktrace </td><br><td><br>When set, a stack trace is recorded after any trace event is recorded.<br></td><br><td><br>event中是否记录堆栈回调<br></td><br></tr><br><br><tr><br><td> branch </td><br><td><br>Enable branch tracing with the tracer. This enables branch tracer along with the currently set tracer. Enabling this with the “nop” tracer is the same as just enabling the “branch” tracer.<br></td><br><td><br>启用分支追踪<br></td><br></tr><br><br></table>

<ul>
<li>function tracer特有的选项：</li>
</ul>
<table border="1"><br><caption> function tracer options </caption><br><br><tr><br><th style="width: 200px;">Option</th><br><th style="width: 400px;">Description</th><br><th style="width: 400px;">说明</th><br></tr><br><br><tr><br><td> func_stack_trace </td><br><td><br>When set, a stack trace is recorded after every function that is recorded. NOTE! Limit the functions that are recorded before enabling this, with “set_ftrace_filter” otherwise the system performance will be critically degraded. Remember to disable this option before clearing the function filter.<br></td><br><td><br>每次进入函数，都记录函数的回调关系。<br></td><br></tr><br><br></table>

<ul>
<li>function_graph tracer特有的选项：</li>
</ul>
<table border="1"><br><caption>  function_graph tracer options </caption><br><br><tr><br><th style="width: 200px;">Option</th><br><th style="width: 400px;">Description</th><br><th style="width: 400px;">说明</th><br></tr><br><br><tr><br><td> funcgraph-overrun </td><br><td><br>When set, the “overrun” of the graph stack is displayed after each function traced. The overrun, is when the stack depth of the calls is greater than what is reserved for each task. Each task has a fixed array of functions to trace in the call graph. If the depth of the calls exceeds that, the function is not traced. The overrun is the number of functions missed due to exceeding this array.<br></td><br><td><br><br></td><br></tr><br><br><tr><br><td> funcgraph-cpu </td><br><td><br>When set, the CPU number of the CPU where the trace occurred is displayed.<br></td><br><td><br>显示所在CPU<br></td><br></tr><br><br><tr><br><td> funcgraph-overhead </td><br><td><br>When set, if the function takes longer than A certain amount, then a delay marker is displayed. See “delay” above, under the header description.<br></td><br><td><br>显示“delay”程度<br></td><br></tr><br><br><tr><br><td> funcgraph-proc </td><br><td><br>Unlike other tracers, the process’ command line is not displayed by default, but instead only when a task is traced in and out during a context switch. Enabling this options has the command of each process displayed at every line.<br></td><br><td><br>显示进程comm<br></td><br></tr><br><br><tr><br><td> funcgraph-duration </td><br><td><br>At the end of each function (the return) the duration of the amount of time in the function is displayed in microseconds.<br></td><br><td><br>显示函数执行时间<br></td><br></tr><br><br><tr><br><td> funcgraph-abstime </td><br><td><br>When set, the timestamp is displayed at each line.<br></td><br><td><br>显示绝对时间戳<br></td><br></tr><br><br><tr><br><td> funcgraph-irqs </td><br><td><br>When disabled, functions that happen inside an interrupt will not be traced.<br></td><br><td><br>如果disable，将不会跟踪中断中的函数<br></td><br></tr><br><br><tr><br><td> funcgraph-tail </td><br><td><br>When set, the return event will include the function that it represents. By default this is off, and only a closing curly bracket “}” is displayed for the return of a function.<br></td><br><td><br>在函数结束时显示函数名<br></td><br></tr><br><br><tr><br><td> sleep-time </td><br><td><br>When running function graph tracer, to include the time a task schedules out in its function. When enabled, it will account time the task has been scheduled out as part of the function call.<br></td><br><td><br>函数的执行时间包括进程被调度出去的sleep时间<br></td><br></tr><br><br><tr><br><td> graph-time </td><br><td><br>When running function profiler with function graph tracer, to include the time to call nested functions. When this is not set, the time reported for the function will only include the time the function itself executed for, not the time for functions that it called.<br></td><br><td><br><br></td><br></tr><br><br></table>

<ul>
<li>blk  tracer特有的选项：</li>
</ul>
<table border="1"><br><caption> blk  tracer options </caption><br><br><tr><br><th style="width: 200px;">Option</th><br><th style="width: 400px;">Description</th><br><th style="width: 400px;">说明</th><br></tr><br><br><tr><br><td> blk_classic </td><br><td><br>Shows a more minimalistic output.<br></td><br><td><br>显示出更加简约的输出。<br></td><br></tr><br><br></table>


<h1 id="6、irqsoff"><a href="#6、irqsoff" class="headerlink" title="6、irqsoff"></a>6、irqsoff</h1><p>当中断关闭CPU不能响应任何外部的事件，将会阻止内核响应timer、鼠标中断，对应的结果就是响应延迟。</p>
<p>irqsoff tracer追踪关中断时间，当一个新的最大latency到来时，它会记住新的最大latency event，丢弃掉旧的最大latency event。”echo 0 &gt;tracing_max_latency”会复位最大值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"># echo 0 &gt; options/function-trace</span><br><span class="line"># echo irqsoff &gt; current_tracer</span><br><span class="line"># echo 1 &gt; tracing_on</span><br><span class="line"># echo 0 &gt; tracing_max_latency</span><br><span class="line"># ls -ltr</span><br><span class="line">[...]</span><br><span class="line"># echo 0 &gt; tracing_on</span><br><span class="line"># cat trace</span><br><span class="line"># tracer: irqsoff</span><br><span class="line">#</span><br><span class="line"># irqsoff latency trace v1.1.5 on 3.8.0-test+</span><br><span class="line"># --------------------------------------------------------------------</span><br><span class="line"># latency: 16 us, #4/4, CPU#0 | (M:preempt VP:0, KP:0, SP:0 HP:0 #P:4)</span><br><span class="line">#    -----------------</span><br><span class="line">#    | task: swapper/0-0 (uid:0 nice:0 policy:0 rt_prio:0)</span><br><span class="line">#    -----------------</span><br><span class="line">#  =&gt; started at: run_timer_softirq</span><br><span class="line">#  =&gt; ended at:   run_timer_softirq</span><br><span class="line">#</span><br><span class="line">#</span><br><span class="line">#                  _------=&gt; CPU#</span><br><span class="line">#                 / _-----=&gt; irqs-off</span><br><span class="line">#                | / _----=&gt; need-resched</span><br><span class="line">#                || / _---=&gt; hardirq/softirq</span><br><span class="line">#                ||| / _--=&gt; preempt-depth</span><br><span class="line">#                |||| /     delay</span><br><span class="line">#  cmd     pid   ||||| time  |   caller</span><br><span class="line">#     \   /      |||||  \    |   /</span><br><span class="line">  &lt;idle&gt;-0       0d.s2    0us+: _raw_spin_lock_irq &lt;-run_timer_softirq</span><br><span class="line">  &lt;idle&gt;-0       0dNs3   17us : _raw_spin_unlock_irq &lt;-run_timer_softirq</span><br><span class="line">  &lt;idle&gt;-0       0dNs3   17us+: trace_hardirqs_on &lt;-run_timer_softirq</span><br><span class="line">  &lt;idle&gt;-0       0dNs3   25us : &lt;stack trace&gt;</span><br><span class="line"> =&gt; _raw_spin_unlock_irq</span><br><span class="line"> =&gt; run_timer_softirq</span><br><span class="line"> =&gt; __do_softirq</span><br><span class="line"> =&gt; call_softirq</span><br><span class="line"> =&gt; do_softirq</span><br><span class="line"> =&gt; irq_exit</span><br><span class="line"> =&gt; smp_apic_timer_interrupt</span><br><span class="line"> =&gt; apic_timer_interrupt</span><br><span class="line"> =&gt; rcu_idle_exit</span><br><span class="line"> =&gt; cpu_idle</span><br><span class="line"> =&gt; rest_init</span><br><span class="line"> =&gt; start_kernel</span><br><span class="line"> =&gt; x86_64_start_reservations</span><br><span class="line"> =&gt; x86_64_start_kernel</span><br></pre></td></tr></table></figure>
<ul>
<li>看到16us的延迟</li>
<li>_raw_spin_lock_irq &lt;- run_timer_softirq 关闭了中断</li>
<li>16us到25us之间，是在做记录工作</li>
</ul>
<p>下面是irqsoff tracer和function-trace同时打开的情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">with echo 1 &gt; options/function-trace</span><br><span class="line"></span><br><span class="line"> # tracer: irqsoff</span><br><span class="line"> #</span><br><span class="line"> # irqsoff latency trace v1.1.5 on 3.8.0-test+</span><br><span class="line"> # --------------------------------------------------------------------</span><br><span class="line"> # latency: 71 us, #168/168, CPU#3 | (M:preempt VP:0, KP:0, SP:0 HP:0 #P:4)</span><br><span class="line"> #    -----------------</span><br><span class="line"> #    | task: bash-2042 (uid:0 nice:0 policy:0 rt_prio:0)</span><br><span class="line"> #    -----------------</span><br><span class="line"> #  =&gt; started at: ata_scsi_queuecmd</span><br><span class="line"> #  =&gt; ended at:   ata_scsi_queuecmd</span><br><span class="line"> #</span><br><span class="line"> #</span><br><span class="line"> #                  _------=&gt; CPU#</span><br><span class="line"> #                 / _-----=&gt; irqs-off</span><br><span class="line"> #                | / _----=&gt; need-resched</span><br><span class="line"> #                || / _---=&gt; hardirq/softirq</span><br><span class="line"> #                ||| / _--=&gt; preempt-depth</span><br><span class="line"> #                |||| /     delay</span><br><span class="line"> #  cmd     pid   ||||| time  |   caller</span><br><span class="line"> #     \   /      |||||  \    |   /</span><br><span class="line">     bash-2042    3d...    0us : _raw_spin_lock_irqsave &lt;-ata_scsi_queuecmd</span><br><span class="line">     bash-2042    3d...    0us : add_preempt_count &lt;-_raw_spin_lock_irqsave</span><br><span class="line">     bash-2042    3d..1    1us : ata_scsi_find_dev &lt;-ata_scsi_queuecmd</span><br><span class="line">     bash-2042    3d..1    1us : __ata_scsi_find_dev &lt;-ata_scsi_find_dev</span><br><span class="line">     bash-2042    3d..1    2us : ata_find_dev.part.14 &lt;-__ata_scsi_find_dev</span><br><span class="line">     bash-2042    3d..1    2us : ata_qc_new_init &lt;-__ata_scsi_queuecmd</span><br><span class="line">     bash-2042    3d..1    3us : ata_sg_init &lt;-__ata_scsi_queuecmd</span><br><span class="line">     bash-2042    3d..1    4us : ata_scsi_rw_xlat &lt;-__ata_scsi_queuecmd</span><br><span class="line">     bash-2042    3d..1    4us : ata_build_rw_tf &lt;-ata_scsi_rw_xlat</span><br><span class="line"> [...]</span><br><span class="line">     bash-2042    3d..1   67us : delay_tsc &lt;-__delay</span><br><span class="line">     bash-2042    3d..1   67us : add_preempt_count &lt;-delay_tsc</span><br><span class="line">     bash-2042    3d..2   67us : sub_preempt_count &lt;-delay_tsc</span><br><span class="line">     bash-2042    3d..1   67us : add_preempt_count &lt;-delay_tsc</span><br><span class="line">     bash-2042    3d..2   68us : sub_preempt_count &lt;-delay_tsc</span><br><span class="line">     bash-2042    3d..1   68us+: ata_bmdma_start &lt;-ata_bmdma_qc_issue</span><br><span class="line">     bash-2042    3d..1   71us : _raw_spin_unlock_irqrestore &lt;-ata_scsi_queuecmd</span><br><span class="line">     bash-2042    3d..1   71us : _raw_spin_unlock_irqrestore &lt;-ata_scsi_queuecmd</span><br><span class="line">     bash-2042    3d..1   72us+: trace_hardirqs_on &lt;-ata_scsi_queuecmd</span><br><span class="line">     bash-2042    3d..1  120us : &lt;stack trace&gt;</span><br><span class="line">  =&gt; _raw_spin_unlock_irqrestore</span><br><span class="line">  =&gt; ata_scsi_queuecmd</span><br><span class="line">  =&gt; scsi_dispatch_cmd</span><br><span class="line">  =&gt; scsi_request_fn</span><br><span class="line">  =&gt; __blk_run_queue_uncond</span><br><span class="line">  =&gt; __blk_run_queue</span><br><span class="line">  =&gt; blk_queue_bio</span><br><span class="line">  =&gt; generic_make_request</span><br><span class="line">  =&gt; submit_bio</span><br><span class="line">  =&gt; submit_bh</span><br><span class="line">  =&gt; __ext3_get_inode_loc</span><br><span class="line">  =&gt; ext3_iget</span><br><span class="line">  =&gt; ext3_lookup</span><br><span class="line">  =&gt; lookup_real</span><br><span class="line">  =&gt; __lookup_hash</span><br><span class="line">  =&gt; walk_component</span><br><span class="line">  =&gt; lookup_last</span><br><span class="line">  =&gt; path_lookupat</span><br><span class="line">  =&gt; filename_lookup</span><br><span class="line">  =&gt; user_path_at_empty</span><br><span class="line">  =&gt; user_path_at</span><br><span class="line">  =&gt; vfs_fstatat</span><br><span class="line">  =&gt; vfs_stat</span><br><span class="line">  =&gt; sys_newstat</span><br><span class="line">  =&gt; system_call_fastpath</span><br></pre></td></tr></table></figure>
<ul>
<li>71us的延迟</li>
<li>但是我们可以看到在此之间的函数调用</li>
<li>使能function-trace增加了不少开销，会增加延迟时间，但是也提供了更多的有用信息</li>
</ul>
<h1 id="7、preemptoff"><a href="#7、preemptoff" class="headerlink" title="7、preemptoff"></a>7、preemptoff</h1><p>当抢占关闭，我们除了接收中断，不能进行任务调度。</p>
<p>preemptoff tracer用来追踪抢占关闭时间，和irqsoff非常类似。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"># echo 0 &gt; options/function-trace</span><br><span class="line"># echo preemptoff &gt; current_tracer</span><br><span class="line"># echo 1 &gt; tracing_on</span><br><span class="line"># echo 0 &gt; tracing_max_latency</span><br><span class="line"># ls -ltr</span><br><span class="line">[...]</span><br><span class="line"># echo 0 &gt; tracing_on</span><br><span class="line"># cat trace</span><br><span class="line"># tracer: preemptoff</span><br><span class="line">#</span><br><span class="line"># preemptoff latency trace v1.1.5 on 3.8.0-test+</span><br><span class="line"># --------------------------------------------------------------------</span><br><span class="line"># latency: 46 us, #4/4, CPU#1 | (M:preempt VP:0, KP:0, SP:0 HP:0 #P:4)</span><br><span class="line">#    -----------------</span><br><span class="line">#    | task: sshd-1991 (uid:0 nice:0 policy:0 rt_prio:0)</span><br><span class="line">#    -----------------</span><br><span class="line">#  =&gt; started at: do_IRQ</span><br><span class="line">#  =&gt; ended at:   do_IRQ</span><br><span class="line">#</span><br><span class="line">#</span><br><span class="line">#                  _------=&gt; CPU#</span><br><span class="line">#                 / _-----=&gt; irqs-off</span><br><span class="line">#                | / _----=&gt; need-resched</span><br><span class="line">#                || / _---=&gt; hardirq/softirq</span><br><span class="line">#                ||| / _--=&gt; preempt-depth</span><br><span class="line">#                |||| /     delay</span><br><span class="line">#  cmd     pid   ||||| time  |   caller</span><br><span class="line">#     \   /      |||||  \    |   /</span><br><span class="line">    sshd-1991    1d.h.    0us+: irq_enter &lt;-do_IRQ</span><br><span class="line">    sshd-1991    1d..1   46us : irq_exit &lt;-do_IRQ</span><br><span class="line">    sshd-1991    1d..1   47us+: trace_preempt_on &lt;-do_IRQ</span><br><span class="line">    sshd-1991    1d..1   52us : &lt;stack trace&gt;</span><br><span class="line"> =&gt; sub_preempt_count</span><br><span class="line"> =&gt; irq_exit</span><br><span class="line"> =&gt; do_IRQ</span><br><span class="line"> =&gt; ret_from_intr</span><br></pre></td></tr></table></figure>
<ul>
<li>当一个中断进入时 (注意 ‘h’)关闭抢占，退出中断时打开抢占；</li>
<li>在抢占关闭打开的整个过程中，中断处于关闭状态(‘d’)，我们不能确定中断的打开时刻；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"># tracer: preemptoff</span><br><span class="line">#</span><br><span class="line"># preemptoff latency trace v1.1.5 on 3.8.0-test+</span><br><span class="line"># --------------------------------------------------------------------</span><br><span class="line"># latency: 83 us, #241/241, CPU#1 | (M:preempt VP:0, KP:0, SP:0 HP:0 #P:4)</span><br><span class="line">#    -----------------</span><br><span class="line">#    | task: bash-1994 (uid:0 nice:0 policy:0 rt_prio:0)</span><br><span class="line">#    -----------------</span><br><span class="line">#  =&gt; started at: wake_up_new_task</span><br><span class="line">#  =&gt; ended at:   task_rq_unlock</span><br><span class="line">#</span><br><span class="line">#</span><br><span class="line">#                  _------=&gt; CPU#</span><br><span class="line">#                 / _-----=&gt; irqs-off</span><br><span class="line">#                | / _----=&gt; need-resched</span><br><span class="line">#                || / _---=&gt; hardirq/softirq</span><br><span class="line">#                ||| / _--=&gt; preempt-depth</span><br><span class="line">#                |||| /     delay</span><br><span class="line">#  cmd     pid   ||||| time  |   caller</span><br><span class="line">#     \   /      |||||  \    |   /</span><br><span class="line">    bash-1994    1d..1    0us : _raw_spin_lock_irqsave &lt;-wake_up_new_task</span><br><span class="line">    bash-1994    1d..1    0us : select_task_rq_fair &lt;-select_task_rq</span><br><span class="line">    bash-1994    1d..1    1us : __rcu_read_lock &lt;-select_task_rq_fair</span><br><span class="line">    bash-1994    1d..1    1us : source_load &lt;-select_task_rq_fair</span><br><span class="line">    bash-1994    1d..1    1us : source_load &lt;-select_task_rq_fair</span><br><span class="line">[...]</span><br><span class="line">    bash-1994    1d..1   12us : irq_enter &lt;-smp_apic_timer_interrupt</span><br><span class="line">    bash-1994    1d..1   12us : rcu_irq_enter &lt;-irq_enter</span><br><span class="line">    bash-1994    1d..1   13us : add_preempt_count &lt;-irq_enter</span><br><span class="line">    bash-1994    1d.h1   13us : exit_idle &lt;-smp_apic_timer_interrupt</span><br><span class="line">    bash-1994    1d.h1   13us : hrtimer_interrupt &lt;-smp_apic_timer_interrupt</span><br><span class="line">    bash-1994    1d.h1   13us : _raw_spin_lock &lt;-hrtimer_interrupt</span><br><span class="line">    bash-1994    1d.h1   14us : add_preempt_count &lt;-_raw_spin_lock</span><br><span class="line">    bash-1994    1d.h2   14us : ktime_get_update_offsets &lt;-hrtimer_interrupt</span><br><span class="line">[...]</span><br><span class="line">    bash-1994    1d.h1   35us : lapic_next_event &lt;-clockevents_program_event</span><br><span class="line">    bash-1994    1d.h1   35us : irq_exit &lt;-smp_apic_timer_interrupt</span><br><span class="line">    bash-1994    1d.h1   36us : sub_preempt_count &lt;-irq_exit</span><br><span class="line">    bash-1994    1d..2   36us : do_softirq &lt;-irq_exit</span><br><span class="line">    bash-1994    1d..2   36us : __do_softirq &lt;-call_softirq</span><br><span class="line">    bash-1994    1d..2   36us : __local_bh_disable &lt;-__do_softirq</span><br><span class="line">    bash-1994    1d.s2   37us : add_preempt_count &lt;-_raw_spin_lock_irq</span><br><span class="line">    bash-1994    1d.s3   38us : _raw_spin_unlock &lt;-run_timer_softirq</span><br><span class="line">    bash-1994    1d.s3   39us : sub_preempt_count &lt;-_raw_spin_unlock</span><br><span class="line">    bash-1994    1d.s2   39us : call_timer_fn &lt;-run_timer_softirq</span><br><span class="line">[...]</span><br><span class="line">    bash-1994    1dNs2   81us : cpu_needs_another_gp &lt;-rcu_process_callbacks</span><br><span class="line">    bash-1994    1dNs2   82us : __local_bh_enable &lt;-__do_softirq</span><br><span class="line">    bash-1994    1dNs2   82us : sub_preempt_count &lt;-__local_bh_enable</span><br><span class="line">    bash-1994    1dN.2   82us : idle_cpu &lt;-irq_exit</span><br><span class="line">    bash-1994    1dN.2   83us : rcu_irq_exit &lt;-irq_exit</span><br><span class="line">    bash-1994    1dN.2   83us : sub_preempt_count &lt;-irq_exit</span><br><span class="line">    bash-1994    1.N.1   84us : _raw_spin_unlock_irqrestore &lt;-task_rq_unlock</span><br><span class="line">    bash-1994    1.N.1   84us+: trace_preempt_on &lt;-task_rq_unlock</span><br><span class="line">    bash-1994    1.N.1  104us : &lt;stack trace&gt;</span><br><span class="line"> =&gt; sub_preempt_count</span><br><span class="line"> =&gt; _raw_spin_unlock_irqrestore</span><br><span class="line"> =&gt; task_rq_unlock</span><br><span class="line"> =&gt; wake_up_new_task</span><br><span class="line"> =&gt; do_fork</span><br><span class="line"> =&gt; sys_clone</span><br><span class="line"> =&gt; stub_clone</span><br></pre></td></tr></table></figure>
<ul>
<li>以上是preemptoff tracer + function-trace</li>
<li>可以看到在整个周期中中断并不是一直被disable</li>
<li>可以看到irq_enter代码进入‘h’中断。在此之前是看不到这种信息的</li>
</ul>
<h1 id="8、preemptirqsoff"><a href="#8、preemptirqsoff" class="headerlink" title="8、preemptirqsoff"></a>8、preemptirqsoff</h1><p>preemptirqsoff tracer追踪抢占/中断任一被关闭的最大延迟时间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">local_irq_disable();</span><br><span class="line">call_function_with_irqs_off();</span><br><span class="line">preempt_disable();</span><br><span class="line">call_function_with_irqs_and_preemption_off();</span><br><span class="line">local_irq_enable();</span><br><span class="line">call_function_with_preemption_off();</span><br><span class="line">preempt_enable();</span><br></pre></td></tr></table></figure>
<ul>
<li>irqsoff tracer记录的时间 = call_function_with_irqs_off() + call_function_with_irqs_and_preemption_off()</li>
<li>preemptoff tracer记录的时间 = call_function_with_irqs_and_preemption_off() + call_function_with_preemption_off()</li>
<li>preemptirqsoff tracer记录的时间 = total时间</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"># echo 0 &gt; options/function-trace</span><br><span class="line"># echo preemptirqsoff &gt; current_tracer</span><br><span class="line"># echo 1 &gt; tracing_on</span><br><span class="line"># echo 0 &gt; tracing_max_latency</span><br><span class="line"># ls -ltr</span><br><span class="line">[...]</span><br><span class="line"># echo 0 &gt; tracing_on</span><br><span class="line"># cat trace</span><br><span class="line"># tracer: preemptirqsoff</span><br><span class="line">#</span><br><span class="line"># preemptirqsoff latency trace v1.1.5 on 3.8.0-test+</span><br><span class="line"># --------------------------------------------------------------------</span><br><span class="line"># latency: 100 us, #4/4, CPU#3 | (M:preempt VP:0, KP:0, SP:0 HP:0 #P:4)</span><br><span class="line">#    -----------------</span><br><span class="line">#    | task: ls-2230 (uid:0 nice:0 policy:0 rt_prio:0)</span><br><span class="line">#    -----------------</span><br><span class="line">#  =&gt; started at: ata_scsi_queuecmd</span><br><span class="line">#  =&gt; ended at:   ata_scsi_queuecmd</span><br><span class="line">#</span><br><span class="line">#</span><br><span class="line">#                  _------=&gt; CPU#</span><br><span class="line">#                 / _-----=&gt; irqs-off</span><br><span class="line">#                | / _----=&gt; need-resched</span><br><span class="line">#                || / _---=&gt; hardirq/softirq</span><br><span class="line">#                ||| / _--=&gt; preempt-depth</span><br><span class="line">#                |||| /     delay</span><br><span class="line">#  cmd     pid   ||||| time  |   caller</span><br><span class="line">#     \   /      |||||  \    |   /</span><br><span class="line">      ls-2230    3d...    0us+: _raw_spin_lock_irqsave &lt;-ata_scsi_queuecmd</span><br><span class="line">      ls-2230    3...1  100us : _raw_spin_unlock_irqrestore &lt;-ata_scsi_queuecmd</span><br><span class="line">      ls-2230    3...1  101us+: trace_preempt_on &lt;-ata_scsi_queuecmd</span><br><span class="line">      ls-2230    3...1  111us : &lt;stack trace&gt;</span><br><span class="line"> =&gt; sub_preempt_count</span><br><span class="line"> =&gt; _raw_spin_unlock_irqrestore</span><br><span class="line"> =&gt; ata_scsi_queuecmd</span><br><span class="line"> =&gt; scsi_dispatch_cmd</span><br><span class="line"> =&gt; scsi_request_fn</span><br><span class="line"> =&gt; __blk_run_queue_uncond</span><br><span class="line"> =&gt; __blk_run_queue</span><br><span class="line"> =&gt; blk_queue_bio</span><br><span class="line"> =&gt; generic_make_request</span><br><span class="line"> =&gt; submit_bio</span><br><span class="line"> =&gt; submit_bh</span><br><span class="line"> =&gt; ext3_bread</span><br><span class="line"> =&gt; ext3_dir_bread</span><br><span class="line"> =&gt; htree_dirblock_to_tree</span><br><span class="line"> =&gt; ext3_htree_fill_tree</span><br><span class="line"> =&gt; ext3_readdir</span><br><span class="line"> =&gt; vfs_readdir</span><br><span class="line"> =&gt; sys_getdents</span><br><span class="line"> =&gt; system_call_fastpath</span><br></pre></td></tr></table></figure>
<p>以下是“preemptirqsoff tracer” + “function-trace”：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"># tracer: preemptirqsoff</span><br><span class="line">#</span><br><span class="line"># preemptirqsoff latency trace v1.1.5 on 3.8.0-test+</span><br><span class="line"># --------------------------------------------------------------------</span><br><span class="line"># latency: 161 us, #339/339, CPU#3 | (M:preempt VP:0, KP:0, SP:0 HP:0 #P:4)</span><br><span class="line">#    -----------------</span><br><span class="line">#    | task: ls-2269 (uid:0 nice:0 policy:0 rt_prio:0)</span><br><span class="line">#    -----------------</span><br><span class="line">#  =&gt; started at: schedule</span><br><span class="line">#  =&gt; ended at:   mutex_unlock</span><br><span class="line">#</span><br><span class="line">#</span><br><span class="line">#                  _------=&gt; CPU#</span><br><span class="line">#                 / _-----=&gt; irqs-off</span><br><span class="line">#                | / _----=&gt; need-resched</span><br><span class="line">#                || / _---=&gt; hardirq/softirq</span><br><span class="line">#                ||| / _--=&gt; preempt-depth</span><br><span class="line">#                |||| /     delay</span><br><span class="line">#  cmd     pid   ||||| time  |   caller</span><br><span class="line">#     \   /      |||||  \    |   /</span><br><span class="line">kworker/-59      3...1    0us : __schedule &lt;-schedule</span><br><span class="line">kworker/-59      3d..1    0us : rcu_preempt_qs &lt;-rcu_note_context_switch</span><br><span class="line">kworker/-59      3d..1    1us : add_preempt_count &lt;-_raw_spin_lock_irq</span><br><span class="line">kworker/-59      3d..2    1us : deactivate_task &lt;-__schedule</span><br><span class="line">kworker/-59      3d..2    1us : dequeue_task &lt;-deactivate_task</span><br><span class="line">kworker/-59      3d..2    2us : update_rq_clock &lt;-dequeue_task</span><br><span class="line">kworker/-59      3d..2    2us : dequeue_task_fair &lt;-dequeue_task</span><br><span class="line">kworker/-59      3d..2    2us : update_curr &lt;-dequeue_task_fair</span><br><span class="line">kworker/-59      3d..2    2us : update_min_vruntime &lt;-update_curr</span><br><span class="line">kworker/-59      3d..2    3us : cpuacct_charge &lt;-update_curr</span><br><span class="line">kworker/-59      3d..2    3us : __rcu_read_lock &lt;-cpuacct_charge</span><br><span class="line">kworker/-59      3d..2    3us : __rcu_read_unlock &lt;-cpuacct_charge</span><br><span class="line">kworker/-59      3d..2    3us : update_cfs_rq_blocked_load &lt;-dequeue_task_fair</span><br><span class="line">kworker/-59      3d..2    4us : clear_buddies &lt;-dequeue_task_fair</span><br><span class="line">kworker/-59      3d..2    4us : account_entity_dequeue &lt;-dequeue_task_fair</span><br><span class="line">kworker/-59      3d..2    4us : update_min_vruntime &lt;-dequeue_task_fair</span><br><span class="line">kworker/-59      3d..2    4us : update_cfs_shares &lt;-dequeue_task_fair</span><br><span class="line">kworker/-59      3d..2    5us : hrtick_update &lt;-dequeue_task_fair</span><br><span class="line">kworker/-59      3d..2    5us : wq_worker_sleeping &lt;-__schedule</span><br><span class="line">kworker/-59      3d..2    5us : kthread_data &lt;-wq_worker_sleeping</span><br><span class="line">kworker/-59      3d..2    5us : put_prev_task_fair &lt;-__schedule</span><br><span class="line">kworker/-59      3d..2    6us : pick_next_task_fair &lt;-pick_next_task</span><br><span class="line">kworker/-59      3d..2    6us : clear_buddies &lt;-pick_next_task_fair</span><br><span class="line">kworker/-59      3d..2    6us : set_next_entity &lt;-pick_next_task_fair</span><br><span class="line">kworker/-59      3d..2    6us : update_stats_wait_end &lt;-set_next_entity</span><br><span class="line">      ls-2269    3d..2    7us : finish_task_switch &lt;-__schedule</span><br><span class="line">      ls-2269    3d..2    7us : _raw_spin_unlock_irq &lt;-finish_task_switch</span><br><span class="line">      ls-2269    3d..2    8us : do_IRQ &lt;-ret_from_intr</span><br><span class="line">      ls-2269    3d..2    8us : irq_enter &lt;-do_IRQ</span><br><span class="line">      ls-2269    3d..2    8us : rcu_irq_enter &lt;-irq_enter</span><br><span class="line">      ls-2269    3d..2    9us : add_preempt_count &lt;-irq_enter</span><br><span class="line">      ls-2269    3d.h2    9us : exit_idle &lt;-do_IRQ</span><br><span class="line">[...]</span><br><span class="line">      ls-2269    3d.h3   20us : sub_preempt_count &lt;-_raw_spin_unlock</span><br><span class="line">      ls-2269    3d.h2   20us : irq_exit &lt;-do_IRQ</span><br><span class="line">      ls-2269    3d.h2   21us : sub_preempt_count &lt;-irq_exit</span><br><span class="line">      ls-2269    3d..3   21us : do_softirq &lt;-irq_exit</span><br><span class="line">      ls-2269    3d..3   21us : __do_softirq &lt;-call_softirq</span><br><span class="line">      ls-2269    3d..3   21us+: __local_bh_disable &lt;-__do_softirq</span><br><span class="line">      ls-2269    3d.s4   29us : sub_preempt_count &lt;-_local_bh_enable_ip</span><br><span class="line">      ls-2269    3d.s5   29us : sub_preempt_count &lt;-_local_bh_enable_ip</span><br><span class="line">      ls-2269    3d.s5   31us : do_IRQ &lt;-ret_from_intr</span><br><span class="line">      ls-2269    3d.s5   31us : irq_enter &lt;-do_IRQ</span><br><span class="line">      ls-2269    3d.s5   31us : rcu_irq_enter &lt;-irq_enter</span><br><span class="line">[...]</span><br><span class="line">      ls-2269    3d.s5   31us : rcu_irq_enter &lt;-irq_enter</span><br><span class="line">      ls-2269    3d.s5   32us : add_preempt_count &lt;-irq_enter</span><br><span class="line">      ls-2269    3d.H5   32us : exit_idle &lt;-do_IRQ</span><br><span class="line">      ls-2269    3d.H5   32us : handle_irq &lt;-do_IRQ</span><br><span class="line">      ls-2269    3d.H5   32us : irq_to_desc &lt;-handle_irq</span><br><span class="line">      ls-2269    3d.H5   33us : handle_fasteoi_irq &lt;-handle_irq</span><br><span class="line">[...]</span><br><span class="line">      ls-2269    3d.s5  158us : _raw_spin_unlock_irqrestore &lt;-rtl8139_poll</span><br><span class="line">      ls-2269    3d.s3  158us : net_rps_action_and_irq_enable.isra.65 &lt;-net_rx_action</span><br><span class="line">      ls-2269    3d.s3  159us : __local_bh_enable &lt;-__do_softirq</span><br><span class="line">      ls-2269    3d.s3  159us : sub_preempt_count &lt;-__local_bh_enable</span><br><span class="line">      ls-2269    3d..3  159us : idle_cpu &lt;-irq_exit</span><br><span class="line">      ls-2269    3d..3  159us : rcu_irq_exit &lt;-irq_exit</span><br><span class="line">      ls-2269    3d..3  160us : sub_preempt_count &lt;-irq_exit</span><br><span class="line">      ls-2269    3d...  161us : __mutex_unlock_slowpath &lt;-mutex_unlock</span><br><span class="line">      ls-2269    3d...  162us+: trace_hardirqs_on &lt;-mutex_unlock</span><br><span class="line">      ls-2269    3d...  186us : &lt;stack trace&gt;</span><br><span class="line"> =&gt; __mutex_unlock_slowpath</span><br><span class="line"> =&gt; mutex_unlock</span><br><span class="line"> =&gt; process_output</span><br><span class="line"> =&gt; n_tty_write</span><br><span class="line"> =&gt; tty_write</span><br><span class="line"> =&gt; vfs_write</span><br><span class="line"> =&gt; sys_write</span><br><span class="line"> =&gt; system_call_fastpath</span><br></pre></td></tr></table></figure>
<ul>
<li>该例子是一个非常典型的例子</li>
<li>kworker进程切换到ls</li>
<li>在ls released the rq lock and enabled interrupts 是一个中断被触发</li>
<li>当中断完成，它开始处理软中断</li>
<li>当软中断执行时，又触发了另一次硬中断。在软中断中的中断，显示‘H’</li>
</ul>
<h1 id="9、wakeup"><a href="#9、wakeup" class="headerlink" title="9、wakeup"></a>9、wakeup</h1><p>wakeup tracer追踪普通进程从被唤醒到真正得到执行之间的延迟。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># echo 0 &gt; options/function-trace</span><br><span class="line"># echo wakeup &gt; current_tracer</span><br><span class="line"># echo 1 &gt; tracing_on</span><br><span class="line"># echo 0 &gt; tracing_max_latency</span><br><span class="line"># chrt -f 5 sleep 1</span><br><span class="line"># echo 0 &gt; tracing_on</span><br><span class="line"># cat trace</span><br><span class="line"># tracer: wakeup</span><br><span class="line">#</span><br><span class="line"># wakeup latency trace v1.1.5 on 3.8.0-test+</span><br><span class="line"># --------------------------------------------------------------------</span><br><span class="line"># latency: 15 us, #4/4, CPU#3 | (M:preempt VP:0, KP:0, SP:0 HP:0 #P:4)</span><br><span class="line">#    -----------------</span><br><span class="line">#    | task: kworker/3:1H-312 (uid:0 nice:-20 policy:0 rt_prio:0)</span><br><span class="line">#    -----------------</span><br><span class="line">#</span><br><span class="line">#                  _------=&gt; CPU#</span><br><span class="line">#                 / _-----=&gt; irqs-off</span><br><span class="line">#                | / _----=&gt; need-resched</span><br><span class="line">#                || / _---=&gt; hardirq/softirq</span><br><span class="line">#                ||| / _--=&gt; preempt-depth</span><br><span class="line">#                |||| /     delay</span><br><span class="line">#  cmd     pid   ||||| time  |   caller</span><br><span class="line">#     \   /      |||||  \    |   /</span><br><span class="line">  &lt;idle&gt;-0       3dNs7    0us :      0:120:R   + [003]   312:100:R kworker/3:1H</span><br><span class="line">  &lt;idle&gt;-0       3dNs7    1us+: ttwu_do_activate.constprop.87 &lt;-try_to_wake_up</span><br><span class="line">  &lt;idle&gt;-0       3d..3   15us : __schedule &lt;-schedule</span><br><span class="line">  &lt;idle&gt;-0       3d..3   15us :      0:120:R ==&gt; [003]   312:100:R kworker/3:1H</span><br></pre></td></tr></table></figure>
<ul>
<li>tracer追踪优先级最高的进程。我们看到nice -20的kworker进程花了15us到唤醒。</li>
</ul>
<h1 id="10、wakeup-rt"><a href="#10、wakeup-rt" class="headerlink" title="10、wakeup_rt"></a>10、wakeup_rt</h1><p>non-RT进程通常看平均延迟。RT进程的最大延迟非常有意义，反应了调度器的性能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># echo 0 &gt; options/function-trace</span><br><span class="line"># echo wakeup_rt &gt; current_tracer</span><br><span class="line"># echo 1 &gt; tracing_on</span><br><span class="line"># echo 0 &gt; tracing_max_latency</span><br><span class="line"># chrt -f 5 sleep 1</span><br><span class="line"># echo 0 &gt; tracing_on</span><br><span class="line"># cat trace</span><br><span class="line"># tracer: wakeup</span><br><span class="line">#</span><br><span class="line"># tracer: wakeup_rt</span><br><span class="line">#</span><br><span class="line"># wakeup_rt latency trace v1.1.5 on 3.8.0-test+</span><br><span class="line"># --------------------------------------------------------------------</span><br><span class="line"># latency: 5 us, #4/4, CPU#3 | (M:preempt VP:0, KP:0, SP:0 HP:0 #P:4)</span><br><span class="line">#    -----------------</span><br><span class="line">#    | task: sleep-2389 (uid:0 nice:0 policy:1 rt_prio:5)</span><br><span class="line">#    -----------------</span><br><span class="line">#</span><br><span class="line">#                  _------=&gt; CPU#</span><br><span class="line">#                 / _-----=&gt; irqs-off</span><br><span class="line">#                | / _----=&gt; need-resched</span><br><span class="line">#                || / _---=&gt; hardirq/softirq</span><br><span class="line">#                ||| / _--=&gt; preempt-depth</span><br><span class="line">#                |||| /     delay</span><br><span class="line">#  cmd     pid   ||||| time  |   caller</span><br><span class="line">#     \   /      |||||  \    |   /</span><br><span class="line">  &lt;idle&gt;-0       3d.h4    0us :      0:120:R   + [003]  2389: 94:R sleep</span><br><span class="line">  &lt;idle&gt;-0       3d.h4    1us+: ttwu_do_activate.constprop.87 &lt;-try_to_wake_up</span><br><span class="line">  &lt;idle&gt;-0       3d..3    5us : __schedule &lt;-schedule</span><br><span class="line">  &lt;idle&gt;-0       3d..3    5us :      0:120:R ==&gt; [003]  2389: 94:R sleep</span><br></pre></td></tr></table></figure>
<ul>
<li>从idle进程切换到rt进程花了5us</li>
<li>进程 PID为2389，rt_prio 5对应内部优先级(99 - rtprio)：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;idle&gt;-0       3d..3    5us :      0:120:R ==&gt; [003]  2389: 94:R sleep</span><br></pre></td></tr></table></figure>
<p>以下是“wakeup_rt tracer” + “function-trace”：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">echo 1 &gt; options/function-trace</span><br><span class="line"></span><br><span class="line"># tracer: wakeup_rt</span><br><span class="line">#</span><br><span class="line"># wakeup_rt latency trace v1.1.5 on 3.8.0-test+</span><br><span class="line"># --------------------------------------------------------------------</span><br><span class="line"># latency: 29 us, #85/85, CPU#3 | (M:preempt VP:0, KP:0, SP:0 HP:0 #P:4)</span><br><span class="line">#    -----------------</span><br><span class="line">#    | task: sleep-2448 (uid:0 nice:0 policy:1 rt_prio:5)</span><br><span class="line">#    -----------------</span><br><span class="line">#</span><br><span class="line">#                  _------=&gt; CPU#</span><br><span class="line">#                 / _-----=&gt; irqs-off</span><br><span class="line">#                | / _----=&gt; need-resched</span><br><span class="line">#                || / _---=&gt; hardirq/softirq</span><br><span class="line">#                ||| / _--=&gt; preempt-depth</span><br><span class="line">#                |||| /     delay</span><br><span class="line">#  cmd     pid   ||||| time  |   caller</span><br><span class="line">#     \   /      |||||  \    |   /</span><br><span class="line">  &lt;idle&gt;-0       3d.h4    1us+:      0:120:R   + [003]  2448: 94:R sleep</span><br><span class="line">  &lt;idle&gt;-0       3d.h4    2us : ttwu_do_activate.constprop.87 &lt;-try_to_wake_up</span><br><span class="line">  &lt;idle&gt;-0       3d.h3    3us : check_preempt_curr &lt;-ttwu_do_wakeup</span><br><span class="line">  &lt;idle&gt;-0       3d.h3    3us : resched_curr &lt;-check_preempt_curr</span><br><span class="line">  &lt;idle&gt;-0       3dNh3    4us : task_woken_rt &lt;-ttwu_do_wakeup</span><br><span class="line">  &lt;idle&gt;-0       3dNh3    4us : _raw_spin_unlock &lt;-try_to_wake_up</span><br><span class="line">  &lt;idle&gt;-0       3dNh3    4us : sub_preempt_count &lt;-_raw_spin_unlock</span><br><span class="line">  &lt;idle&gt;-0       3dNh2    5us : ttwu_stat &lt;-try_to_wake_up</span><br><span class="line">  &lt;idle&gt;-0       3dNh2    5us : _raw_spin_unlock_irqrestore &lt;-try_to_wake_up</span><br><span class="line">  &lt;idle&gt;-0       3dNh2    6us : sub_preempt_count &lt;-_raw_spin_unlock_irqrestore</span><br><span class="line">  &lt;idle&gt;-0       3dNh1    6us : _raw_spin_lock &lt;-__run_hrtimer</span><br><span class="line">  &lt;idle&gt;-0       3dNh1    6us : add_preempt_count &lt;-_raw_spin_lock</span><br><span class="line">  &lt;idle&gt;-0       3dNh2    7us : _raw_spin_unlock &lt;-hrtimer_interrupt</span><br><span class="line">  &lt;idle&gt;-0       3dNh2    7us : sub_preempt_count &lt;-_raw_spin_unlock</span><br><span class="line">  &lt;idle&gt;-0       3dNh1    7us : tick_program_event &lt;-hrtimer_interrupt</span><br><span class="line">  &lt;idle&gt;-0       3dNh1    7us : clockevents_program_event &lt;-tick_program_event</span><br><span class="line">  &lt;idle&gt;-0       3dNh1    8us : ktime_get &lt;-clockevents_program_event</span><br><span class="line">  &lt;idle&gt;-0       3dNh1    8us : lapic_next_event &lt;-clockevents_program_event</span><br><span class="line">  &lt;idle&gt;-0       3dNh1    8us : irq_exit &lt;-smp_apic_timer_interrupt</span><br><span class="line">  &lt;idle&gt;-0       3dNh1    9us : sub_preempt_count &lt;-irq_exit</span><br><span class="line">  &lt;idle&gt;-0       3dN.2    9us : idle_cpu &lt;-irq_exit</span><br><span class="line">  &lt;idle&gt;-0       3dN.2    9us : rcu_irq_exit &lt;-irq_exit</span><br><span class="line">  &lt;idle&gt;-0       3dN.2   10us : rcu_eqs_enter_common.isra.45 &lt;-rcu_irq_exit</span><br><span class="line">  &lt;idle&gt;-0       3dN.2   10us : sub_preempt_count &lt;-irq_exit</span><br><span class="line">  &lt;idle&gt;-0       3.N.1   11us : rcu_idle_exit &lt;-cpu_idle</span><br><span class="line">  &lt;idle&gt;-0       3dN.1   11us : rcu_eqs_exit_common.isra.43 &lt;-rcu_idle_exit</span><br><span class="line">  &lt;idle&gt;-0       3.N.1   11us : tick_nohz_idle_exit &lt;-cpu_idle</span><br><span class="line">  &lt;idle&gt;-0       3dN.1   12us : menu_hrtimer_cancel &lt;-tick_nohz_idle_exit</span><br><span class="line">  &lt;idle&gt;-0       3dN.1   12us : ktime_get &lt;-tick_nohz_idle_exit</span><br><span class="line">  &lt;idle&gt;-0       3dN.1   12us : tick_do_update_jiffies64 &lt;-tick_nohz_idle_exit</span><br><span class="line">  &lt;idle&gt;-0       3dN.1   13us : cpu_load_update_nohz &lt;-tick_nohz_idle_exit</span><br><span class="line">  &lt;idle&gt;-0       3dN.1   13us : _raw_spin_lock &lt;-cpu_load_update_nohz</span><br><span class="line">  &lt;idle&gt;-0       3dN.1   13us : add_preempt_count &lt;-_raw_spin_lock</span><br><span class="line">  &lt;idle&gt;-0       3dN.2   13us : __cpu_load_update &lt;-cpu_load_update_nohz</span><br><span class="line">  &lt;idle&gt;-0       3dN.2   14us : sched_avg_update &lt;-__cpu_load_update</span><br><span class="line">  &lt;idle&gt;-0       3dN.2   14us : _raw_spin_unlock &lt;-cpu_load_update_nohz</span><br><span class="line">  &lt;idle&gt;-0       3dN.2   14us : sub_preempt_count &lt;-_raw_spin_unlock</span><br><span class="line">  &lt;idle&gt;-0       3dN.1   15us : calc_load_nohz_stop &lt;-tick_nohz_idle_exit</span><br><span class="line">  &lt;idle&gt;-0       3dN.1   15us : touch_softlockup_watchdog &lt;-tick_nohz_idle_exit</span><br><span class="line">  &lt;idle&gt;-0       3dN.1   15us : hrtimer_cancel &lt;-tick_nohz_idle_exit</span><br><span class="line">  &lt;idle&gt;-0       3dN.1   15us : hrtimer_try_to_cancel &lt;-hrtimer_cancel</span><br><span class="line">  &lt;idle&gt;-0       3dN.1   16us : lock_hrtimer_base.isra.18 &lt;-hrtimer_try_to_cancel</span><br><span class="line">  &lt;idle&gt;-0       3dN.1   16us : _raw_spin_lock_irqsave &lt;-lock_hrtimer_base.isra.18</span><br><span class="line">  &lt;idle&gt;-0       3dN.1   16us : add_preempt_count &lt;-_raw_spin_lock_irqsave</span><br><span class="line">  &lt;idle&gt;-0       3dN.2   17us : __remove_hrtimer &lt;-remove_hrtimer.part.16</span><br><span class="line">  &lt;idle&gt;-0       3dN.2   17us : hrtimer_force_reprogram &lt;-__remove_hrtimer</span><br><span class="line">  &lt;idle&gt;-0       3dN.2   17us : tick_program_event &lt;-hrtimer_force_reprogram</span><br><span class="line">  &lt;idle&gt;-0       3dN.2   18us : clockevents_program_event &lt;-tick_program_event</span><br><span class="line">  &lt;idle&gt;-0       3dN.2   18us : ktime_get &lt;-clockevents_program_event</span><br><span class="line">  &lt;idle&gt;-0       3dN.2   18us : lapic_next_event &lt;-clockevents_program_event</span><br><span class="line">  &lt;idle&gt;-0       3dN.2   19us : _raw_spin_unlock_irqrestore &lt;-hrtimer_try_to_cancel</span><br><span class="line">  &lt;idle&gt;-0       3dN.2   19us : sub_preempt_count &lt;-_raw_spin_unlock_irqrestore</span><br><span class="line">  &lt;idle&gt;-0       3dN.1   19us : hrtimer_forward &lt;-tick_nohz_idle_exit</span><br><span class="line">  &lt;idle&gt;-0       3dN.1   20us : ktime_add_safe &lt;-hrtimer_forward</span><br><span class="line">  &lt;idle&gt;-0       3dN.1   20us : ktime_add_safe &lt;-hrtimer_forward</span><br><span class="line">  &lt;idle&gt;-0       3dN.1   20us : hrtimer_start_range_ns &lt;-hrtimer_start_expires.constprop.11</span><br><span class="line">  &lt;idle&gt;-0       3dN.1   20us : __hrtimer_start_range_ns &lt;-hrtimer_start_range_ns</span><br><span class="line">  &lt;idle&gt;-0       3dN.1   21us : lock_hrtimer_base.isra.18 &lt;-__hrtimer_start_range_ns</span><br><span class="line">  &lt;idle&gt;-0       3dN.1   21us : _raw_spin_lock_irqsave &lt;-lock_hrtimer_base.isra.18</span><br><span class="line">  &lt;idle&gt;-0       3dN.1   21us : add_preempt_count &lt;-_raw_spin_lock_irqsave</span><br><span class="line">  &lt;idle&gt;-0       3dN.2   22us : ktime_add_safe &lt;-__hrtimer_start_range_ns</span><br><span class="line">  &lt;idle&gt;-0       3dN.2   22us : enqueue_hrtimer &lt;-__hrtimer_start_range_ns</span><br><span class="line">  &lt;idle&gt;-0       3dN.2   22us : tick_program_event &lt;-__hrtimer_start_range_ns</span><br><span class="line">  &lt;idle&gt;-0       3dN.2   23us : clockevents_program_event &lt;-tick_program_event</span><br><span class="line">  &lt;idle&gt;-0       3dN.2   23us : ktime_get &lt;-clockevents_program_event</span><br><span class="line">  &lt;idle&gt;-0       3dN.2   23us : lapic_next_event &lt;-clockevents_program_event</span><br><span class="line">  &lt;idle&gt;-0       3dN.2   24us : _raw_spin_unlock_irqrestore &lt;-__hrtimer_start_range_ns</span><br><span class="line">  &lt;idle&gt;-0       3dN.2   24us : sub_preempt_count &lt;-_raw_spin_unlock_irqrestore</span><br><span class="line">  &lt;idle&gt;-0       3dN.1   24us : account_idle_ticks &lt;-tick_nohz_idle_exit</span><br><span class="line">  &lt;idle&gt;-0       3dN.1   24us : account_idle_time &lt;-account_idle_ticks</span><br><span class="line">  &lt;idle&gt;-0       3.N.1   25us : sub_preempt_count &lt;-cpu_idle</span><br><span class="line">  &lt;idle&gt;-0       3.N..   25us : schedule &lt;-cpu_idle</span><br><span class="line">  &lt;idle&gt;-0       3.N..   25us : __schedule &lt;-preempt_schedule</span><br><span class="line">  &lt;idle&gt;-0       3.N..   26us : add_preempt_count &lt;-__schedule</span><br><span class="line">  &lt;idle&gt;-0       3.N.1   26us : rcu_note_context_switch &lt;-__schedule</span><br><span class="line">  &lt;idle&gt;-0       3.N.1   26us : rcu_sched_qs &lt;-rcu_note_context_switch</span><br><span class="line">  &lt;idle&gt;-0       3dN.1   27us : rcu_preempt_qs &lt;-rcu_note_context_switch</span><br><span class="line">  &lt;idle&gt;-0       3.N.1   27us : _raw_spin_lock_irq &lt;-__schedule</span><br><span class="line">  &lt;idle&gt;-0       3dN.1   27us : add_preempt_count &lt;-_raw_spin_lock_irq</span><br><span class="line">  &lt;idle&gt;-0       3dN.2   28us : put_prev_task_idle &lt;-__schedule</span><br><span class="line">  &lt;idle&gt;-0       3dN.2   28us : pick_next_task_stop &lt;-pick_next_task</span><br><span class="line">  &lt;idle&gt;-0       3dN.2   28us : pick_next_task_rt &lt;-pick_next_task</span><br><span class="line">  &lt;idle&gt;-0       3dN.2   29us : dequeue_pushable_task &lt;-pick_next_task_rt</span><br><span class="line">  &lt;idle&gt;-0       3d..3   29us : __schedule &lt;-preempt_schedule</span><br><span class="line">  &lt;idle&gt;-0       3d..3   30us :      0:120:R ==&gt; [003]  2448: 94:R sleep</span><br></pre></td></tr></table></figure>
<h1 id="11、Latency-tracing-and-events"><a href="#11、Latency-tracing-and-events" class="headerlink" title="11、Latency tracing and events"></a>11、Latency tracing and events</h1><p>如果“xxxlatency tracer” + “function-trace”方式会带来很多开销，但是你又想知道中间发生了什么，可以使用折中的方法：“xxxlatency tracer” + “trace event”：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"># echo 0 &gt; options/function-trace</span><br><span class="line"># echo wakeup_rt &gt; current_tracer</span><br><span class="line"># echo 1 &gt; events/enable</span><br><span class="line"># echo 1 &gt; tracing_on</span><br><span class="line"># echo 0 &gt; tracing_max_latency</span><br><span class="line"># chrt -f 5 sleep 1</span><br><span class="line"># echo 0 &gt; tracing_on</span><br><span class="line"># cat trace</span><br><span class="line"># tracer: wakeup_rt</span><br><span class="line">#</span><br><span class="line"># wakeup_rt latency trace v1.1.5 on 3.8.0-test+</span><br><span class="line"># --------------------------------------------------------------------</span><br><span class="line"># latency: 6 us, #12/12, CPU#2 | (M:preempt VP:0, KP:0, SP:0 HP:0 #P:4)</span><br><span class="line">#    -----------------</span><br><span class="line">#    | task: sleep-5882 (uid:0 nice:0 policy:1 rt_prio:5)</span><br><span class="line">#    -----------------</span><br><span class="line">#</span><br><span class="line">#                  _------=&gt; CPU#</span><br><span class="line">#                 / _-----=&gt; irqs-off</span><br><span class="line">#                | / _----=&gt; need-resched</span><br><span class="line">#                || / _---=&gt; hardirq/softirq</span><br><span class="line">#                ||| / _--=&gt; preempt-depth</span><br><span class="line">#                |||| /     delay</span><br><span class="line">#  cmd     pid   ||||| time  |   caller</span><br><span class="line">#     \   /      |||||  \    |   /</span><br><span class="line">  &lt;idle&gt;-0       2d.h4    0us :      0:120:R   + [002]  5882: 94:R sleep</span><br><span class="line">  &lt;idle&gt;-0       2d.h4    0us : ttwu_do_activate.constprop.87 &lt;-try_to_wake_up</span><br><span class="line">  &lt;idle&gt;-0       2d.h4    1us : sched_wakeup: comm=sleep pid=5882 prio=94 success=1 target_cpu=002</span><br><span class="line">  &lt;idle&gt;-0       2dNh2    1us : hrtimer_expire_exit: hrtimer=ffff88007796feb8</span><br><span class="line">  &lt;idle&gt;-0       2.N.2    2us : power_end: cpu_id=2</span><br><span class="line">  &lt;idle&gt;-0       2.N.2    3us : cpu_idle: state=4294967295 cpu_id=2</span><br><span class="line">  &lt;idle&gt;-0       2dN.3    4us : hrtimer_cancel: hrtimer=ffff88007d50d5e0</span><br><span class="line">  &lt;idle&gt;-0       2dN.3    4us : hrtimer_start: hrtimer=ffff88007d50d5e0 function=tick_sched_timer expires=34311211000000 softexpires=34311211000000</span><br><span class="line">  &lt;idle&gt;-0       2.N.2    5us : rcu_utilization: Start context switch</span><br><span class="line">  &lt;idle&gt;-0       2.N.2    5us : rcu_utilization: End context switch</span><br><span class="line">  &lt;idle&gt;-0       2d..3    6us : __schedule &lt;-schedule</span><br><span class="line">  &lt;idle&gt;-0       2d..3    6us :      0:120:R ==&gt; [002]  5882: 94:R sleep</span><br></pre></td></tr></table></figure>
<h1 id="12、Hardware-Latency-Detector"><a href="#12、Hardware-Latency-Detector" class="headerlink" title="12、Hardware Latency Detector"></a>12、Hardware Latency Detector</h1><p>计算硬件延迟。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># echo hwlat &gt; current_tracer</span><br><span class="line"># sleep 100</span><br><span class="line"># cat trace</span><br><span class="line"># tracer: hwlat</span><br><span class="line">#</span><br><span class="line">#                              _-----=&gt; irqs-off</span><br><span class="line">#                             / _----=&gt; need-resched</span><br><span class="line">#                            | / _---=&gt; hardirq/softirq</span><br><span class="line">#                            || / _--=&gt; preempt-depth</span><br><span class="line">#                            ||| /     delay</span><br><span class="line">#           TASK-PID   CPU#  ||||    TIMESTAMP  FUNCTION</span><br><span class="line">#              | |       |   ||||       |         |</span><br><span class="line">           &lt;...&gt;-3638  [001] d... 19452.055471: #1     inner/outer(us):   12/14    ts:1499801089.066141940</span><br><span class="line">           &lt;...&gt;-3638  [003] d... 19454.071354: #2     inner/outer(us):   11/9     ts:1499801091.082164365</span><br><span class="line">           &lt;...&gt;-3638  [002] dn.. 19461.126852: #3     inner/outer(us):   12/9     ts:1499801098.138150062</span><br><span class="line">           &lt;...&gt;-3638  [001] d... 19488.340960: #4     inner/outer(us):    8/12    ts:1499801125.354139633</span><br><span class="line">           &lt;...&gt;-3638  [003] d... 19494.388553: #5     inner/outer(us):    8/12    ts:1499801131.402150961</span><br><span class="line">           &lt;...&gt;-3638  [003] d... 19501.283419: #6     inner/outer(us):    0/12    ts:1499801138.297435289 nmi-total:4 nmi-count:1</span><br></pre></td></tr></table></figure>
<p>所有的event都是在中断disable ‘d’。每个字段相应的含义如下：</p>
<table border="1"><br><caption> hwlat </caption><br><br><tr><br><th style="width: 200px;">Field</th><br><th style="width: 200px;">Value</th><br><th style="width: 400px;">Description</th><br><th style="width: 400px;">说明</th><br></tr><br><br><tr><br><td> #1 </td><br><td> - </td><br><td><br>This is the count of events recorded that were greater than the tracing_threshold (See below).<br></td><br><td><br>大于tracing_threshold的event的编号<br></td><br></tr><br><br><tr><br><td> inner/outer(us) </td><br><td> 12/14 </td><br><td><br>This shows two numbers as “inner latency” and “outer latency”. The test runs in a loop checking a timestamp twice. The latency detected within the two timestamps is the “inner latency” and the latency detected after the previous timestamp and the next timestamp in the loop is the “outer latency”.<br></td><br><td><br>“inner latency” 和 “outer latency”<br></td><br></tr><br><br><tr><br><td> ts </td><br><td> 1499801089.066141940 </td><br><td><br>The absolute timestamp that the event happened.<br></td><br><td><br>绝对时间戳<br></td><br></tr><br><br><tr><br><td> nmi-total:4 nmi-count:1 </td><br><td> - </td><br><td><br>On architectures that support it, if an NMI comes in during the test, the time spent in NMI is reported in “nmi-total” (in microseconds).<br><br>All architectures that have NMIs will show the “nmi-count” if an NMI comes in during the test.<br></td><br><td><br><br></td><br></tr><br><br></table>

<p>hwlat相关的文件：</p>
<table border="1"><br><caption> hwlat file </caption><br><br><tr><br><th style="width: 200px;">File</th><br><th style="width: 400px;">Description</th><br><th style="width: 400px;">说明</th><br></tr><br><br><tr><br><td> tracing_threshold </td><br><td><br>This gets automatically set to “10” to represent 10 microseconds. This is the threshold of latency that needs to be detected before the trace will be recorded.<br><br>Note, when hwlat tracer is finished (another tracer is written into “current_tracer”), the original value for tracing_threshold is placed back into this file.<br></td><br><td><br>大于tracing_threshold的event才会被记录<br></td><br></tr><br><br><tr><br><td> hwlat_detector/width </td><br><td><br>The length of time the test runs with interrupts disabled.<br></td><br><td><br><br></td><br></tr><br><br><tr><br><td> hwlat_detector/window </td><br><td><br>The length of time of the window which the test runs. That is, the test will run for “width” microseconds per “window” microseconds<br></td><br><td><br><br></td><br></tr><br><br><tr><br><td> tracing_cpumask </td><br><td><br>When the test is started. A kernel thread is created that runs the test. This thread will alternate between CPUs listed in the tracing_cpumask between each period (one “window”). To limit the test to specific CPUs set the mask in this file to only the CPUs that the test should run on.<br></td><br><td><br><br></td><br></tr><br><br></table>

<h1 id="13、function"><a href="#13、function" class="headerlink" title="13、function"></a>13、function</h1><p>function tracer，确保“ftrace_enabled”被设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># sysctl kernel.ftrace_enabled=1</span><br><span class="line"># echo function &gt; current_tracer</span><br><span class="line"># echo 1 &gt; tracing_on</span><br><span class="line"># usleep 1</span><br><span class="line"># echo 0 &gt; tracing_on</span><br><span class="line"># cat trace</span><br><span class="line"># tracer: function</span><br><span class="line">#</span><br><span class="line"># entries-in-buffer/entries-written: 24799/24799   #P:4</span><br><span class="line">#</span><br><span class="line">#                              _-----=&gt; irqs-off</span><br><span class="line">#                             / _----=&gt; need-resched</span><br><span class="line">#                            | / _---=&gt; hardirq/softirq</span><br><span class="line">#                            || / _--=&gt; preempt-depth</span><br><span class="line">#                            ||| /     delay</span><br><span class="line">#           TASK-PID   CPU#  ||||    TIMESTAMP  FUNCTION</span><br><span class="line">#              | |       |   ||||       |         |</span><br><span class="line">            bash-1994  [002] ....  3082.063030: mutex_unlock &lt;-rb_simple_write</span><br><span class="line">            bash-1994  [002] ....  3082.063031: __mutex_unlock_slowpath &lt;-mutex_unlock</span><br><span class="line">            bash-1994  [002] ....  3082.063031: __fsnotify_parent &lt;-fsnotify_modify</span><br><span class="line">            bash-1994  [002] ....  3082.063032: fsnotify &lt;-fsnotify_modify</span><br><span class="line">            bash-1994  [002] ....  3082.063032: __srcu_read_lock &lt;-fsnotify</span><br><span class="line">            bash-1994  [002] ....  3082.063032: add_preempt_count &lt;-__srcu_read_lock</span><br><span class="line">            bash-1994  [002] ...1  3082.063032: sub_preempt_count &lt;-__srcu_read_lock</span><br><span class="line">            bash-1994  [002] ....  3082.063033: __srcu_read_unlock &lt;-fsnotify</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>
<p>使用echo来打开关闭tracing的方式太慢了，可能会引起数据覆盖。可以使用c预研代码来操控开关：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int trace_fd;</span><br><span class="line">[...]</span><br><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line">        [...]</span><br><span class="line">        trace_fd = open(tracing_file(&quot;tracing_on&quot;), O_WRONLY);</span><br><span class="line">        [...]</span><br><span class="line">        if (condition_hit()) &#123;</span><br><span class="line">                write(trace_fd, &quot;0&quot;, 1);</span><br><span class="line">        &#125;</span><br><span class="line">        [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="13-1、Single-thread-tracing"><a href="#13-1、Single-thread-tracing" class="headerlink" title="13.1、Single thread tracing"></a>13.1、Single thread tracing</h2><p>function tracer可以针对某一个PID的进程设置过滤：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># cat set_ftrace_pid</span><br><span class="line">no pid</span><br><span class="line"># echo 3111 &gt; set_ftrace_pid</span><br><span class="line"># cat set_ftrace_pid</span><br><span class="line">3111</span><br><span class="line"># echo function &gt; current_tracer</span><br><span class="line"># cat trace | head</span><br><span class="line"># tracer: function</span><br><span class="line">#</span><br><span class="line">#           TASK-PID    CPU#    TIMESTAMP  FUNCTION</span><br><span class="line">#              | |       |          |         |</span><br><span class="line">    yum-updatesd-3111  [003]  1637.254676: finish_task_switch &lt;-thread_return</span><br><span class="line">    yum-updatesd-3111  [003]  1637.254681: hrtimer_cancel &lt;-schedule_hrtimeout_range</span><br><span class="line">    yum-updatesd-3111  [003]  1637.254682: hrtimer_try_to_cancel &lt;-hrtimer_cancel</span><br><span class="line">    yum-updatesd-3111  [003]  1637.254683: lock_hrtimer_base &lt;-hrtimer_try_to_cancel</span><br><span class="line">    yum-updatesd-3111  [003]  1637.254685: fget_light &lt;-do_sys_poll</span><br><span class="line">    yum-updatesd-3111  [003]  1637.254686: pipe_poll &lt;-do_sys_poll</span><br><span class="line"># echo &gt; set_ftrace_pid</span><br><span class="line"># cat trace |head</span><br><span class="line"># tracer: function</span><br><span class="line">#</span><br><span class="line">#           TASK-PID    CPU#    TIMESTAMP  FUNCTION</span><br><span class="line">#              | |       |          |         |</span><br><span class="line">##### CPU 3 buffer started ####</span><br><span class="line">    yum-updatesd-3111  [003]  1701.957688: free_poll_entry &lt;-poll_freewait</span><br><span class="line">    yum-updatesd-3111  [003]  1701.957689: remove_wait_queue &lt;-free_poll_entry</span><br><span class="line">    yum-updatesd-3111  [003]  1701.957691: fput &lt;-free_poll_entry</span><br><span class="line">    yum-updatesd-3111  [003]  1701.957692: audit_syscall_exit &lt;-sysret_audit</span><br><span class="line">    yum-updatesd-3111  [003]  1701.957693: path_put &lt;-audit_syscall_exit</span><br></pre></td></tr></table></figure>
<p>可以在程序运行时，通过C程序来设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">#define _STR(x) #x</span><br><span class="line">#define STR(x) _STR(x)</span><br><span class="line">#define MAX_PATH 256</span><br><span class="line"></span><br><span class="line">const char *find_tracefs(void)</span><br><span class="line">&#123;</span><br><span class="line">       static char tracefs[MAX_PATH+1];</span><br><span class="line">       static int tracefs_found;</span><br><span class="line">       char type[100];</span><br><span class="line">       FILE *fp;</span><br><span class="line"></span><br><span class="line">       if (tracefs_found)</span><br><span class="line">               return tracefs;</span><br><span class="line"></span><br><span class="line">       if ((fp = fopen(&quot;/proc/mounts&quot;,&quot;r&quot;)) == NULL) &#123;</span><br><span class="line">               perror(&quot;/proc/mounts&quot;);</span><br><span class="line">               return NULL;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       while (fscanf(fp, &quot;%*s %&quot;</span><br><span class="line">                     STR(MAX_PATH)</span><br><span class="line">                     &quot;s %99s %*s %*d %*d\n&quot;,</span><br><span class="line">                     tracefs, type) == 2) &#123;</span><br><span class="line">               if (strcmp(type, &quot;tracefs&quot;) == 0)</span><br><span class="line">                       break;</span><br><span class="line">       &#125;</span><br><span class="line">       fclose(fp);</span><br><span class="line"></span><br><span class="line">       if (strcmp(type, &quot;tracefs&quot;) != 0) &#123;</span><br><span class="line">               fprintf(stderr, &quot;tracefs not mounted&quot;);</span><br><span class="line">               return NULL;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       strcat(tracefs, &quot;/tracing/&quot;);</span><br><span class="line">       tracefs_found = 1;</span><br><span class="line"></span><br><span class="line">       return tracefs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const char *tracing_file(const char *file_name)</span><br><span class="line">&#123;</span><br><span class="line">       static char trace_file[MAX_PATH+1];</span><br><span class="line">       snprintf(trace_file, MAX_PATH, &quot;%s/%s&quot;, find_tracefs(), file_name);</span><br><span class="line">       return trace_file;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main (int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">        if (argc &lt; 1)</span><br><span class="line">                exit(-1);</span><br><span class="line"></span><br><span class="line">        if (fork() &gt; 0) &#123;</span><br><span class="line">                int fd, ffd;</span><br><span class="line">                char line[64];</span><br><span class="line">                int s;</span><br><span class="line"></span><br><span class="line">                ffd = open(tracing_file(&quot;current_tracer&quot;), O_WRONLY);</span><br><span class="line">                if (ffd &lt; 0)</span><br><span class="line">                        exit(-1);</span><br><span class="line">                write(ffd, &quot;nop&quot;, 3);</span><br><span class="line"></span><br><span class="line">                fd = open(tracing_file(&quot;set_ftrace_pid&quot;), O_WRONLY);</span><br><span class="line">                s = sprintf(line, &quot;%d\n&quot;, getpid());</span><br><span class="line">                write(fd, line, s);</span><br><span class="line"></span><br><span class="line">                write(ffd, &quot;function&quot;, 8);</span><br><span class="line"></span><br><span class="line">                close(fd);</span><br><span class="line">                close(ffd);</span><br><span class="line"></span><br><span class="line">                execvp(argv[1], argv+1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者通过脚本来设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">tracefs=`sed -ne &apos;s/^tracefs \(.*\) tracefs.*/\1/p&apos; /proc/mounts`</span><br><span class="line">echo nop &gt; $tracefs/tracing/current_tracer</span><br><span class="line">echo 0 &gt; $tracefs/tracing/tracing_on</span><br><span class="line">echo $$ &gt; $tracefs/tracing/set_ftrace_pid</span><br><span class="line">echo function &gt; $tracefs/tracing/current_tracer</span><br><span class="line">echo 1 &gt; $tracefs/tracing/tracing_on</span><br><span class="line">exec &quot;$@&quot;</span><br></pre></td></tr></table></figure>
<h1 id="14、function-graph-tracer"><a href="#14、function-graph-tracer" class="headerlink" title="14、function graph tracer"></a>14、function graph tracer</h1><p>function graph tracer非常类似function tracer除了同时追踪函数的进入和退出。它是利用每个task_struct中的return address堆栈动态分配来实现的，在进入函数的时候会使用自定义的probe函数替换掉原本的return地址。因此原始的return地址会存放在task_struct返回地址堆栈中。</p>
<p>在所有的函数退出点插入probe函数，导致新的特性：</p>
<ul>
<li>测量函数的执行时间</li>
<li>有一个可靠的调用栈来画函数调用图</li>
</ul>
<p>这个tracer应用到以下的场景：</p>
<ul>
<li>你想要找出内核奇怪行为的原因，需要看到具体细节上发生了什么</li>
<li>你正在经历奇怪的延迟但是非常难找到它的起源</li>
<li>你想要快速查找出特定函数的执行路径</li>
<li>你想窥视一个正在工作中的内核，看看到底发生了什么</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># tracer: function_graph</span><br><span class="line">#</span><br><span class="line"># CPU  DURATION                  FUNCTION CALLS</span><br><span class="line"># |     |   |                     |   |   |   |</span><br><span class="line"></span><br><span class="line"> 0)               |  sys_open() &#123;</span><br><span class="line"> 0)               |    do_sys_open() &#123;</span><br><span class="line"> 0)               |      getname() &#123;</span><br><span class="line"> 0)               |        kmem_cache_alloc() &#123;</span><br><span class="line"> 0)   1.382 us    |          __might_sleep();</span><br><span class="line"> 0)   2.478 us    |        &#125;</span><br><span class="line"> 0)               |        strncpy_from_user() &#123;</span><br><span class="line"> 0)               |          might_fault() &#123;</span><br><span class="line"> 0)   1.389 us    |            __might_sleep();</span><br><span class="line"> 0)   2.553 us    |          &#125;</span><br><span class="line"> 0)   3.807 us    |        &#125;</span><br><span class="line"> 0)   7.876 us    |      &#125;</span><br><span class="line"> 0)               |      alloc_fd() &#123;</span><br><span class="line"> 0)   0.668 us    |        _spin_lock();</span><br><span class="line"> 0)   0.570 us    |        expand_files();</span><br><span class="line"> 0)   0.586 us    |        _spin_unlock();</span><br></pre></td></tr></table></figure>
<p>这有一系列的列信息可以动态的anbale/disable，你可以根据你的需要组合option配置：</p>
<ul>
<li><p>运行cpu的编号：</p>
<p>  hide: echo nofuncgraph-cpu &gt; trace_options<br>  show: echo funcgraph-cpu &gt; trace_options</p>
</li>
<li><p>函数执行时间。在函数的闭括号行显示，或者在叶子函数的同一行显示。默认enable：</p>
<p>  hide: echo nofuncgraph-duration &gt; trace_options<br>  show: echo funcgraph-duration &gt; trace_options</p>
</li>
<li><p>开销字段，在执行时间字段之前，标明时间大小的程度：</p>
<p>  例如：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">3) # 1837.709 us |          &#125; /* __switch_to */</span><br><span class="line">3)               |          finish_task_switch() &#123;</span><br><span class="line">3)   0.313 us    |            _raw_spin_unlock_irq();</span><br><span class="line">3)   3.177 us    |          &#125;</span><br><span class="line">3) # 1889.063 us |        &#125; /* __schedule */</span><br><span class="line">3) ! 140.417 us  |      &#125; /* __schedule */</span><br><span class="line">3) # 2034.948 us |    &#125; /* schedule */</span><br><span class="line">3) * 33998.59 us |  &#125; /* schedule_preempt_disabled */</span><br><span class="line"></span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line">1)   0.260 us    |              msecs_to_jiffies();</span><br><span class="line">1)   0.313 us    |              __rcu_read_unlock();</span><br><span class="line">1) + 61.770 us   |            &#125;</span><br><span class="line">1) + 64.479 us   |          &#125;</span><br><span class="line">1)   0.313 us    |          rcu_bh_qs();</span><br><span class="line">1)   0.313 us    |          __local_bh_enable();</span><br><span class="line">1) ! 217.240 us  |        &#125;</span><br><span class="line">1)   0.365 us    |        idle_cpu();</span><br><span class="line">1)               |        rcu_irq_exit() &#123;</span><br><span class="line">1)   0.417 us    |          rcu_eqs_enter_common.isra.47();</span><br><span class="line">1)   3.125 us    |        &#125;</span><br><span class="line">1) ! 227.812 us  |      &#125;</span><br><span class="line">1) ! 457.395 us  |    &#125;</span><br><span class="line">1) @ 119760.2 us |  &#125;</span><br><span class="line"></span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line">2)               |    handle_IPI() &#123;</span><br><span class="line">1)   6.979 us    |                  &#125;</span><br><span class="line">2)   0.417 us    |      scheduler_ipi();</span><br><span class="line">1)   9.791 us    |                &#125;</span><br><span class="line">1) + 12.917 us   |              &#125;</span><br><span class="line">2)   3.490 us    |    &#125;</span><br><span class="line">1) + 15.729 us   |            &#125;</span><br><span class="line">1) + 18.542 us   |          &#125;</span><br><span class="line">2) $ 3594274 us  |  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<pre><code>flgs的含义如下：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ means that the function exceeded 10 usecs.</span><br><span class="line">! means that the function exceeded 100 usecs.</span><br><span class="line"># means that the function exceeded 1000 usecs.</span><br><span class="line">* means that the function exceeded 10 msecs.</span><br><span class="line">@ means that the function exceeded 100 msecs.</span><br><span class="line">$ means that the function exceeded 1 sec.</span><br></pre></td></tr></table></figure>
</code></pre><ul>
<li><p>task/pid字段，用来显示执行进程的cmdline和pid。默认disable：</p>
<p>  hide: echo nofuncgraph-proc &gt; trace_options<br>  show: echo funcgraph-proc &gt; trace_options</p>
<p>  例如：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># tracer: function_graph</span><br><span class="line">#</span><br><span class="line"># CPU  TASK/PID        DURATION                  FUNCTION CALLS</span><br><span class="line"># |    |    |           |   |                     |   |   |   |</span><br><span class="line">0)    sh-4802     |               |                  d_free() &#123;</span><br><span class="line">0)    sh-4802     |               |                    call_rcu() &#123;</span><br><span class="line">0)    sh-4802     |               |                      __call_rcu() &#123;</span><br><span class="line">0)    sh-4802     |   0.616 us    |                        rcu_process_gp_end();</span><br><span class="line">0)    sh-4802     |   0.586 us    |                        check_for_new_grace_period();</span><br><span class="line">0)    sh-4802     |   2.899 us    |                      &#125;</span><br><span class="line">0)    sh-4802     |   4.040 us    |                    &#125;</span><br><span class="line">0)    sh-4802     |   5.151 us    |                  &#125;</span><br><span class="line">0)    sh-4802     | + 49.370 us   |                &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>绝对时间戳字段：</p>
<p>  hide: echo nofuncgraph-abstime &gt; trace_options<br>  show: echo funcgraph-abstime &gt; trace_options</p>
<p>  例如：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line">#      TIME       CPU  DURATION                  FUNCTION CALLS</span><br><span class="line">#       |         |     |   |                     |   |   |   |</span><br><span class="line">360.774522 |   1)   0.541 us    |                                          &#125;</span><br><span class="line">360.774522 |   1)   4.663 us    |                                        &#125;</span><br><span class="line">360.774523 |   1)   0.541 us    |                                        __wake_up_bit();</span><br><span class="line">360.774524 |   1)   6.796 us    |                                      &#125;</span><br><span class="line">360.774524 |   1)   7.952 us    |                                    &#125;</span><br><span class="line">360.774525 |   1)   9.063 us    |                                  &#125;</span><br><span class="line">360.774525 |   1)   0.615 us    |                                  journal_mark_dirty();</span><br><span class="line">360.774527 |   1)   0.578 us    |                                  __brelse();</span><br><span class="line">360.774528 |   1)               |                                  reiserfs_prepare_for_journal() &#123;</span><br><span class="line">360.774528 |   1)               |                                    unlock_buffer() &#123;</span><br><span class="line">360.774529 |   1)               |                                      wake_up_bit() &#123;</span><br><span class="line">360.774529 |   1)               |                                        bit_waitqueue() &#123;</span><br><span class="line">360.774530 |   1)   0.594 us    |                                          __phys_addr();</span><br></pre></td></tr></table></figure>
</li>
<li><p>在函数结束括号处显示函数名。这样方便使用grep找出函数的执行时间，默认disable：</p>
<p>  hide: echo nofuncgraph-tail &gt; trace_options<br>  show: echo funcgraph-tail &gt; trace_options</p>
<p>  例子nofuncgraph-tail (default)：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0)               |      putname() &#123;</span><br><span class="line">0)               |        kmem_cache_free() &#123;</span><br><span class="line">0)   0.518 us    |          __phys_addr();</span><br><span class="line">0)   1.757 us    |        &#125;</span><br><span class="line">0)   2.861 us    |      &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<pre><code>例子funcgraph-tail：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0)               |      putname() &#123;</span><br><span class="line">0)               |        kmem_cache_free() &#123;</span><br><span class="line">0)   0.518 us    |          __phys_addr();</span><br><span class="line">0)   1.757 us    |        &#125; /* kmem_cache_free() */</span><br><span class="line">0)   2.861 us    |      &#125; /* putname() */</span><br></pre></td></tr></table></figure>
</code></pre><ul>
<li><p>还可以使用 trace_printk() 打印一些注释。可以在<strong>might_sleep()中加一些注释，你可以include &lt;linux/ftrace.h&gt;然后在</strong>might_sleep()中调用trace_printk()：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trace_printk(&quot;I&apos;m a comment!\n&quot;)</span><br></pre></td></tr></table></figure>
<p>  将会产生：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1)               |             __might_sleep() &#123;</span><br><span class="line">1)               |                /* I&apos;m a comment! */</span><br><span class="line">1)   1.449 us    |             &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="15、dynamic-ftrace"><a href="#15、dynamic-ftrace" class="headerlink" title="15、dynamic ftrace"></a>15、dynamic ftrace</h1><p>如果CONFIG_DYNAMIC_FTRACE被设置，系统在function tracing disbale时几乎没有开销。这种方式利用了gcc的-pg选项，会在每个函数的入口处放置mcount函数，初始时mcount函数只是一个简单的返回。</p>
<p>在编译c代码时kernel使用一个脚本解析c obj文件搜集出所有需要跟踪的mount函数的调用位置。gcc verson 4.6在x86中已经使用“<strong>fentry</strong>”替代了“mcount”。mount的调用在 函数stack frame创建之前。</p>
<p>不是所有的函数都需要跟踪的，notrace声明函数、inline函数都不需要跟踪，在 “available_filter_functions”中可以看到所有需要跟踪的函数名。</p>
<p>脚本创建了一个section “__mcount_loc” 用来存放所有mcount/fentry 的调用位置，这个section最后会被编译到kernel当中，被链接成一张表。</p>
<p>在boot up阶段，SMP启动之前，dynamic ftrace扫描“__mcount_loc”表并把所有的调用mcount替换成nop指令。在available_filter_functions列表中的函数会机型记录。驱动模块在load时在运行之前会处理，在驱动模块unload时会从ftrace function list中移除。这都是自动完成的，不需要驱动模块作者来担心的。</p>
<p>当tracing enable，修改插入点的方法依赖于架构。老机制使用kstop_machine来防止修改代码时多cpu的竞争；新机制放一个breakpoint 指令到修改的位置，同步cpu修改breakpoint没有覆盖的剩下指令，再次同步cpu移除掉breakpoint指令完成完整ftrace call的设置。</p>
<p>有些架构没有同步问题，可以直接使用新代码覆盖旧代码，其他CPU同时执行没有问题。</p>
<p>函数被跟踪后又较大的副作用。我们可以来选择哪些函数希望被trace、哪些函数希望保持nops指令。有两个文件用来配置这个功能：</p>
<p>set_ftrace_filter<br>set_ftrace_notrace</p>
<p>我们把希望trace的函数加入到available_filter_functions文件中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># cat available_filter_functions</span><br><span class="line">put_prev_task_idle</span><br><span class="line">kmem_cache_create</span><br><span class="line">pick_next_task_rt</span><br><span class="line">get_online_cpus</span><br><span class="line">pick_next_task_fair</span><br><span class="line">mutex_lock</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>
<p>如果我们只想跟踪sys_nanosleep 、hrtimer_interrupt：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># echo sys_nanosleep hrtimer_interrupt &gt; set_ftrace_filter</span><br><span class="line"># echo function &gt; current_tracer</span><br><span class="line"># echo 1 &gt; tracing_on</span><br><span class="line"># usleep 1</span><br><span class="line"># echo 0 &gt; tracing_on</span><br><span class="line"># cat trace</span><br><span class="line"># tracer: function</span><br><span class="line">#</span><br><span class="line"># entries-in-buffer/entries-written: 5/5   #P:4</span><br><span class="line">#</span><br><span class="line">#                              _-----=&gt; irqs-off</span><br><span class="line">#                             / _----=&gt; need-resched</span><br><span class="line">#                            | / _---=&gt; hardirq/softirq</span><br><span class="line">#                            || / _--=&gt; preempt-depth</span><br><span class="line">#                            ||| /     delay</span><br><span class="line">#           TASK-PID   CPU#  ||||    TIMESTAMP  FUNCTION</span><br><span class="line">#              | |       |   ||||       |         |</span><br><span class="line">          usleep-2665  [001] ....  4186.475355: sys_nanosleep &lt;-system_call_fastpath</span><br><span class="line">          &lt;idle&gt;-0     [001] d.h1  4186.475409: hrtimer_interrupt &lt;-smp_apic_timer_interrupt</span><br><span class="line">          usleep-2665  [001] d.h1  4186.475426: hrtimer_interrupt &lt;-smp_apic_timer_interrupt</span><br><span class="line">          &lt;idle&gt;-0     [003] d.h1  4186.475426: hrtimer_interrupt &lt;-smp_apic_timer_interrupt</span><br><span class="line">          &lt;idle&gt;-0     [002] d.h1  4186.475427: hrtimer_interrupt &lt;-smp_apic_timer_interrupt</span><br></pre></td></tr></table></figure>
<p>看哪些函数被跟踪，同样可以cat文件查看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># cat set_ftrace_filter</span><br><span class="line">hrtimer_interrupt</span><br><span class="line">sys_nanosleep</span><br></pre></td></tr></table></figure>
<p>可能这些还不够，我们还运行块匹配：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;match&gt;*</span><br><span class="line">    will match functions that begin with &lt;match&gt;</span><br><span class="line">*&lt;match&gt;</span><br><span class="line">    will match functions that end with &lt;match&gt;</span><br><span class="line">*&lt;match&gt;*</span><br><span class="line">    will match functions that have &lt;match&gt; in it</span><br><span class="line">&lt;match1&gt;*&lt;match2&gt;</span><br><span class="line">    will match functions that begin with &lt;match1&gt; and end with &lt;match2&gt;</span><br></pre></td></tr></table></figure>
<p>配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># echo &apos;hrtimer_*&apos; &gt; set_ftrace_filter</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># tracer: function</span><br><span class="line">#</span><br><span class="line"># entries-in-buffer/entries-written: 897/897   #P:4</span><br><span class="line">#</span><br><span class="line">#                              _-----=&gt; irqs-off</span><br><span class="line">#                             / _----=&gt; need-resched</span><br><span class="line">#                            | / _---=&gt; hardirq/softirq</span><br><span class="line">#                            || / _--=&gt; preempt-depth</span><br><span class="line">#                            ||| /     delay</span><br><span class="line">#           TASK-PID   CPU#  ||||    TIMESTAMP  FUNCTION</span><br><span class="line">#              | |       |   ||||       |         |</span><br><span class="line">          &lt;idle&gt;-0     [003] dN.1  4228.547803: hrtimer_cancel &lt;-tick_nohz_idle_exit</span><br><span class="line">          &lt;idle&gt;-0     [003] dN.1  4228.547804: hrtimer_try_to_cancel &lt;-hrtimer_cancel</span><br><span class="line">          &lt;idle&gt;-0     [003] dN.2  4228.547805: hrtimer_force_reprogram &lt;-__remove_hrtimer</span><br><span class="line">          &lt;idle&gt;-0     [003] dN.1  4228.547805: hrtimer_forward &lt;-tick_nohz_idle_exit</span><br><span class="line">          &lt;idle&gt;-0     [003] dN.1  4228.547805: hrtimer_start_range_ns &lt;-hrtimer_start_expires.constprop.11</span><br><span class="line">          &lt;idle&gt;-0     [003] d..1  4228.547858: hrtimer_get_next_event &lt;-get_next_timer_interrupt</span><br><span class="line">          &lt;idle&gt;-0     [003] d..1  4228.547859: hrtimer_start &lt;-__tick_nohz_idle_enter</span><br><span class="line">          &lt;idle&gt;-0     [003] d..2  4228.547860: hrtimer_force_reprogram &lt;-__rem</span><br></pre></td></tr></table></figure>
<p>注意sys_nanosleep的丢失：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># cat set_ftrace_filter</span><br><span class="line">hrtimer_run_queues</span><br><span class="line">hrtimer_run_pending</span><br><span class="line">hrtimer_init</span><br><span class="line">hrtimer_cancel</span><br><span class="line">hrtimer_try_to_cancel</span><br><span class="line">hrtimer_forward</span><br><span class="line">hrtimer_start</span><br><span class="line">hrtimer_reprogram</span><br><span class="line">hrtimer_force_reprogram</span><br><span class="line">hrtimer_get_next_event</span><br><span class="line">hrtimer_interrupt</span><br><span class="line">hrtimer_nanosleep</span><br><span class="line">hrtimer_wakeup</span><br><span class="line">hrtimer_get_remaining</span><br><span class="line">hrtimer_get_res</span><br><span class="line">hrtimer_init_sleeper</span><br></pre></td></tr></table></figure>
<p>‘&gt;’ 和 ‘&gt;&gt;’ 作用和在bash中相同。重写filter配置使用‘&gt;’，追加filter配置使用‘&gt;&gt;’。</p>
<p>清除filter配置，所有的函数都将会被跟踪：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># echo &gt; set_ftrace_filter</span><br><span class="line"># cat set_ftrace_filter</span><br><span class="line">#</span><br></pre></td></tr></table></figure>
<p>使用追加方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># echo sys_nanosleep &gt; set_ftrace_filter</span><br><span class="line"># cat set_ftrace_filter</span><br><span class="line">sys_nanosleep</span><br><span class="line"># echo &apos;hrtimer_*&apos; &gt;&gt; set_ftrace_filter</span><br><span class="line"># cat set_ftrace_filter</span><br><span class="line">hrtimer_run_queues</span><br><span class="line">hrtimer_run_pending</span><br><span class="line">hrtimer_init</span><br><span class="line">hrtimer_cancel</span><br><span class="line">hrtimer_try_to_cancel</span><br><span class="line">hrtimer_forward</span><br><span class="line">hrtimer_start</span><br><span class="line">hrtimer_reprogram</span><br><span class="line">hrtimer_force_reprogram</span><br><span class="line">hrtimer_get_next_event</span><br><span class="line">hrtimer_interrupt</span><br><span class="line">sys_nanosleep</span><br><span class="line">hrtimer_nanosleep</span><br><span class="line">hrtimer_wakeup</span><br><span class="line">hrtimer_get_remaining</span><br><span class="line">hrtimer_get_res</span><br><span class="line">hrtimer_init_sleeper</span><br></pre></td></tr></table></figure>
<p>配置set_ftrace_notrace防止这些函数被跟踪：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># echo &apos;*preempt*&apos; &apos;*lock*&apos; &gt; set_ftrace_notrace</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># tracer: function</span><br><span class="line">#</span><br><span class="line"># entries-in-buffer/entries-written: 39608/39608   #P:4</span><br><span class="line">#</span><br><span class="line">#                              _-----=&gt; irqs-off</span><br><span class="line">#                             / _----=&gt; need-resched</span><br><span class="line">#                            | / _---=&gt; hardirq/softirq</span><br><span class="line">#                            || / _--=&gt; preempt-depth</span><br><span class="line">#                            ||| /     delay</span><br><span class="line">#           TASK-PID   CPU#  ||||    TIMESTAMP  FUNCTION</span><br><span class="line">#              | |       |   ||||       |         |</span><br><span class="line">            bash-1994  [000] ....  4342.324896: file_ra_state_init &lt;-do_dentry_open</span><br><span class="line">            bash-1994  [000] ....  4342.324897: open_check_o_direct &lt;-do_last</span><br><span class="line">            bash-1994  [000] ....  4342.324897: ima_file_check &lt;-do_last</span><br><span class="line">            bash-1994  [000] ....  4342.324898: process_measurement &lt;-ima_file_check</span><br><span class="line">            bash-1994  [000] ....  4342.324898: ima_get_action &lt;-process_measurement</span><br><span class="line">            bash-1994  [000] ....  4342.324898: ima_match_policy &lt;-ima_get_action</span><br><span class="line">            bash-1994  [000] ....  4342.324899: do_truncate &lt;-do_last</span><br><span class="line">            bash-1994  [000] ....  4342.324899: should_remove_suid &lt;-do_truncate</span><br><span class="line">            bash-1994  [000] ....  4342.324899: notify_change &lt;-do_truncate</span><br><span class="line">            bash-1994  [000] ....  4342.324900: current_fs_time &lt;-notify_change</span><br><span class="line">            bash-1994  [000] ....  4342.324900: current_kernel_time &lt;-current_fs_time</span><br><span class="line">            bash-1994  [000] ....  4342.324900: timespec_trunc &lt;-current_fs_time</span><br></pre></td></tr></table></figure>
<h2 id="15-1、Dynamic-ftrace-with-the-function-graph-tracer"><a href="#15-1、Dynamic-ftrace-with-the-function-graph-tracer" class="headerlink" title="15.1、Dynamic ftrace with the function graph tracer"></a>15.1、Dynamic ftrace with the function graph tracer</h2><p>如果你想看某个函数和他所有孩子的graph trace，可以使用set_graph_function来配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo __do_fault &gt; set_graph_function</span><br></pre></td></tr></table></figure>
<p>结果，查看 __do_fault()扩展开的trace：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">0)               |  __do_fault() &#123;</span><br><span class="line">0)               |    filemap_fault() &#123;</span><br><span class="line">0)               |      find_lock_page() &#123;</span><br><span class="line">0)   0.804 us    |        find_get_page();</span><br><span class="line">0)               |        __might_sleep() &#123;</span><br><span class="line">0)   1.329 us    |        &#125;</span><br><span class="line">0)   3.904 us    |      &#125;</span><br><span class="line">0)   4.979 us    |    &#125;</span><br><span class="line">0)   0.653 us    |    _spin_lock();</span><br><span class="line">0)   0.578 us    |    page_add_file_rmap();</span><br><span class="line">0)   0.525 us    |    native_set_pte_at();</span><br><span class="line">0)   0.585 us    |    _spin_unlock();</span><br><span class="line">0)               |    unlock_page() &#123;</span><br><span class="line">0)   0.541 us    |      page_waitqueue();</span><br><span class="line">0)   0.639 us    |      __wake_up_bit();</span><br><span class="line">0)   2.786 us    |    &#125;</span><br><span class="line">0) + 14.237 us   |  &#125;</span><br><span class="line">0)               |  __do_fault() &#123;</span><br><span class="line">0)               |    filemap_fault() &#123;</span><br><span class="line">0)               |      find_lock_page() &#123;</span><br><span class="line">0)   0.698 us    |        find_get_page();</span><br><span class="line">0)               |        __might_sleep() &#123;</span><br><span class="line">0)   1.412 us    |        &#125;</span><br><span class="line">0)   3.950 us    |      &#125;</span><br><span class="line">0)   5.098 us    |    &#125;</span><br><span class="line">0)   0.631 us    |    _spin_lock();</span><br><span class="line">0)   0.571 us    |    page_add_file_rmap();</span><br><span class="line">0)   0.526 us    |    native_set_pte_at();</span><br><span class="line">0)   0.586 us    |    _spin_unlock();</span><br><span class="line">0)               |    unlock_page() &#123;</span><br><span class="line">0)   0.533 us    |      page_waitqueue();</span><br><span class="line">0)   0.638 us    |      __wake_up_bit();</span><br><span class="line">0)   2.793 us    |    &#125;</span><br><span class="line">0) + 14.012 us   |  &#125;</span><br></pre></td></tr></table></figure>
<p>你也可以一次跟踪多个函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo sys_open &gt; set_graph_function</span><br><span class="line">echo sys_close &gt;&gt; set_graph_function</span><br></pre></td></tr></table></figure>
<p>如果你想跟踪所有的函数，清除filter配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &gt; set_graph_function</span><br></pre></td></tr></table></figure>
<h1 id="16、ftrace-enabled"><a href="#16、ftrace-enabled" class="headerlink" title="16、ftrace_enabled"></a>16、ftrace_enabled</h1><p>proc sysctl ftrace_enable是 function tracer的大开关。默认是enable，如果被disable所有相关的trace都会被disable，包括 (perf, kprobes, stack tracing, profiling, etc)。</p>
<p>请非常小心的disbale。</p>
<p>disbale和enbale动作如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> sysctl kernel.ftrace_enabled=0</span><br><span class="line"> sysctl kernel.ftrace_enabled=1</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line"> echo 0 &gt; /proc/sys/kernel/ftrace_enabled</span><br><span class="line"> echo 1 &gt; /proc/sys/kernel/ftrace_enabled</span><br></pre></td></tr></table></figure>
<h1 id="17、Filter-commands"><a href="#17、Filter-commands" class="headerlink" title="17、Filter commands"></a>17、Filter commands</h1><p>支持通过一系列的command来设置set_ftrace_filter，配置filter。格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;function&gt;:&lt;command&gt;:&lt;parameter&gt;</span><br></pre></td></tr></table></figure>
<p>支持以下的command：</p>
<ul>
<li><p>mod: 该命令使能某个模块的过滤。parameter用来定义模块。例如，追踪ext3模块的write*函数：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo ‘write*:mod:ext3’ &gt; set_ftrace_filter</span><br></pre></td></tr></table></figure>
</li>
</ul>
<pre><code>追加配置使用&apos;&gt;&gt;&apos;，移除特定模块的函数使用&apos;!&apos;前缀：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &apos;!writeback*:mod:ext3&apos; &gt;&gt; set_ftrace_filter</span><br></pre></td></tr></table></figure>


支持模块通配符。例如去掉所有的函数追踪除了某个模块：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &apos;!*:mod:!ext3&apos; &gt;&gt; set_ftrace_filter</span><br></pre></td></tr></table></figure>


去掉所有的模块追踪，但是非模块的kernel部分继续追踪：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &apos;!*:mod:*&apos; &gt;&gt; set_ftrace_filter</span><br></pre></td></tr></table></figure>


仅仅使能kernel部分的追踪：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &apos;*write*:mod:!*&apos; &gt;&gt; set_ftrace_filter</span><br></pre></td></tr></table></figure>


用mod通配符使能filter：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &apos;*write*:mod:*snd*&apos; &gt;&gt; set_ftrace_filter</span><br></pre></td></tr></table></figure>
</code></pre><ul>
<li><p>traceon/traceoff: 这个命令在制定的函数被调用时打开/关闭tracing。parameter 定义函数命中多少次以后打开/关闭tracing，如果没有描述则不做限制。</p>
<p>  例如，disable tracing当schedule bug命中前5次：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &apos;__schedule_bug:traceoff:5&apos; &gt; set_ftrace_filter</span><br></pre></td></tr></table></figure>
</li>
</ul>
<pre><code>当__schedule_bug被命中时，一直关闭tracing：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &apos;__schedule_bug:traceoff&apos; &gt; set_ftrace_filter</span><br></pre></td></tr></table></figure>


这些命令是累积的，无论你是否使用追加方式配置到set_ftrace_filter。如果要移除某个命令，使用‘!’前缀并且parameter次数drop到0：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &apos;!__schedule_bug:traceoff:0&apos; &gt; set_ftrace_filter</span><br></pre></td></tr></table></figure>


移除没有counter的命令：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &apos;!__schedule_bug:traceoff&apos; &gt; set_ftrace_filter</span><br></pre></td></tr></table></figure>
</code></pre><ul>
<li><p>snapshot: 当函数命中时将会导致一个快照被触发：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &apos;native_flush_tlb_others:snapshot&apos; &gt; set_ftrace_filter</span><br></pre></td></tr></table></figure>
</li>
</ul>
<pre><code>仅仅触发一次：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &apos;native_flush_tlb_others:snapshot:1&apos; &gt; set_ftrace_filter</span><br></pre></td></tr></table></figure>


移除上述的配置：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &apos;!native_flush_tlb_others:snapshot&apos; &gt; set_ftrace_filter</span><br><span class="line">echo &apos;!native_flush_tlb_others:snapshot:0&apos; &gt; set_ftrace_filter</span><br></pre></td></tr></table></figure>
</code></pre><ul>
<li><p>enable_event/disable_event: 这些命令可以enable/disable trace event。因为function tracing回调都是非常敏感的，当这些命令注册，这些函数的tracepoint被active但是处于“soft disable”状态，它会被调用但是不会产生记录，这些tracepoint只是用来判断条件是否被触发。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &apos;try_to_wake_up:enable_event:sched:sched_switch:2&apos; &gt; \</span><br><span class="line">  set_ftrace_filter</span><br></pre></td></tr></table></figure>
</li>
</ul>
<pre><code>格式如下：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;function&gt;:enable_event:&lt;system&gt;:&lt;event&gt;[:count]</span><br><span class="line">&lt;function&gt;:disable_event:&lt;system&gt;:&lt;event&gt;[:count]</span><br></pre></td></tr></table></figure>


移除配置：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">echo &apos;!try_to_wake_up:enable_event:sched:sched_switch:0&apos; &gt; \</span><br><span class="line">      set_ftrace_filter</span><br><span class="line">echo &apos;!schedule:disable_event:sched:sched_switch&apos; &gt; \</span><br><span class="line">      set_ftrace_filter</span><br></pre></td></tr></table></figure>
</code></pre><ul>
<li>dump: 当函数被命中会dump ringbuffer中所有内容到console。</li>
<li>cpudump: 当函数被命中会dump当前cpu ringbuffer中所有内容到console。</li>
</ul>
<h1 id="18、trace-pipe"><a href="#18、trace-pipe" class="headerlink" title="18、trace_pipe"></a>18、trace_pipe</h1><p>trace_pipe对比trace文件输出同样的内容，但是对tracing的影响不同。每次的trace_pipe读时消耗型的，连续读的内容是不同的，不会中止tracing。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># echo function &gt; current_tracer</span><br><span class="line"># cat trace_pipe &gt; /tmp/trace.out &amp;</span><br><span class="line">[1] 4153</span><br><span class="line"># echo 1 &gt; tracing_on</span><br><span class="line"># usleep 1</span><br><span class="line"># echo 0 &gt; tracing_on</span><br><span class="line"># cat trace</span><br><span class="line"># tracer: function</span><br><span class="line">#</span><br><span class="line"># entries-in-buffer/entries-written: 0/0   #P:4</span><br><span class="line">#</span><br><span class="line">#                              _-----=&gt; irqs-off</span><br><span class="line">#                             / _----=&gt; need-resched</span><br><span class="line">#                            | / _---=&gt; hardirq/softirq</span><br><span class="line">#                            || / _--=&gt; preempt-depth</span><br><span class="line">#                            ||| /     delay</span><br><span class="line">#           TASK-PID   CPU#  ||||    TIMESTAMP  FUNCTION</span><br><span class="line">#              | |       |   ||||       |         |</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># cat /tmp/trace.out</span><br><span class="line">           bash-1994  [000] ....  5281.568961: mutex_unlock &lt;-rb_simple_write</span><br><span class="line">           bash-1994  [000] ....  5281.568963: __mutex_unlock_slowpath &lt;-mutex_unlock</span><br><span class="line">           bash-1994  [000] ....  5281.568963: __fsnotify_parent &lt;-fsnotify_modify</span><br><span class="line">           bash-1994  [000] ....  5281.568964: fsnotify &lt;-fsnotify_modify</span><br><span class="line">           bash-1994  [000] ....  5281.568964: __srcu_read_lock &lt;-fsnotify</span><br><span class="line">           bash-1994  [000] ....  5281.568964: add_preempt_count &lt;-__srcu_read_lock</span><br><span class="line">           bash-1994  [000] ...1  5281.568965: sub_preempt_count &lt;-__srcu_read_lock</span><br><span class="line">           bash-1994  [000] ....  5281.568965: __srcu_read_unlock &lt;-fsnotify</span><br><span class="line">           bash-1994  [000] ....  5281.568967: sys_dup2 &lt;-system_call_fastpath</span><br></pre></td></tr></table></figure>
<p>注意，读trace_pipe将会阻塞直到更多的内容到来。</p>
<h1 id="19、trace-entries"><a href="#19、trace-entries" class="headerlink" title="19、trace entries"></a>19、trace entries</h1><p>数据过多或者不够在诊断内核问题时都是很麻烦的。buffer_size_kb 用来修改内部tracing buffer的大小，这个数字展示了每个cpu上的buffer大小，如果需要知道buffer的总和，乘以系统中cpu的数量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># cat buffer_size_kb</span><br><span class="line">1408 (units kilobytes)</span><br></pre></td></tr></table></figure>
<p>读总大小：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># cat buffer_total_size_kb</span><br><span class="line">5632</span><br></pre></td></tr></table></figure>
<p>修改buffer大小：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># echo 10000 &gt; buffer_size_kb</span><br><span class="line"># cat buffer_size_kb</span><br><span class="line">10000 (units kilobytes)</span><br></pre></td></tr></table></figure>
<p>可以尽可能的分配的更多，但是如果你分配的过多，有可能会引起Out-Of-Memory：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># echo 1000000000000 &gt; buffer_size_kb</span><br><span class="line">-bash: echo: write error: Cannot allocate memory</span><br><span class="line"># cat buffer_size_kb</span><br><span class="line">85</span><br></pre></td></tr></table></figure>
<p>per_cpu的buffer大小，可以独立的修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># echo 10000 &gt; per_cpu/cpu0/buffer_size_kb</span><br><span class="line"># echo 100 &gt; per_cpu/cpu1/buffer_size_kb</span><br></pre></td></tr></table></figure>
<p>当per_cpu的buffer大小不一致，buffer_size_kb 会显示X：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># cat buffer_size_kb</span><br><span class="line">X</span><br></pre></td></tr></table></figure>
<p>这种情况下，buffer_total_size_kb继续是有用的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># cat buffer_total_size_kb</span><br><span class="line">12916</span><br></pre></td></tr></table></figure>
<p>给顶级的buffer_size_kb文件写值，将会重新把per_cpu buffer配置成相同。</p>
<h1 id="20、Snapshot"><a href="#20、Snapshot" class="headerlink" title="20、Snapshot"></a>20、Snapshot</h1><p>配置CONFIG_TRACER_SNAPSHOT 将会使快照特性有效对于所有的non latency tracers。(Latency tracers仅仅记录最大延迟，例如“irqsoff” or “wakeup”，不能使用这个特性，因为它们已经在内部使用快照机制)</p>
<p>快照在一个特定时间点保留当前trace buffer而不停止跟踪。ftrace交换当前缓存区和备用缓存区，在新的当前缓存区(之前的备用缓存区)中继续跟踪。</p>
<p>以下是tracefs中关于这个特性的相关配置文件：</p>
<ul>
<li><p>snapshot:</p>
<p>  它用来拿到快照并且读出快照。Echo 1到文件会分配一个备份的缓存区并且进行交换，然后从快照中读内容使用和trace文件同样的格式输出。读快照和系统tracing并行进行。Echo 0到文件会释放备份缓存区，Echo其他的正值数会清除快照的内容。</p>
<p>  status\input | 0 | 1 | else<br>  —|—|—|—<br>  not allocated | (do nothing) | alloc+swap | (do nothing)<br>  allocated | free | swap | clear</p>
</li>
</ul>
<p>以下是snapshot的一个使用实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># echo 1 &gt; events/sched/enable</span><br><span class="line"># echo 1 &gt; snapshot</span><br><span class="line"># cat snapshot</span><br><span class="line"># tracer: nop</span><br><span class="line">#</span><br><span class="line"># entries-in-buffer/entries-written: 71/71   #P:8</span><br><span class="line">#</span><br><span class="line">#                              _-----=&gt; irqs-off</span><br><span class="line">#                             / _----=&gt; need-resched</span><br><span class="line">#                            | / _---=&gt; hardirq/softirq</span><br><span class="line">#                            || / _--=&gt; preempt-depth</span><br><span class="line">#                            ||| /     delay</span><br><span class="line">#           TASK-PID   CPU#  ||||    TIMESTAMP  FUNCTION</span><br><span class="line">#              | |       |   ||||       |         |</span><br><span class="line">          &lt;idle&gt;-0     [005] d...  2440.603828: sched_switch: prev_comm=swapper/5 prev_pid=0 prev_prio=120   prev_state=R ==&gt; next_comm=snapshot-test-2 next_pid=2242 next_prio=120</span><br><span class="line">           sleep-2242  [005] d...  2440.603846: sched_switch: prev_comm=snapshot-test-2 prev_pid=2242 prev_prio=120   prev_state=R ==&gt; next_comm=kworker/5:1 next_pid=60 next_prio=120</span><br><span class="line">[...]</span><br><span class="line">        &lt;idle&gt;-0     [002] d...  2440.707230: sched_switch: prev_comm=swapper/2 prev_pid=0 prev_prio=120 prev_state=R ==&gt; next_comm=snapshot-test-2 next_pid=2229 next_prio=120</span><br><span class="line"></span><br><span class="line"># cat trace</span><br><span class="line"># tracer: nop</span><br><span class="line">#</span><br><span class="line"># entries-in-buffer/entries-written: 77/77   #P:8</span><br><span class="line">#</span><br><span class="line">#                              _-----=&gt; irqs-off</span><br><span class="line">#                             / _----=&gt; need-resched</span><br><span class="line">#                            | / _---=&gt; hardirq/softirq</span><br><span class="line">#                            || / _--=&gt; preempt-depth</span><br><span class="line">#                            ||| /     delay</span><br><span class="line">#           TASK-PID   CPU#  ||||    TIMESTAMP  FUNCTION</span><br><span class="line">#              | |       |   ||||       |         |</span><br><span class="line">          &lt;idle&gt;-0     [007] d...  2440.707395: sched_switch: prev_comm=swapper/7 prev_pid=0 prev_prio=120 prev_state=R ==&gt; next_comm=snapshot-test-2 next_pid=2243 next_prio=120</span><br><span class="line"> snapshot-test-2-2229  [002] d...  2440.707438: sched_switch: prev_comm=snapshot-test-2 prev_pid=2229 prev_prio=120 prev_state=S ==&gt; next_comm=swapper/2 next_pid=0 next_prio=120</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>
<p>当你在latency tracers下尝试使用快照，将会得到以下结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># echo wakeup &gt; current_tracer</span><br><span class="line"># echo 1 &gt; snapshot</span><br><span class="line">bash: echo: write error: Device or resource busy</span><br><span class="line"># cat snapshot</span><br><span class="line">cat: snapshot: Device or resource busy</span><br></pre></td></tr></table></figure>
<h1 id="21、Instances"><a href="#21、Instances" class="headerlink" title="21、Instances"></a>21、Instances</h1><p>在tracefs中有个“instances”文件夹，这个文件夹可以使用mkdir创建新的子文件夹、使用rmdir删除子文件夹。如果子文件夹被创建，它默认包含以下文件和文件夹：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># mkdir instances/foo</span><br><span class="line"># ls instances/foo</span><br><span class="line">buffer_size_kb  buffer_total_size_kb  events  free_buffer  per_cpu</span><br><span class="line">set_event  snapshot  trace  trace_clock  trace_marker  trace_options</span><br><span class="line">trace_pipe  tracing_on</span><br></pre></td></tr></table></figure>
<p>如你所见，新的文件夹类似于tracing文件夹本身。实际上，它是非常类似的，除了buffer和events 是不可知的也许来自主文件夹或者是来自其他创建的实例。</p>
<p>在新文件夹中的文件拥有和tracing中文件一样的名字，除了它使用独立的新的buffer。这些文件影响自己的buffer不影响主buffer，除了trace_options，当前trace_options的配置会影响所有的新实例和top buffer都会保持一样，以后会改进这一点。</p>
<p>注意文件夹中没有“function tracer”文件，也没有“current_tracer”和“available_tracers”文件，这是因为这个buffer当前只会给trace event使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"># mkdir instances/foo</span><br><span class="line"># mkdir instances/bar</span><br><span class="line"># mkdir instances/zoot</span><br><span class="line"># echo 100000 &gt; buffer_size_kb</span><br><span class="line"># echo 1000 &gt; instances/foo/buffer_size_kb</span><br><span class="line"># echo 5000 &gt; instances/bar/per_cpu/cpu1/buffer_size_kb</span><br><span class="line"># echo function &gt; current_trace</span><br><span class="line"># echo 1 &gt; instances/foo/events/sched/sched_wakeup/enable</span><br><span class="line"># echo 1 &gt; instances/foo/events/sched/sched_wakeup_new/enable</span><br><span class="line"># echo 1 &gt; instances/foo/events/sched/sched_switch/enable</span><br><span class="line"># echo 1 &gt; instances/bar/events/irq/enable</span><br><span class="line"># echo 1 &gt; instances/zoot/events/syscalls/enable</span><br><span class="line"># cat trace_pipe</span><br><span class="line">CPU:2 [LOST 11745 EVENTS]</span><br><span class="line">            bash-2044  [002] .... 10594.481032: _raw_spin_lock_irqsave &lt;-get_page_from_freelist</span><br><span class="line">            bash-2044  [002] d... 10594.481032: add_preempt_count &lt;-_raw_spin_lock_irqsave</span><br><span class="line">            bash-2044  [002] d..1 10594.481032: __rmqueue &lt;-get_page_from_freelist</span><br><span class="line">            bash-2044  [002] d..1 10594.481033: _raw_spin_unlock &lt;-get_page_from_freelist</span><br><span class="line">            bash-2044  [002] d..1 10594.481033: sub_preempt_count &lt;-_raw_spin_unlock</span><br><span class="line">            bash-2044  [002] d... 10594.481033: get_pageblock_flags_group &lt;-get_pageblock_migratetype</span><br><span class="line">            bash-2044  [002] d... 10594.481034: __mod_zone_page_state &lt;-get_page_from_freelist</span><br><span class="line">            bash-2044  [002] d... 10594.481034: zone_statistics &lt;-get_page_from_freelist</span><br><span class="line">            bash-2044  [002] d... 10594.481034: __inc_zone_state &lt;-zone_statistics</span><br><span class="line">            bash-2044  [002] d... 10594.481034: __inc_zone_state &lt;-zone_statistics</span><br><span class="line">            bash-2044  [002] .... 10594.481035: arch_dup_task_struct &lt;-copy_process</span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line"># cat instances/foo/trace_pipe</span><br><span class="line">            bash-1998  [000] d..4   136.676759: sched_wakeup: comm=kworker/0:1 pid=59 prio=120 success=1 target_cpu=000</span><br><span class="line">            bash-1998  [000] dN.4   136.676760: sched_wakeup: comm=bash pid=1998 prio=120 success=1 target_cpu=000</span><br><span class="line">          &lt;idle&gt;-0     [003] d.h3   136.676906: sched_wakeup: comm=rcu_preempt pid=9 prio=120 success=1 target_cpu=003</span><br><span class="line">          &lt;idle&gt;-0     [003] d..3   136.676909: sched_switch: prev_comm=swapper/3 prev_pid=0 prev_prio=120 prev_state=R ==&gt; next_comm=rcu_preempt next_pid=9 next_prio=120</span><br><span class="line">     rcu_preempt-9     [003] d..3   136.676916: sched_switch: prev_comm=rcu_preempt prev_pid=9 prev_prio=120 prev_state=S ==&gt; next_comm=swapper/3 next_pid=0 next_prio=120</span><br><span class="line">            bash-1998  [000] d..4   136.677014: sched_wakeup: comm=kworker/0:1 pid=59 prio=120 success=1 target_cpu=000</span><br><span class="line">            bash-1998  [000] dN.4   136.677016: sched_wakeup: comm=bash pid=1998 prio=120 success=1 target_cpu=000</span><br><span class="line">            bash-1998  [000] d..3   136.677018: sched_switch: prev_comm=bash prev_pid=1998 prev_prio=120 prev_state=R+ ==&gt; next_comm=kworker/0:1 next_pid=59 next_prio=120</span><br><span class="line">     kworker/0:1-59    [000] d..4   136.677022: sched_wakeup: comm=sshd pid=1995 prio=120 success=1 target_cpu=001</span><br><span class="line">     kworker/0:1-59    [000] d..3   136.677025: sched_switch: prev_comm=kworker/0:1 prev_pid=59 prev_prio=120 prev_state=S ==&gt; next_comm=bash next_pid=1998 next_prio=120</span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line"># cat instances/bar/trace_pipe</span><br><span class="line">     migration/1-14    [001] d.h3   138.732674: softirq_raise: vec=3 [action=NET_RX]</span><br><span class="line">          &lt;idle&gt;-0     [001] dNh3   138.732725: softirq_raise: vec=3 [action=NET_RX]</span><br><span class="line">            bash-1998  [000] d.h1   138.733101: softirq_raise: vec=1 [action=TIMER]</span><br><span class="line">            bash-1998  [000] d.h1   138.733102: softirq_raise: vec=9 [action=RCU]</span><br><span class="line">            bash-1998  [000] ..s2   138.733105: softirq_entry: vec=1 [action=TIMER]</span><br><span class="line">            bash-1998  [000] ..s2   138.733106: softirq_exit: vec=1 [action=TIMER]</span><br><span class="line">            bash-1998  [000] ..s2   138.733106: softirq_entry: vec=9 [action=RCU]</span><br><span class="line">            bash-1998  [000] ..s2   138.733109: softirq_exit: vec=9 [action=RCU]</span><br><span class="line">            sshd-1995  [001] d.h1   138.733278: irq_handler_entry: irq=21 name=uhci_hcd:usb4</span><br><span class="line">            sshd-1995  [001] d.h1   138.733280: irq_handler_exit: irq=21 ret=unhandled</span><br><span class="line">            sshd-1995  [001] d.h1   138.733281: irq_handler_entry: irq=21 name=eth0</span><br><span class="line">            sshd-1995  [001] d.h1   138.733283: irq_handler_exit: irq=21 ret=handled</span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line"># cat instances/zoot/trace</span><br><span class="line"># tracer: nop</span><br><span class="line">#</span><br><span class="line"># entries-in-buffer/entries-written: 18996/18996   #P:4</span><br><span class="line">#</span><br><span class="line">#                              _-----=&gt; irqs-off</span><br><span class="line">#                             / _----=&gt; need-resched</span><br><span class="line">#                            | / _---=&gt; hardirq/softirq</span><br><span class="line">#                            || / _--=&gt; preempt-depth</span><br><span class="line">#                            ||| /     delay</span><br><span class="line">#           TASK-PID   CPU#  ||||    TIMESTAMP  FUNCTION</span><br><span class="line">#              | |       |   ||||       |         |</span><br><span class="line">            bash-1998  [000] d...   140.733501: sys_write -&gt; 0x2</span><br><span class="line">            bash-1998  [000] d...   140.733504: sys_dup2(oldfd: a, newfd: 1)</span><br><span class="line">            bash-1998  [000] d...   140.733506: sys_dup2 -&gt; 0x1</span><br><span class="line">            bash-1998  [000] d...   140.733508: sys_fcntl(fd: a, cmd: 1, arg: 0)</span><br><span class="line">            bash-1998  [000] d...   140.733509: sys_fcntl -&gt; 0x1</span><br><span class="line">            bash-1998  [000] d...   140.733510: sys_close(fd: a)</span><br><span class="line">            bash-1998  [000] d...   140.733510: sys_close -&gt; 0x0</span><br><span class="line">            bash-1998  [000] d...   140.733514: sys_rt_sigprocmask(how: 0, nset: 0, oset: 6e2768, sigsetsize: 8)</span><br><span class="line">            bash-1998  [000] d...   140.733515: sys_rt_sigprocmask -&gt; 0x0</span><br><span class="line">            bash-1998  [000] d...   140.733516: sys_rt_sigaction(sig: 2, act: 7fff718846f0, oact: 7fff71884650, sigsetsize: 8)</span><br><span class="line">            bash-1998  [000] d...   140.733516: sys_rt_sigaction -&gt; 0x0</span><br></pre></td></tr></table></figure>
<p>可以看到，top trace buffer只显示function tracing，foo 实例显示wakeups和task switches。</p>
<p>移除实例，只需简单的删除文件夹：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># rmdir instances/foo</span><br><span class="line"># rmdir instances/bar</span><br><span class="line"># rmdir instances/zoot</span><br></pre></td></tr></table></figure>
<p>如果实例中的文件正在open状态，rmdir将会返回EBUSY失败。</p>
<h1 id="22、Stack-trace"><a href="#22、Stack-trace" class="headerlink" title="22、Stack trace"></a>22、Stack trace</h1><p>因为kernel拥有固定的堆栈大小，所以在函数中不浪费堆栈是非常重要的。内核开发者必须小心在堆栈上分配内存，如果分配过多，系统可能会有堆栈溢出的危险，并且会发生出错，通常导致系统panic。</p>
<p>有一些工具用来检查这个，但是通常是中断周期性的检查使用率。但是如果你能在每个函数调用中执行这个检查，那将变得非常有用。由于fTrace提供了function trace，因此在每个函数调用中检查堆栈大小是方便的。通过stack tracer来启用。</p>
<p>配置CONFIG_STACK_TRACER 将会包含ftrace stack tracing功能。写 ‘1’ 到 /proc/sys/kernel/stack_tracer_enabled，使能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># echo 1 &gt; /proc/sys/kernel/stack_tracer_enabled</span><br></pre></td></tr></table></figure>
<p>也可以在kernel启动命令行中使能，在cmdline中增加“stacktrace” 参数。</p>
<p>运行一段时间后，看看输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># cat stack_max_size</span><br><span class="line">2928</span><br><span class="line"></span><br><span class="line"># cat stack_trace</span><br><span class="line">        Depth    Size   Location    (18 entries)</span><br><span class="line">        -----    ----   --------</span><br><span class="line">  0)     2928     224   update_sd_lb_stats+0xbc/0x4ac</span><br><span class="line">  1)     2704     160   find_busiest_group+0x31/0x1f1</span><br><span class="line">  2)     2544     256   load_balance+0xd9/0x662</span><br><span class="line">  3)     2288      80   idle_balance+0xbb/0x130</span><br><span class="line">  4)     2208     128   __schedule+0x26e/0x5b9</span><br><span class="line">  5)     2080      16   schedule+0x64/0x66</span><br><span class="line">  6)     2064     128   schedule_timeout+0x34/0xe0</span><br><span class="line">  7)     1936     112   wait_for_common+0x97/0xf1</span><br><span class="line">  8)     1824      16   wait_for_completion+0x1d/0x1f</span><br><span class="line">  9)     1808     128   flush_work+0xfe/0x119</span><br><span class="line"> 10)     1680      16   tty_flush_to_ldisc+0x1e/0x20</span><br><span class="line"> 11)     1664      48   input_available_p+0x1d/0x5c</span><br><span class="line"> 12)     1616      48   n_tty_poll+0x6d/0x134</span><br><span class="line"> 13)     1568      64   tty_poll+0x64/0x7f</span><br><span class="line"> 14)     1504     880   do_select+0x31e/0x511</span><br><span class="line"> 15)      624     400   core_sys_select+0x177/0x216</span><br><span class="line"> 16)      224      96   sys_select+0x91/0xb9</span><br><span class="line"> 17)      128     128   system_call_fastpath+0x16/0x1b</span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.kernel.org/doc/html/latest/trace/ftrace.html" target="_blank" rel="noopener">1、ftrace - Function Tracer</a></p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/ftrace/" rel="tag"># ftrace</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/12/21/linux_scheduler/" rel="next" title="Linux Schedule">
                <i class="fa fa-chevron-left"></i> Linux Schedule
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/12/21/ftrace_trace_event/" rel="prev" title="Linux Ftrace 1.2、trace event">
                Linux Ftrace 1.2、trace event <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/touxiang/ycqs.jpg" alt="pwl999">
            
              <p class="site-author-name" itemprop="name">pwl999</p>
              <p class="site-description motion-element" itemprop="description">RTFSC(Read The Fucking Source Code)</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives">
                
                    <span class="site-state-item-count">30</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">3</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">22</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1、背景："><span class="nav-number">1.</span> <span class="nav-text">1、背景：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2、文件接口"><span class="nav-number">2.</span> <span class="nav-text">2、文件接口</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3、Tracers"><span class="nav-number">3.</span> <span class="nav-text">3、Tracers</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4、Examples-of-using-the-tracer"><span class="nav-number">4.</span> <span class="nav-text">4、Examples of using the tracer</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1、Output-format"><span class="nav-number">4.1.</span> <span class="nav-text">4.1、Output format</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2、Latency-trace-format"><span class="nav-number">4.2.</span> <span class="nav-text">4.2、Latency trace format</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5、trace-options"><span class="nav-number">5.</span> <span class="nav-text">5、trace_options</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6、irqsoff"><span class="nav-number">6.</span> <span class="nav-text">6、irqsoff</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7、preemptoff"><span class="nav-number">7.</span> <span class="nav-text">7、preemptoff</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8、preemptirqsoff"><span class="nav-number">8.</span> <span class="nav-text">8、preemptirqsoff</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9、wakeup"><span class="nav-number">9.</span> <span class="nav-text">9、wakeup</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10、wakeup-rt"><span class="nav-number">10.</span> <span class="nav-text">10、wakeup_rt</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#11、Latency-tracing-and-events"><span class="nav-number">11.</span> <span class="nav-text">11、Latency tracing and events</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#12、Hardware-Latency-Detector"><span class="nav-number">12.</span> <span class="nav-text">12、Hardware Latency Detector</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#13、function"><span class="nav-number">13.</span> <span class="nav-text">13、function</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#13-1、Single-thread-tracing"><span class="nav-number">13.1.</span> <span class="nav-text">13.1、Single thread tracing</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#14、function-graph-tracer"><span class="nav-number">14.</span> <span class="nav-text">14、function graph tracer</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#15、dynamic-ftrace"><span class="nav-number">15.</span> <span class="nav-text">15、dynamic ftrace</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#15-1、Dynamic-ftrace-with-the-function-graph-tracer"><span class="nav-number">15.1.</span> <span class="nav-text">15.1、Dynamic ftrace with the function graph tracer</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#16、ftrace-enabled"><span class="nav-number">16.</span> <span class="nav-text">16、ftrace_enabled</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#17、Filter-commands"><span class="nav-number">17.</span> <span class="nav-text">17、Filter commands</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#18、trace-pipe"><span class="nav-number">18.</span> <span class="nav-text">18、trace_pipe</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#19、trace-entries"><span class="nav-number">19.</span> <span class="nav-text">19、trace entries</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#20、Snapshot"><span class="nav-number">20.</span> <span class="nav-text">20、Snapshot</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#21、Instances"><span class="nav-number">21.</span> <span class="nav-text">21、Instances</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#22、Stack-trace"><span class="nav-number">22.</span> <span class="nav-text">22、Stack trace</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考资料"><span class="nav-number">23.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">pwl999</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v6.6.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script src="/js/src/utils.js?v=6.6.0"></script>

  <script src="/js/src/motion.js?v=6.6.0"></script>



  
  


  <script src="/js/src/affix.js?v=6.6.0"></script>

  <script src="/js/src/schemes/pisces.js?v=6.6.0"></script>



  
  <script src="/js/src/scrollspy.js?v=6.6.0"></script>
<script src="/js/src/post-details.js?v=6.6.0"></script>



  


  <script src="/js/src/bootstrap.js?v=6.6.0"></script>



  

  
    <script id="dsq-count-scr" src="https://.disqus.com/count.js" async></script>
  

  





  











  





  

  

  

  

  

  
  

  

  

  

  

  

  

</body>
</html>
