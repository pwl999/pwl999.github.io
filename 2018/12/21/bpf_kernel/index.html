<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
































<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.6.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.6.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.6.0" color="#222">









<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.6.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="BPF的字面上意思Berkeley Packet Filter意味着它是从包过滤而来。如果在开始前对BPF缺乏感性的认识建议先看一下参考文档：“3.1、Berkeley Packet Filter (BPF) (Kernel Document)”、“3.2、BPF and XDP Reference Guide”。 本质上它是一种内核代码注入的技术：  内核中实现了一个cBPF/eBPF虚拟机；">
<meta name="keywords" content="BPF">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux BPF 1.1、bpf内核框架">
<meta property="og:url" content="http://yoursite.com/2018/12/21/bpf_kernel/index.html">
<meta property="og:site_name" content="pwl999&#39;s blog">
<meta property="og:description" content="BPF的字面上意思Berkeley Packet Filter意味着它是从包过滤而来。如果在开始前对BPF缺乏感性的认识建议先看一下参考文档：“3.1、Berkeley Packet Filter (BPF) (Kernel Document)”、“3.2、BPF and XDP Reference Guide”。 本质上它是一种内核代码注入的技术：  内核中实现了一个cBPF/eBPF虚拟机；">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/images/bpf/bpf_frame.png">
<meta property="og:image" content="http://yoursite.com/images/bpf/DFS5.png">
<meta property="og:updated_time" content="2018-12-21T03:28:44.603Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Linux BPF 1.1、bpf内核框架">
<meta name="twitter:description" content="BPF的字面上意思Berkeley Packet Filter意味着它是从包过滤而来。如果在开始前对BPF缺乏感性的认识建议先看一下参考文档：“3.1、Berkeley Packet Filter (BPF) (Kernel Document)”、“3.2、BPF and XDP Reference Guide”。 本质上它是一种内核代码注入的技术：  内核中实现了一个cBPF/eBPF虚拟机；">
<meta name="twitter:image" content="http://yoursite.com/images/bpf/bpf_frame.png">






  <link rel="canonical" href="http://yoursite.com/2018/12/21/bpf_kernel/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Linux BPF 1.1、bpf内核框架 | pwl999's blog</title>
  












  <noscript>
  <style>
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion .logo-line-before i { left: initial; }
    .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">pwl999's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/21/bpf_kernel/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="pwl999">
      <meta itemprop="description" content="RTFSC(Read The Fucking Source Code)">
      <meta itemprop="image" content="/images/touxiang/ycqs.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="pwl999's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Linux BPF 1.1、bpf内核框架

              
            
          </h1>
        

        <div class="post-meta">

          

        <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-21 10:18:21 / 修改时间：11:28:44" itemprop="dateCreated datePublished" datetime="2018-12-21T10:18:21+08:00">2018-12-21</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/Trace/" itemprop="url" rel="index"><span itemprop="name">Trace</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>BPF的字面上意思Berkeley Packet Filter意味着它是从包过滤而来。如果在开始前对BPF缺乏感性的认识建议先看一下参考文档：“<a href="https://blog.csdn.net/pwl999/article/details/82502410" target="_blank" rel="noopener">3.1、Berkeley Packet Filter (BPF) (Kernel Document)</a>”、“<a href="https://blog.csdn.net/pwl999/article/details/82706679" target="_blank" rel="noopener">3.2、BPF and XDP Reference Guide</a>”。</p>
<p>本质上它是一种<strong>内核代码注入</strong>的技术：</p>
<ul>
<li>内核中实现了一个cBPF/eBPF虚拟机；</li>
<li>用户态可以用C来写运行的代码，再通过一个Clang&amp;LLVM的编译器将C代码编译成BPF目标码；</li>
<li>用户态通过系统调用bpf()将BPF目标码注入到内核当中；</li>
<li>内核通过JIT(Just-In-Time)将BPF目编码转换成本地指令码；如果当前架构不支持JIT转换内核则会使用一个解析器(interpreter)来模拟运行，这种运行效率较低；</li>
<li>内核在packet filter和tracing等应用中提供了一系列的钩子来运行BPF代码。目前支持以下类型的BPF代码：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">static int __init register_kprobe_prog_ops(void)</span><br><span class="line">&#123;</span><br><span class="line">	bpf_register_prog_type(&amp;kprobe_tl);</span><br><span class="line">	bpf_register_prog_type(&amp;tracepoint_tl);</span><br><span class="line">	bpf_register_prog_type(&amp;perf_event_tl);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int __init register_sk_filter_ops(void)</span><br><span class="line">&#123;</span><br><span class="line">	bpf_register_prog_type(&amp;sk_filter_type);</span><br><span class="line">	bpf_register_prog_type(&amp;sched_cls_type);</span><br><span class="line">	bpf_register_prog_type(&amp;sched_act_type);</span><br><span class="line">	bpf_register_prog_type(&amp;xdp_type);</span><br><span class="line">	bpf_register_prog_type(&amp;cg_skb_type);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BPF的好处在哪里？ <strong>是因为它提供了一种在不修改内核代码的情况下，可以灵活修改内核处理策略的方法</strong>。<br>这在包过滤和系统tracing这种需要频繁修改规则的场合非常有用。因为如果只在用户态修改策略的话那么所有数据需要复制一份给用户态开销较大；如果在内核态修改策略的话需要修改内核代码重新编译内核，而且容易引人安全问题。BPF这种内核代码注入技术的生存空间就是它可以在这两者间取得一个平衡。</p>
<p>Systamp就是解决了这个问题得以发展的，它使用了ko的方式来实现内核代码注入(有点笨拙，但是也解决了实际问题)。</p>
<blockquote>
<p>Systemtap工作原理：是通过将脚本语句翻译成C语句，编译成内核模块。模块加载之后，将所有探测的事件以Kprobe钩子的方式挂到内核上，当任何处理器上的某个事件发生时，相应钩子上句柄就会被执行。最后，当systemtap会话结束之后，钩子从内核上取下，移除模块。整个过程用一个命令stap就可以完成。</p>
</blockquote>
<p>既然是提供向内核注入代码的技术，那么安全问题肯定是重中之重。平时防范他人通过漏洞向内核中注入代码，这下子专门开了一个口子不是大开方便之门。所以内核指定了很多的规则来限制BPF代码，确保它的错误不会影响到内核：</p>
<ul>
<li>一个BPF程序的代码数量不能超过BPF_MAXINSNS (4K)，它的总运行步数不能超过32K (4.9内核中这个值改成了96k)；</li>
<li>BPF代码中禁止循环，这也是为了保证出错时不会出现死循环来hang死内核。一个BPF程序总的可能的分支数也被限制到1K；</li>
<li>为了限制它的作用域，BPF代码不能访问全局变量，只能访问局部变量。一个BPF程序只有512字节的堆栈。在开始时会传入一个ctx指针，BPF程序的数据访问就被限制在ctx变量和堆栈局部变量中；</li>
<li>如果BPF需要访问全局变量，它只能访问BPF map对象。BPF map对象是同时能被用户态、BPF程序、内核态共同访问的，BPF对map的访问通过helper function来实现；</li>
<li>旧版本BPF代码中不支持BPF对BPF函数的调用，所以所有的BPF函数必须声明成always_inline。在Linux内核4.16和LLVM 6.0以后，才支持BPF to BPF Calls；</li>
<li>BPF虽然不能函数调用，但是它可以使用Tail Call机制从一个BPF程序直接跳转到另一个BPF程序。它需要通过BPF_MAP_TYPE_PROG_ARRAY类型的map来知道另一个BPF程序的指针。这种跳转的次数也是有限制的，32次；</li>
<li>BPF程序可以调用一些内核函数来辅助做一些事情(helper function)；</li>
<li>有些架构(64 bit x86_64, arm64, ppc64, s390x, mips64, sparc64 and 32 bit arm)已经支持BPF的JIT，它可以高效的几乎一比一的把BPF代码转换成本机代码(因为eBPF的指令集已经做了优化，非常类似最新的arm/x86架构，ABI也类似)。如果当前架构不支持JTI只能使用内核的解析器(interpreter)来模拟运行；</li>
<li>内核还可以通过一些额外的手段来加固BPF的安全性(Hardening)。主要包括：把BPF代码映像和JIT代码映像的page都锁成只读，JIT编译时把常量致盲(constant blinding)，以及对bpf()系统调用的权限限制；</li>
</ul>
<p>对BPF这些安全规则的检查主要是在BPF代码加载时，通过BPF verifier来实现的。大概分为两步：</p>
<ul>
<li>第一步，通过DAG(Directed Acyclic Graph 有向无环图)的DFS(Depth-first Search)深度优先算法来遍历BPF程序的代码路径，确保没有环路发生；</li>
<li>第二步，逐条分析BPF每条指令的运行，对register和对stack的影响，最坏情况下是否有越界行为(对变量的访问是否越界，运行的指令数是否越界)。这里也有一个快速分析的优化方法：修剪(Pruning)。如果当前指令的当前分支的状态，和当前指令另一个已分析分支的状态相等或者是它的一个子集，那么当前指令的当前分支就不需要分析了，因为它肯定是符合规则的。</li>
</ul>
<p>整个BPF的开发过程大概如下图所示：</p>
<p><img src="/images/bpf/bpf_frame.png" alt="bpf_frame"></p>
<h1 id="1、bpf-系统调用"><a href="#1、bpf-系统调用" class="headerlink" title="1、bpf()系统调用"></a>1、bpf()系统调用</h1><p>核心代码在bpf()系统调用中，我们从入口开始分析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(bpf, int, cmd, union bpf_attr __user *, uattr, unsigned int, size)</span><br><span class="line">&#123;</span><br><span class="line">	union bpf_attr attr = &#123;&#125;;</span><br><span class="line">	int err;</span><br><span class="line"></span><br><span class="line">	if (!capable(CAP_SYS_ADMIN) &amp;&amp; sysctl_unprivileged_bpf_disabled)</span><br><span class="line">		return -EPERM;</span><br><span class="line"></span><br><span class="line">	if (!access_ok(VERIFY_READ, uattr, 1))</span><br><span class="line">		return -EFAULT;</span><br><span class="line"></span><br><span class="line">	if (size &gt; PAGE_SIZE)	/* silly large */</span><br><span class="line">		return -E2BIG;</span><br><span class="line"></span><br><span class="line">	/* If we&apos;re handed a bigger struct than we know of,</span><br><span class="line">	 * ensure all the unknown bits are 0 - i.e. new</span><br><span class="line">	 * user-space does not rely on any kernel feature</span><br><span class="line">	 * extensions we dont know about yet.</span><br><span class="line">	 */</span><br><span class="line">	if (size &gt; sizeof(attr)) &#123;</span><br><span class="line">		unsigned char __user *addr;</span><br><span class="line">		unsigned char __user *end;</span><br><span class="line">		unsigned char val;</span><br><span class="line"></span><br><span class="line">		addr = (void __user *)uattr + sizeof(attr);</span><br><span class="line">		end  = (void __user *)uattr + size;</span><br><span class="line"></span><br><span class="line">		for (; addr &lt; end; addr++) &#123;</span><br><span class="line">			err = get_user(val, addr);</span><br><span class="line">			if (err)</span><br><span class="line">				return err;</span><br><span class="line">			if (val)</span><br><span class="line">				return -E2BIG;</span><br><span class="line">		&#125;</span><br><span class="line">		size = sizeof(attr);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* copy attributes from user space, may be less than sizeof(bpf_attr) */</span><br><span class="line">	if (copy_from_user(&amp;attr, uattr, size) != 0)</span><br><span class="line">		return -EFAULT;</span><br><span class="line"></span><br><span class="line">	switch (cmd) &#123;</span><br><span class="line">	case BPF_MAP_CREATE:</span><br><span class="line">		err = map_create(&amp;attr);</span><br><span class="line">		break;</span><br><span class="line">	case BPF_MAP_LOOKUP_ELEM:</span><br><span class="line">		err = map_lookup_elem(&amp;attr);</span><br><span class="line">		break;</span><br><span class="line">	case BPF_MAP_UPDATE_ELEM:</span><br><span class="line">		err = map_update_elem(&amp;attr);</span><br><span class="line">		break;</span><br><span class="line">	case BPF_MAP_DELETE_ELEM:</span><br><span class="line">		err = map_delete_elem(&amp;attr);</span><br><span class="line">		break;</span><br><span class="line">	case BPF_MAP_GET_NEXT_KEY:</span><br><span class="line">		err = map_get_next_key(&amp;attr);</span><br><span class="line">		break;</span><br><span class="line">	case BPF_PROG_LOAD:</span><br><span class="line">		err = bpf_prog_load(&amp;attr);</span><br><span class="line">		break;</span><br><span class="line">	case BPF_OBJ_PIN:</span><br><span class="line">		err = bpf_obj_pin(&amp;attr);</span><br><span class="line">		break;</span><br><span class="line">	case BPF_OBJ_GET:</span><br><span class="line">		err = bpf_obj_get(&amp;attr);</span><br><span class="line">		break;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_CGROUP_BPF</span><br><span class="line">	case BPF_PROG_ATTACH:</span><br><span class="line">		err = bpf_prog_attach(&amp;attr);</span><br><span class="line">		break;</span><br><span class="line">	case BPF_PROG_DETACH:</span><br><span class="line">		err = bpf_prog_detach(&amp;attr);</span><br><span class="line">		break;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	default:</span><br><span class="line">		err = -EINVAL;</span><br><span class="line">		break;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-1、bpf加载"><a href="#1-1、bpf加载" class="headerlink" title="1.1、bpf加载"></a>1.1、bpf加载</h2><p>BPF_PROG_LOAD命令负责加载一段BPF程序到内核当中：</p>
<ul>
<li>拷贝程序到内核；</li>
<li>校验它的安全性；</li>
<li>如果可能对它进行JIT编译；</li>
<li>然后分配一个文件句柄fd给它。</li>
</ul>
<p>完成这一切后，后续再把这段BPF程序挂载到需要运行的钩子上面。</p>
<h3 id="1-1-1、bpf内存空间分配"><a href="#1-1-1、bpf内存空间分配" class="headerlink" title="1.1.1、bpf内存空间分配"></a>1.1.1、bpf内存空间分配</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">static int bpf_prog_load(union bpf_attr *attr)</span><br><span class="line">&#123;</span><br><span class="line">	enum bpf_prog_type type = attr-&gt;prog_type;</span><br><span class="line">	struct bpf_prog *prog;</span><br><span class="line">	int err;</span><br><span class="line">	char license[128];</span><br><span class="line">	bool is_gpl;</span><br><span class="line"></span><br><span class="line">	if (CHECK_ATTR(BPF_PROG_LOAD))</span><br><span class="line">		return -EINVAL;</span><br><span class="line"></span><br><span class="line">	/* copy eBPF program license from user space */</span><br><span class="line">	/* (1.1) 根据attr-&gt;license地址，从用户空间拷贝license字符串到内核 */</span><br><span class="line">	if (strncpy_from_user(license, u64_to_ptr(attr-&gt;license),</span><br><span class="line">			      sizeof(license) - 1) &lt; 0)</span><br><span class="line">		return -EFAULT;</span><br><span class="line">	license[sizeof(license) - 1] = 0;</span><br><span class="line"></span><br><span class="line">	/* eBPF programs must be GPL compatible to use GPL-ed functions */</span><br><span class="line">	/* (1.2) 判断license是否符合GPL协议 */</span><br><span class="line">	is_gpl = license_is_gpl_compatible(license);</span><br><span class="line"></span><br><span class="line">    /* (1.3) 判断BPF的总指令数是否超过BPF_MAXINSNS(4k) */</span><br><span class="line">	if (attr-&gt;insn_cnt &gt;= BPF_MAXINSNS)</span><br><span class="line">		return -EINVAL;</span><br><span class="line"></span><br><span class="line">    /* (1.4) 如果加载BPF_PROG_TYPE_KPROBE类型的BPF程序，指定的内核版本需要和当前内核版本匹配。 </span><br><span class="line">        不然由于内核的改动，可能会附加到错误的地址上。</span><br><span class="line">     */</span><br><span class="line">	if (type == BPF_PROG_TYPE_KPROBE &amp;&amp;</span><br><span class="line">	    attr-&gt;kern_version != LINUX_VERSION_CODE)</span><br><span class="line">		return -EINVAL;</span><br><span class="line"></span><br><span class="line">    /* (1.5) 对BPF_PROG_TYPE_SOCKET_FILTER和BPF_PROG_TYPE_CGROUP_SKB以外的BPF程序加载，需要管理员权限 */</span><br><span class="line">	if (type != BPF_PROG_TYPE_SOCKET_FILTER &amp;&amp;</span><br><span class="line">	    type != BPF_PROG_TYPE_CGROUP_SKB &amp;&amp;</span><br><span class="line">	    !capable(CAP_SYS_ADMIN))</span><br><span class="line">		return -EPERM;</span><br><span class="line"></span><br><span class="line">	/* plain bpf_prog allocation */</span><br><span class="line">	/* (2.1) 根据BPF指令数分配bpf_prog空间，和bpf_prog-&gt;aux空间 */</span><br><span class="line">	prog = bpf_prog_alloc(bpf_prog_size(attr-&gt;insn_cnt), GFP_USER);</span><br><span class="line">	if (!prog)</span><br><span class="line">		return -ENOMEM;</span><br><span class="line"></span><br><span class="line">    /* (2.2) 把整个bpf_prog空间在当前进程的memlock_limit中锁定 */</span><br><span class="line">	err = bpf_prog_charge_memlock(prog);</span><br><span class="line">	if (err)</span><br><span class="line">		goto free_prog_nouncharge;</span><br><span class="line"></span><br><span class="line">	prog-&gt;len = attr-&gt;insn_cnt;</span><br><span class="line"></span><br><span class="line">	err = -EFAULT;</span><br><span class="line">	/* (2.3) 把BPF代码从用户空间地址attr-&gt;insns，拷贝到内核空间地址prog-&gt;insns */</span><br><span class="line">	if (copy_from_user(prog-&gt;insns, u64_to_ptr(attr-&gt;insns),</span><br><span class="line">			   prog-&gt;len * sizeof(struct bpf_insn)) != 0)</span><br><span class="line">		goto free_prog;</span><br><span class="line"></span><br><span class="line">	prog-&gt;orig_prog = NULL;</span><br><span class="line">	prog-&gt;jited = 0;</span><br><span class="line"></span><br><span class="line">	atomic_set(&amp;prog-&gt;aux-&gt;refcnt, 1);</span><br><span class="line">	prog-&gt;gpl_compatible = is_gpl ? 1 : 0;</span><br><span class="line"></span><br><span class="line">	/* find program type: socket_filter vs tracing_filter */</span><br><span class="line">	/* (2.4) 根据attr-&gt;prog_type指定的type值，找到对应的bpf_prog_types，</span><br><span class="line">	    给bpf_prog-&gt;aux-&gt;ops赋值，这个ops是一个函数操作集</span><br><span class="line">	 */</span><br><span class="line">	err = find_prog_type(type, prog);</span><br><span class="line">	if (err &lt; 0)</span><br><span class="line">		goto free_prog;</span><br><span class="line"></span><br><span class="line">	/* run eBPF verifier */</span><br><span class="line">	/* (3) 使用verifer对BPF程序进行合法性扫描 */</span><br><span class="line">	err = bpf_check(&amp;prog, attr);</span><br><span class="line">	if (err &lt; 0)</span><br><span class="line">		goto free_used_maps;</span><br><span class="line"></span><br><span class="line">	/* eBPF program is ready to be JITed */</span><br><span class="line">	/* (4) 尝试对BPF程序进行JIT转换 */</span><br><span class="line">	prog = bpf_prog_select_runtime(prog, &amp;err);</span><br><span class="line">	if (err &lt; 0)</span><br><span class="line">		goto free_used_maps;</span><br><span class="line"></span><br><span class="line">    /* (5) 给BPF程序分配一个文件句柄fd */</span><br><span class="line">	err = bpf_prog_new_fd(prog);</span><br><span class="line">	if (err &lt; 0)</span><br><span class="line">		/* failed to allocate fd */</span><br><span class="line">		goto free_used_maps;</span><br><span class="line"></span><br><span class="line">	return err;</span><br><span class="line"></span><br><span class="line">free_used_maps:</span><br><span class="line">	free_used_maps(prog-&gt;aux);</span><br><span class="line">free_prog:</span><br><span class="line">	bpf_prog_uncharge_memlock(prog);</span><br><span class="line">free_prog_nouncharge:</span><br><span class="line">	bpf_prog_free(prog);</span><br><span class="line">	return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这其中对BPF来说有个重要的数据结构就是struct bpf_prog：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">struct bpf_prog &#123;</span><br><span class="line">	u16			pages;		/* Number of allocated pages */</span><br><span class="line">	kmemcheck_bitfield_begin(meta);</span><br><span class="line">	u16			jited:1,	/* Is our filter JIT&apos;ed? */</span><br><span class="line">				gpl_compatible:1, /* Is filter GPL compatible? */</span><br><span class="line">				cb_access:1,	/* Is control block accessed? */</span><br><span class="line">				dst_needed:1;	/* Do we need dst entry? */</span><br><span class="line">	kmemcheck_bitfield_end(meta);</span><br><span class="line">	u32			len;		/* Number of filter blocks */</span><br><span class="line">	enum bpf_prog_type	type;		/* Type of BPF program */</span><br><span class="line">	struct bpf_prog_aux	*aux;		/* Auxiliary fields */</span><br><span class="line">	struct sock_fprog_kern	*orig_prog;	/* Original BPF program */</span><br><span class="line">	unsigned int		(*bpf_func)(const struct sk_buff *skb,</span><br><span class="line">					    const struct bpf_insn *filter);</span><br><span class="line">	/* Instructions for interpreter */</span><br><span class="line">	union &#123;</span><br><span class="line">		struct sock_filter	insns[0];</span><br><span class="line">		struct bpf_insn		insnsi[0];</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中重要的成员如下：</p>
<ul>
<li>len：程序包含bpf指令的数量；</li>
<li>type：当前bpf程序的类型(kprobe/tracepoint/perf_event/sk_filter/sched_cls/sched_act/xdp/cg_skb)；</li>
<li>aux：主要用来辅助verifier校验和转换的数据；</li>
<li>orig_prog：</li>
<li>bpf_func：运行时BPF程序的入口。如果JIT转换成功，这里指向的就是BPF程序JIT转换后的映像；否则这里指向内核解析器(interpreter)的通用入口__bpf_prog_run()；</li>
<li>insnsi[]：从用户态拷贝过来的，BPF程序原始指令的存放空间；</li>
</ul>
<h3 id="1-1-2、bpf-verifier"><a href="#1-1-2、bpf-verifier" class="headerlink" title="1.1.2、bpf verifier"></a>1.1.2、bpf verifier</h3><p>关于verifier的步骤和规则，在“<a href="https://blog.csdn.net/pwl999/article/details/82502410" target="_blank" rel="noopener">3.1、Berkeley Packet Filter (BPF) (Kernel Document)</a>”一文的“eBPF verifier”一节有详细描述。</p>
<p>另外，在kernel/bpf/verifier.c文件的开头对eBPF verifier也有一段详细的注释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">bpf_check()是一个静态代码分析器，它按指令遍历eBPF程序指令并更新寄存器/堆栈状态。分析条件分支的所有路径，直到&apos;bpf_exit&apos;指令。</span><br><span class="line"></span><br><span class="line">1、第一步是深度优先搜索，检查程序是否为DAG(Directed Acyclic Graph 有向无环图)。它将会拒绝以下程序：</span><br><span class="line"> </span><br><span class="line"> - 大于BPF_MAXINSNS条指令(BPF_MAXINSNS=4096)</span><br><span class="line"> - 如果出现循环(通过back-edge检测)</span><br><span class="line"> - 不可达的指令存在(不应该是森林，程序等于一个函数)</span><br><span class="line"> - 越界或畸形的跳跃</span><br><span class="line"> </span><br><span class="line">2、第二步是从第一步所有可能路径的展开。 </span><br><span class="line"></span><br><span class="line">- 因为它分析了程序所有的路径，这个分析的最大长度限制为32k个指令，即使指令总数小于4k也会受到影响，因为有太多的分支改变了堆栈/寄存器。  </span><br><span class="line">- 分支的分析数量被限制为1k。</span><br><span class="line"></span><br><span class="line">在进入每条指令时，每个寄存器都有一个类型，该指令根据指令语义改变寄存器的类型：</span><br><span class="line"></span><br><span class="line">- rule 1、如果指令是BPF_MOV64_REG(BPF_REG_1, BPF_REG_5)，则将R5的类型复制到R1。</span><br><span class="line"></span><br><span class="line">所有寄存器都是64位的。  </span><br><span class="line">* R0 -返回寄存器  </span><br><span class="line">* R1-R5参数传递寄存器  </span><br><span class="line">* R6-R9被调用方保存寄存器  </span><br><span class="line">* R10 -帧指针只读  </span><br><span class="line"></span><br><span class="line">- rule 2、在BPF程序开始时，寄存器R1包含一个指向bpf_context的指针，类型为PTR_TO_CTX。</span><br><span class="line"></span><br><span class="line">- rule 3、verifier跟踪指针上的算术运算：</span><br><span class="line"></span><br><span class="line">`</span><br><span class="line">    BPF_MOV64_REG(BPF_REG_1, BPF_REG_10),</span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_1, -20),</span><br><span class="line">`</span><br><span class="line"></span><br><span class="line">第一条指令将R10(它具有FRAME_PTR)类型复制到R1中，第二条算术指令是匹配的模式，用于识别它想要构造一个指向堆栈中某个元素的指针。  </span><br><span class="line">因此，在第二条指令之后，寄存器R1的类型为PTR_TO_STACK(-20常数需要进一步的堆栈边界检查)。表示这个reg是一个指针由堆栈加上常数。</span><br><span class="line"></span><br><span class="line">- rule 4、大多数时候寄存器都有UNKNOWN_VALUE类型，这意味着寄存器有一些值，但它不是一个有效的指针。(就像指针+指针变成了UNKNOWN_VALUE类型)</span><br><span class="line"></span><br><span class="line">- rule 5、当verifier看到load指令或store指令时，基本寄存器的类型可以是:PTR_TO_MAP_VALUE、PTR_TO_CTX、FRAME_PTR。这是由check_mem_access()函数识别的三种指针类型。</span><br><span class="line"></span><br><span class="line">- rule 6、PTR_TO_MAP_VALUE表示这个寄存器指向‘map元素的值’，并且可以访问[ptr, ptr + map value_size)的范围。</span><br><span class="line"></span><br><span class="line">- rule 7、寄存器用于向函数调用传递参数，将根据函数参数约束进行检查。</span><br><span class="line"></span><br><span class="line">ARG_PTR_TO_MAP_KEY就是这样的参数约束之一。  </span><br><span class="line">这意味着传递给这个函数的寄存器类型必须是PTR_TO_STACK，它将作为‘map element key的指针’在函数内部使用。</span><br><span class="line"></span><br><span class="line">例如bpf_map_lookup_elem()的参数约束:</span><br><span class="line"></span><br><span class="line">`</span><br><span class="line">   .ret_type = RET_PTR_TO_MAP_VALUE_OR_NULL,</span><br><span class="line">   .arg1_type = ARG_CONST_MAP_PTR,</span><br><span class="line">   .arg2_type = ARG_PTR_TO_MAP_KEY,</span><br><span class="line">`</span><br><span class="line"></span><br><span class="line">ret_type表示该函数返回“指向map element value的指针或null”。  </span><br><span class="line">函数期望第一个参数是指向‘struct bpf_map’的const指针，第二个参数应该是指向stack的指针，这个指针在helper函数中用作map element key的指针。</span><br><span class="line"></span><br><span class="line">在内核侧的helper函数如下：</span><br><span class="line"></span><br><span class="line">`</span><br><span class="line"> u64 bpf_map_lookup_elem(u64 r1, u64 r2, u64 r3, u64 r4, u64 r5)</span><br><span class="line"> &#123;</span><br><span class="line">    struct bpf_map *map = (struct bpf_map *) (unsigned long) r1;</span><br><span class="line">    void *key = (void *) (unsigned long) r2;</span><br><span class="line">    void *value;</span><br><span class="line"></span><br><span class="line">    here kernel can access &apos;key&apos; and &apos;map&apos; pointers safely, knowing that</span><br><span class="line">    [key, key + map-&gt;key_size) bytes are valid and were initialized on</span><br><span class="line">    the stack of eBPF program.</span><br><span class="line"> &#125;</span><br><span class="line">`</span><br><span class="line"></span><br><span class="line">相应的eBPF程序如下：</span><br><span class="line"></span><br><span class="line">`</span><br><span class="line">    BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),  // after this insn R2 type is FRAME_PTR</span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4), // after this insn R2 type is PTR_TO_STACK</span><br><span class="line">    BPF_LD_MAP_FD(BPF_REG_1, map_fd),      // after this insn R1 type is CONST_PTR_TO_MAP</span><br><span class="line">    BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),</span><br><span class="line">`</span><br><span class="line"></span><br><span class="line">这里verifier查看map_lookup_elem()的原型，看到:  </span><br><span class="line"></span><br><span class="line">- .arg1_type == ARG_CONST_MAP_PTR and R1-&gt;type == CONST_PTR_TO_MAP, 这个是ok的。现在verifier知道map key的尺寸了：R1-&gt;map_ptr-&gt;key_size。</span><br><span class="line"></span><br><span class="line">- 然后.arg2_type == ARG_PTR_TO_MAP_KEY and R2-&gt;type == PTR_TO_STACK也是ok的。  </span><br><span class="line">现在verifier检测 [R2, R2 + map&apos;s key_size]是否在堆栈限制内，并且在调用之前被初始化。  </span><br><span class="line"></span><br><span class="line">- 如果可以，那么verifier允许这个BPF_CALL指令，并查看.ret_type  RET_PTR_TO_MAP_VALUE_OR_NULL，因此它设置R0-&gt;类型= PTR_TO_MAP_VALUE_OR_NULL，这意味着bpf_map_lookup_elem()函数返回map value指针或NULL。  </span><br><span class="line">当类型PTR_TO_MAP_VALUE_OR_NULL通过&apos;if (reg != 0) goto +off&apos; 指令判断时，在真分支中持有指针的寄存器将状态更改为PTR_TO_MAP_VALUE，在假分支中相同的寄存器将状态更改为CONST_IMM。看check_cond_jmp_op()的实现。  </span><br><span class="line">函数调用以后R0设置为返回函数类型后，将寄存器R1-R5设置为NOT_INIT，以指示它们不再可读。</span><br></pre></td></tr></table></figure>
<p>原文如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">/* bpf_check() is a static code analyzer that walks eBPF program</span><br><span class="line"> * instruction by instruction and updates register/stack state.</span><br><span class="line"> * All paths of conditional branches are analyzed until &apos;bpf_exit&apos; insn.</span><br><span class="line"> *</span><br><span class="line"> * The first pass is depth-first-search to check that the program is a DAG.</span><br><span class="line"> * It rejects the following programs:</span><br><span class="line"> * - larger than BPF_MAXINSNS insns</span><br><span class="line"> * - if loop is present (detected via back-edge)</span><br><span class="line"> * - unreachable insns exist (shouldn&apos;t be a forest. program = one function)</span><br><span class="line"> * - out of bounds or malformed jumps</span><br><span class="line"> * The second pass is all possible path descent from the 1st insn.</span><br><span class="line"> * Since it&apos;s analyzing all pathes through the program, the length of the</span><br><span class="line"> * analysis is limited to 32k insn, which may be hit even if total number of</span><br><span class="line"> * insn is less then 4K, but there are too many branches that change stack/regs.</span><br><span class="line"> * Number of &apos;branches to be analyzed&apos; is limited to 1k</span><br><span class="line"> *</span><br><span class="line"> * On entry to each instruction, each register has a type, and the instruction</span><br><span class="line"> * changes the types of the registers depending on instruction semantics.</span><br><span class="line"> * If instruction is BPF_MOV64_REG(BPF_REG_1, BPF_REG_5), then type of R5 is</span><br><span class="line"> * copied to R1.</span><br><span class="line"> *</span><br><span class="line"> * All registers are 64-bit.</span><br><span class="line"> * R0 - return register</span><br><span class="line"> * R1-R5 argument passing registers</span><br><span class="line"> * R6-R9 callee saved registers</span><br><span class="line"> * R10 - frame pointer read-only</span><br><span class="line"> *</span><br><span class="line"> * At the start of BPF program the register R1 contains a pointer to bpf_context</span><br><span class="line"> * and has type PTR_TO_CTX.</span><br><span class="line"> *</span><br><span class="line"> * Verifier tracks arithmetic operations on pointers in case:</span><br><span class="line"> *    BPF_MOV64_REG(BPF_REG_1, BPF_REG_10),</span><br><span class="line"> *    BPF_ALU64_IMM(BPF_ADD, BPF_REG_1, -20),</span><br><span class="line"> * 1st insn copies R10 (which has FRAME_PTR) type into R1</span><br><span class="line"> * and 2nd arithmetic instruction is pattern matched to recognize</span><br><span class="line"> * that it wants to construct a pointer to some element within stack.</span><br><span class="line"> * So after 2nd insn, the register R1 has type PTR_TO_STACK</span><br><span class="line"> * (and -20 constant is saved for further stack bounds checking).</span><br><span class="line"> * Meaning that this reg is a pointer to stack plus known immediate constant.</span><br><span class="line"> *</span><br><span class="line"> * Most of the time the registers have UNKNOWN_VALUE type, which</span><br><span class="line"> * means the register has some value, but it&apos;s not a valid pointer.</span><br><span class="line"> * (like pointer plus pointer becomes UNKNOWN_VALUE type)</span><br><span class="line"> *</span><br><span class="line"> * When verifier sees load or store instructions the type of base register</span><br><span class="line"> * can be: PTR_TO_MAP_VALUE, PTR_TO_CTX, FRAME_PTR. These are three pointer</span><br><span class="line"> * types recognized by check_mem_access() function.</span><br><span class="line"> *</span><br><span class="line"> * PTR_TO_MAP_VALUE means that this register is pointing to &apos;map element value&apos;</span><br><span class="line"> * and the range of [ptr, ptr + map&apos;s value_size) is accessible.</span><br><span class="line"> *</span><br><span class="line"> * registers used to pass values to function calls are checked against</span><br><span class="line"> * function argument constraints.</span><br><span class="line"> *</span><br><span class="line"> * ARG_PTR_TO_MAP_KEY is one of such argument constraints.</span><br><span class="line"> * It means that the register type passed to this function must be</span><br><span class="line"> * PTR_TO_STACK and it will be used inside the function as</span><br><span class="line"> * &apos;pointer to map element key&apos;</span><br><span class="line"> *</span><br><span class="line"> * For example the argument constraints for bpf_map_lookup_elem():</span><br><span class="line"> *   .ret_type = RET_PTR_TO_MAP_VALUE_OR_NULL,</span><br><span class="line"> *   .arg1_type = ARG_CONST_MAP_PTR,</span><br><span class="line"> *   .arg2_type = ARG_PTR_TO_MAP_KEY,</span><br><span class="line"> *</span><br><span class="line"> * ret_type says that this function returns &apos;pointer to map elem value or null&apos;</span><br><span class="line"> * function expects 1st argument to be a const pointer to &apos;struct bpf_map&apos; and</span><br><span class="line"> * 2nd argument should be a pointer to stack, which will be used inside</span><br><span class="line"> * the helper function as a pointer to map element key.</span><br><span class="line"> *</span><br><span class="line"> * On the kernel side the helper function looks like:</span><br><span class="line"> * u64 bpf_map_lookup_elem(u64 r1, u64 r2, u64 r3, u64 r4, u64 r5)</span><br><span class="line"> * &#123;</span><br><span class="line"> *    struct bpf_map *map = (struct bpf_map *) (unsigned long) r1;</span><br><span class="line"> *    void *key = (void *) (unsigned long) r2;</span><br><span class="line"> *    void *value;</span><br><span class="line"> *</span><br><span class="line"> *    here kernel can access &apos;key&apos; and &apos;map&apos; pointers safely, knowing that</span><br><span class="line"> *    [key, key + map-&gt;key_size) bytes are valid and were initialized on</span><br><span class="line"> *    the stack of eBPF program.</span><br><span class="line"> * &#125;</span><br><span class="line"> *</span><br><span class="line"> * Corresponding eBPF program may look like:</span><br><span class="line"> *    BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),  // after this insn R2 type is FRAME_PTR</span><br><span class="line"> *    BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4), // after this insn R2 type is PTR_TO_STACK</span><br><span class="line"> *    BPF_LD_MAP_FD(BPF_REG_1, map_fd),      // after this insn R1 type is CONST_PTR_TO_MAP</span><br><span class="line"> *    BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),</span><br><span class="line"> * here verifier looks at prototype of map_lookup_elem() and sees:</span><br><span class="line"> * .arg1_type == ARG_CONST_MAP_PTR and R1-&gt;type == CONST_PTR_TO_MAP, which is ok,</span><br><span class="line"> * Now verifier knows that this map has key of R1-&gt;map_ptr-&gt;key_size bytes</span><br><span class="line"> *</span><br><span class="line"> * Then .arg2_type == ARG_PTR_TO_MAP_KEY and R2-&gt;type == PTR_TO_STACK, ok so far,</span><br><span class="line"> * Now verifier checks that [R2, R2 + map&apos;s key_size) are within stack limits</span><br><span class="line"> * and were initialized prior to this call.</span><br><span class="line"> * If it&apos;s ok, then verifier allows this BPF_CALL insn and looks at</span><br><span class="line"> * .ret_type which is RET_PTR_TO_MAP_VALUE_OR_NULL, so it sets</span><br><span class="line"> * R0-&gt;type = PTR_TO_MAP_VALUE_OR_NULL which means bpf_map_lookup_elem() function</span><br><span class="line"> * returns ether pointer to map value or NULL.</span><br><span class="line"> *</span><br><span class="line"> * When type PTR_TO_MAP_VALUE_OR_NULL passes through &apos;if (reg != 0) goto +off&apos;</span><br><span class="line"> * insn, the register holding that pointer in the true branch changes state to</span><br><span class="line"> * PTR_TO_MAP_VALUE and the same register changes state to CONST_IMM in the false</span><br><span class="line"> * branch. See check_cond_jmp_op().</span><br><span class="line"> *</span><br><span class="line"> * After the call R0 is set to return type of the function and registers R1-R5</span><br><span class="line"> * are set to NOT_INIT to indicate that they are no longer readable.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<p>BPF verifier总体代码流程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line">int bpf_check(struct bpf_prog **prog, union bpf_attr *attr)</span><br><span class="line">&#123;</span><br><span class="line">	char __user *log_ubuf = NULL;</span><br><span class="line">	struct bpf_verifier_env *env;</span><br><span class="line">	int ret = -EINVAL;</span><br><span class="line"></span><br><span class="line">	if ((*prog)-&gt;len &lt;= 0 || (*prog)-&gt;len &gt; BPF_MAXINSNS)</span><br><span class="line">		return -E2BIG;</span><br><span class="line"></span><br><span class="line">	/* &apos;struct bpf_verifier_env&apos; can be global, but since it&apos;s not small,</span><br><span class="line">	 * allocate/free it every time bpf_check() is called</span><br><span class="line">	 */</span><br><span class="line">	/* (3.1) 分配verifier静态扫描需要的数据结构  */</span><br><span class="line">	env = kzalloc(sizeof(struct bpf_verifier_env), GFP_KERNEL);</span><br><span class="line">	if (!env)</span><br><span class="line">		return -ENOMEM;</span><br><span class="line"></span><br><span class="line">	env-&gt;insn_aux_data = vzalloc(sizeof(struct bpf_insn_aux_data) *</span><br><span class="line">				     (*prog)-&gt;len);</span><br><span class="line">	ret = -ENOMEM;</span><br><span class="line">	if (!env-&gt;insn_aux_data)</span><br><span class="line">		goto err_free_env;</span><br><span class="line">	env-&gt;prog = *prog;</span><br><span class="line"></span><br><span class="line">	/* grab the mutex to protect few globals used by verifier */</span><br><span class="line">	mutex_lock(&amp;bpf_verifier_lock);</span><br><span class="line"></span><br><span class="line">    /* (3.2) 如果用户指定了attr-&gt;log_buf，说明用户需要具体的代码扫描log，这个在出错时非常有用 </span><br><span class="line">        先在内核中分配log空间，在返回时拷贝给用户</span><br><span class="line">     */</span><br><span class="line">	if (attr-&gt;log_level || attr-&gt;log_buf || attr-&gt;log_size) &#123;</span><br><span class="line">		/* user requested verbose verifier output</span><br><span class="line">		 * and supplied buffer to store the verification trace</span><br><span class="line">		 */</span><br><span class="line">		log_level = attr-&gt;log_level;</span><br><span class="line">		log_ubuf = (char __user *) (unsigned long) attr-&gt;log_buf;</span><br><span class="line">		log_size = attr-&gt;log_size;</span><br><span class="line">		log_len = 0;</span><br><span class="line"></span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">		/* log_* values have to be sane */</span><br><span class="line">		if (log_size &lt; 128 || log_size &gt; UINT_MAX &gt;&gt; 8 ||</span><br><span class="line">		    log_level == 0 || log_ubuf == NULL)</span><br><span class="line">			goto err_unlock;</span><br><span class="line"></span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		log_buf = vmalloc(log_size);</span><br><span class="line">		if (!log_buf)</span><br><span class="line">			goto err_unlock;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		log_level = 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (3.3) 把BPF程序中操作map的指令，从map_fd替换成实际的map指针 </span><br><span class="line">        由此可见用户态的loader程序，肯定是先根据__section(&quot;maps&quot;)中定义的map调用bpf()创建map，再加载其他的程序section；</span><br><span class="line">     */</span><br><span class="line">	ret = replace_map_fd_with_map_ptr(env);</span><br><span class="line">	if (ret &lt; 0)</span><br><span class="line">		goto skip_full_check;</span><br><span class="line"></span><br><span class="line">	env-&gt;explored_states = kcalloc(env-&gt;prog-&gt;len,</span><br><span class="line">				       sizeof(struct bpf_verifier_state_list *),</span><br><span class="line">				       GFP_USER);</span><br><span class="line">	ret = -ENOMEM;</span><br><span class="line">	if (!env-&gt;explored_states)</span><br><span class="line">		goto skip_full_check;</span><br><span class="line"></span><br><span class="line">    /* (3.4) step1、检查有没有环路 */</span><br><span class="line">	ret = check_cfg(env);</span><br><span class="line">	if (ret &lt; 0)</span><br><span class="line">		goto skip_full_check;</span><br><span class="line"></span><br><span class="line">	env-&gt;allow_ptr_leaks = capable(CAP_SYS_ADMIN);</span><br><span class="line"></span><br><span class="line">    /* (3.5) step2、详细扫描BPF代码的运行过程，跟踪分析寄存器和堆栈，检查是否有不符合规则的情况出现 */</span><br><span class="line">	ret = do_check(env);</span><br><span class="line"></span><br><span class="line">skip_full_check:</span><br><span class="line">	while (pop_stack(env, NULL) &gt;= 0);</span><br><span class="line">	free_states(env);</span><br><span class="line">    </span><br><span class="line">    /* (3.6) 把扫描分析出来的dead代码(就是不会运行的代码)转成nop指令 */</span><br><span class="line">	if (ret == 0)</span><br><span class="line">		sanitize_dead_code(env);</span><br><span class="line"></span><br><span class="line">    /* (3.7) 根据程序的type，转换对ctx指针成员的访问 */</span><br><span class="line">	if (ret == 0)</span><br><span class="line">		/* program is valid, convert *(u32*)(ctx + off) accesses */</span><br><span class="line">		ret = convert_ctx_accesses(env);</span><br><span class="line"></span><br><span class="line">    /* (3.8) 修复BPF指令中对内核helper function函数的调用，把函数编号替换成实际的函数指针 */</span><br><span class="line">	if (ret == 0)</span><br><span class="line">		ret = fixup_bpf_calls(env);</span><br><span class="line"></span><br><span class="line">	if (log_level &amp;&amp; log_len &gt;= log_size - 1) &#123;</span><br><span class="line">		BUG_ON(log_len &gt;= log_size);</span><br><span class="line">		/* verifier log exceeded user supplied buffer */</span><br><span class="line">		ret = -ENOSPC;</span><br><span class="line">		/* fall through to return what was recorded */</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (3.9) 拷贝verifier log到用户空间 */</span><br><span class="line">	/* copy verifier log back to user space including trailing zero */</span><br><span class="line">	if (log_level &amp;&amp; copy_to_user(log_ubuf, log_buf, log_len + 1) != 0) &#123;</span><br><span class="line">		ret = -EFAULT;</span><br><span class="line">		goto free_log_buf;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (3.10) 备份BPF程序对map的引用信息，到prog-&gt;aux-&gt;used_maps中 */</span><br><span class="line">	if (ret == 0 &amp;&amp; env-&gt;used_map_cnt) &#123;</span><br><span class="line">		/* if program passed verifier, update used_maps in bpf_prog_info */</span><br><span class="line">		env-&gt;prog-&gt;aux-&gt;used_maps = kmalloc_array(env-&gt;used_map_cnt,</span><br><span class="line">							  sizeof(env-&gt;used_maps[0]),</span><br><span class="line">							  GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">		if (!env-&gt;prog-&gt;aux-&gt;used_maps) &#123;</span><br><span class="line">			ret = -ENOMEM;</span><br><span class="line">			goto free_log_buf;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		memcpy(env-&gt;prog-&gt;aux-&gt;used_maps, env-&gt;used_maps,</span><br><span class="line">		       sizeof(env-&gt;used_maps[0]) * env-&gt;used_map_cnt);</span><br><span class="line">		env-&gt;prog-&gt;aux-&gt;used_map_cnt = env-&gt;used_map_cnt;</span><br><span class="line"></span><br><span class="line">		/* program is valid. Convert pseudo bpf_ld_imm64 into generic</span><br><span class="line">		 * bpf_ld_imm64 instructions</span><br><span class="line">		 */</span><br><span class="line">		convert_pseudo_ld_imm64(env);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">free_log_buf:</span><br><span class="line">	if (log_level)</span><br><span class="line">		vfree(log_buf);</span><br><span class="line">	if (!env-&gt;prog-&gt;aux-&gt;used_maps)</span><br><span class="line">		/* if we didn&apos;t copy map pointers into bpf_prog_info, release</span><br><span class="line">		 * them now. Otherwise free_bpf_prog_info() will release them.</span><br><span class="line">		 */</span><br><span class="line">		release_maps(env);</span><br><span class="line">	*prog = env-&gt;prog;</span><br><span class="line">err_unlock:</span><br><span class="line">	mutex_unlock(&amp;bpf_verifier_lock);</span><br><span class="line">	vfree(env-&gt;insn_aux_data);</span><br><span class="line">err_free_env:</span><br><span class="line">	kfree(env);</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>1、把BPF程序中操作map的指令，从map_fd替换成实际的map指针。</li>
</ul>
<p>由此可见用户态的loader程序，肯定是先根据__section(“maps”)中定义的map调用bpf()创建map，再加载其他的程序section。</p>
<p>符合条件：(insn[0].code == (BPF_LD | BPF_IMM | BPF_DW)) &amp;&amp; (insn[0]-&gt;src_reg == BPF_PSEUDO_MAP_FD) 的指令为map指针加载指针。<br>把原始的立即数作为fd找到对应的map指针。<br>把64bit的map指针拆分成两个32bit的立即数，存储到insn[0].imm、insn[1].imm中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">static int replace_map_fd_with_map_ptr(struct bpf_verifier_env *env)</span><br><span class="line">&#123;</span><br><span class="line">	struct bpf_insn *insn = env-&gt;prog-&gt;insnsi;</span><br><span class="line">	int insn_cnt = env-&gt;prog-&gt;len;</span><br><span class="line">	int i, j, err;</span><br><span class="line"></span><br><span class="line">    /* (3.3.1) 遍历所有BPF指令 */</span><br><span class="line">	for (i = 0; i &lt; insn_cnt; i++, insn++) &#123;</span><br><span class="line">		if (BPF_CLASS(insn-&gt;code) == BPF_LDX &amp;&amp;</span><br><span class="line">		    (BPF_MODE(insn-&gt;code) != BPF_MEM || insn-&gt;imm != 0)) &#123;</span><br><span class="line">			verbose(&quot;BPF_LDX uses reserved fields\n&quot;);</span><br><span class="line">			return -EINVAL;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (BPF_CLASS(insn-&gt;code) == BPF_STX &amp;&amp;</span><br><span class="line">		    ((BPF_MODE(insn-&gt;code) != BPF_MEM &amp;&amp;</span><br><span class="line">		      BPF_MODE(insn-&gt;code) != BPF_XADD) || insn-&gt;imm != 0)) &#123;</span><br><span class="line">			verbose(&quot;BPF_STX uses reserved fields\n&quot;);</span><br><span class="line">			return -EINVAL;</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">        /* (3.3.2) 符合条件：(insn[0].code == (BPF_LD | BPF_IMM | BPF_DW)) &amp;&amp; (insn[0]-&gt;src_reg == BPF_PSEUDO_MAP_FD)  </span><br><span class="line">            的指令为map指针加载指针</span><br><span class="line">         */</span><br><span class="line">		if (insn[0].code == (BPF_LD | BPF_IMM | BPF_DW)) &#123;</span><br><span class="line">			struct bpf_map *map;</span><br><span class="line">			struct fd f;</span><br><span class="line"></span><br><span class="line">			if (i == insn_cnt - 1 || insn[1].code != 0 ||</span><br><span class="line">			    insn[1].dst_reg != 0 || insn[1].src_reg != 0 ||</span><br><span class="line">			    insn[1].off != 0) &#123;</span><br><span class="line">				verbose(&quot;invalid bpf_ld_imm64 insn\n&quot;);</span><br><span class="line">				return -EINVAL;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			if (insn-&gt;src_reg == 0)</span><br><span class="line">				/* valid generic load 64-bit imm */</span><br><span class="line">				goto next_insn;</span><br><span class="line"></span><br><span class="line">			if (insn-&gt;src_reg != BPF_PSEUDO_MAP_FD) &#123;</span><br><span class="line">				verbose(&quot;unrecognized bpf_ld_imm64 insn\n&quot;);</span><br><span class="line">				return -EINVAL;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">            /* (3.3.3) 根据指令中的立即数insn[0]-&gt;imm指定的fd，得到实际的map指针 */</span><br><span class="line">			f = fdget(insn-&gt;imm);</span><br><span class="line">			map = __bpf_map_get(f);</span><br><span class="line">			if (IS_ERR(map)) &#123;</span><br><span class="line">				verbose(&quot;fd %d is not pointing to valid bpf_map\n&quot;,</span><br><span class="line">					insn-&gt;imm);</span><br><span class="line">				return PTR_ERR(map);</span><br><span class="line">			&#125;</span><br><span class="line">的·</span><br><span class="line">            /* (3.3.4) 检查map和当前类型BPF程序的兼容性 */</span><br><span class="line">			err = check_map_prog_compatibility(map, env-&gt;prog);</span><br><span class="line">			if (err) &#123;</span><br><span class="line">				fdput(f);</span><br><span class="line">				return err;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">            /* (3.3.5) 把64bit的map指针拆分成两个32bit的立即数，存储到insn[0].imm、insn[1].imm中 */</span><br><span class="line">			/* store map pointer inside BPF_LD_IMM64 instruction */</span><br><span class="line">			insn[0].imm = (u32) (unsigned long) map;</span><br><span class="line">			insn[1].imm = ((u64) (unsigned long) map) &gt;&gt; 32;</span><br><span class="line"></span><br><span class="line">			/* check whether we recorded this map already */</span><br><span class="line">			for (j = 0; j &lt; env-&gt;used_map_cnt; j++)</span><br><span class="line">				if (env-&gt;used_maps[j] == map) &#123;</span><br><span class="line">					fdput(f);</span><br><span class="line">					goto next_insn;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">            /* (3.3.6) 一个prog最多引用64个map */</span><br><span class="line">			if (env-&gt;used_map_cnt &gt;= MAX_USED_MAPS) &#123;</span><br><span class="line">				fdput(f);</span><br><span class="line">				return -E2BIG;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			/* hold the map. If the program is rejected by verifier,</span><br><span class="line">			 * the map will be released by release_maps() or it</span><br><span class="line">			 * will be used by the valid program until it&apos;s unloaded</span><br><span class="line">			 * and all maps are released in free_bpf_prog_info()</span><br><span class="line">			 */</span><br><span class="line">			map = bpf_map_inc(map, false);</span><br><span class="line">			if (IS_ERR(map)) &#123;</span><br><span class="line">				fdput(f);</span><br><span class="line">				return PTR_ERR(map);</span><br><span class="line">			&#125;</span><br><span class="line">			/* (3.3.7) 记录prog对map的引用 */</span><br><span class="line">			env-&gt;used_maps[env-&gt;used_map_cnt++] = map;</span><br><span class="line"></span><br><span class="line">			fdput(f);</span><br><span class="line">next_insn:</span><br><span class="line">			insn++;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* now all pseudo BPF_LD_IMM64 instructions load valid</span><br><span class="line">	 * &apos;struct bpf_map *&apos; into a register instead of user map_fd.</span><br><span class="line">	 * These pointers will be used later by verifier to validate map access.</span><br><span class="line">	 */</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>2、Step 1、通过DAG(Directed Acyclic Graph 有向无环图)的DFS(Depth-first Search)深度优先算法来遍历BPF程序的代码路径，确保没有环路发生；</li>
</ul>
<p>DAG的DFS算法可以参考“<a href="http://www.csie.ntnu.edu.tw/~u91029/Graph.html#5" target="_blank" rel="noopener">Graph</a>”一文。其中最重要的概念如下图：</p>
<p><img src="/images/bpf/DFS5.png" alt="DFS5"></p>
<p>一个图形”Graph”经过DAG的DFS算法遍历后，对每一个根节点都会形成一颗树“DFS Tree”，多个根节点得到的多棵树形成一个森林”DFS Forest”。根据搜索的结构整个“Graph”的边“Edge”可以分成四类：</p>
<ul>
<li>Tree Edges：在DFS树上的边；</li>
<li>Back Edges：从子节点连向祖先节点的边(形成环)；</li>
<li>Forward Edges：直接连向孙节点的边(跨子节点的连接)；</li>
<li>Cross Edges：叶子之间的连接，或者树之间的连接；</li>
</ul>
<p>对BPF verifier来说，检查BPF程序的运行路径图中是否有“Back Edges”的存在，确保程序中没有环路。</p>
<p>具体的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">static int check_cfg(struct bpf_verifier_env *env)</span><br><span class="line">&#123;</span><br><span class="line">	struct bpf_insn *insns = env-&gt;prog-&gt;insnsi;</span><br><span class="line">	int insn_cnt = env-&gt;prog-&gt;len;</span><br><span class="line">	int ret = 0;</span><br><span class="line">	int i, t;</span><br><span class="line"></span><br><span class="line">	insn_state = kcalloc(insn_cnt, sizeof(int), GFP_KERNEL);</span><br><span class="line">	if (!insn_state)</span><br><span class="line">		return -ENOMEM;</span><br><span class="line"></span><br><span class="line">	insn_stack = kcalloc(insn_cnt, sizeof(int), GFP_KERNEL);</span><br><span class="line">	if (!insn_stack) &#123;</span><br><span class="line">		kfree(insn_state);</span><br><span class="line">		return -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	insn_state[0] = DISCOVERED; /* mark 1st insn as discovered */</span><br><span class="line">	insn_stack[0] = 0; /* 0 is the first instruction */</span><br><span class="line">	cur_stack = 1;</span><br><span class="line"></span><br><span class="line">    /* (3.4.1) DFS深度优先算法的循环 */</span><br><span class="line">peek_stack:</span><br><span class="line">	if (cur_stack == 0)</span><br><span class="line">		goto check_state;</span><br><span class="line">	t = insn_stack[cur_stack - 1];</span><br><span class="line"></span><br><span class="line">    /* (3.4.2) 分支指令 */</span><br><span class="line">	if (BPF_CLASS(insns[t].code) == BPF_JMP) &#123;</span><br><span class="line">		u8 opcode = BPF_OP(insns[t].code);</span><br><span class="line"></span><br><span class="line">        /* (3.4.2.1) 碰到BPF_EXIT指令，路径终结，开始回溯确认 */</span><br><span class="line">		if (opcode == BPF_EXIT) &#123;</span><br><span class="line">			goto mark_explored;</span><br><span class="line">			</span><br><span class="line">		/* (3.4.2.2) 碰到BPF_CALL指令，继续探索 </span><br><span class="line">		    并且把env-&gt;explored_states[]设置成STATE_LIST_MARK，标识call函数调用后需要重新跟踪计算寄存器和堆栈</span><br><span class="line">		 */</span><br><span class="line">		&#125; else if (opcode == BPF_CALL) &#123;</span><br><span class="line">			ret = push_insn(t, t + 1, FALLTHROUGH, env);</span><br><span class="line">			if (ret == 1)</span><br><span class="line">				goto peek_stack;</span><br><span class="line">			else if (ret &lt; 0)</span><br><span class="line">				goto err_free;</span><br><span class="line">			if (t + 1 &lt; insn_cnt)</span><br><span class="line">				env-&gt;explored_states[t + 1] = STATE_LIST_MARK;</span><br><span class="line">				</span><br><span class="line">		/* (3.4.2.3) 碰到BPF_JA指令，继续探索 </span><br><span class="line">		    并且把env-&gt;explored_states[]设置成STATE_LIST_MARK，标识call函数调用后需要重新跟踪计算寄存器和堆栈</span><br><span class="line">		 */</span><br><span class="line">		&#125; else if (opcode == BPF_JA) &#123;</span><br><span class="line">			if (BPF_SRC(insns[t].code) != BPF_K) &#123;</span><br><span class="line">				ret = -EINVAL;</span><br><span class="line">				goto err_free;</span><br><span class="line">			&#125;</span><br><span class="line">			/* unconditional jump with single edge */</span><br><span class="line">			ret = push_insn(t, t + insns[t].off + 1,</span><br><span class="line">					FALLTHROUGH, env);</span><br><span class="line">			if (ret == 1)</span><br><span class="line">				goto peek_stack;</span><br><span class="line">			else if (ret &lt; 0)</span><br><span class="line">				goto err_free;</span><br><span class="line">			/* tell verifier to check for equivalent states</span><br><span class="line">			 * after every call and jump</span><br><span class="line">			 */</span><br><span class="line">			if (t + 1 &lt; insn_cnt)</span><br><span class="line">				env-&gt;explored_states[t + 1] = STATE_LIST_MARK;</span><br><span class="line">				</span><br><span class="line">		/* (3.4.2.4) 剩下的是有条件跳转指令，首先探测条件失败路径，再探测条件成功路径 </span><br><span class="line">		    并且把env-&gt;explored_states[]设置成STATE_LIST_MARK，标识call函数调用后需要重新跟踪计算寄存器和堆栈</span><br><span class="line">		 */</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			/* conditional jump with two edges */</span><br><span class="line">			env-&gt;explored_states[t] = STATE_LIST_MARK;</span><br><span class="line">			</span><br><span class="line">			/* 条件失败路径 */</span><br><span class="line">			ret = push_insn(t, t + 1, FALLTHROUGH, env);</span><br><span class="line">			if (ret == 1)</span><br><span class="line">				goto peek_stack;</span><br><span class="line">			else if (ret &lt; 0)</span><br><span class="line">				goto err_free;</span><br><span class="line"></span><br><span class="line">            /* 条件成功路径 */</span><br><span class="line">			ret = push_insn(t, t + insns[t].off + 1, BRANCH, env);</span><br><span class="line">			if (ret == 1)</span><br><span class="line">				goto peek_stack;</span><br><span class="line">			else if (ret &lt; 0)</span><br><span class="line">				goto err_free;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	/* (3.4.3) 非分支指令 */</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		/* all other non-branch instructions with single</span><br><span class="line">		 * fall-through edge</span><br><span class="line">		 */</span><br><span class="line">		ret = push_insn(t, t + 1, FALLTHROUGH, env);</span><br><span class="line">		/* (3.4.3.1) ret的含义如下</span><br><span class="line">		    ret == 1：继续探索路径</span><br><span class="line">		    ret == 0：已经是叶子节点了，跳转到mark_explored确认并回溯</span><br><span class="line">		    ret &lt; 0：探测到&quot;back-edge&quot;环路，或者其他错误</span><br><span class="line">		 */</span><br><span class="line">		if (ret == 1)</span><br><span class="line">			goto peek_stack;</span><br><span class="line">		else if (ret &lt; 0)</span><br><span class="line">			goto err_free;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (3.4.4) 确认并回溯，状态标记为EXPLORED </span><br><span class="line">     */</span><br><span class="line">mark_explored:</span><br><span class="line">	insn_state[t] = EXPLORED;</span><br><span class="line">	if (cur_stack-- &lt;= 0) &#123;</span><br><span class="line">		verbose(&quot;pop stack internal bug\n&quot;);</span><br><span class="line">		ret = -EFAULT;</span><br><span class="line">		goto err_free;</span><br><span class="line">	&#125;</span><br><span class="line">	goto peek_stack;</span><br><span class="line"></span><br><span class="line">    /* (3.4.5) 确认没有unreachable的指令，就是路径没法抵达 */</span><br><span class="line">check_state:</span><br><span class="line">	for (i = 0; i &lt; insn_cnt; i++) &#123;</span><br><span class="line">		if (insn_state[i] != EXPLORED) &#123;</span><br><span class="line">			verbose(&quot;unreachable insn %d\n&quot;, i);</span><br><span class="line">			ret = -EINVAL;</span><br><span class="line">			goto err_free;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ret = 0; /* cfg looks good */</span><br><span class="line"></span><br><span class="line">err_free:</span><br><span class="line">	kfree(insn_state);</span><br><span class="line">	kfree(insn_stack);</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>3、step2、详细扫描BPF代码的运行过程，跟踪分析寄存器和堆栈，检查是否有不符合规则的情况出现。</li>
</ul>
<p>这段代码的具体算法就是把step1的路径重新走一遍，并且跟踪寄存器和堆栈的变化，判断最坏情况下是否有违反规则的情况出现。<br>在碰到指令对应explored_states[]被设置成STATE_LIST_MARK，需要给当前指令独立分配一个bpf_verifier_state_list链表，来存储这个指令在多个分支上的不同状况。<br>这里也有一个快速分析的优化方法：修剪(Pruning)。如果当前指令的当前分支的状态cur_state，和当前指令另一个已分析分支的状态(当前指令explored_states[]链表中的一个bpf_verifier_state_list成员)相等或者是它的一个子集，那么当前指令的当前分支就不需要分析了，因为它肯定是符合规则的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br></pre></td><td class="code"><pre><span class="line">static int do_check(struct bpf_verifier_env *env)</span><br><span class="line">&#123;</span><br><span class="line">	struct bpf_verifier_state *state = &amp;env-&gt;cur_state;</span><br><span class="line">	struct bpf_insn *insns = env-&gt;prog-&gt;insnsi;</span><br><span class="line">	struct bpf_reg_state *regs = state-&gt;regs;</span><br><span class="line">	int insn_cnt = env-&gt;prog-&gt;len;</span><br><span class="line">	int insn_idx, prev_insn_idx = 0;</span><br><span class="line">	int insn_processed = 0;</span><br><span class="line">	bool do_print_state = false;</span><br><span class="line"></span><br><span class="line">	init_reg_state(regs);</span><br><span class="line">	insn_idx = 0;</span><br><span class="line">	env-&gt;varlen_map_value_access = false;</span><br><span class="line">	for (;;) &#123;</span><br><span class="line">		struct bpf_insn *insn;</span><br><span class="line">		u8 class;</span><br><span class="line">		int err;</span><br><span class="line"></span><br><span class="line">		if (insn_idx &gt;= insn_cnt) &#123;</span><br><span class="line">			verbose(&quot;invalid insn idx %d insn_cnt %d\n&quot;,</span><br><span class="line">				insn_idx, insn_cnt);</span><br><span class="line">			return -EFAULT;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		insn = &amp;insns[insn_idx];</span><br><span class="line">		class = BPF_CLASS(insn-&gt;code);</span><br><span class="line"></span><br><span class="line">		if (++insn_processed &gt; BPF_COMPLEXITY_LIMIT_INSNS) &#123;</span><br><span class="line">			verbose(&quot;BPF program is too large. Proccessed %d insn\n&quot;,</span><br><span class="line">				insn_processed);</span><br><span class="line">			return -E2BIG;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		err = is_state_visited(env, insn_idx);</span><br><span class="line">		if (err &lt; 0)</span><br><span class="line">			return err;</span><br><span class="line">		if (err == 1) &#123;</span><br><span class="line">			/* found equivalent state, can prune the search */</span><br><span class="line">			if (log_level) &#123;</span><br><span class="line">				if (do_print_state)</span><br><span class="line">					verbose(&quot;\nfrom %d to %d: safe\n&quot;,</span><br><span class="line">						prev_insn_idx, insn_idx);</span><br><span class="line">				else</span><br><span class="line">					verbose(&quot;%d: safe\n&quot;, insn_idx);</span><br><span class="line">			&#125;</span><br><span class="line">			goto process_bpf_exit;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (need_resched())</span><br><span class="line">			cond_resched();</span><br><span class="line"></span><br><span class="line">		if (log_level &amp;&amp; do_print_state) &#123;</span><br><span class="line">			verbose(&quot;\nfrom %d to %d:&quot;, prev_insn_idx, insn_idx);</span><br><span class="line">			print_verifier_state(&amp;env-&gt;cur_state);</span><br><span class="line">			do_print_state = false;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (log_level) &#123;</span><br><span class="line">			verbose(&quot;%d: &quot;, insn_idx);</span><br><span class="line">			print_bpf_insn(env, insn);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		err = ext_analyzer_insn_hook(env, insn_idx, prev_insn_idx);</span><br><span class="line">		if (err)</span><br><span class="line">			return err;</span><br><span class="line"></span><br><span class="line">		env-&gt;insn_aux_data[insn_idx].seen = true;</span><br><span class="line">		if (class == BPF_ALU || class == BPF_ALU64) &#123;</span><br><span class="line">			err = check_alu_op(env, insn);</span><br><span class="line">			if (err)</span><br><span class="line">				return err;</span><br><span class="line"></span><br><span class="line">		&#125; else if (class == BPF_LDX) &#123;</span><br><span class="line">			enum bpf_reg_type *prev_src_type, src_reg_type;</span><br><span class="line"></span><br><span class="line">			/* check for reserved fields is already done */</span><br><span class="line"></span><br><span class="line">			/* check src operand */</span><br><span class="line">			err = check_reg_arg(regs, insn-&gt;src_reg, SRC_OP);</span><br><span class="line">			if (err)</span><br><span class="line">				return err;</span><br><span class="line"></span><br><span class="line">			err = check_reg_arg(regs, insn-&gt;dst_reg, DST_OP_NO_MARK);</span><br><span class="line">			if (err)</span><br><span class="line">				return err;</span><br><span class="line"></span><br><span class="line">			src_reg_type = regs[insn-&gt;src_reg].type;</span><br><span class="line"></span><br><span class="line">			/* check that memory (src_reg + off) is readable,</span><br><span class="line">			 * the state of dst_reg will be updated by this func</span><br><span class="line">			 */</span><br><span class="line">			err = check_mem_access(env, insn-&gt;src_reg, insn-&gt;off,</span><br><span class="line">					       BPF_SIZE(insn-&gt;code), BPF_READ,</span><br><span class="line">					       insn-&gt;dst_reg);</span><br><span class="line">			if (err)</span><br><span class="line">				return err;</span><br><span class="line"></span><br><span class="line">			reset_reg_range_values(regs, insn-&gt;dst_reg);</span><br><span class="line">			if (BPF_SIZE(insn-&gt;code) != BPF_W &amp;&amp;</span><br><span class="line">			    BPF_SIZE(insn-&gt;code) != BPF_DW) &#123;</span><br><span class="line">				insn_idx++;</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			prev_src_type = &amp;env-&gt;insn_aux_data[insn_idx].ptr_type;</span><br><span class="line"></span><br><span class="line">			if (*prev_src_type == NOT_INIT) &#123;</span><br><span class="line">				/* saw a valid insn</span><br><span class="line">				 * dst_reg = *(u32 *)(src_reg + off)</span><br><span class="line">				 * save type to validate intersecting paths</span><br><span class="line">				 */</span><br><span class="line">				*prev_src_type = src_reg_type;</span><br><span class="line"></span><br><span class="line">			&#125; else if (src_reg_type != *prev_src_type &amp;&amp;</span><br><span class="line">				   (src_reg_type == PTR_TO_CTX ||</span><br><span class="line">				    *prev_src_type == PTR_TO_CTX)) &#123;</span><br><span class="line">				/* ABuser program is trying to use the same insn</span><br><span class="line">				 * dst_reg = *(u32*) (src_reg + off)</span><br><span class="line">				 * with different pointer types:</span><br><span class="line">				 * src_reg == ctx in one branch and</span><br><span class="line">				 * src_reg == stack|map in some other branch.</span><br><span class="line">				 * Reject it.</span><br><span class="line">				 */</span><br><span class="line">				verbose(&quot;same insn cannot be used with different pointers\n&quot;);</span><br><span class="line">				return -EINVAL;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125; else if (class == BPF_STX) &#123;</span><br><span class="line">			enum bpf_reg_type *prev_dst_type, dst_reg_type;</span><br><span class="line"></span><br><span class="line">			if (BPF_MODE(insn-&gt;code) == BPF_XADD) &#123;</span><br><span class="line">				err = check_xadd(env, insn);</span><br><span class="line">				if (err)</span><br><span class="line">					return err;</span><br><span class="line">				insn_idx++;</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			/* check src1 operand */</span><br><span class="line">			err = check_reg_arg(regs, insn-&gt;src_reg, SRC_OP);</span><br><span class="line">			if (err)</span><br><span class="line">				return err;</span><br><span class="line">			/* check src2 operand */</span><br><span class="line">			err = check_reg_arg(regs, insn-&gt;dst_reg, SRC_OP);</span><br><span class="line">			if (err)</span><br><span class="line">				return err;</span><br><span class="line"></span><br><span class="line">			dst_reg_type = regs[insn-&gt;dst_reg].type;</span><br><span class="line"></span><br><span class="line">			/* check that memory (dst_reg + off) is writeable */</span><br><span class="line">			err = check_mem_access(env, insn-&gt;dst_reg, insn-&gt;off,</span><br><span class="line">					       BPF_SIZE(insn-&gt;code), BPF_WRITE,</span><br><span class="line">					       insn-&gt;src_reg);</span><br><span class="line">			if (err)</span><br><span class="line">				return err;</span><br><span class="line"></span><br><span class="line">			prev_dst_type = &amp;env-&gt;insn_aux_data[insn_idx].ptr_type;</span><br><span class="line"></span><br><span class="line">			if (*prev_dst_type == NOT_INIT) &#123;</span><br><span class="line">				*prev_dst_type = dst_reg_type;</span><br><span class="line">			&#125; else if (dst_reg_type != *prev_dst_type &amp;&amp;</span><br><span class="line">				   (dst_reg_type == PTR_TO_CTX ||</span><br><span class="line">				    *prev_dst_type == PTR_TO_CTX)) &#123;</span><br><span class="line">				verbose(&quot;same insn cannot be used with different pointers\n&quot;);</span><br><span class="line">				return -EINVAL;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125; else if (class == BPF_ST) &#123;</span><br><span class="line">			if (BPF_MODE(insn-&gt;code) != BPF_MEM ||</span><br><span class="line">			    insn-&gt;src_reg != BPF_REG_0) &#123;</span><br><span class="line">				verbose(&quot;BPF_ST uses reserved fields\n&quot;);</span><br><span class="line">				return -EINVAL;</span><br><span class="line">			&#125;</span><br><span class="line">			/* check src operand */</span><br><span class="line">			err = check_reg_arg(regs, insn-&gt;dst_reg, SRC_OP);</span><br><span class="line">			if (err)</span><br><span class="line">				return err;</span><br><span class="line"></span><br><span class="line">			if (is_ctx_reg(env, insn-&gt;dst_reg)) &#123;</span><br><span class="line">				verbose(&quot;BPF_ST stores into R%d context is not allowed\n&quot;,</span><br><span class="line">					insn-&gt;dst_reg);</span><br><span class="line">				return -EACCES;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			/* check that memory (dst_reg + off) is writeable */</span><br><span class="line">			err = check_mem_access(env, insn-&gt;dst_reg, insn-&gt;off,</span><br><span class="line">					       BPF_SIZE(insn-&gt;code), BPF_WRITE,</span><br><span class="line">					       -1);</span><br><span class="line">			if (err)</span><br><span class="line">				return err;</span><br><span class="line"></span><br><span class="line">		&#125; else if (class == BPF_JMP) &#123;</span><br><span class="line">			u8 opcode = BPF_OP(insn-&gt;code);</span><br><span class="line"></span><br><span class="line">			if (opcode == BPF_CALL) &#123;</span><br><span class="line">				if (BPF_SRC(insn-&gt;code) != BPF_K ||</span><br><span class="line">				    insn-&gt;off != 0 ||</span><br><span class="line">				    insn-&gt;src_reg != BPF_REG_0 ||</span><br><span class="line">				    insn-&gt;dst_reg != BPF_REG_0) &#123;</span><br><span class="line">					verbose(&quot;BPF_CALL uses reserved fields\n&quot;);</span><br><span class="line">					return -EINVAL;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				err = check_call(env, insn-&gt;imm, insn_idx);</span><br><span class="line">				if (err)</span><br><span class="line">					return err;</span><br><span class="line"></span><br><span class="line">			&#125; else if (opcode == BPF_JA) &#123;</span><br><span class="line">				if (BPF_SRC(insn-&gt;code) != BPF_K ||</span><br><span class="line">				    insn-&gt;imm != 0 ||</span><br><span class="line">				    insn-&gt;src_reg != BPF_REG_0 ||</span><br><span class="line">				    insn-&gt;dst_reg != BPF_REG_0) &#123;</span><br><span class="line">					verbose(&quot;BPF_JA uses reserved fields\n&quot;);</span><br><span class="line">					return -EINVAL;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				insn_idx += insn-&gt;off + 1;</span><br><span class="line">				continue;</span><br><span class="line"></span><br><span class="line">			&#125; else if (opcode == BPF_EXIT) &#123;</span><br><span class="line">				if (BPF_SRC(insn-&gt;code) != BPF_K ||</span><br><span class="line">				    insn-&gt;imm != 0 ||</span><br><span class="line">				    insn-&gt;src_reg != BPF_REG_0 ||</span><br><span class="line">				    insn-&gt;dst_reg != BPF_REG_0) &#123;</span><br><span class="line">					verbose(&quot;BPF_EXIT uses reserved fields\n&quot;);</span><br><span class="line">					return -EINVAL;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				/* eBPF calling convetion is such that R0 is used</span><br><span class="line">				 * to return the value from eBPF program.</span><br><span class="line">				 * Make sure that it&apos;s readable at this time</span><br><span class="line">				 * of bpf_exit, which means that program wrote</span><br><span class="line">				 * something into it earlier</span><br><span class="line">				 */</span><br><span class="line">				err = check_reg_arg(regs, BPF_REG_0, SRC_OP);</span><br><span class="line">				if (err)</span><br><span class="line">					return err;</span><br><span class="line"></span><br><span class="line">				if (is_pointer_value(env, BPF_REG_0)) &#123;</span><br><span class="line">					verbose(&quot;R0 leaks addr as return value\n&quot;);</span><br><span class="line">					return -EACCES;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">process_bpf_exit:</span><br><span class="line">				insn_idx = pop_stack(env, &amp;prev_insn_idx);</span><br><span class="line">				if (insn_idx &lt; 0) &#123;</span><br><span class="line">					break;</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					do_print_state = true;</span><br><span class="line">					continue;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				err = check_cond_jmp_op(env, insn, &amp;insn_idx);</span><br><span class="line">				if (err)</span><br><span class="line">					return err;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; else if (class == BPF_LD) &#123;</span><br><span class="line">			u8 mode = BPF_MODE(insn-&gt;code);</span><br><span class="line"></span><br><span class="line">			if (mode == BPF_ABS || mode == BPF_IND) &#123;</span><br><span class="line">				err = check_ld_abs(env, insn);</span><br><span class="line">				if (err)</span><br><span class="line">					return err;</span><br><span class="line"></span><br><span class="line">			&#125; else if (mode == BPF_IMM) &#123;</span><br><span class="line">				err = check_ld_imm(env, insn);</span><br><span class="line">				if (err)</span><br><span class="line">					return err;</span><br><span class="line"></span><br><span class="line">				insn_idx++;</span><br><span class="line">				env-&gt;insn_aux_data[insn_idx].seen = true;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				verbose(&quot;invalid BPF_LD mode\n&quot;);</span><br><span class="line">				return -EINVAL;</span><br><span class="line">			&#125;</span><br><span class="line">			reset_reg_range_values(regs, insn-&gt;dst_reg);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			verbose(&quot;unknown insn class %d\n&quot;, class);</span><br><span class="line">			return -EINVAL;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		insn_idx++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	verbose(&quot;processed %d insns\n&quot;, insn_processed);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>4、修复BPF指令中对内核helper function函数的调用，把函数编号替换成实际的函数指针。</li>
</ul>
<p>符合条件：(insn-&gt;code == (BPF_JMP | BPF_CALL)) 的指令，即是调用helper function的指令。<br>通用helper function的处理：根据insn-&gt;imm指定的编号找打对应的函数指针，然后再把函数指针和__bpf_call_base之间的offset，赋值到insn-&gt;imm中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">static int fixup_bpf_calls(struct bpf_verifier_env *env)</span><br><span class="line">&#123;</span><br><span class="line">	struct bpf_prog *prog = env-&gt;prog;</span><br><span class="line">	struct bpf_insn *insn = prog-&gt;insnsi;</span><br><span class="line">	const struct bpf_func_proto *fn;</span><br><span class="line">	const int insn_cnt = prog-&gt;len;</span><br><span class="line">	struct bpf_insn insn_buf[16];</span><br><span class="line">	struct bpf_prog *new_prog;</span><br><span class="line">	struct bpf_map *map_ptr;</span><br><span class="line">	int i, cnt, delta = 0;</span><br><span class="line"></span><br><span class="line">    /* (3.8.1) 遍历指令 */</span><br><span class="line">	for (i = 0; i &lt; insn_cnt; i++, insn++) &#123;</span><br><span class="line">	</span><br><span class="line">	    /* (3.8.2) 修复ALU指令的一个bug */</span><br><span class="line">		if (insn-&gt;code == (BPF_ALU | BPF_MOD | BPF_X) ||</span><br><span class="line">		    insn-&gt;code == (BPF_ALU | BPF_DIV | BPF_X)) &#123;</span><br><span class="line">			/* due to JIT bugs clear upper 32-bits of src register</span><br><span class="line">			 * before div/mod operation</span><br><span class="line">			 */</span><br><span class="line">			insn_buf[0] = BPF_MOV32_REG(insn-&gt;src_reg, insn-&gt;src_reg);</span><br><span class="line">			insn_buf[1] = *insn;</span><br><span class="line">			cnt = 2;</span><br><span class="line">			new_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);</span><br><span class="line">			if (!new_prog)</span><br><span class="line">				return -ENOMEM;</span><br><span class="line"></span><br><span class="line">			delta    += cnt - 1;</span><br><span class="line">			env-&gt;prog = prog = new_prog;</span><br><span class="line">			insn      = new_prog-&gt;insnsi + i + delta;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        /* (3.8.3) 符合条件：(insn-&gt;code == (BPF_JMP | BPF_CALL)) </span><br><span class="line">            的指令，即是调用helper function的指令</span><br><span class="line">         */</span><br><span class="line">		if (insn-&gt;code != (BPF_JMP | BPF_CALL))</span><br><span class="line">			continue;</span><br><span class="line"></span><br><span class="line">        /* (3.8.3.1) 几种特殊helper function的处理 */</span><br><span class="line">		if (insn-&gt;imm == BPF_FUNC_get_route_realm)</span><br><span class="line">			prog-&gt;dst_needed = 1;</span><br><span class="line">		if (insn-&gt;imm == BPF_FUNC_get_prandom_u32)</span><br><span class="line">			bpf_user_rnd_init_once();</span><br><span class="line">		if (insn-&gt;imm == BPF_FUNC_tail_call) &#123;</span><br><span class="line">			/* mark bpf_tail_call as different opcode to avoid</span><br><span class="line">			 * conditional branch in the interpeter for every normal</span><br><span class="line">			 * call and to prevent accidental JITing by JIT compiler</span><br><span class="line">			 * that doesn&apos;t support bpf_tail_call yet</span><br><span class="line"> 			 */</span><br><span class="line">			insn-&gt;imm = 0;</span><br><span class="line">			insn-&gt;code |= BPF_X;</span><br><span class="line"></span><br><span class="line">			/* instead of changing every JIT dealing with tail_call</span><br><span class="line">			 * emit two extra insns:</span><br><span class="line">			 * if (index &gt;= max_entries) goto out;</span><br><span class="line">			 * index &amp;= array-&gt;index_mask;</span><br><span class="line">			 * to avoid out-of-bounds cpu speculation</span><br><span class="line">			 */</span><br><span class="line">			map_ptr = env-&gt;insn_aux_data[i + delta].map_ptr;</span><br><span class="line">			if (!map_ptr-&gt;unpriv_array)</span><br><span class="line">				continue;</span><br><span class="line">			insn_buf[0] = BPF_JMP_IMM(BPF_JGE, BPF_REG_3,</span><br><span class="line">						  map_ptr-&gt;max_entries, 2);</span><br><span class="line">			insn_buf[1] = BPF_ALU32_IMM(BPF_AND, BPF_REG_3,</span><br><span class="line">						    container_of(map_ptr,</span><br><span class="line">								 struct bpf_array,</span><br><span class="line">								 map)-&gt;index_mask);</span><br><span class="line">			insn_buf[2] = *insn;</span><br><span class="line">			cnt = 3;</span><br><span class="line">			new_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);</span><br><span class="line">			if (!new_prog)</span><br><span class="line">				return -ENOMEM;</span><br><span class="line"></span><br><span class="line">			delta    += cnt - 1;</span><br><span class="line">			env-&gt;prog = prog = new_prog;</span><br><span class="line">			insn      = new_prog-&gt;insnsi + i + delta;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        /* (3.8.3.2) 通用helper function的处理：根据insn-&gt;imm指定的编号找打对应的函数指针 */</span><br><span class="line">		fn = prog-&gt;aux-&gt;ops-&gt;get_func_proto(insn-&gt;imm);</span><br><span class="line">		/* all functions that have prototype and verifier allowed</span><br><span class="line">		 * programs to call them, must be real in-kernel functions</span><br><span class="line">		 */</span><br><span class="line">		if (!fn-&gt;func) &#123;</span><br><span class="line">			verbose(&quot;kernel subsystem misconfigured func %d\n&quot;,</span><br><span class="line">				insn-&gt;imm);</span><br><span class="line">			return -EFAULT;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		/* (3.8.3.3) 然后再把函数指针和__bpf_call_base之间的offset，赋值到insn-&gt;imm中 */</span><br><span class="line">		insn-&gt;imm = fn-&gt;func - __bpf_call_base;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-1-3、bpf-JIT-kernel-interpreter"><a href="#1-1-3、bpf-JIT-kernel-interpreter" class="headerlink" title="1.1.3、bpf JIT/kernel interpreter"></a>1.1.3、bpf JIT/kernel interpreter</h3><p>在verifier验证通过以后，内核通过JIT(Just-In-Time)将BPF目编码转换成本地指令码；如果当前架构不支持JIT转换内核则会使用一个解析器(interpreter)来模拟运行，这种运行效率较低；<br>有些架构(64 bit x86_64, arm64, ppc64, s390x, mips64, sparc64 and 32 bit arm)已经支持BPF的JIT，它可以高效的几乎一比一的把BPF代码转换成本机代码(因为eBPF的指令集已经做了优化，非常类似最新的arm/x86架构，ABI也类似)。如果当前架构不支持JTI只能使用内核的解析器(interpreter)来模拟运行；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">struct bpf_prog *bpf_prog_select_runtime(struct bpf_prog *fp, int *err)</span><br><span class="line">&#123;</span><br><span class="line">#ifndef CONFIG_BPF_JIT_ALWAYS_ON</span><br><span class="line">    /* (4.1) 在不支持JIT只能使用解析器(interpreter)时，BPF程序的运行入口 */</span><br><span class="line">	fp-&gt;bpf_func = (void *) __bpf_prog_run;</span><br><span class="line">#else</span><br><span class="line">	fp-&gt;bpf_func = (void *) __bpf_prog_ret0;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	/* eBPF JITs can rewrite the program in case constant</span><br><span class="line">	 * blinding is active. However, in case of error during</span><br><span class="line">	 * blinding, bpf_int_jit_compile() must always return a</span><br><span class="line">	 * valid program, which in this case would simply not</span><br><span class="line">	 * be JITed, but falls back to the interpreter.</span><br><span class="line">	 */</span><br><span class="line">	/* (4.2) 尝试对BPF程序进行JIT转换 */</span><br><span class="line">	fp = bpf_int_jit_compile(fp);</span><br><span class="line">#ifdef CONFIG_BPF_JIT_ALWAYS_ON</span><br><span class="line">	if (!fp-&gt;jited) &#123;</span><br><span class="line">		*err = -ENOTSUPP;</span><br><span class="line">		return fp;</span><br><span class="line">	&#125;</span><br><span class="line">#endif</span><br><span class="line">	bpf_prog_lock_ro(fp);</span><br><span class="line"></span><br><span class="line">	/* The tail call compatibility check can only be done at</span><br><span class="line">	 * this late stage as we need to determine, if we deal</span><br><span class="line">	 * with JITed or non JITed program concatenations and not</span><br><span class="line">	 * all eBPF JITs might immediately support all features.</span><br><span class="line">	 */</span><br><span class="line">	/* (4.3) 对tail call使用的BPF_MAP_TYPE_PROG_ARRAY类型的map，进行一些检查 */</span><br><span class="line">	*err = bpf_check_tail_call(fp);</span><br><span class="line"></span><br><span class="line">	return fp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>1、JIT</li>
</ul>
<p>以arm64的JIT转换为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">struct bpf_prog *bpf_int_jit_compile(struct bpf_prog *prog)</span><br><span class="line">&#123;</span><br><span class="line">	struct bpf_prog *tmp, *orig_prog = prog;</span><br><span class="line">	struct bpf_binary_header *header;</span><br><span class="line">	bool tmp_blinded = false;</span><br><span class="line">	struct jit_ctx ctx;</span><br><span class="line">	int image_size;</span><br><span class="line">	u8 *image_ptr;</span><br><span class="line"></span><br><span class="line">	if (!bpf_jit_enable)</span><br><span class="line">		return orig_prog;</span><br><span class="line"></span><br><span class="line">    /* (4.2.1) 把常量致盲(constant blinding) */</span><br><span class="line">	tmp = bpf_jit_blind_constants(prog);</span><br><span class="line">	/* If blinding was requested and we failed during blinding,</span><br><span class="line">	 * we must fall back to the interpreter.</span><br><span class="line">	 */</span><br><span class="line">	if (IS_ERR(tmp))</span><br><span class="line">		return orig_prog;</span><br><span class="line">	if (tmp != prog) &#123;</span><br><span class="line">		tmp_blinded = true;</span><br><span class="line">		prog = tmp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	memset(&amp;ctx, 0, sizeof(ctx));</span><br><span class="line">	ctx.prog = prog;</span><br><span class="line"></span><br><span class="line">	ctx.offset = kcalloc(prog-&gt;len, sizeof(int), GFP_KERNEL);</span><br><span class="line">	if (ctx.offset == NULL) &#123;</span><br><span class="line">		prog = orig_prog;</span><br><span class="line">		goto out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* 1. Initial fake pass to compute ctx-&gt;idx. */</span><br><span class="line">	/* (4.2.2) JIT指令转换，但是不储存转换结果，只是记录 “prologue + body + epilogue”转换后需要的总长度 */</span><br><span class="line"></span><br><span class="line">	/* Fake pass to fill in ctx-&gt;offset. */</span><br><span class="line">	if (build_body(&amp;ctx)) &#123;</span><br><span class="line">		prog = orig_prog;</span><br><span class="line">		goto out_off;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (build_prologue(&amp;ctx)) &#123;</span><br><span class="line">		prog = orig_prog;</span><br><span class="line">		goto out_off;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ctx.epilogue_offset = ctx.idx;</span><br><span class="line">	build_epilogue(&amp;ctx);</span><br><span class="line"></span><br><span class="line">	/* Now we know the actual image size. */</span><br><span class="line">	/* (4.2.3) 根据计算的总长度，分配JIT转换后指令的存储空间：ctx.image */</span><br><span class="line">	image_size = sizeof(u32) * ctx.idx;</span><br><span class="line">	header = bpf_jit_binary_alloc(image_size, &amp;image_ptr,</span><br><span class="line">				      sizeof(u32), jit_fill_hole);</span><br><span class="line">	if (header == NULL) &#123;</span><br><span class="line">		prog = orig_prog;</span><br><span class="line">		goto out_off;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* 2. Now, the actual pass. */</span><br><span class="line">	/* (4.2.4) 重新做一次JIT转换，把转换后的指令存储到 ctx.image */</span><br><span class="line"></span><br><span class="line">	ctx.image = (u32 *)image_ptr;</span><br><span class="line">	ctx.idx = 0;</span><br><span class="line"></span><br><span class="line">    /* (4.2.4.1) 构造转换后image的头，负责构造BPF程序运行时的堆栈，8条指令 */</span><br><span class="line">	build_prologue(&amp;ctx);</span><br><span class="line"></span><br><span class="line">    /* (4.2.4.2) 把BPF程序进行JIT本地化指令转换 */</span><br><span class="line">	if (build_body(&amp;ctx)) &#123;</span><br><span class="line">		bpf_jit_binary_free(header);</span><br><span class="line">		prog = orig_prog;</span><br><span class="line">		goto out_off;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (4.2.4.3) 构造转换后image的尾部，负载清理工作，7条指令 */</span><br><span class="line">	build_epilogue(&amp;ctx);</span><br><span class="line"></span><br><span class="line">	/* 3. Extra pass to validate JITed code. */</span><br><span class="line">	/* (4.2.5) 确保转换后的指令中没有AARCH64_BREAK_FAULT */</span><br><span class="line">	if (validate_code(&amp;ctx)) &#123;</span><br><span class="line">		bpf_jit_binary_free(header);</span><br><span class="line">		prog = orig_prog;</span><br><span class="line">		goto out_off;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* And we&apos;re done. */</span><br><span class="line">	if (bpf_jit_enable &gt; 1)</span><br><span class="line">		bpf_jit_dump(prog-&gt;len, image_size, 2, ctx.image);</span><br><span class="line"></span><br><span class="line">    /* (4.2.6) 刷新新image对应的icache */</span><br><span class="line">	bpf_flush_icache(header, ctx.image + ctx.idx);</span><br><span class="line"></span><br><span class="line">    /* (4.2.7) 把image对应的page设置为read only */</span><br><span class="line">	set_memory_ro((unsigned long)header, header-&gt;pages);</span><br><span class="line">	</span><br><span class="line">	/* (4.2.8) 把转换后的image赋值给prog-&gt;bpf_func */</span><br><span class="line">	prog-&gt;bpf_func = (void *)ctx.image;</span><br><span class="line">	prog-&gt;jited = 1;</span><br><span class="line"></span><br><span class="line">out_off:</span><br><span class="line">	kfree(ctx.offset);</span><br><span class="line">out:</span><br><span class="line">	if (tmp_blinded)</span><br><span class="line">		bpf_jit_prog_release_other(prog, prog == orig_prog ?</span><br><span class="line">					   tmp : orig_prog);</span><br><span class="line">	return prog;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JIT的核心转换分为3部分：prologue + body + epilogue。<br>prologue：新增的指令，负责BPF运行堆栈的构建和运行现场的保护；<br>body：BPF主体部分；<br>epilogue：负责BPF运行完现场的恢复和清理；</p>
<ul>
<li>1.1、prologue</li>
</ul>
<p>A64_<em>：开头的是本机的相关寄存器<br>BPF_</em>：开头的是BPF虚拟机的寄存器</p>
<p>整个过程还是比较巧妙的：<br>首先将A64_FP/A64_LR保存进堆栈A64_SP，然后把当前A64_SP保存进A64_FP；<br>继续保存callee saved registers进堆栈A64_SP：r6, r7, r8, r9, fp, tcc，然后把当前A64_SP保存进BPF_FP；<br>把A64_SP减去STACK_SIZE，给BPF_FP留出512字节的堆栈空间；<br>这样BPF程序使用的是BPF_FP开始的512字节堆栈空间，普通kernel函数使用的是A64_SP继续向下的堆栈空间，互不干扰；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">static int build_prologue(struct jit_ctx *ctx)</span><br><span class="line">&#123;</span><br><span class="line">	const u8 r6 = bpf2a64[BPF_REG_6];</span><br><span class="line">	const u8 r7 = bpf2a64[BPF_REG_7];</span><br><span class="line">	const u8 r8 = bpf2a64[BPF_REG_8];</span><br><span class="line">	const u8 r9 = bpf2a64[BPF_REG_9];</span><br><span class="line">	const u8 fp = bpf2a64[BPF_REG_FP];</span><br><span class="line">	const u8 tcc = bpf2a64[TCALL_CNT];</span><br><span class="line">	const int idx0 = ctx-&gt;idx;</span><br><span class="line">	int cur_offset;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * BPF prog stack layout</span><br><span class="line">	 *</span><br><span class="line">	 *                         high</span><br><span class="line">	 * original A64_SP =&gt;   0:+-----+ BPF prologue</span><br><span class="line">	 *                        |FP/LR|</span><br><span class="line">	 * current A64_FP =&gt;  -16:+-----+</span><br><span class="line">	 *                        | ... | callee saved registers</span><br><span class="line">	 * BPF fp register =&gt; -64:+-----+ &lt;= (BPF_FP)</span><br><span class="line">	 *                        |     |</span><br><span class="line">	 *                        | ... | BPF prog stack</span><br><span class="line">	 *                        |     |</span><br><span class="line">	 *                        +-----+ &lt;= (BPF_FP - MAX_BPF_STACK)</span><br><span class="line">	 *                        |RSVD | JIT scratchpad</span><br><span class="line">	 * current A64_SP =&gt;      +-----+ &lt;= (BPF_FP - STACK_SIZE)</span><br><span class="line">	 *                        |     |</span><br><span class="line">	 *                        | ... | Function call stack</span><br><span class="line">	 *                        |     |</span><br><span class="line">	 *                        +-----+</span><br><span class="line">	 *                          low</span><br><span class="line">	 *</span><br><span class="line">	 */</span><br><span class="line"></span><br><span class="line">	/* Save FP and LR registers to stay align with ARM64 AAPCS */</span><br><span class="line">	emit(A64_PUSH(A64_FP, A64_LR, A64_SP), ctx);</span><br><span class="line">	emit(A64_MOV(1, A64_FP, A64_SP), ctx);</span><br><span class="line"></span><br><span class="line">	/* Save callee-saved registers */</span><br><span class="line">	emit(A64_PUSH(r6, r7, A64_SP), ctx);</span><br><span class="line">	emit(A64_PUSH(r8, r9, A64_SP), ctx);</span><br><span class="line">	emit(A64_PUSH(fp, tcc, A64_SP), ctx);</span><br><span class="line"></span><br><span class="line">	/* Set up BPF prog stack base register */</span><br><span class="line">	emit(A64_MOV(1, fp, A64_SP), ctx);</span><br><span class="line"></span><br><span class="line">	/* Initialize tail_call_cnt */</span><br><span class="line">	emit(A64_MOVZ(1, tcc, 0, 0), ctx);</span><br><span class="line"></span><br><span class="line">	/* Set up function call stack */</span><br><span class="line">	emit(A64_SUB_I(1, A64_SP, A64_SP, STACK_SIZE), ctx);</span><br><span class="line"></span><br><span class="line">	cur_offset = ctx-&gt;idx - idx0;</span><br><span class="line">	if (cur_offset != PROLOGUE_OFFSET) &#123;</span><br><span class="line">		pr_err_once(&quot;PROLOGUE_OFFSET = %d, expected %d!\n&quot;,</span><br><span class="line">			    cur_offset, PROLOGUE_OFFSET);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>1.2、body</li>
</ul>
<p>把BPF指令翻译成本地arm64指令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br></pre></td><td class="code"><pre><span class="line">static int build_body(struct jit_ctx *ctx)</span><br><span class="line">&#123;</span><br><span class="line">	const struct bpf_prog *prog = ctx-&gt;prog;</span><br><span class="line">	int i;</span><br><span class="line"></span><br><span class="line">	for (i = 0; i &lt; prog-&gt;len; i++) &#123;</span><br><span class="line">		const struct bpf_insn *insn = &amp;prog-&gt;insnsi[i];</span><br><span class="line">		int ret;</span><br><span class="line"></span><br><span class="line">		ret = build_insn(insn, ctx);</span><br><span class="line">		if (ret &gt; 0) &#123;</span><br><span class="line">			i++;</span><br><span class="line">			if (ctx-&gt;image == NULL)</span><br><span class="line">				ctx-&gt;offset[i] = ctx-&gt;idx;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		if (ctx-&gt;image == NULL)</span><br><span class="line">			ctx-&gt;offset[i] = ctx-&gt;idx;</span><br><span class="line">		if (ret)</span><br><span class="line">			return ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">/* JITs an eBPF instruction.</span><br><span class="line"> * Returns:</span><br><span class="line"> * 0  - successfully JITed an 8-byte eBPF instruction.</span><br><span class="line"> * &gt;0 - successfully JITed a 16-byte eBPF instruction.</span><br><span class="line"> * &lt;0 - failed to JIT.</span><br><span class="line"> */</span><br><span class="line">static int build_insn(const struct bpf_insn *insn, struct jit_ctx *ctx)</span><br><span class="line">&#123;</span><br><span class="line">	const u8 code = insn-&gt;code;</span><br><span class="line">	const u8 dst = bpf2a64[insn-&gt;dst_reg];</span><br><span class="line">	const u8 src = bpf2a64[insn-&gt;src_reg];</span><br><span class="line">	const u8 tmp = bpf2a64[TMP_REG_1];</span><br><span class="line">	const u8 tmp2 = bpf2a64[TMP_REG_2];</span><br><span class="line">	const s16 off = insn-&gt;off;</span><br><span class="line">	const s32 imm = insn-&gt;imm;</span><br><span class="line">	const int i = insn - ctx-&gt;prog-&gt;insnsi;</span><br><span class="line">	const bool is64 = BPF_CLASS(code) == BPF_ALU64;</span><br><span class="line">	u8 jmp_cond;</span><br><span class="line">	s32 jmp_offset;</span><br><span class="line"></span><br><span class="line">#define check_imm(bits, imm) do &#123;				\</span><br><span class="line">	if ((((imm) &gt; 0) &amp;&amp; ((imm) &gt;&gt; (bits))) ||		\</span><br><span class="line">	    (((imm) &lt; 0) &amp;&amp; (~(imm) &gt;&gt; (bits)))) &#123;		\</span><br><span class="line">		pr_info(&quot;[%2d] imm=%d(0x%x) out of range\n&quot;,	\</span><br><span class="line">			i, imm, imm);				\</span><br><span class="line">		return -EINVAL;					\</span><br><span class="line">	&#125;							\</span><br><span class="line">&#125; while (0)</span><br><span class="line">#define check_imm19(imm) check_imm(19, imm)</span><br><span class="line">#define check_imm26(imm) check_imm(26, imm)</span><br><span class="line"></span><br><span class="line">	switch (code) &#123;</span><br><span class="line">	/* dst = src */</span><br><span class="line">	case BPF_ALU | BPF_MOV | BPF_X:</span><br><span class="line">	case BPF_ALU64 | BPF_MOV | BPF_X:</span><br><span class="line">		emit(A64_MOV(is64, dst, src), ctx);</span><br><span class="line">		break;</span><br><span class="line">	/* dst = dst OP src */</span><br><span class="line">	case BPF_ALU | BPF_ADD | BPF_X:</span><br><span class="line">	case BPF_ALU64 | BPF_ADD | BPF_X:</span><br><span class="line">		emit(A64_ADD(is64, dst, dst, src), ctx);</span><br><span class="line">		break;</span><br><span class="line">	case BPF_ALU | BPF_SUB | BPF_X:</span><br><span class="line">	case BPF_ALU64 | BPF_SUB | BPF_X:</span><br><span class="line">		emit(A64_SUB(is64, dst, dst, src), ctx);</span><br><span class="line">		break;</span><br><span class="line">	case BPF_ALU | BPF_AND | BPF_X:</span><br><span class="line">	case BPF_ALU64 | BPF_AND | BPF_X:</span><br><span class="line">		emit(A64_AND(is64, dst, dst, src), ctx);</span><br><span class="line">		break;</span><br><span class="line">	case BPF_ALU | BPF_OR | BPF_X:</span><br><span class="line">	case BPF_ALU64 | BPF_OR | BPF_X:</span><br><span class="line">		emit(A64_ORR(is64, dst, dst, src), ctx);</span><br><span class="line">		break;</span><br><span class="line">	case BPF_ALU | BPF_XOR | BPF_X:</span><br><span class="line">	case BPF_ALU64 | BPF_XOR | BPF_X:</span><br><span class="line">		emit(A64_EOR(is64, dst, dst, src), ctx);</span><br><span class="line">		break;</span><br><span class="line">	case BPF_ALU | BPF_MUL | BPF_X:</span><br><span class="line">	case BPF_ALU64 | BPF_MUL | BPF_X:</span><br><span class="line">		emit(A64_MUL(is64, dst, dst, src), ctx);</span><br><span class="line">		break;</span><br><span class="line">	case BPF_ALU | BPF_DIV | BPF_X:</span><br><span class="line">	case BPF_ALU64 | BPF_DIV | BPF_X:</span><br><span class="line">	case BPF_ALU | BPF_MOD | BPF_X:</span><br><span class="line">	case BPF_ALU64 | BPF_MOD | BPF_X:</span><br><span class="line">	&#123;</span><br><span class="line">		const u8 r0 = bpf2a64[BPF_REG_0];</span><br><span class="line"></span><br><span class="line">		/* if (src == 0) return 0 */</span><br><span class="line">		jmp_offset = 3; /* skip ahead to else path */</span><br><span class="line">		check_imm19(jmp_offset);</span><br><span class="line">		emit(A64_CBNZ(is64, src, jmp_offset), ctx);</span><br><span class="line">		emit(A64_MOVZ(1, r0, 0, 0), ctx);</span><br><span class="line">		jmp_offset = epilogue_offset(ctx);</span><br><span class="line">		check_imm26(jmp_offset);</span><br><span class="line">		emit(A64_B(jmp_offset), ctx);</span><br><span class="line">		/* else */</span><br><span class="line">		switch (BPF_OP(code)) &#123;</span><br><span class="line">		case BPF_DIV:</span><br><span class="line">			emit(A64_UDIV(is64, dst, dst, src), ctx);</span><br><span class="line">			break;</span><br><span class="line">		case BPF_MOD:</span><br><span class="line">			emit(A64_UDIV(is64, tmp, dst, src), ctx);</span><br><span class="line">			emit(A64_MUL(is64, tmp, tmp, src), ctx);</span><br><span class="line">			emit(A64_SUB(is64, dst, dst, tmp), ctx);</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		break;</span><br><span class="line">	&#125;</span><br><span class="line">	case BPF_ALU | BPF_LSH | BPF_X:</span><br><span class="line">	case BPF_ALU64 | BPF_LSH | BPF_X:</span><br><span class="line">		emit(A64_LSLV(is64, dst, dst, src), ctx);</span><br><span class="line">		break;</span><br><span class="line">	case BPF_ALU | BPF_RSH | BPF_X:</span><br><span class="line">	case BPF_ALU64 | BPF_RSH | BPF_X:</span><br><span class="line">		emit(A64_LSRV(is64, dst, dst, src), ctx);</span><br><span class="line">		break;</span><br><span class="line">	case BPF_ALU | BPF_ARSH | BPF_X:</span><br><span class="line">	case BPF_ALU64 | BPF_ARSH | BPF_X:</span><br><span class="line">		emit(A64_ASRV(is64, dst, dst, src), ctx);</span><br><span class="line">		break;</span><br><span class="line">	/* dst = -dst */</span><br><span class="line">	case BPF_ALU | BPF_NEG:</span><br><span class="line">	case BPF_ALU64 | BPF_NEG:</span><br><span class="line">		emit(A64_NEG(is64, dst, dst), ctx);</span><br><span class="line">		break;</span><br><span class="line">	/* dst = BSWAP##imm(dst) */</span><br><span class="line">	case BPF_ALU | BPF_END | BPF_FROM_LE:</span><br><span class="line">	case BPF_ALU | BPF_END | BPF_FROM_BE:</span><br><span class="line">#ifdef CONFIG_CPU_BIG_ENDIAN</span><br><span class="line">		if (BPF_SRC(code) == BPF_FROM_BE)</span><br><span class="line">			goto emit_bswap_uxt;</span><br><span class="line">#else /* !CONFIG_CPU_BIG_ENDIAN */</span><br><span class="line">		if (BPF_SRC(code) == BPF_FROM_LE)</span><br><span class="line">			goto emit_bswap_uxt;</span><br><span class="line">#endif</span><br><span class="line">		switch (imm) &#123;</span><br><span class="line">		case 16:</span><br><span class="line">			emit(A64_REV16(is64, dst, dst), ctx);</span><br><span class="line">			/* zero-extend 16 bits into 64 bits */</span><br><span class="line">			emit(A64_UXTH(is64, dst, dst), ctx);</span><br><span class="line">			break;</span><br><span class="line">		case 32:</span><br><span class="line">			emit(A64_REV32(is64, dst, dst), ctx);</span><br><span class="line">			/* upper 32 bits already cleared */</span><br><span class="line">			break;</span><br><span class="line">		case 64:</span><br><span class="line">			emit(A64_REV64(dst, dst), ctx);</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		break;</span><br><span class="line">emit_bswap_uxt:</span><br><span class="line">		switch (imm) &#123;</span><br><span class="line">		case 16:</span><br><span class="line">			/* zero-extend 16 bits into 64 bits */</span><br><span class="line">			emit(A64_UXTH(is64, dst, dst), ctx);</span><br><span class="line">			break;</span><br><span class="line">		case 32:</span><br><span class="line">			/* zero-extend 32 bits into 64 bits */</span><br><span class="line">			emit(A64_UXTW(is64, dst, dst), ctx);</span><br><span class="line">			break;</span><br><span class="line">		case 64:</span><br><span class="line">			/* nop */</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		break;</span><br><span class="line">	/* dst = imm */</span><br><span class="line">	case BPF_ALU | BPF_MOV | BPF_K:</span><br><span class="line">	case BPF_ALU64 | BPF_MOV | BPF_K:</span><br><span class="line">		emit_a64_mov_i(is64, dst, imm, ctx);</span><br><span class="line">		break;</span><br><span class="line">	/* dst = dst OP imm */</span><br><span class="line">	case BPF_ALU | BPF_ADD | BPF_K:</span><br><span class="line">	case BPF_ALU64 | BPF_ADD | BPF_K:</span><br><span class="line">		emit_a64_mov_i(is64, tmp, imm, ctx);</span><br><span class="line">		emit(A64_ADD(is64, dst, dst, tmp), ctx);</span><br><span class="line">		break;</span><br><span class="line">	case BPF_ALU | BPF_SUB | BPF_K:</span><br><span class="line">	case BPF_ALU64 | BPF_SUB | BPF_K:</span><br><span class="line">		emit_a64_mov_i(is64, tmp, imm, ctx);</span><br><span class="line">		emit(A64_SUB(is64, dst, dst, tmp), ctx);</span><br><span class="line">		break;</span><br><span class="line">	case BPF_ALU | BPF_AND | BPF_K:</span><br><span class="line">	case BPF_ALU64 | BPF_AND | BPF_K:</span><br><span class="line">		emit_a64_mov_i(is64, tmp, imm, ctx);</span><br><span class="line">		emit(A64_AND(is64, dst, dst, tmp), ctx);</span><br><span class="line">		break;</span><br><span class="line">	case BPF_ALU | BPF_OR | BPF_K:</span><br><span class="line">	case BPF_ALU64 | BPF_OR | BPF_K:</span><br><span class="line">		emit_a64_mov_i(is64, tmp, imm, ctx);</span><br><span class="line">		emit(A64_ORR(is64, dst, dst, tmp), ctx);</span><br><span class="line">		break;</span><br><span class="line">	case BPF_ALU | BPF_XOR | BPF_K:</span><br><span class="line">	case BPF_ALU64 | BPF_XOR | BPF_K:</span><br><span class="line">		emit_a64_mov_i(is64, tmp, imm, ctx);</span><br><span class="line">		emit(A64_EOR(is64, dst, dst, tmp), ctx);</span><br><span class="line">		break;</span><br><span class="line">	case BPF_ALU | BPF_MUL | BPF_K:</span><br><span class="line">	case BPF_ALU64 | BPF_MUL | BPF_K:</span><br><span class="line">		emit_a64_mov_i(is64, tmp, imm, ctx);</span><br><span class="line">		emit(A64_MUL(is64, dst, dst, tmp), ctx);</span><br><span class="line">		break;</span><br><span class="line">	case BPF_ALU | BPF_DIV | BPF_K:</span><br><span class="line">	case BPF_ALU64 | BPF_DIV | BPF_K:</span><br><span class="line">		emit_a64_mov_i(is64, tmp, imm, ctx);</span><br><span class="line">		emit(A64_UDIV(is64, dst, dst, tmp), ctx);</span><br><span class="line">		break;</span><br><span class="line">	case BPF_ALU | BPF_MOD | BPF_K:</span><br><span class="line">	case BPF_ALU64 | BPF_MOD | BPF_K:</span><br><span class="line">		emit_a64_mov_i(is64, tmp2, imm, ctx);</span><br><span class="line">		emit(A64_UDIV(is64, tmp, dst, tmp2), ctx);</span><br><span class="line">		emit(A64_MUL(is64, tmp, tmp, tmp2), ctx);</span><br><span class="line">		emit(A64_SUB(is64, dst, dst, tmp), ctx);</span><br><span class="line">		break;</span><br><span class="line">	case BPF_ALU | BPF_LSH | BPF_K:</span><br><span class="line">	case BPF_ALU64 | BPF_LSH | BPF_K:</span><br><span class="line">		emit(A64_LSL(is64, dst, dst, imm), ctx);</span><br><span class="line">		break;</span><br><span class="line">	case BPF_ALU | BPF_RSH | BPF_K:</span><br><span class="line">	case BPF_ALU64 | BPF_RSH | BPF_K:</span><br><span class="line">		emit(A64_LSR(is64, dst, dst, imm), ctx);</span><br><span class="line">		break;</span><br><span class="line">	case BPF_ALU | BPF_ARSH | BPF_K:</span><br><span class="line">	case BPF_ALU64 | BPF_ARSH | BPF_K:</span><br><span class="line">		emit(A64_ASR(is64, dst, dst, imm), ctx);</span><br><span class="line">		break;</span><br><span class="line"></span><br><span class="line">	/* JUMP off */</span><br><span class="line">	case BPF_JMP | BPF_JA:</span><br><span class="line">		jmp_offset = bpf2a64_offset(i + off, i, ctx);</span><br><span class="line">		check_imm26(jmp_offset);</span><br><span class="line">		emit(A64_B(jmp_offset), ctx);</span><br><span class="line">		break;</span><br><span class="line">	/* IF (dst COND src) JUMP off */</span><br><span class="line">	case BPF_JMP | BPF_JEQ | BPF_X:</span><br><span class="line">	case BPF_JMP | BPF_JGT | BPF_X:</span><br><span class="line">	case BPF_JMP | BPF_JGE | BPF_X:</span><br><span class="line">	case BPF_JMP | BPF_JNE | BPF_X:</span><br><span class="line">	case BPF_JMP | BPF_JSGT | BPF_X:</span><br><span class="line">	case BPF_JMP | BPF_JSGE | BPF_X:</span><br><span class="line">		emit(A64_CMP(1, dst, src), ctx);</span><br><span class="line">emit_cond_jmp:</span><br><span class="line">		jmp_offset = bpf2a64_offset(i + off, i, ctx);</span><br><span class="line">		check_imm19(jmp_offset);</span><br><span class="line">		switch (BPF_OP(code)) &#123;</span><br><span class="line">		case BPF_JEQ:</span><br><span class="line">			jmp_cond = A64_COND_EQ;</span><br><span class="line">			break;</span><br><span class="line">		case BPF_JGT:</span><br><span class="line">			jmp_cond = A64_COND_HI;</span><br><span class="line">			break;</span><br><span class="line">		case BPF_JGE:</span><br><span class="line">			jmp_cond = A64_COND_CS;</span><br><span class="line">			break;</span><br><span class="line">		case BPF_JSET:</span><br><span class="line">		case BPF_JNE:</span><br><span class="line">			jmp_cond = A64_COND_NE;</span><br><span class="line">			break;</span><br><span class="line">		case BPF_JSGT:</span><br><span class="line">			jmp_cond = A64_COND_GT;</span><br><span class="line">			break;</span><br><span class="line">		case BPF_JSGE:</span><br><span class="line">			jmp_cond = A64_COND_GE;</span><br><span class="line">			break;</span><br><span class="line">		default:</span><br><span class="line">			return -EFAULT;</span><br><span class="line">		&#125;</span><br><span class="line">		emit(A64_B_(jmp_cond, jmp_offset), ctx);</span><br><span class="line">		break;</span><br><span class="line">	case BPF_JMP | BPF_JSET | BPF_X:</span><br><span class="line">		emit(A64_TST(1, dst, src), ctx);</span><br><span class="line">		goto emit_cond_jmp;</span><br><span class="line">	/* IF (dst COND imm) JUMP off */</span><br><span class="line">	case BPF_JMP | BPF_JEQ | BPF_K:</span><br><span class="line">	case BPF_JMP | BPF_JGT | BPF_K:</span><br><span class="line">	case BPF_JMP | BPF_JGE | BPF_K:</span><br><span class="line">	case BPF_JMP | BPF_JNE | BPF_K:</span><br><span class="line">	case BPF_JMP | BPF_JSGT | BPF_K:</span><br><span class="line">	case BPF_JMP | BPF_JSGE | BPF_K:</span><br><span class="line">		emit_a64_mov_i(1, tmp, imm, ctx);</span><br><span class="line">		emit(A64_CMP(1, dst, tmp), ctx);</span><br><span class="line">		goto emit_cond_jmp;</span><br><span class="line">	case BPF_JMP | BPF_JSET | BPF_K:</span><br><span class="line">		emit_a64_mov_i(1, tmp, imm, ctx);</span><br><span class="line">		emit(A64_TST(1, dst, tmp), ctx);</span><br><span class="line">		goto emit_cond_jmp;</span><br><span class="line">	/* function call */</span><br><span class="line">	case BPF_JMP | BPF_CALL:</span><br><span class="line">	&#123;</span><br><span class="line">		const u8 r0 = bpf2a64[BPF_REG_0];</span><br><span class="line">		const u64 func = (u64)__bpf_call_base + imm;</span><br><span class="line"></span><br><span class="line">		emit_a64_mov_i64(tmp, func, ctx);</span><br><span class="line">		emit(A64_BLR(tmp), ctx);</span><br><span class="line">		emit(A64_MOV(1, r0, A64_R(0)), ctx);</span><br><span class="line">		break;</span><br><span class="line">	&#125;</span><br><span class="line">	/* tail call */</span><br><span class="line">	case BPF_JMP | BPF_CALL | BPF_X:</span><br><span class="line">		if (emit_bpf_tail_call(ctx))</span><br><span class="line">			return -EFAULT;</span><br><span class="line">		break;</span><br><span class="line">	/* function return */</span><br><span class="line">	case BPF_JMP | BPF_EXIT:</span><br><span class="line">		/* Optimization: when last instruction is EXIT,</span><br><span class="line">		   simply fallthrough to epilogue. */</span><br><span class="line">		if (i == ctx-&gt;prog-&gt;len - 1)</span><br><span class="line">			break;</span><br><span class="line">		jmp_offset = epilogue_offset(ctx);</span><br><span class="line">		check_imm26(jmp_offset);</span><br><span class="line">		emit(A64_B(jmp_offset), ctx);</span><br><span class="line">		break;</span><br><span class="line"></span><br><span class="line">	/* dst = imm64 */</span><br><span class="line">	case BPF_LD | BPF_IMM | BPF_DW:</span><br><span class="line">	&#123;</span><br><span class="line">		const struct bpf_insn insn1 = insn[1];</span><br><span class="line">		u64 imm64;</span><br><span class="line"></span><br><span class="line">		if (insn1.code != 0 || insn1.src_reg != 0 ||</span><br><span class="line">		    insn1.dst_reg != 0 || insn1.off != 0) &#123;</span><br><span class="line">			/* Note: verifier in BPF core must catch invalid</span><br><span class="line">			 * instructions.</span><br><span class="line">			 */</span><br><span class="line">			pr_err_once(&quot;Invalid BPF_LD_IMM64 instruction\n&quot;);</span><br><span class="line">			return -EINVAL;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		imm64 = (u64)insn1.imm &lt;&lt; 32 | (u32)imm;</span><br><span class="line">		emit_a64_mov_i64(dst, imm64, ctx);</span><br><span class="line"></span><br><span class="line">		return 1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* LDX: dst = *(size *)(src + off) */</span><br><span class="line">	case BPF_LDX | BPF_MEM | BPF_W:</span><br><span class="line">	case BPF_LDX | BPF_MEM | BPF_H:</span><br><span class="line">	case BPF_LDX | BPF_MEM | BPF_B:</span><br><span class="line">	case BPF_LDX | BPF_MEM | BPF_DW:</span><br><span class="line">		emit_a64_mov_i(1, tmp, off, ctx);</span><br><span class="line">		switch (BPF_SIZE(code)) &#123;</span><br><span class="line">		case BPF_W:</span><br><span class="line">			emit(A64_LDR32(dst, src, tmp), ctx);</span><br><span class="line">			break;</span><br><span class="line">		case BPF_H:</span><br><span class="line">			emit(A64_LDRH(dst, src, tmp), ctx);</span><br><span class="line">			break;</span><br><span class="line">		case BPF_B:</span><br><span class="line">			emit(A64_LDRB(dst, src, tmp), ctx);</span><br><span class="line">			break;</span><br><span class="line">		case BPF_DW:</span><br><span class="line">			emit(A64_LDR64(dst, src, tmp), ctx);</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		break;</span><br><span class="line"></span><br><span class="line">	/* ST: *(size *)(dst + off) = imm */</span><br><span class="line">	case BPF_ST | BPF_MEM | BPF_W:</span><br><span class="line">	case BPF_ST | BPF_MEM | BPF_H:</span><br><span class="line">	case BPF_ST | BPF_MEM | BPF_B:</span><br><span class="line">	case BPF_ST | BPF_MEM | BPF_DW:</span><br><span class="line">		/* Load imm to a register then store it */</span><br><span class="line">		emit_a64_mov_i(1, tmp2, off, ctx);</span><br><span class="line">		emit_a64_mov_i(1, tmp, imm, ctx);</span><br><span class="line">		switch (BPF_SIZE(code)) &#123;</span><br><span class="line">		case BPF_W:</span><br><span class="line">			emit(A64_STR32(tmp, dst, tmp2), ctx);</span><br><span class="line">			break;</span><br><span class="line">		case BPF_H:</span><br><span class="line">			emit(A64_STRH(tmp, dst, tmp2), ctx);</span><br><span class="line">			break;</span><br><span class="line">		case BPF_B:</span><br><span class="line">			emit(A64_STRB(tmp, dst, tmp2), ctx);</span><br><span class="line">			break;</span><br><span class="line">		case BPF_DW:</span><br><span class="line">			emit(A64_STR64(tmp, dst, tmp2), ctx);</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		break;</span><br><span class="line"></span><br><span class="line">	/* STX: *(size *)(dst + off) = src */</span><br><span class="line">	case BPF_STX | BPF_MEM | BPF_W:</span><br><span class="line">	case BPF_STX | BPF_MEM | BPF_H:</span><br><span class="line">	case BPF_STX | BPF_MEM | BPF_B:</span><br><span class="line">	case BPF_STX | BPF_MEM | BPF_DW:</span><br><span class="line">		emit_a64_mov_i(1, tmp, off, ctx);</span><br><span class="line">		switch (BPF_SIZE(code)) &#123;</span><br><span class="line">		case BPF_W:</span><br><span class="line">			emit(A64_STR32(src, dst, tmp), ctx);</span><br><span class="line">			break;</span><br><span class="line">		case BPF_H:</span><br><span class="line">			emit(A64_STRH(src, dst, tmp), ctx);</span><br><span class="line">			break;</span><br><span class="line">		case BPF_B:</span><br><span class="line">			emit(A64_STRB(src, dst, tmp), ctx);</span><br><span class="line">			break;</span><br><span class="line">		case BPF_DW:</span><br><span class="line">			emit(A64_STR64(src, dst, tmp), ctx);</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		break;</span><br><span class="line">	/* STX XADD: lock *(u32 *)(dst + off) += src */</span><br><span class="line">	case BPF_STX | BPF_XADD | BPF_W:</span><br><span class="line">	/* STX XADD: lock *(u64 *)(dst + off) += src */</span><br><span class="line">	case BPF_STX | BPF_XADD | BPF_DW:</span><br><span class="line">		goto notyet;</span><br><span class="line"></span><br><span class="line">	/* R0 = ntohx(*(size *)(((struct sk_buff *)R6)-&gt;data + imm)) */</span><br><span class="line">	case BPF_LD | BPF_ABS | BPF_W:</span><br><span class="line">	case BPF_LD | BPF_ABS | BPF_H:</span><br><span class="line">	case BPF_LD | BPF_ABS | BPF_B:</span><br><span class="line">	/* R0 = ntohx(*(size *)(((struct sk_buff *)R6)-&gt;data + src + imm)) */</span><br><span class="line">	case BPF_LD | BPF_IND | BPF_W:</span><br><span class="line">	case BPF_LD | BPF_IND | BPF_H:</span><br><span class="line">	case BPF_LD | BPF_IND | BPF_B:</span><br><span class="line">	&#123;</span><br><span class="line">		const u8 r0 = bpf2a64[BPF_REG_0]; /* r0 = return value */</span><br><span class="line">		const u8 r6 = bpf2a64[BPF_REG_6]; /* r6 = pointer to sk_buff */</span><br><span class="line">		const u8 fp = bpf2a64[BPF_REG_FP];</span><br><span class="line">		const u8 r1 = bpf2a64[BPF_REG_1]; /* r1: struct sk_buff *skb */</span><br><span class="line">		const u8 r2 = bpf2a64[BPF_REG_2]; /* r2: int k */</span><br><span class="line">		const u8 r3 = bpf2a64[BPF_REG_3]; /* r3: unsigned int size */</span><br><span class="line">		const u8 r4 = bpf2a64[BPF_REG_4]; /* r4: void *buffer */</span><br><span class="line">		const u8 r5 = bpf2a64[BPF_REG_5]; /* r5: void *(*func)(...) */</span><br><span class="line">		int size;</span><br><span class="line"></span><br><span class="line">		emit(A64_MOV(1, r1, r6), ctx);</span><br><span class="line">		emit_a64_mov_i(0, r2, imm, ctx);</span><br><span class="line">		if (BPF_MODE(code) == BPF_IND)</span><br><span class="line">			emit(A64_ADD(0, r2, r2, src), ctx);</span><br><span class="line">		switch (BPF_SIZE(code)) &#123;</span><br><span class="line">		case BPF_W:</span><br><span class="line">			size = 4;</span><br><span class="line">			break;</span><br><span class="line">		case BPF_H:</span><br><span class="line">			size = 2;</span><br><span class="line">			break;</span><br><span class="line">		case BPF_B:</span><br><span class="line">			size = 1;</span><br><span class="line">			break;</span><br><span class="line">		default:</span><br><span class="line">			return -EINVAL;</span><br><span class="line">		&#125;</span><br><span class="line">		emit_a64_mov_i64(r3, size, ctx);</span><br><span class="line">		emit(A64_SUB_I(1, r4, fp, STACK_SIZE), ctx);</span><br><span class="line">		emit_a64_mov_i64(r5, (unsigned long)bpf_load_pointer, ctx);</span><br><span class="line">		emit(A64_BLR(r5), ctx);</span><br><span class="line">		emit(A64_MOV(1, r0, A64_R(0)), ctx);</span><br><span class="line"></span><br><span class="line">		jmp_offset = epilogue_offset(ctx);</span><br><span class="line">		check_imm19(jmp_offset);</span><br><span class="line">		emit(A64_CBZ(1, r0, jmp_offset), ctx);</span><br><span class="line">		emit(A64_MOV(1, r5, r0), ctx);</span><br><span class="line">		switch (BPF_SIZE(code)) &#123;</span><br><span class="line">		case BPF_W:</span><br><span class="line">			emit(A64_LDR32(r0, r5, A64_ZR), ctx);</span><br><span class="line">#ifndef CONFIG_CPU_BIG_ENDIAN</span><br><span class="line">			emit(A64_REV32(0, r0, r0), ctx);</span><br><span class="line">#endif</span><br><span class="line">			break;</span><br><span class="line">		case BPF_H:</span><br><span class="line">			emit(A64_LDRH(r0, r5, A64_ZR), ctx);</span><br><span class="line">#ifndef CONFIG_CPU_BIG_ENDIAN</span><br><span class="line">			emit(A64_REV16(0, r0, r0), ctx);</span><br><span class="line">#endif</span><br><span class="line">			break;</span><br><span class="line">		case BPF_B:</span><br><span class="line">			emit(A64_LDRB(r0, r5, A64_ZR), ctx);</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		break;</span><br><span class="line">	&#125;</span><br><span class="line">notyet:</span><br><span class="line">		pr_info_once(&quot;*** NOT YET: opcode %02x ***\n&quot;, code);</span><br><span class="line">		return -EFAULT;</span><br><span class="line"></span><br><span class="line">	default:</span><br><span class="line">		pr_err_once(&quot;unknown opcode %02x\n&quot;, code);</span><br><span class="line">		return -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static inline void emit(const u32 insn, struct jit_ctx *ctx)</span><br><span class="line">&#123;</span><br><span class="line">	if (ctx-&gt;image != NULL)</span><br><span class="line">		ctx-&gt;image[ctx-&gt;idx] = cpu_to_le32(insn);</span><br><span class="line"></span><br><span class="line">	ctx-&gt;idx++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>1.3、epilogue</li>
</ul>
<p>做和prologue相反的工作，恢复和清理堆栈：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">static void build_epilogue(struct jit_ctx *ctx)</span><br><span class="line">&#123;</span><br><span class="line">	const u8 r0 = bpf2a64[BPF_REG_0];</span><br><span class="line">	const u8 r6 = bpf2a64[BPF_REG_6];</span><br><span class="line">	const u8 r7 = bpf2a64[BPF_REG_7];</span><br><span class="line">	const u8 r8 = bpf2a64[BPF_REG_8];</span><br><span class="line">	const u8 r9 = bpf2a64[BPF_REG_9];</span><br><span class="line">	const u8 fp = bpf2a64[BPF_REG_FP];</span><br><span class="line"></span><br><span class="line">	/* We&apos;re done with BPF stack */</span><br><span class="line">	emit(A64_ADD_I(1, A64_SP, A64_SP, STACK_SIZE), ctx);</span><br><span class="line"></span><br><span class="line">	/* Restore fs (x25) and x26 */</span><br><span class="line">	emit(A64_POP(fp, A64_R(26), A64_SP), ctx);</span><br><span class="line"></span><br><span class="line">	/* Restore callee-saved register */</span><br><span class="line">	emit(A64_POP(r8, r9, A64_SP), ctx);</span><br><span class="line">	emit(A64_POP(r6, r7, A64_SP), ctx);</span><br><span class="line"></span><br><span class="line">	/* Restore FP/LR registers */</span><br><span class="line">	emit(A64_POP(A64_FP, A64_LR, A64_SP), ctx);</span><br><span class="line"></span><br><span class="line">	/* Set return value */</span><br><span class="line">	emit(A64_MOV(1, A64_R(0), r0), ctx);</span><br><span class="line"></span><br><span class="line">	emit(A64_RET(A64_LR), ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>2、interpreter</li>
</ul>
<p>对于不支持JIT的情况，内核只能使用一个解析器来解释prog-&gt;insnsi[]中BPF的指令含义，模拟BPF指令的运行:<br>使用“u64 stack[MAX_BPF_STACK / sizeof(u64)]”局部变量来模拟BPF堆栈空间；<br>使用“u64 regs[MAX_BPF_REG]”局部变量来模拟BPF寄存器；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *	__bpf_prog_run - run eBPF program on a given context</span><br><span class="line"> *	@ctx: is the data we are operating on</span><br><span class="line"> *	@insn: is the array of eBPF instructions</span><br><span class="line"> *</span><br><span class="line"> * Decode and execute eBPF instructions.</span><br><span class="line"> */</span><br><span class="line">static unsigned int __bpf_prog_run(void *ctx, const struct bpf_insn *insn)</span><br><span class="line">&#123;</span><br><span class="line">	u64 stack[MAX_BPF_STACK / sizeof(u64)];</span><br><span class="line">	u64 regs[MAX_BPF_REG], tmp;</span><br><span class="line">	static const void *jumptable[256] = &#123;</span><br><span class="line">		[0 ... 255] = &amp;&amp;default_label,</span><br><span class="line">		/* Now overwrite non-defaults ... */</span><br><span class="line">		/* 32 bit ALU operations */</span><br><span class="line">		[BPF_ALU | BPF_ADD | BPF_X] = &amp;&amp;ALU_ADD_X,</span><br><span class="line">		[BPF_ALU | BPF_ADD | BPF_K] = &amp;&amp;ALU_ADD_K,</span><br><span class="line">		[BPF_ALU | BPF_SUB | BPF_X] = &amp;&amp;ALU_SUB_X,</span><br><span class="line">		[BPF_ALU | BPF_SUB | BPF_K] = &amp;&amp;ALU_SUB_K,</span><br><span class="line">		[BPF_ALU | BPF_AND | BPF_X] = &amp;&amp;ALU_AND_X,</span><br><span class="line">		[BPF_ALU | BPF_AND | BPF_K] = &amp;&amp;ALU_AND_K,</span><br><span class="line">		[BPF_ALU | BPF_OR | BPF_X]  = &amp;&amp;ALU_OR_X,</span><br><span class="line">		[BPF_ALU | BPF_OR | BPF_K]  = &amp;&amp;ALU_OR_K,</span><br><span class="line">		[BPF_ALU | BPF_LSH | BPF_X] = &amp;&amp;ALU_LSH_X,</span><br><span class="line">		[BPF_ALU | BPF_LSH | BPF_K] = &amp;&amp;ALU_LSH_K,</span><br><span class="line">		[BPF_ALU | BPF_RSH | BPF_X] = &amp;&amp;ALU_RSH_X,</span><br><span class="line">		[BPF_ALU | BPF_RSH | BPF_K] = &amp;&amp;ALU_RSH_K,</span><br><span class="line">		[BPF_ALU | BPF_XOR | BPF_X] = &amp;&amp;ALU_XOR_X,</span><br><span class="line">		[BPF_ALU | BPF_XOR | BPF_K] = &amp;&amp;ALU_XOR_K,</span><br><span class="line">		[BPF_ALU | BPF_MUL | BPF_X] = &amp;&amp;ALU_MUL_X,</span><br><span class="line">		[BPF_ALU | BPF_MUL | BPF_K] = &amp;&amp;ALU_MUL_K,</span><br><span class="line">		[BPF_ALU | BPF_MOV | BPF_X] = &amp;&amp;ALU_MOV_X,</span><br><span class="line">		[BPF_ALU | BPF_MOV | BPF_K] = &amp;&amp;ALU_MOV_K,</span><br><span class="line">		[BPF_ALU | BPF_DIV | BPF_X] = &amp;&amp;ALU_DIV_X,</span><br><span class="line">		[BPF_ALU | BPF_DIV | BPF_K] = &amp;&amp;ALU_DIV_K,</span><br><span class="line">		[BPF_ALU | BPF_MOD | BPF_X] = &amp;&amp;ALU_MOD_X,</span><br><span class="line">		[BPF_ALU | BPF_MOD | BPF_K] = &amp;&amp;ALU_MOD_K,</span><br><span class="line">		[BPF_ALU | BPF_NEG] = &amp;&amp;ALU_NEG,</span><br><span class="line">		[BPF_ALU | BPF_END | BPF_TO_BE] = &amp;&amp;ALU_END_TO_BE,</span><br><span class="line">		[BPF_ALU | BPF_END | BPF_TO_LE] = &amp;&amp;ALU_END_TO_LE,</span><br><span class="line">		/* 64 bit ALU operations */</span><br><span class="line">		[BPF_ALU64 | BPF_ADD | BPF_X] = &amp;&amp;ALU64_ADD_X,</span><br><span class="line">		[BPF_ALU64 | BPF_ADD | BPF_K] = &amp;&amp;ALU64_ADD_K,</span><br><span class="line">		[BPF_ALU64 | BPF_SUB | BPF_X] = &amp;&amp;ALU64_SUB_X,</span><br><span class="line">		[BPF_ALU64 | BPF_SUB | BPF_K] = &amp;&amp;ALU64_SUB_K,</span><br><span class="line">		[BPF_ALU64 | BPF_AND | BPF_X] = &amp;&amp;ALU64_AND_X,</span><br><span class="line">		[BPF_ALU64 | BPF_AND | BPF_K] = &amp;&amp;ALU64_AND_K,</span><br><span class="line">		[BPF_ALU64 | BPF_OR | BPF_X] = &amp;&amp;ALU64_OR_X,</span><br><span class="line">		[BPF_ALU64 | BPF_OR | BPF_K] = &amp;&amp;ALU64_OR_K,</span><br><span class="line">		[BPF_ALU64 | BPF_LSH | BPF_X] = &amp;&amp;ALU64_LSH_X,</span><br><span class="line">		[BPF_ALU64 | BPF_LSH | BPF_K] = &amp;&amp;ALU64_LSH_K,</span><br><span class="line">		[BPF_ALU64 | BPF_RSH | BPF_X] = &amp;&amp;ALU64_RSH_X,</span><br><span class="line">		[BPF_ALU64 | BPF_RSH | BPF_K] = &amp;&amp;ALU64_RSH_K,</span><br><span class="line">		[BPF_ALU64 | BPF_XOR | BPF_X] = &amp;&amp;ALU64_XOR_X,</span><br><span class="line">		[BPF_ALU64 | BPF_XOR | BPF_K] = &amp;&amp;ALU64_XOR_K,</span><br><span class="line">		[BPF_ALU64 | BPF_MUL | BPF_X] = &amp;&amp;ALU64_MUL_X,</span><br><span class="line">		[BPF_ALU64 | BPF_MUL | BPF_K] = &amp;&amp;ALU64_MUL_K,</span><br><span class="line">		[BPF_ALU64 | BPF_MOV | BPF_X] = &amp;&amp;ALU64_MOV_X,</span><br><span class="line">		[BPF_ALU64 | BPF_MOV | BPF_K] = &amp;&amp;ALU64_MOV_K,</span><br><span class="line">		[BPF_ALU64 | BPF_ARSH | BPF_X] = &amp;&amp;ALU64_ARSH_X,</span><br><span class="line">		[BPF_ALU64 | BPF_ARSH | BPF_K] = &amp;&amp;ALU64_ARSH_K,</span><br><span class="line">		[BPF_ALU64 | BPF_DIV | BPF_X] = &amp;&amp;ALU64_DIV_X,</span><br><span class="line">		[BPF_ALU64 | BPF_DIV | BPF_K] = &amp;&amp;ALU64_DIV_K,</span><br><span class="line">		[BPF_ALU64 | BPF_MOD | BPF_X] = &amp;&amp;ALU64_MOD_X,</span><br><span class="line">		[BPF_ALU64 | BPF_MOD | BPF_K] = &amp;&amp;ALU64_MOD_K,</span><br><span class="line">		[BPF_ALU64 | BPF_NEG] = &amp;&amp;ALU64_NEG,</span><br><span class="line">		/* Call instruction */</span><br><span class="line">		[BPF_JMP | BPF_CALL] = &amp;&amp;JMP_CALL,</span><br><span class="line">		[BPF_JMP | BPF_CALL | BPF_X] = &amp;&amp;JMP_TAIL_CALL,</span><br><span class="line">		/* Jumps */</span><br><span class="line">		[BPF_JMP | BPF_JA] = &amp;&amp;JMP_JA,</span><br><span class="line">		[BPF_JMP | BPF_JEQ | BPF_X] = &amp;&amp;JMP_JEQ_X,</span><br><span class="line">		[BPF_JMP | BPF_JEQ | BPF_K] = &amp;&amp;JMP_JEQ_K,</span><br><span class="line">		[BPF_JMP | BPF_JNE | BPF_X] = &amp;&amp;JMP_JNE_X,</span><br><span class="line">		[BPF_JMP | BPF_JNE | BPF_K] = &amp;&amp;JMP_JNE_K,</span><br><span class="line">		[BPF_JMP | BPF_JGT | BPF_X] = &amp;&amp;JMP_JGT_X,</span><br><span class="line">		[BPF_JMP | BPF_JGT | BPF_K] = &amp;&amp;JMP_JGT_K,</span><br><span class="line">		[BPF_JMP | BPF_JGE | BPF_X] = &amp;&amp;JMP_JGE_X,</span><br><span class="line">		[BPF_JMP | BPF_JGE | BPF_K] = &amp;&amp;JMP_JGE_K,</span><br><span class="line">		[BPF_JMP | BPF_JSGT | BPF_X] = &amp;&amp;JMP_JSGT_X,</span><br><span class="line">		[BPF_JMP | BPF_JSGT | BPF_K] = &amp;&amp;JMP_JSGT_K,</span><br><span class="line">		[BPF_JMP | BPF_JSGE | BPF_X] = &amp;&amp;JMP_JSGE_X,</span><br><span class="line">		[BPF_JMP | BPF_JSGE | BPF_K] = &amp;&amp;JMP_JSGE_K,</span><br><span class="line">		[BPF_JMP | BPF_JSET | BPF_X] = &amp;&amp;JMP_JSET_X,</span><br><span class="line">		[BPF_JMP | BPF_JSET | BPF_K] = &amp;&amp;JMP_JSET_K,</span><br><span class="line">		/* Program return */</span><br><span class="line">		[BPF_JMP | BPF_EXIT] = &amp;&amp;JMP_EXIT,</span><br><span class="line">		/* Store instructions */</span><br><span class="line">		[BPF_STX | BPF_MEM | BPF_B] = &amp;&amp;STX_MEM_B,</span><br><span class="line">		[BPF_STX | BPF_MEM | BPF_H] = &amp;&amp;STX_MEM_H,</span><br><span class="line">		[BPF_STX | BPF_MEM | BPF_W] = &amp;&amp;STX_MEM_W,</span><br><span class="line">		[BPF_STX | BPF_MEM | BPF_DW] = &amp;&amp;STX_MEM_DW,</span><br><span class="line">		[BPF_STX | BPF_XADD | BPF_W] = &amp;&amp;STX_XADD_W,</span><br><span class="line">		[BPF_STX | BPF_XADD | BPF_DW] = &amp;&amp;STX_XADD_DW,</span><br><span class="line">		[BPF_ST | BPF_MEM | BPF_B] = &amp;&amp;ST_MEM_B,</span><br><span class="line">		[BPF_ST | BPF_MEM | BPF_H] = &amp;&amp;ST_MEM_H,</span><br><span class="line">		[BPF_ST | BPF_MEM | BPF_W] = &amp;&amp;ST_MEM_W,</span><br><span class="line">		[BPF_ST | BPF_MEM | BPF_DW] = &amp;&amp;ST_MEM_DW,</span><br><span class="line">		/* Load instructions */</span><br><span class="line">		[BPF_LDX | BPF_MEM | BPF_B] = &amp;&amp;LDX_MEM_B,</span><br><span class="line">		[BPF_LDX | BPF_MEM | BPF_H] = &amp;&amp;LDX_MEM_H,</span><br><span class="line">		[BPF_LDX | BPF_MEM | BPF_W] = &amp;&amp;LDX_MEM_W,</span><br><span class="line">		[BPF_LDX | BPF_MEM | BPF_DW] = &amp;&amp;LDX_MEM_DW,</span><br><span class="line">		[BPF_LD | BPF_ABS | BPF_W] = &amp;&amp;LD_ABS_W,</span><br><span class="line">		[BPF_LD | BPF_ABS | BPF_H] = &amp;&amp;LD_ABS_H,</span><br><span class="line">		[BPF_LD | BPF_ABS | BPF_B] = &amp;&amp;LD_ABS_B,</span><br><span class="line">		[BPF_LD | BPF_IND | BPF_W] = &amp;&amp;LD_IND_W,</span><br><span class="line">		[BPF_LD | BPF_IND | BPF_H] = &amp;&amp;LD_IND_H,</span><br><span class="line">		[BPF_LD | BPF_IND | BPF_B] = &amp;&amp;LD_IND_B,</span><br><span class="line">		[BPF_LD | BPF_IMM | BPF_DW] = &amp;&amp;LD_IMM_DW,</span><br><span class="line">	&#125;;</span><br><span class="line">	u32 tail_call_cnt = 0;</span><br><span class="line">	void *ptr;</span><br><span class="line">	int off;</span><br><span class="line"></span><br><span class="line">#define CONT	 (&#123; insn++; goto select_insn; &#125;)</span><br><span class="line">#define CONT_JMP (&#123; insn++; goto select_insn; &#125;)</span><br><span class="line"></span><br><span class="line">	FP = (u64) (unsigned long) &amp;stack[ARRAY_SIZE(stack)];</span><br><span class="line">	ARG1 = (u64) (unsigned long) ctx;</span><br><span class="line"></span><br><span class="line">select_insn:</span><br><span class="line">	goto *jumptable[insn-&gt;code];</span><br><span class="line"></span><br><span class="line">	/* ALU */</span><br><span class="line">#define ALU(OPCODE, OP)			\</span><br><span class="line">	ALU64_##OPCODE##_X:		\</span><br><span class="line">		DST = DST OP SRC;	\</span><br><span class="line">		CONT;			\</span><br><span class="line">	ALU_##OPCODE##_X:		\</span><br><span class="line">		DST = (u32) DST OP (u32) SRC;	\</span><br><span class="line">		CONT;			\</span><br><span class="line">	ALU64_##OPCODE##_K:		\</span><br><span class="line">		DST = DST OP IMM;		\</span><br><span class="line">		CONT;			\</span><br><span class="line">	ALU_##OPCODE##_K:		\</span><br><span class="line">		DST = (u32) DST OP (u32) IMM;	\</span><br><span class="line">		CONT;</span><br><span class="line"></span><br><span class="line">	ALU(ADD,  +)</span><br><span class="line">	ALU(SUB,  -)</span><br><span class="line">	ALU(AND,  &amp;)</span><br><span class="line">	ALU(OR,   |)</span><br><span class="line">	ALU(LSH, &lt;&lt;)</span><br><span class="line">	ALU(RSH, &gt;&gt;)</span><br><span class="line">	ALU(XOR,  ^)</span><br><span class="line">	ALU(MUL,  *)</span><br><span class="line">#undef ALU</span><br><span class="line">	ALU_NEG:</span><br><span class="line">		DST = (u32) -DST;</span><br><span class="line">		CONT;</span><br><span class="line">	ALU64_NEG:</span><br><span class="line">		DST = -DST;</span><br><span class="line">		CONT;</span><br><span class="line">	ALU_MOV_X:</span><br><span class="line">		DST = (u32) SRC;</span><br><span class="line">		CONT;</span><br><span class="line">	ALU_MOV_K:</span><br><span class="line">		DST = (u32) IMM;</span><br><span class="line">		CONT;</span><br><span class="line">	ALU64_MOV_X:</span><br><span class="line">		DST = SRC;</span><br><span class="line">		CONT;</span><br><span class="line">	ALU64_MOV_K:</span><br><span class="line">		DST = IMM;</span><br><span class="line">		CONT;</span><br><span class="line">	LD_IMM_DW:</span><br><span class="line">		DST = (u64) (u32) insn[0].imm | ((u64) (u32) insn[1].imm) &lt;&lt; 32;</span><br><span class="line">		insn++;</span><br><span class="line">		CONT;</span><br><span class="line">	ALU64_ARSH_X:</span><br><span class="line">		(*(s64 *) &amp;DST) &gt;&gt;= SRC;</span><br><span class="line">		CONT;</span><br><span class="line">	ALU64_ARSH_K:</span><br><span class="line">		(*(s64 *) &amp;DST) &gt;&gt;= IMM;</span><br><span class="line">		CONT;</span><br><span class="line">	ALU64_MOD_X:</span><br><span class="line">		if (unlikely(SRC == 0))</span><br><span class="line">			return 0;</span><br><span class="line">		div64_u64_rem(DST, SRC, &amp;tmp);</span><br><span class="line">		DST = tmp;</span><br><span class="line">		CONT;</span><br><span class="line">	ALU_MOD_X:</span><br><span class="line">		if (unlikely((u32)SRC == 0))</span><br><span class="line">			return 0;</span><br><span class="line">		tmp = (u32) DST;</span><br><span class="line">		DST = do_div(tmp, (u32) SRC);</span><br><span class="line">		CONT;</span><br><span class="line">	ALU64_MOD_K:</span><br><span class="line">		div64_u64_rem(DST, IMM, &amp;tmp);</span><br><span class="line">		DST = tmp;</span><br><span class="line">		CONT;</span><br><span class="line">	ALU_MOD_K:</span><br><span class="line">		tmp = (u32) DST;</span><br><span class="line">		DST = do_div(tmp, (u32) IMM);</span><br><span class="line">		CONT;</span><br><span class="line">	ALU64_DIV_X:</span><br><span class="line">		if (unlikely(SRC == 0))</span><br><span class="line">			return 0;</span><br><span class="line">		DST = div64_u64(DST, SRC);</span><br><span class="line">		CONT;</span><br><span class="line">	ALU_DIV_X:</span><br><span class="line">		if (unlikely((u32)SRC == 0))</span><br><span class="line">			return 0;</span><br><span class="line">		tmp = (u32) DST;</span><br><span class="line">		do_div(tmp, (u32) SRC);</span><br><span class="line">		DST = (u32) tmp;</span><br><span class="line">		CONT;</span><br><span class="line">	ALU64_DIV_K:</span><br><span class="line">		DST = div64_u64(DST, IMM);</span><br><span class="line">		CONT;</span><br><span class="line">	ALU_DIV_K:</span><br><span class="line">		tmp = (u32) DST;</span><br><span class="line">		do_div(tmp, (u32) IMM);</span><br><span class="line">		DST = (u32) tmp;</span><br><span class="line">		CONT;</span><br><span class="line">	ALU_END_TO_BE:</span><br><span class="line">		switch (IMM) &#123;</span><br><span class="line">		case 16:</span><br><span class="line">			DST = (__force u16) cpu_to_be16(DST);</span><br><span class="line">			break;</span><br><span class="line">		case 32:</span><br><span class="line">			DST = (__force u32) cpu_to_be32(DST);</span><br><span class="line">			break;</span><br><span class="line">		case 64:</span><br><span class="line">			DST = (__force u64) cpu_to_be64(DST);</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		CONT;</span><br><span class="line">	ALU_END_TO_LE:</span><br><span class="line">		switch (IMM) &#123;</span><br><span class="line">		case 16:</span><br><span class="line">			DST = (__force u16) cpu_to_le16(DST);</span><br><span class="line">			break;</span><br><span class="line">		case 32:</span><br><span class="line">			DST = (__force u32) cpu_to_le32(DST);</span><br><span class="line">			break;</span><br><span class="line">		case 64:</span><br><span class="line">			DST = (__force u64) cpu_to_le64(DST);</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		CONT;</span><br><span class="line"></span><br><span class="line">	/* CALL */</span><br><span class="line">	JMP_CALL:</span><br><span class="line">		/* Function call scratches BPF_R1-BPF_R5 registers,</span><br><span class="line">		 * preserves BPF_R6-BPF_R9, and stores return value</span><br><span class="line">		 * into BPF_R0.</span><br><span class="line">		 */</span><br><span class="line">		BPF_R0 = (__bpf_call_base + insn-&gt;imm)(BPF_R1, BPF_R2, BPF_R3,</span><br><span class="line">						       BPF_R4, BPF_R5);</span><br><span class="line">		CONT;</span><br><span class="line"></span><br><span class="line">	JMP_TAIL_CALL: &#123;</span><br><span class="line">		struct bpf_map *map = (struct bpf_map *) (unsigned long) BPF_R2;</span><br><span class="line">		struct bpf_array *array = container_of(map, struct bpf_array, map);</span><br><span class="line">		struct bpf_prog *prog;</span><br><span class="line">		u32 index = BPF_R3;</span><br><span class="line"></span><br><span class="line">		if (unlikely(index &gt;= array-&gt;map.max_entries))</span><br><span class="line">			goto out;</span><br><span class="line">		if (unlikely(tail_call_cnt &gt; MAX_TAIL_CALL_CNT))</span><br><span class="line">			goto out;</span><br><span class="line"></span><br><span class="line">		tail_call_cnt++;</span><br><span class="line"></span><br><span class="line">		prog = READ_ONCE(array-&gt;ptrs[index]);</span><br><span class="line">		if (!prog)</span><br><span class="line">			goto out;</span><br><span class="line"></span><br><span class="line">		/* ARG1 at this point is guaranteed to point to CTX from</span><br><span class="line">		 * the verifier side due to the fact that the tail call is</span><br><span class="line">		 * handeled like a helper, that is, bpf_tail_call_proto,</span><br><span class="line">		 * where arg1_type is ARG_PTR_TO_CTX.</span><br><span class="line">		 */</span><br><span class="line">		insn = prog-&gt;insnsi;</span><br><span class="line">		goto select_insn;</span><br><span class="line">out:</span><br><span class="line">		CONT;</span><br><span class="line">	&#125;</span><br><span class="line">	/* JMP */</span><br><span class="line">	JMP_JA:</span><br><span class="line">		insn += insn-&gt;off;</span><br><span class="line">		CONT;</span><br><span class="line">	JMP_JEQ_X:</span><br><span class="line">		if (DST == SRC) &#123;</span><br><span class="line">			insn += insn-&gt;off;</span><br><span class="line">			CONT_JMP;</span><br><span class="line">		&#125;</span><br><span class="line">		CONT;</span><br><span class="line">	JMP_JEQ_K:</span><br><span class="line">		if (DST == IMM) &#123;</span><br><span class="line">			insn += insn-&gt;off;</span><br><span class="line">			CONT_JMP;</span><br><span class="line">		&#125;</span><br><span class="line">		CONT;</span><br><span class="line">	JMP_JNE_X:</span><br><span class="line">		if (DST != SRC) &#123;</span><br><span class="line">			insn += insn-&gt;off;</span><br><span class="line">			CONT_JMP;</span><br><span class="line">		&#125;</span><br><span class="line">		CONT;</span><br><span class="line">	JMP_JNE_K:</span><br><span class="line">		if (DST != IMM) &#123;</span><br><span class="line">			insn += insn-&gt;off;</span><br><span class="line">			CONT_JMP;</span><br><span class="line">		&#125;</span><br><span class="line">		CONT;</span><br><span class="line">	JMP_JGT_X:</span><br><span class="line">		if (DST &gt; SRC) &#123;</span><br><span class="line">			insn += insn-&gt;off;</span><br><span class="line">			CONT_JMP;</span><br><span class="line">		&#125;</span><br><span class="line">		CONT;</span><br><span class="line">	JMP_JGT_K:</span><br><span class="line">		if (DST &gt; IMM) &#123;</span><br><span class="line">			insn += insn-&gt;off;</span><br><span class="line">			CONT_JMP;</span><br><span class="line">		&#125;</span><br><span class="line">		CONT;</span><br><span class="line">	JMP_JGE_X:</span><br><span class="line">		if (DST &gt;= SRC) &#123;</span><br><span class="line">			insn += insn-&gt;off;</span><br><span class="line">			CONT_JMP;</span><br><span class="line">		&#125;</span><br><span class="line">		CONT;</span><br><span class="line">	JMP_JGE_K:</span><br><span class="line">		if (DST &gt;= IMM) &#123;</span><br><span class="line">			insn += insn-&gt;off;</span><br><span class="line">			CONT_JMP;</span><br><span class="line">		&#125;</span><br><span class="line">		CONT;</span><br><span class="line">	JMP_JSGT_X:</span><br><span class="line">		if (((s64) DST) &gt; ((s64) SRC)) &#123;</span><br><span class="line">			insn += insn-&gt;off;</span><br><span class="line">			CONT_JMP;</span><br><span class="line">		&#125;</span><br><span class="line">		CONT;</span><br><span class="line">	JMP_JSGT_K:</span><br><span class="line">		if (((s64) DST) &gt; ((s64) IMM)) &#123;</span><br><span class="line">			insn += insn-&gt;off;</span><br><span class="line">			CONT_JMP;</span><br><span class="line">		&#125;</span><br><span class="line">		CONT;</span><br><span class="line">	JMP_JSGE_X:</span><br><span class="line">		if (((s64) DST) &gt;= ((s64) SRC)) &#123;</span><br><span class="line">			insn += insn-&gt;off;</span><br><span class="line">			CONT_JMP;</span><br><span class="line">		&#125;</span><br><span class="line">		CONT;</span><br><span class="line">	JMP_JSGE_K:</span><br><span class="line">		if (((s64) DST) &gt;= ((s64) IMM)) &#123;</span><br><span class="line">			insn += insn-&gt;off;</span><br><span class="line">			CONT_JMP;</span><br><span class="line">		&#125;</span><br><span class="line">		CONT;</span><br><span class="line">	JMP_JSET_X:</span><br><span class="line">		if (DST &amp; SRC) &#123;</span><br><span class="line">			insn += insn-&gt;off;</span><br><span class="line">			CONT_JMP;</span><br><span class="line">		&#125;</span><br><span class="line">		CONT;</span><br><span class="line">	JMP_JSET_K:</span><br><span class="line">		if (DST &amp; IMM) &#123;</span><br><span class="line">			insn += insn-&gt;off;</span><br><span class="line">			CONT_JMP;</span><br><span class="line">		&#125;</span><br><span class="line">		CONT;</span><br><span class="line">	JMP_EXIT:</span><br><span class="line">		return BPF_R0;</span><br><span class="line"></span><br><span class="line">	/* STX and ST and LDX*/</span><br><span class="line">#define LDST(SIZEOP, SIZE)						\</span><br><span class="line">	STX_MEM_##SIZEOP:						\</span><br><span class="line">		*(SIZE *)(unsigned long) (DST + insn-&gt;off) = SRC;	\</span><br><span class="line">		CONT;							\</span><br><span class="line">	ST_MEM_##SIZEOP:						\</span><br><span class="line">		*(SIZE *)(unsigned long) (DST + insn-&gt;off) = IMM;	\</span><br><span class="line">		CONT;							\</span><br><span class="line">	LDX_MEM_##SIZEOP:						\</span><br><span class="line">		DST = *(SIZE *)(unsigned long) (SRC + insn-&gt;off);	\</span><br><span class="line">		CONT;</span><br><span class="line"></span><br><span class="line">	LDST(B,   u8)</span><br><span class="line">	LDST(H,  u16)</span><br><span class="line">	LDST(W,  u32)</span><br><span class="line">	LDST(DW, u64)</span><br><span class="line">#undef LDST</span><br><span class="line">	STX_XADD_W: /* lock xadd *(u32 *)(dst_reg + off16) += src_reg */</span><br><span class="line">		atomic_add((u32) SRC, (atomic_t *)(unsigned long)</span><br><span class="line">			   (DST + insn-&gt;off));</span><br><span class="line">		CONT;</span><br><span class="line">	STX_XADD_DW: /* lock xadd *(u64 *)(dst_reg + off16) += src_reg */</span><br><span class="line">		atomic64_add((u64) SRC, (atomic64_t *)(unsigned long)</span><br><span class="line">			     (DST + insn-&gt;off));</span><br><span class="line">		CONT;</span><br><span class="line">	LD_ABS_W: /* BPF_R0 = ntohl(*(u32 *) (skb-&gt;data + imm32)) */</span><br><span class="line">		off = IMM;</span><br><span class="line">load_word:</span><br><span class="line">		/* BPF_LD + BPD_ABS and BPF_LD + BPF_IND insns are</span><br><span class="line">		 * only appearing in the programs where ctx ==</span><br><span class="line">		 * skb. All programs keep &apos;ctx&apos; in regs[BPF_REG_CTX]</span><br><span class="line">		 * == BPF_R6, bpf_convert_filter() saves it in BPF_R6,</span><br><span class="line">		 * internal BPF verifier will check that BPF_R6 ==</span><br><span class="line">		 * ctx.</span><br><span class="line">		 *</span><br><span class="line">		 * BPF_ABS and BPF_IND are wrappers of function calls,</span><br><span class="line">		 * so they scratch BPF_R1-BPF_R5 registers, preserve</span><br><span class="line">		 * BPF_R6-BPF_R9, and store return value into BPF_R0.</span><br><span class="line">		 *</span><br><span class="line">		 * Implicit input:</span><br><span class="line">		 *   ctx == skb == BPF_R6 == CTX</span><br><span class="line">		 *</span><br><span class="line">		 * Explicit input:</span><br><span class="line">		 *   SRC == any register</span><br><span class="line">		 *   IMM == 32-bit immediate</span><br><span class="line">		 *</span><br><span class="line">		 * Output:</span><br><span class="line">		 *   BPF_R0 - 8/16/32-bit skb data converted to cpu endianness</span><br><span class="line">		 */</span><br><span class="line"></span><br><span class="line">		ptr = bpf_load_pointer((struct sk_buff *) (unsigned long) CTX, off, 4, &amp;tmp);</span><br><span class="line">		if (likely(ptr != NULL)) &#123;</span><br><span class="line">			BPF_R0 = get_unaligned_be32(ptr);</span><br><span class="line">			CONT;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return 0;</span><br><span class="line">	LD_ABS_H: /* BPF_R0 = ntohs(*(u16 *) (skb-&gt;data + imm32)) */</span><br><span class="line">		off = IMM;</span><br><span class="line">load_half:</span><br><span class="line">		ptr = bpf_load_pointer((struct sk_buff *) (unsigned long) CTX, off, 2, &amp;tmp);</span><br><span class="line">		if (likely(ptr != NULL)) &#123;</span><br><span class="line">			BPF_R0 = get_unaligned_be16(ptr);</span><br><span class="line">			CONT;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return 0;</span><br><span class="line">	LD_ABS_B: /* BPF_R0 = *(u8 *) (skb-&gt;data + imm32) */</span><br><span class="line">		off = IMM;</span><br><span class="line">load_byte:</span><br><span class="line">		ptr = bpf_load_pointer((struct sk_buff *) (unsigned long) CTX, off, 1, &amp;tmp);</span><br><span class="line">		if (likely(ptr != NULL)) &#123;</span><br><span class="line">			BPF_R0 = *(u8 *)ptr;</span><br><span class="line">			CONT;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return 0;</span><br><span class="line">	LD_IND_W: /* BPF_R0 = ntohl(*(u32 *) (skb-&gt;data + src_reg + imm32)) */</span><br><span class="line">		off = IMM + SRC;</span><br><span class="line">		goto load_word;</span><br><span class="line">	LD_IND_H: /* BPF_R0 = ntohs(*(u16 *) (skb-&gt;data + src_reg + imm32)) */</span><br><span class="line">		off = IMM + SRC;</span><br><span class="line">		goto load_half;</span><br><span class="line">	LD_IND_B: /* BPF_R0 = *(u8 *) (skb-&gt;data + src_reg + imm32) */</span><br><span class="line">		off = IMM + SRC;</span><br><span class="line">		goto load_byte;</span><br><span class="line"></span><br><span class="line">	default_label:</span><br><span class="line">		/* If we ever reach this, we have a bug somewhere. */</span><br><span class="line">		WARN_RATELIMIT(1, &quot;unknown opcode %02x\n&quot;, insn-&gt;code);</span><br><span class="line">		return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>3、BPF_PROG_RUN()</li>
</ul>
<p>不论是转换成JIT的映像，或者是使用interpreter解释器。最后BPF程序运行的时候都是使用BPF_PROG_RUN()这个宏来调用的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ret = BPF_PROG_RUN(prog, ctx);</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">#define BPF_PROG_RUN(filter, ctx)  (*filter-&gt;bpf_func)(ctx, filter-&gt;insnsi)</span><br></pre></td></tr></table></figure>
<h3 id="1-1-4、fd分配"><a href="#1-1-4、fd分配" class="headerlink" title="1.1.4、fd分配"></a>1.1.4、fd分配</h3><p>对于加载到内核空间的BPF程序，最后会给它分配一个文件句柄fd，将prog存储到对应的file-&gt;private_data上。方便后续的引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">int bpf_prog_new_fd(struct bpf_prog *prog)</span><br><span class="line">&#123;</span><br><span class="line">	return anon_inode_getfd(&quot;bpf-prog&quot;, &amp;bpf_prog_fops, prog,</span><br><span class="line">				O_RDWR | O_CLOEXEC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">int anon_inode_getfd(const char *name, const struct file_operations *fops,</span><br><span class="line">		     void *priv, int flags)</span><br><span class="line">&#123;</span><br><span class="line">	int error, fd;</span><br><span class="line">	struct file *file;</span><br><span class="line"></span><br><span class="line">	error = get_unused_fd_flags(flags);</span><br><span class="line">	if (error &lt; 0)</span><br><span class="line">		return error;</span><br><span class="line">	fd = error;</span><br><span class="line"></span><br><span class="line">	file = anon_inode_getfile(name, fops, priv, flags);</span><br><span class="line">	if (IS_ERR(file)) &#123;</span><br><span class="line">		error = PTR_ERR(file);</span><br><span class="line">		goto err_put_unused_fd;</span><br><span class="line">	&#125;</span><br><span class="line">	fd_install(fd, file);</span><br><span class="line"></span><br><span class="line">	return fd;</span><br><span class="line"></span><br><span class="line">err_put_unused_fd:</span><br><span class="line">	put_unused_fd(fd);</span><br><span class="line">	return error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">struct file *anon_inode_getfile(const char *name,</span><br><span class="line">				const struct file_operations *fops,</span><br><span class="line">				void *priv, int flags)</span><br><span class="line">&#123;</span><br><span class="line">	struct qstr this;</span><br><span class="line">	struct path path;</span><br><span class="line">	struct file *file;</span><br><span class="line"></span><br><span class="line">	if (IS_ERR(anon_inode_inode))</span><br><span class="line">		return ERR_PTR(-ENODEV);</span><br><span class="line"></span><br><span class="line">	if (fops-&gt;owner &amp;&amp; !try_module_get(fops-&gt;owner))</span><br><span class="line">		return ERR_PTR(-ENOENT);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Link the inode to a directory entry by creating a unique name</span><br><span class="line">	 * using the inode sequence number.</span><br><span class="line">	 */</span><br><span class="line">	file = ERR_PTR(-ENOMEM);</span><br><span class="line">	this.name = name;</span><br><span class="line">	this.len = strlen(name);</span><br><span class="line">	this.hash = 0;</span><br><span class="line">	path.dentry = d_alloc_pseudo(anon_inode_mnt-&gt;mnt_sb, &amp;this);</span><br><span class="line">	if (!path.dentry)</span><br><span class="line">		goto err_module;</span><br><span class="line"></span><br><span class="line">	path.mnt = mntget(anon_inode_mnt);</span><br><span class="line">	/*</span><br><span class="line">	 * We know the anon_inode inode count is always greater than zero,</span><br><span class="line">	 * so ihold() is safe.</span><br><span class="line">	 */</span><br><span class="line">	ihold(anon_inode_inode);</span><br><span class="line"></span><br><span class="line">	d_instantiate(path.dentry, anon_inode_inode);</span><br><span class="line"></span><br><span class="line">	file = alloc_file(&amp;path, OPEN_FMODE(flags), fops);</span><br><span class="line">	if (IS_ERR(file))</span><br><span class="line">		goto err_dput;</span><br><span class="line">	file-&gt;f_mapping = anon_inode_inode-&gt;i_mapping;</span><br><span class="line"></span><br><span class="line">	file-&gt;f_flags = flags &amp; (O_ACCMODE | O_NONBLOCK);</span><br><span class="line">	file-&gt;private_data = priv;</span><br><span class="line"></span><br><span class="line">	return file;</span><br><span class="line"></span><br><span class="line">err_dput:</span><br><span class="line">	path_put(&amp;path);</span><br><span class="line">err_module:</span><br><span class="line">	module_put(fops-&gt;owner);</span><br><span class="line">	return file;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-2、bpf-map操作"><a href="#1-2、bpf-map操作" class="headerlink" title="1.2、bpf map操作"></a>1.2、bpf map操作</h2><p>BPF map的应用场景有几种：</p>
<ul>
<li>BPF程序和用户态态的交互：BPF程序运行完，得到的结果存储到map中，供用户态访问；</li>
<li>BPF程序内部交互：如果BPF程序内部需要用全局变量来交互，但是由于安全原因BPF程序不允许访问全局变量，可以使用map来充当全局变量；</li>
<li>BPF Tail call：Tail call是一个BPF程序跳转到另一BPF程序，BPF程序首先通过BPF_MAP_TYPE_PROG_ARRAY类型的map来知道另一个BPF程序的指针，然后调用tail_call()的helper function来执行Tail call。</li>
<li>BPF程序和内核态的交互：和BPF程序以外的内核程序交互，也可以使用map作为中介；</li>
</ul>
<p>目前，支持的map种类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">static int __init register_array_map(void)</span><br><span class="line">&#123;</span><br><span class="line">	bpf_register_map_type(&amp;array_type);</span><br><span class="line">	bpf_register_map_type(&amp;percpu_array_type);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">static int __init register_cgroup_array_map(void)</span><br><span class="line">&#123;</span><br><span class="line">	bpf_register_map_type(&amp;cgroup_array_type);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">static int __init register_htab_map(void)</span><br><span class="line">&#123;</span><br><span class="line">	bpf_register_map_type(&amp;htab_type);</span><br><span class="line">	bpf_register_map_type(&amp;htab_percpu_type);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">static int __init register_perf_event_array_map(void)</span><br><span class="line">&#123;</span><br><span class="line">	bpf_register_map_type(&amp;perf_event_array_type);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">static int __init register_prog_array_map(void)</span><br><span class="line">&#123;</span><br><span class="line">	bpf_register_map_type(&amp;prog_array_type);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">static int __init register_stack_map(void)</span><br><span class="line">&#123;</span><br><span class="line">	bpf_register_map_type(&amp;stack_map_type);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不论哪种map，对map的使用都是用”键-值“对(key-value)的形式来使用的。</p>
<h3 id="1-2-1、map的创建"><a href="#1-2-1、map的创建" class="headerlink" title="1.2.1、map的创建"></a>1.2.1、map的创建</h3><p>如果用户态的BPF c程序有定义map，map最后会被编译进<strong>section(“maps”)。<br>用户态的loader在加载BPF程序的时候，首先会根据</strong>section(“maps”)中的成员来调用bpf()系统调用来创建map对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">static int map_create(union bpf_attr *attr)</span><br><span class="line">&#123;</span><br><span class="line">	struct bpf_map *map;</span><br><span class="line">	int err;</span><br><span class="line"></span><br><span class="line">	err = CHECK_ATTR(BPF_MAP_CREATE);</span><br><span class="line">	if (err)</span><br><span class="line">		return -EINVAL;</span><br><span class="line"></span><br><span class="line">	/* find map type and init map: hashtable vs rbtree vs bloom vs ... */</span><br><span class="line">	/* (1) 根据map的类型分配空间 */</span><br><span class="line">	map = find_and_alloc_map(attr);</span><br><span class="line">	if (IS_ERR(map))</span><br><span class="line">		return PTR_ERR(map);</span><br><span class="line"></span><br><span class="line">	atomic_set(&amp;map-&gt;refcnt, 1);</span><br><span class="line">	atomic_set(&amp;map-&gt;usercnt, 1);</span><br><span class="line"></span><br><span class="line">    /* (2) 在进程vm中给map锁定空间 */</span><br><span class="line">	err = bpf_map_charge_memlock(map);</span><br><span class="line">	if (err)</span><br><span class="line">		goto free_map_nouncharge;</span><br><span class="line"></span><br><span class="line">    /* (3) 给map分配对应的文件句柄 */</span><br><span class="line">	err = bpf_map_new_fd(map);</span><br><span class="line">	if (err &lt; 0)</span><br><span class="line">		/* failed to allocate fd */</span><br><span class="line">		goto free_map;</span><br><span class="line"></span><br><span class="line">	return err;</span><br><span class="line"></span><br><span class="line">free_map:</span><br><span class="line">	bpf_map_uncharge_memlock(map);</span><br><span class="line">free_map_nouncharge:</span><br><span class="line">	map-&gt;ops-&gt;map_free(map);</span><br><span class="line">	return err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">static struct bpf_map *find_and_alloc_map(union bpf_attr *attr)</span><br><span class="line">&#123;</span><br><span class="line">	struct bpf_map_type_list *tl;</span><br><span class="line">	struct bpf_map *map;</span><br><span class="line"></span><br><span class="line">	list_for_each_entry(tl, &amp;bpf_map_types, list_node) &#123;</span><br><span class="line">		if (tl-&gt;type == attr-&gt;map_type) &#123;</span><br><span class="line">		</span><br><span class="line">		    /* (1.1) 根据type找到对应的tl，分配map空间 */</span><br><span class="line">			map = tl-&gt;ops-&gt;map_alloc(attr);</span><br><span class="line">			if (IS_ERR(map))</span><br><span class="line">				return map;</span><br><span class="line">			map-&gt;ops = tl-&gt;ops;</span><br><span class="line">			map-&gt;map_type = attr-&gt;map_type;</span><br><span class="line">			return map;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return ERR_PTR(-EINVAL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">int bpf_map_new_fd(struct bpf_map *map)</span><br><span class="line">&#123;</span><br><span class="line">    /* (3.1) 给map分配对应的文件句柄fd，把map指针赋值给file-&gt;private_data */</span><br><span class="line">	return anon_inode_getfd(&quot;bpf-map&quot;, &amp;bpf_map_fops, map,</span><br><span class="line">				O_RDWR | O_CLOEXEC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>1、BPF_MAP_TYPE_ARRAY</li>
</ul>
<p>我们以BPF_MAP_TYPE_ARRAY类型的map为例，来看看map的分配过程：</p>
<p>从用户态传过来的attr成员意义如下：<br>attr-&gt;map_type：map的类型；<br>attr-&gt;key_size：键key成员的大小；<br>attr-&gt;value_size：值value成员的大小；<br>attr-&gt;max_entries：需要存储多少个条目(“键-值“对)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">static const struct bpf_map_ops array_ops = &#123;</span><br><span class="line">	.map_alloc = array_map_alloc,</span><br><span class="line">	.map_free = array_map_free,</span><br><span class="line">	.map_get_next_key = array_map_get_next_key,</span><br><span class="line">	.map_lookup_elem = array_map_lookup_elem,</span><br><span class="line">	.map_update_elem = array_map_update_elem,</span><br><span class="line">	.map_delete_elem = array_map_delete_elem,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct bpf_map_type_list array_type __read_mostly = &#123;</span><br><span class="line">	.ops = &amp;array_ops,</span><br><span class="line">	.type = BPF_MAP_TYPE_ARRAY,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static struct bpf_map *array_map_alloc(union bpf_attr *attr)</span><br><span class="line">&#123;</span><br><span class="line">	bool percpu = attr-&gt;map_type == BPF_MAP_TYPE_PERCPU_ARRAY;</span><br><span class="line">	u32 elem_size, index_mask, max_entries;</span><br><span class="line">	bool unpriv = !capable(CAP_SYS_ADMIN);</span><br><span class="line">	struct bpf_array *array;</span><br><span class="line">	u64 array_size, mask64;</span><br><span class="line"></span><br><span class="line">	/* check sanity of attributes */</span><br><span class="line">	if (attr-&gt;max_entries == 0 || attr-&gt;key_size != 4 ||</span><br><span class="line">	    attr-&gt;value_size == 0 || attr-&gt;map_flags)</span><br><span class="line">		return ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">	if (attr-&gt;value_size &gt;= 1 &lt;&lt; (KMALLOC_SHIFT_MAX - 1))</span><br><span class="line">		/* if value_size is bigger, the user space won&apos;t be able to</span><br><span class="line">		 * access the elements.</span><br><span class="line">		 */</span><br><span class="line">		return ERR_PTR(-E2BIG);</span><br><span class="line"></span><br><span class="line">    /* (1.1.1) 计算value的size，key的size不用计算也不用存储，因为这里的key直接就是index */</span><br><span class="line">	elem_size = round_up(attr-&gt;value_size, 8);</span><br><span class="line"></span><br><span class="line">	max_entries = attr-&gt;max_entries;</span><br><span class="line"></span><br><span class="line">	/* On 32 bit archs roundup_pow_of_two() with max_entries that has</span><br><span class="line">	 * upper most bit set in u32 space is undefined behavior due to</span><br><span class="line">	 * resulting 1U &lt;&lt; 32, so do it manually here in u64 space.</span><br><span class="line">	 */</span><br><span class="line">	mask64 = fls_long(max_entries - 1);</span><br><span class="line">	mask64 = 1ULL &lt;&lt; mask64;</span><br><span class="line">	mask64 -= 1;</span><br><span class="line"></span><br><span class="line">	index_mask = mask64;</span><br><span class="line">	if (unpriv) &#123;</span><br><span class="line">		/* round up array size to nearest power of 2,</span><br><span class="line">		 * since cpu will speculate within index_mask limits</span><br><span class="line">		 */</span><br><span class="line">		max_entries = index_mask + 1;</span><br><span class="line">		/* Check for overflows. */</span><br><span class="line">		if (max_entries &lt; attr-&gt;max_entries)</span><br><span class="line">			return ERR_PTR(-E2BIG);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (1.1.2) 计算bpf_array + value数组的总大小，bpf_array包含了map的通用结构bpf_map */</span><br><span class="line">	array_size = sizeof(*array);</span><br><span class="line">	if (percpu)</span><br><span class="line">		array_size += (u64) max_entries * sizeof(void *);</span><br><span class="line">	else</span><br><span class="line">		array_size += (u64) max_entries * elem_size;</span><br><span class="line"></span><br><span class="line">	/* make sure there is no u32 overflow later in round_up() */</span><br><span class="line">	if (array_size &gt;= U32_MAX - PAGE_SIZE)</span><br><span class="line">		return ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">	/* allocate all map elements and zero-initialize them */</span><br><span class="line">	/* (1.1.3) 根据总大小，分配bpf_array空间 */</span><br><span class="line">	array = bpf_map_area_alloc(array_size);</span><br><span class="line">	if (!array)</span><br><span class="line">		return ERR_PTR(-ENOMEM);</span><br><span class="line">	array-&gt;index_mask = index_mask;</span><br><span class="line">	array-&gt;map.unpriv_array = unpriv;</span><br><span class="line"></span><br><span class="line">	/* copy mandatory map attributes */</span><br><span class="line">	/* (1.1.4) 拷贝attr到array-&gt;map中 */</span><br><span class="line">	array-&gt;map.map_type = attr-&gt;map_type;</span><br><span class="line">	array-&gt;map.key_size = attr-&gt;key_size;</span><br><span class="line">	array-&gt;map.value_size = attr-&gt;value_size;</span><br><span class="line">	array-&gt;map.max_entries = attr-&gt;max_entries;</span><br><span class="line">	array-&gt;elem_size = elem_size;</span><br><span class="line"></span><br><span class="line">	if (!percpu)</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">	array_size += (u64) attr-&gt;max_entries * elem_size * num_possible_cpus();</span><br><span class="line"></span><br><span class="line">	if (array_size &gt;= U32_MAX - PAGE_SIZE ||</span><br><span class="line">	    elem_size &gt; PCPU_MIN_UNIT_SIZE || bpf_array_alloc_percpu(array)) &#123;</span><br><span class="line">		bpf_map_area_free(array);</span><br><span class="line">		return ERR_PTR(-ENOMEM);</span><br><span class="line">	&#125;</span><br><span class="line">out:</span><br><span class="line">	array-&gt;map.pages = round_up(array_size, PAGE_SIZE) &gt;&gt; PAGE_SHIFT;</span><br><span class="line"></span><br><span class="line">	return &amp;array-&gt;map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>2、BPF_MAP_TYPE_HASH</li>
</ul>
<p>我们以BPF_MAP_TYPE_HASH类型的map为例，来看看map的分配过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line">static const struct bpf_map_ops htab_ops = &#123;</span><br><span class="line">	.map_alloc = htab_map_alloc,</span><br><span class="line">	.map_free = htab_map_free,</span><br><span class="line">	.map_get_next_key = htab_map_get_next_key,</span><br><span class="line">	.map_lookup_elem = htab_map_lookup_elem,</span><br><span class="line">	.map_update_elem = htab_map_update_elem,</span><br><span class="line">	.map_delete_elem = htab_map_delete_elem,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct bpf_map_type_list htab_type __read_mostly = &#123;</span><br><span class="line">	.ops = &amp;htab_ops,</span><br><span class="line">	.type = BPF_MAP_TYPE_HASH,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static struct bpf_map *htab_map_alloc(union bpf_attr *attr)</span><br><span class="line">&#123;</span><br><span class="line">	bool percpu = attr-&gt;map_type == BPF_MAP_TYPE_PERCPU_HASH;</span><br><span class="line">	struct bpf_htab *htab;</span><br><span class="line">	int err, i;</span><br><span class="line">	u64 cost;</span><br><span class="line"></span><br><span class="line">	if (attr-&gt;map_flags &amp; ~BPF_F_NO_PREALLOC)</span><br><span class="line">		/* reserved bits should not be used */</span><br><span class="line">		return ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">    /* (1.1.1) 因为hash是用链表存储的，所以bpf_htab结构是固定的，优先分配 */</span><br><span class="line">	htab = kzalloc(sizeof(*htab), GFP_USER);</span><br><span class="line">	if (!htab)</span><br><span class="line">		return ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">	/* mandatory map attributes */</span><br><span class="line">	htab-&gt;map.map_type = attr-&gt;map_type;</span><br><span class="line">	htab-&gt;map.key_size = attr-&gt;key_size;</span><br><span class="line">	htab-&gt;map.value_size = attr-&gt;value_size;</span><br><span class="line">	htab-&gt;map.max_entries = attr-&gt;max_entries;</span><br><span class="line">	htab-&gt;map.map_flags = attr-&gt;map_flags;</span><br><span class="line"></span><br><span class="line">	/* check sanity of attributes.</span><br><span class="line">	 * value_size == 0 may be allowed in the future to use map as a set</span><br><span class="line">	 */</span><br><span class="line">	err = -EINVAL;</span><br><span class="line">	if (htab-&gt;map.max_entries == 0 || htab-&gt;map.key_size == 0 ||</span><br><span class="line">	    htab-&gt;map.value_size == 0)</span><br><span class="line">		goto free_htab;</span><br><span class="line"></span><br><span class="line">	/* hash table size must be power of 2 */</span><br><span class="line">	/* (1.1.2) 链表头buckets的个数，等于和最大条目值最接近的2的n次方 */</span><br><span class="line">	htab-&gt;n_buckets = roundup_pow_of_two(htab-&gt;map.max_entries);</span><br><span class="line"></span><br><span class="line">	err = -E2BIG;</span><br><span class="line">	if (htab-&gt;map.key_size &gt; MAX_BPF_STACK)</span><br><span class="line">		/* eBPF programs initialize keys on stack, so they cannot be</span><br><span class="line">		 * larger than max stack size</span><br><span class="line">		 */</span><br><span class="line">		goto free_htab;</span><br><span class="line"></span><br><span class="line">	if (htab-&gt;map.value_size &gt;= (1 &lt;&lt; (KMALLOC_SHIFT_MAX - 1)) -</span><br><span class="line">	    MAX_BPF_STACK - sizeof(struct htab_elem))</span><br><span class="line">		/* if value_size is bigger, the user space won&apos;t be able to</span><br><span class="line">		 * access the elements via bpf syscall. This check also makes</span><br><span class="line">		 * sure that the elem_size doesn&apos;t overflow and it&apos;s</span><br><span class="line">		 * kmalloc-able later in htab_map_update_elem()</span><br><span class="line">		 */</span><br><span class="line">		goto free_htab;</span><br><span class="line"></span><br><span class="line">	if (percpu &amp;&amp; round_up(htab-&gt;map.value_size, 8) &gt; PCPU_MIN_UNIT_SIZE)</span><br><span class="line">		/* make sure the size for pcpu_alloc() is reasonable */</span><br><span class="line">		goto free_htab;</span><br><span class="line"></span><br><span class="line">    /* (1.1.3) hash的一个element size = htab_elem + key_size + value_size */</span><br><span class="line">	htab-&gt;elem_size = sizeof(struct htab_elem) +</span><br><span class="line">			  round_up(htab-&gt;map.key_size, 8);</span><br><span class="line">	if (percpu)</span><br><span class="line">		htab-&gt;elem_size += sizeof(void *);</span><br><span class="line">	else</span><br><span class="line">		htab-&gt;elem_size += round_up(htab-&gt;map.value_size, 8);</span><br><span class="line"></span><br><span class="line">	/* prevent zero size kmalloc and check for u32 overflow */</span><br><span class="line">	if (htab-&gt;n_buckets == 0 ||</span><br><span class="line">	    htab-&gt;n_buckets &gt; U32_MAX / sizeof(struct bucket))</span><br><span class="line">		goto free_htab;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /* (1.1.4) 总占用内存的大小cost = bucket_size*max_entries + elem_size*max_entries + extra_element_size，</span><br><span class="line">        其中extra_element_size = elem_size * num_possible_cpus();</span><br><span class="line">     */</span><br><span class="line">	cost = (u64) htab-&gt;n_buckets * sizeof(struct bucket) +</span><br><span class="line">	       (u64) htab-&gt;elem_size * htab-&gt;map.max_entries;</span><br><span class="line"></span><br><span class="line">	if (percpu)</span><br><span class="line">		cost += (u64) round_up(htab-&gt;map.value_size, 8) *</span><br><span class="line">			num_possible_cpus() * htab-&gt;map.max_entries;</span><br><span class="line">	else</span><br><span class="line">	       cost += (u64) htab-&gt;elem_size * num_possible_cpus();</span><br><span class="line"></span><br><span class="line">	if (cost &gt;= U32_MAX - PAGE_SIZE)</span><br><span class="line">		/* make sure page count doesn&apos;t overflow */</span><br><span class="line">		goto free_htab;</span><br><span class="line"></span><br><span class="line">	htab-&gt;map.pages = round_up(cost, PAGE_SIZE) &gt;&gt; PAGE_SHIFT;</span><br><span class="line"></span><br><span class="line">	/* if map size is larger than memlock limit, reject it early */</span><br><span class="line">	err = bpf_map_precharge_memlock(htab-&gt;map.pages);</span><br><span class="line">	if (err)</span><br><span class="line">		goto free_htab;</span><br><span class="line"></span><br><span class="line">	err = -ENOMEM;</span><br><span class="line">	/* (1.1.5) 分配bucket空间 */</span><br><span class="line">	htab-&gt;buckets = bpf_map_area_alloc(htab-&gt;n_buckets *</span><br><span class="line">					   sizeof(struct bucket));</span><br><span class="line">	if (!htab-&gt;buckets)</span><br><span class="line">		goto free_htab;</span><br><span class="line"></span><br><span class="line">	for (i = 0; i &lt; htab-&gt;n_buckets; i++) &#123;</span><br><span class="line">		INIT_HLIST_HEAD(&amp;htab-&gt;buckets[i].head);</span><br><span class="line">		raw_spin_lock_init(&amp;htab-&gt;buckets[i].lock);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (1.1.6) 分配extra elems空间 */</span><br><span class="line">	if (!percpu) &#123;</span><br><span class="line">		err = alloc_extra_elems(htab);</span><br><span class="line">		if (err)</span><br><span class="line">			goto free_buckets;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (1.1.7) 分配elems空间，并且将其平均挂载到htab-&gt;freelist的percpu链表上 */</span><br><span class="line">	if (!(attr-&gt;map_flags &amp; BPF_F_NO_PREALLOC)) &#123;</span><br><span class="line">		err = prealloc_elems_and_freelist(htab);</span><br><span class="line">		if (err)</span><br><span class="line">			goto free_extra_elems;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return &amp;htab-&gt;map;</span><br><span class="line"></span><br><span class="line">free_extra_elems:</span><br><span class="line">	free_percpu(htab-&gt;extra_elems);</span><br><span class="line">free_buckets:</span><br><span class="line">	bpf_map_area_free(htab-&gt;buckets);</span><br><span class="line">free_htab:</span><br><span class="line">	kfree(htab);</span><br><span class="line">	return ERR_PTR(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-2、map的查找"><a href="#1-2-2、map的查找" class="headerlink" title="1.2.2、map的查找"></a>1.2.2、map的查找</h3><p>查找就是通过key来找到对应的value。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">static int map_lookup_elem(union bpf_attr *attr)</span><br><span class="line">&#123;</span><br><span class="line">	void __user *ukey = u64_to_ptr(attr-&gt;key);</span><br><span class="line">	void __user *uvalue = u64_to_ptr(attr-&gt;value);</span><br><span class="line">	int ufd = attr-&gt;map_fd;</span><br><span class="line">	struct bpf_map *map;</span><br><span class="line">	void *key, *value, *ptr;</span><br><span class="line">	u32 value_size;</span><br><span class="line">	struct fd f;</span><br><span class="line">	int err;</span><br><span class="line"></span><br><span class="line">	if (CHECK_ATTR(BPF_MAP_LOOKUP_ELEM))</span><br><span class="line">		return -EINVAL;</span><br><span class="line"></span><br><span class="line">	f = fdget(ufd);</span><br><span class="line">	map = __bpf_map_get(f);</span><br><span class="line">	if (IS_ERR(map))</span><br><span class="line">		return PTR_ERR(map);</span><br><span class="line"></span><br><span class="line">	err = -ENOMEM;</span><br><span class="line">	key = kmalloc(map-&gt;key_size, GFP_USER);</span><br><span class="line">	if (!key)</span><br><span class="line">		goto err_put;</span><br><span class="line"></span><br><span class="line">	err = -EFAULT;</span><br><span class="line">	if (copy_from_user(key, ukey, map-&gt;key_size) != 0)</span><br><span class="line">		goto free_key;</span><br><span class="line"></span><br><span class="line">	if (map-&gt;map_type == BPF_MAP_TYPE_PERCPU_HASH ||</span><br><span class="line">	    map-&gt;map_type == BPF_MAP_TYPE_PERCPU_ARRAY)</span><br><span class="line">		value_size = round_up(map-&gt;value_size, 8) * num_possible_cpus();</span><br><span class="line">	else</span><br><span class="line">		value_size = map-&gt;value_size;</span><br><span class="line"></span><br><span class="line">	err = -ENOMEM;</span><br><span class="line">	value = kmalloc(value_size, GFP_USER | __GFP_NOWARN);</span><br><span class="line">	if (!value)</span><br><span class="line">		goto free_key;</span><br><span class="line"></span><br><span class="line">    /* (1) 几种特殊类型map的处理 */</span><br><span class="line">	if (map-&gt;map_type == BPF_MAP_TYPE_PERCPU_HASH) &#123;</span><br><span class="line">		err = bpf_percpu_hash_copy(map, key, value);</span><br><span class="line">	&#125; else if (map-&gt;map_type == BPF_MAP_TYPE_PERCPU_ARRAY) &#123;</span><br><span class="line">		err = bpf_percpu_array_copy(map, key, value);</span><br><span class="line">	&#125; else if (map-&gt;map_type == BPF_MAP_TYPE_STACK_TRACE) &#123;</span><br><span class="line">		err = bpf_stackmap_copy(map, key, value);</span><br><span class="line">	</span><br><span class="line">	/* (2) 其他类型map都会调用map-&gt;ops-&gt;map_lookup_elem()函数 */</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		rcu_read_lock();</span><br><span class="line">		ptr = map-&gt;ops-&gt;map_lookup_elem(map, key);</span><br><span class="line">		</span><br><span class="line">		/* (3.1) 赋值给value */</span><br><span class="line">		if (ptr)</span><br><span class="line">			memcpy(value, ptr, value_size);</span><br><span class="line">		rcu_read_unlock();</span><br><span class="line">		err = ptr ? 0 : -ENOENT;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (err)</span><br><span class="line">		goto free_value;</span><br><span class="line"></span><br><span class="line">	err = -EFAULT;</span><br><span class="line">	</span><br><span class="line">	/* (3.2) 将value值拷贝会给用户空间 */</span><br><span class="line">	if (copy_to_user(uvalue, value, value_size) != 0)</span><br><span class="line">		goto free_value;</span><br><span class="line"></span><br><span class="line">	err = 0;</span><br><span class="line"></span><br><span class="line">free_value:</span><br><span class="line">	kfree(value);</span><br><span class="line">free_key:</span><br><span class="line">	kfree(key);</span><br><span class="line">err_put:</span><br><span class="line">	fdput(f);</span><br><span class="line">	return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>1、BPF_MAP_TYPE_ARRAY</li>
</ul>
<p>BPF_MAP_TYPE_ARRAY类型的map最终调用到array_map_lookup_elem()：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static void *array_map_lookup_elem(struct bpf_map *map, void *key)</span><br><span class="line">&#123;</span><br><span class="line">	struct bpf_array *array = container_of(map, struct bpf_array, map);</span><br><span class="line">	</span><br><span class="line">	/* (2.1) key就是index */</span><br><span class="line">	u32 index = *(u32 *)key;</span><br><span class="line"></span><br><span class="line">	if (unlikely(index &gt;= array-&gt;map.max_entries))</span><br><span class="line">		return NULL;</span><br><span class="line"></span><br><span class="line">    /* (2.2) 根据index，找到array-&gt;value[]数组中的value指针 */</span><br><span class="line">	return array-&gt;value + array-&gt;elem_size * (index &amp; array-&gt;index_mask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>2、BPF_MAP_TYPE_HASH</li>
</ul>
<p>BPF_MAP_TYPE_HASH类型的map最终调用到htab_map_lookup_elem()：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">static void *htab_map_lookup_elem(struct bpf_map *map, void *key)</span><br><span class="line">&#123;</span><br><span class="line">	struct htab_elem *l = __htab_map_lookup_elem(map, key);</span><br><span class="line"></span><br><span class="line">	if (l)</span><br><span class="line">		return l-&gt;key + round_up(map-&gt;key_size, 8);</span><br><span class="line"></span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static void *__htab_map_lookup_elem(struct bpf_map *map, void *key)</span><br><span class="line">&#123;</span><br><span class="line">	struct bpf_htab *htab = container_of(map, struct bpf_htab, map);</span><br><span class="line">	struct hlist_head *head;</span><br><span class="line">	struct htab_elem *l;</span><br><span class="line">	u32 hash, key_size;</span><br><span class="line"></span><br><span class="line">	/* Must be called with rcu_read_lock. */</span><br><span class="line">	WARN_ON_ONCE(!rcu_read_lock_held());</span><br><span class="line"></span><br><span class="line">	key_size = map-&gt;key_size;</span><br><span class="line"></span><br><span class="line">    /* (2.1) 根据key计算出hash值 */</span><br><span class="line">	hash = htab_map_hash(key, key_size);</span><br><span class="line"></span><br><span class="line">    /* (2.2) 根据hash值找到链表头bucket */</span><br><span class="line">	head = select_bucket(htab, hash);</span><br><span class="line"></span><br><span class="line">    /* (2.3) 在bucket链表中搜索key相等的htab_elem，如果找不到返回NULL */</span><br><span class="line">	l = lookup_elem_raw(head, hash, key, key_size);</span><br><span class="line"></span><br><span class="line">	return l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-3、BPF-FUNC-map-lookup-elem"><a href="#1-2-3、BPF-FUNC-map-lookup-elem" class="headerlink" title="1.2.3、BPF_FUNC_map_lookup_elem"></a>1.2.3、BPF_FUNC_map_lookup_elem</h3><p>除了用户态空间需要通过bpf()系统调用来查找key对应的value值。BPF程序中也需要根据key查找到value的地址，然后在BPF程序中使用。BPF程序时通过调用BPF_FUNC_map_lookup_elem helper function来实现的。</p>
<p>我们以perf_event为例，看看BPF_FUNC_map_lookup_elem helper function的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">static const struct bpf_verifier_ops perf_event_prog_ops = &#123;</span><br><span class="line">	.get_func_proto		= tp_prog_func_proto,</span><br><span class="line">	.is_valid_access	= pe_prog_is_valid_access,</span><br><span class="line">	.convert_ctx_access	= pe_prog_convert_ctx_access,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct bpf_prog_type_list perf_event_tl = &#123;</span><br><span class="line">	.ops	= &amp;perf_event_prog_ops,</span><br><span class="line">	.type	= BPF_PROG_TYPE_PERF_EVENT,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static const struct bpf_func_proto *tp_prog_func_proto(enum bpf_func_id func_id)</span><br><span class="line">&#123;</span><br><span class="line">	switch (func_id) &#123;</span><br><span class="line">	case BPF_FUNC_perf_event_output:</span><br><span class="line">		return &amp;bpf_perf_event_output_proto_tp;</span><br><span class="line">	case BPF_FUNC_get_stackid:</span><br><span class="line">		return &amp;bpf_get_stackid_proto_tp;</span><br><span class="line">	default:</span><br><span class="line">		return tracing_func_proto(func_id);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static const struct bpf_func_proto *tracing_func_proto(enum bpf_func_id func_id)</span><br><span class="line">&#123;</span><br><span class="line">	switch (func_id) &#123;</span><br><span class="line">	case BPF_FUNC_map_lookup_elem:</span><br><span class="line">		return &amp;bpf_map_lookup_elem_proto;</span><br><span class="line">	case BPF_FUNC_map_update_elem:</span><br><span class="line">		return &amp;bpf_map_update_elem_proto;</span><br><span class="line">	case BPF_FUNC_map_delete_elem:</span><br><span class="line">		return &amp;bpf_map_delete_elem_proto;</span><br><span class="line">	case BPF_FUNC_probe_read:</span><br><span class="line">		return &amp;bpf_probe_read_proto;</span><br><span class="line">	case BPF_FUNC_ktime_get_ns:</span><br><span class="line">		return &amp;bpf_ktime_get_ns_proto;</span><br><span class="line">	case BPF_FUNC_tail_call:</span><br><span class="line">		return &amp;bpf_tail_call_proto;</span><br><span class="line">	case BPF_FUNC_get_current_pid_tgid:</span><br><span class="line">		return &amp;bpf_get_current_pid_tgid_proto;</span><br><span class="line">	case BPF_FUNC_get_current_task:</span><br><span class="line">		return &amp;bpf_get_current_task_proto;</span><br><span class="line">	case BPF_FUNC_get_current_uid_gid:</span><br><span class="line">		return &amp;bpf_get_current_uid_gid_proto;</span><br><span class="line">	case BPF_FUNC_get_current_comm:</span><br><span class="line">		return &amp;bpf_get_current_comm_proto;</span><br><span class="line">	case BPF_FUNC_trace_printk:</span><br><span class="line">		return bpf_get_trace_printk_proto();</span><br><span class="line">	case BPF_FUNC_get_smp_processor_id:</span><br><span class="line">		return &amp;bpf_get_smp_processor_id_proto;</span><br><span class="line">	case BPF_FUNC_perf_event_read:</span><br><span class="line">		return &amp;bpf_perf_event_read_proto;</span><br><span class="line">	case BPF_FUNC_probe_write_user:</span><br><span class="line">		return bpf_get_probe_write_proto();</span><br><span class="line">	case BPF_FUNC_current_task_under_cgroup:</span><br><span class="line">		return &amp;bpf_current_task_under_cgroup_proto;</span><br><span class="line">	case BPF_FUNC_get_prandom_u32:</span><br><span class="line">		return &amp;bpf_get_prandom_u32_proto;</span><br><span class="line">	default:</span><br><span class="line">		return NULL;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">const struct bpf_func_proto bpf_map_lookup_elem_proto = &#123;</span><br><span class="line">	.func		= bpf_map_lookup_elem,</span><br><span class="line">	.gpl_only	= false,</span><br><span class="line">	.pkt_access	= true,</span><br><span class="line">	.ret_type	= RET_PTR_TO_MAP_VALUE_OR_NULL,</span><br><span class="line">	.arg1_type	= ARG_CONST_MAP_PTR,</span><br><span class="line">	.arg2_type	= ARG_PTR_TO_MAP_KEY,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">BPF_CALL_2(bpf_map_lookup_elem, struct bpf_map *, map, void *, key)</span><br><span class="line">&#123;</span><br><span class="line">	WARN_ON_ONCE(!rcu_read_lock_held());</span><br><span class="line">	return (unsigned long) map-&gt;ops-&gt;map_lookup_elem(map, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和bpf()系统调用一样，最后调用的都是map-&gt;ops-&gt;map_lookup_elem()函数，只不过BPF程序需要返回的是value的指针，而bpf()系统调用需要返回的是value的值。<br>关于map的helper function，还有BPF_FUNC_map_update_elem、BPF_FUNC_map_delete_elem可以使用，原理一样。</p>
<h2 id="1-3、obj-pin"><a href="#1-3、obj-pin" class="headerlink" title="1.3、obj pin"></a>1.3、obj pin</h2><p>系统把bpf_prog和bpf_map都和文件句柄绑定起来。有一系列的好处：比如可以在用户态使用一系列的通用文件操作；也有一系列的坏处：因为fd生存在进程空间的，其他进程不能访问，而且一旦本进程退出，这些对象都会处于失联状态无法访问。</p>
<p>所以系统也支持把bpf对象进行全局化的声明，具体的做法是把这些对象绑定到一个专用的文件系统当中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ls /sys/fs/bpf/</span><br><span class="line">#</span><br></pre></td></tr></table></figure>
<p>具体分为pin操作和get操作。</p>
<h3 id="1-3-1、bpf-obj-pin"><a href="#1-3-1、bpf-obj-pin" class="headerlink" title="1.3.1、bpf_obj_pin()"></a>1.3.1、bpf_obj_pin()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">static int bpf_obj_pin(const union bpf_attr *attr)</span><br><span class="line">&#123;</span><br><span class="line">	if (CHECK_ATTR(BPF_OBJ))</span><br><span class="line">		return -EINVAL;</span><br><span class="line"></span><br><span class="line">	return bpf_obj_pin_user(attr-&gt;bpf_fd, u64_to_ptr(attr-&gt;pathname));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">int bpf_obj_pin_user(u32 ufd, const char __user *pathname)</span><br><span class="line">&#123;</span><br><span class="line">	struct filename *pname;</span><br><span class="line">	enum bpf_type type;</span><br><span class="line">	void *raw;</span><br><span class="line">	int ret;</span><br><span class="line"></span><br><span class="line">    /* (1) 根据字符串获取路径 */</span><br><span class="line">	pname = getname(pathname);</span><br><span class="line">	if (IS_ERR(pname))</span><br><span class="line">		return PTR_ERR(pname);</span><br><span class="line"></span><br><span class="line">    /* (2) 根据fd获取到bpf_map/bpf_prog对象 */</span><br><span class="line">	raw = bpf_fd_probe_obj(ufd, &amp;type);</span><br><span class="line">	if (IS_ERR(raw)) &#123;</span><br><span class="line">		ret = PTR_ERR(raw);</span><br><span class="line">		goto out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (3) 创建文件节点，和bpf对象联结起来 */</span><br><span class="line">	ret = bpf_obj_do_pin(pname, raw, type);</span><br><span class="line">	if (ret != 0)</span><br><span class="line">		bpf_any_put(raw, type);</span><br><span class="line">out:</span><br><span class="line">	putname(pname);</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">static void *bpf_fd_probe_obj(u32 ufd, enum bpf_type *type)</span><br><span class="line">&#123;</span><br><span class="line">	void *raw;</span><br><span class="line"></span><br><span class="line">    /* (2.1) 根据fd，尝试获取map对象 */</span><br><span class="line">	*type = BPF_TYPE_MAP;</span><br><span class="line">	raw = bpf_map_get_with_uref(ufd);</span><br><span class="line">	if (IS_ERR(raw)) &#123;</span><br><span class="line">	    /* (2.2) 如果失败，根据fd，尝试获取prog对象 */</span><br><span class="line">		*type = BPF_TYPE_PROG;</span><br><span class="line">		raw = bpf_prog_get(ufd);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return raw;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">static int bpf_obj_do_pin(const struct filename *pathname, void *raw,</span><br><span class="line">			  enum bpf_type type)</span><br><span class="line">&#123;</span><br><span class="line">	struct dentry *dentry;</span><br><span class="line">	struct inode *dir;</span><br><span class="line">	struct path path;</span><br><span class="line">	umode_t mode;</span><br><span class="line">	dev_t devt;</span><br><span class="line">	int ret;</span><br><span class="line"></span><br><span class="line">    /* (3.1) 创建dentry对象 */</span><br><span class="line">	dentry = kern_path_create(AT_FDCWD, pathname-&gt;name, &amp;path, 0);</span><br><span class="line">	if (IS_ERR(dentry))</span><br><span class="line">		return PTR_ERR(dentry);</span><br><span class="line"></span><br><span class="line">	mode = S_IFREG | ((S_IRUSR | S_IWUSR) &amp; ~current_umask());</span><br><span class="line">	</span><br><span class="line">	/* (3.2) type存储在devt中 */</span><br><span class="line">	devt = MKDEV(UNNAMED_MAJOR, type);</span><br><span class="line"></span><br><span class="line">	ret = security_path_mknod(&amp;path, dentry, mode, devt);</span><br><span class="line">	if (ret)</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">	dir = d_inode(path.dentry);</span><br><span class="line">	if (dir-&gt;i_op != &amp;bpf_dir_iops) &#123;</span><br><span class="line">		ret = -EPERM;</span><br><span class="line">		goto out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (3.3) 对象指针raw存放到dentry-&gt;d_fsdata中，再来创建inode */</span><br><span class="line">	dentry-&gt;d_fsdata = raw;</span><br><span class="line">	ret = vfs_mknod(dir, dentry, mode, devt);</span><br><span class="line">	dentry-&gt;d_fsdata = NULL;</span><br><span class="line">out:</span><br><span class="line">	done_path_create(&amp;path, dentry);</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-2、bpf-obj-get"><a href="#1-3-2、bpf-obj-get" class="headerlink" title="1.3.2、bpf_obj_get()"></a>1.3.2、bpf_obj_get()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">static int bpf_obj_get(const union bpf_attr *attr)</span><br><span class="line">&#123;</span><br><span class="line">	if (CHECK_ATTR(BPF_OBJ) || attr-&gt;bpf_fd != 0)</span><br><span class="line">		return -EINVAL;</span><br><span class="line"></span><br><span class="line">	return bpf_obj_get_user(u64_to_ptr(attr-&gt;pathname));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">int bpf_obj_get_user(const char __user *pathname)</span><br><span class="line">&#123;</span><br><span class="line">	enum bpf_type type = BPF_TYPE_UNSPEC;</span><br><span class="line">	struct filename *pname;</span><br><span class="line">	int ret = -ENOENT;</span><br><span class="line">	void *raw;</span><br><span class="line">    </span><br><span class="line">    /* (1) 根据字符串获取路径 */</span><br><span class="line">	pname = getname(pathname);</span><br><span class="line">	if (IS_ERR(pname))</span><br><span class="line">		return PTR_ERR(pname);</span><br><span class="line"></span><br><span class="line">    /* (2) 根据路径，在对应inode中找到bpf对象的raw指针和type */</span><br><span class="line">	raw = bpf_obj_do_get(pname, &amp;type);</span><br><span class="line">	if (IS_ERR(raw)) &#123;</span><br><span class="line">		ret = PTR_ERR(raw);</span><br><span class="line">		goto out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (3) 根据对象type，在本进程中给bpf对象分配一个fd */</span><br><span class="line">	if (type == BPF_TYPE_PROG)</span><br><span class="line">		ret = bpf_prog_new_fd(raw);</span><br><span class="line">	else if (type == BPF_TYPE_MAP)</span><br><span class="line">		ret = bpf_map_new_fd(raw);</span><br><span class="line">	else</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">	if (ret &lt; 0)</span><br><span class="line">		bpf_any_put(raw, type);</span><br><span class="line">out:</span><br><span class="line">	putname(pname);</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static void *bpf_obj_do_get(const struct filename *pathname,</span><br><span class="line">			    enum bpf_type *type)</span><br><span class="line">&#123;</span><br><span class="line">	struct inode *inode;</span><br><span class="line">	struct path path;</span><br><span class="line">	void *raw;</span><br><span class="line">	int ret;</span><br><span class="line"></span><br><span class="line">    /* (2.1) 根据路径，获取到dentry */</span><br><span class="line">	ret = kern_path(pathname-&gt;name, LOOKUP_FOLLOW, &amp;path);</span><br><span class="line">	if (ret)</span><br><span class="line">		return ERR_PTR(ret);</span><br><span class="line"></span><br><span class="line">    /* (2.2) 根据dentry，获取到inode */</span><br><span class="line">	inode = d_backing_inode(path.dentry);</span><br><span class="line">	ret = inode_permission(inode, MAY_WRITE);</span><br><span class="line">	if (ret)</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">    /* (2.3) 根据inode，获取到type */</span><br><span class="line">	ret = bpf_inode_type(inode, type);</span><br><span class="line">	if (ret)</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">    /* (2.4) 根据inode和type，获取到raw指针 */</span><br><span class="line">	raw = bpf_any_get(inode-&gt;i_private, *type);</span><br><span class="line">	if (!IS_ERR(raw))</span><br><span class="line">		touch_atime(&amp;path);</span><br><span class="line"></span><br><span class="line">	path_put(&amp;path);</span><br><span class="line">	return raw;</span><br><span class="line">out:</span><br><span class="line">	path_put(&amp;path);</span><br><span class="line">	return ERR_PTR(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2、Tracing类型的BPF程序"><a href="#2、Tracing类型的BPF程序" class="headerlink" title="2、Tracing类型的BPF程序"></a>2、Tracing类型的BPF程序</h1><p>经过上一节的内容，bpf程序和map已经加载到内核当中了。什么时候bpf程序才能发挥它的作用呢？<br>这就需要bpf的应用系统把其挂载到适当的钩子上，当钩子所在点的路径被执行，钩子被触发，BPF程序得以执行。</p>
<p>目前应用bpf的子系统分为两大类：</p>
<ul>
<li>tracing：kprobe、tracepoint、perf_event</li>
<li>filter：sk_filter、sched_cls、sched_act、xdp、cg_skb</li>
</ul>
<p>我们仔细分析一下tracing类子系统应用bpf的过程，tracing类型的bpf操作都是通过perf来完成的。</p>
<h2 id="2-1、bpf程序的绑定"><a href="#2-1、bpf程序的绑定" class="headerlink" title="2.1、bpf程序的绑定"></a>2.1、bpf程序的绑定</h2><p>在使用perf_event_open()系统调用创建perf_event并且返回一个文件句柄后，可以使用ioctl的PERF_EVENT_IOC_SET_BPF命令把加载好的bpf程序和当前perf_event绑定起来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line">static long perf_ioctl(struct file *file, unsigned int cmd, unsigned long arg)</span><br><span class="line">&#123;</span><br><span class="line">	struct perf_event *event = file-&gt;private_data;</span><br><span class="line">	struct perf_event_context *ctx;</span><br><span class="line">	long ret;</span><br><span class="line"></span><br><span class="line">	ctx = perf_event_ctx_lock(event);</span><br><span class="line">	ret = _perf_ioctl(event, cmd, arg);</span><br><span class="line">	perf_event_ctx_unlock(event, ctx);</span><br><span class="line"></span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static long _perf_ioctl(struct perf_event *event, unsigned int cmd, unsigned long arg)</span><br><span class="line">&#123;</span><br><span class="line">	void (*func)(struct perf_event *);</span><br><span class="line">	u32 flags = arg;</span><br><span class="line"></span><br><span class="line">	switch (cmd) &#123;</span><br><span class="line">	case PERF_EVENT_IOC_ENABLE:</span><br><span class="line">		func = _perf_event_enable;</span><br><span class="line">		break;</span><br><span class="line">	case PERF_EVENT_IOC_DISABLE:</span><br><span class="line">		func = _perf_event_disable;</span><br><span class="line">		break;</span><br><span class="line">	case PERF_EVENT_IOC_RESET:</span><br><span class="line">		func = _perf_event_reset;</span><br><span class="line">		break;</span><br><span class="line"></span><br><span class="line">	case PERF_EVENT_IOC_REFRESH:</span><br><span class="line">		return _perf_event_refresh(event, arg);</span><br><span class="line"></span><br><span class="line">	case PERF_EVENT_IOC_PERIOD:</span><br><span class="line">		return perf_event_period(event, (u64 __user *)arg);</span><br><span class="line"></span><br><span class="line">	case PERF_EVENT_IOC_ID:</span><br><span class="line">	&#123;</span><br><span class="line">		u64 id = primary_event_id(event);</span><br><span class="line"></span><br><span class="line">		if (copy_to_user((void __user *)arg, &amp;id, sizeof(id)))</span><br><span class="line">			return -EFAULT;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	case PERF_EVENT_IOC_SET_OUTPUT:</span><br><span class="line">	&#123;</span><br><span class="line">		int ret;</span><br><span class="line">		if (arg != -1) &#123;</span><br><span class="line">			struct perf_event *output_event;</span><br><span class="line">			struct fd output;</span><br><span class="line">			ret = perf_fget_light(arg, &amp;output);</span><br><span class="line">			if (ret)</span><br><span class="line">				return ret;</span><br><span class="line">			output_event = output.file-&gt;private_data;</span><br><span class="line">			ret = perf_event_set_output(event, output_event);</span><br><span class="line">			fdput(output);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			ret = perf_event_set_output(event, NULL);</span><br><span class="line">		&#125;</span><br><span class="line">		return ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	case PERF_EVENT_IOC_SET_FILTER:</span><br><span class="line">		return perf_event_set_filter(event, (void __user *)arg);</span><br><span class="line"></span><br><span class="line">	case PERF_EVENT_IOC_SET_BPF:</span><br><span class="line">		return perf_event_set_bpf_prog(event, arg);</span><br><span class="line"></span><br><span class="line">	case PERF_EVENT_IOC_PAUSE_OUTPUT: &#123;</span><br><span class="line">		struct ring_buffer *rb;</span><br><span class="line"></span><br><span class="line">		rcu_read_lock();</span><br><span class="line">		rb = rcu_dereference(event-&gt;rb);</span><br><span class="line">		if (!rb || !rb-&gt;nr_pages) &#123;</span><br><span class="line">			rcu_read_unlock();</span><br><span class="line">			return -EINVAL;</span><br><span class="line">		&#125;</span><br><span class="line">		rb_toggle_paused(rb, !!arg);</span><br><span class="line">		rcu_read_unlock();</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	default:</span><br><span class="line">		return -ENOTTY;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (flags &amp; PERF_IOC_FLAG_GROUP)</span><br><span class="line">		perf_event_for_each(event, func);</span><br><span class="line">	else</span><br><span class="line">		perf_event_for_each_child(event, func);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static int perf_event_set_bpf_prog(struct perf_event *event, u32 prog_fd)</span><br><span class="line">&#123;</span><br><span class="line">	bool is_kprobe, is_tracepoint;</span><br><span class="line">	struct bpf_prog *prog;</span><br><span class="line"></span><br><span class="line">    /* (1) 对于PERF_TYPE_HARDWARE、PERF_TYPE_SOFTWARE类型的perf_event，需要绑定BPF_PROG_TYPE_PERF_EVENT类型的BPF prog </span><br><span class="line">        event-&gt;prog = prog;</span><br><span class="line">     */</span><br><span class="line">	if (event-&gt;attr.type == PERF_TYPE_HARDWARE ||</span><br><span class="line">	    event-&gt;attr.type == PERF_TYPE_SOFTWARE)</span><br><span class="line">		return perf_event_set_bpf_handler(event, prog_fd);</span><br><span class="line"></span><br><span class="line">	if (event-&gt;attr.type != PERF_TYPE_TRACEPOINT)</span><br><span class="line">		return -EINVAL;</span><br><span class="line"></span><br><span class="line">	if (event-&gt;tp_event-&gt;prog)</span><br><span class="line">		return -EEXIST;</span><br><span class="line"></span><br><span class="line">	is_kprobe = event-&gt;tp_event-&gt;flags &amp; TRACE_EVENT_FL_UKPROBE;</span><br><span class="line">	is_tracepoint = event-&gt;tp_event-&gt;flags &amp; TRACE_EVENT_FL_TRACEPOINT;</span><br><span class="line">	if (!is_kprobe &amp;&amp; !is_tracepoint)</span><br><span class="line">		/* bpf programs can only be attached to u/kprobe or tracepoint */</span><br><span class="line">		return -EINVAL;</span><br><span class="line"></span><br><span class="line">	prog = bpf_prog_get(prog_fd);</span><br><span class="line">	if (IS_ERR(prog))</span><br><span class="line">		return PTR_ERR(prog);</span><br><span class="line"></span><br><span class="line">    /* (2) 对于TRACE_EVENT_FL_TRACEPOINT类型的perf_event，需要绑定BPF_PROG_TYPE_TRACEPOINT类型的BPF prog </span><br><span class="line">        对于TRACE_EVENT_FL_UKPROBE类型的perf_event，需要绑定BPF_PROG_TYPE_KPROBE类型的BPF prog </span><br><span class="line">        event-&gt;tp_event-&gt;prog = prog;</span><br><span class="line">     */</span><br><span class="line">	if ((is_kprobe &amp;&amp; prog-&gt;type != BPF_PROG_TYPE_KPROBE) ||</span><br><span class="line">	    (is_tracepoint &amp;&amp; prog-&gt;type != BPF_PROG_TYPE_TRACEPOINT)) &#123;</span><br><span class="line">		/* valid fd, but invalid bpf program type */</span><br><span class="line">		bpf_prog_put(prog);</span><br><span class="line">		return -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (3) 如果是tracepoint类型的perf_event，需要注意自定义数据的大小不能超过bpf_prog中规定的context的大小，不然会被认为是非法访问 */</span><br><span class="line">	if (is_tracepoint) &#123;</span><br><span class="line">		int off = trace_event_get_offsets(event-&gt;tp_event);</span><br><span class="line"></span><br><span class="line">		if (prog-&gt;aux-&gt;max_ctx_offset &gt; off) &#123;</span><br><span class="line">			bpf_prog_put(prog);</span><br><span class="line">			return -EACCES;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	event-&gt;tp_event-&gt;prog = prog;</span><br><span class="line">	event-&gt;tp_event-&gt;bpf_prog_owner = event;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，perf_event绑定bpf_prog的规则如下：</p>
<ul>
<li>对于PERF_TYPE_HARDWARE、PERF_TYPE_SOFTWARE类型的perf_event，需要绑定BPF_PROG_TYPE_PERF_EVENT类型的BPF prog。event-&gt;prog = prog;</li>
<li>对于TRACE_EVENT_FL_TRACEPOINT实现的PERF_TYPE_TRACEPOINT类型的perf_event，需要绑定BPF_PROG_TYPE_TRACEPOINT类型的BPF prog。event-&gt;tp_event-&gt;prog = prog;</li>
<li>对于TRACE_EVENT_FL_UKPROBE实现的PERF_TYPE_TRACEPOINT类型的perf_event，需要绑定BPF_PROG_TYPE_KPROBE类型的BPF prog。event-&gt;tp_event-&gt;prog = prog;</li>
</ul>
<h2 id="2-2、bpf程序的执行"><a href="#2-2、bpf程序的执行" class="headerlink" title="2.2、bpf程序的执行"></a>2.2、bpf程序的执行</h2><p>因为几种perf_event的执行路径不一样，我们分开描述。</p>
<ul>
<li>1、PERF_TYPE_HARDWARE、PERF_TYPE_SOFTWARE类型的perf_event。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">static void bpf_overflow_handler(struct perf_event *event,</span><br><span class="line">				 struct perf_sample_data *data,</span><br><span class="line">				 struct pt_regs *regs)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    /* (1) 构造context */</span><br><span class="line">	struct bpf_perf_event_data_kern ctx = &#123;</span><br><span class="line">		.data = data,</span><br><span class="line">		.regs = regs,</span><br><span class="line">	&#125;;</span><br><span class="line">	int ret = 0;</span><br><span class="line"></span><br><span class="line">	preempt_disable();</span><br><span class="line">	if (unlikely(__this_cpu_inc_return(bpf_prog_active) != 1))</span><br><span class="line">		goto out;</span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	</span><br><span class="line">	/* (2) 调用bpf_prog处理 */</span><br><span class="line">	ret = BPF_PROG_RUN(event-&gt;prog, (void *)&amp;ctx);</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">out:</span><br><span class="line">	__this_cpu_dec(bpf_prog_active);</span><br><span class="line">	preempt_enable();</span><br><span class="line">	if (!ret)</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">    /* (3) perf_event的数据处理 */</span><br><span class="line">	event-&gt;orig_overflow_handler(event, data, regs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>2、TRACE_EVENT_FL_TRACEPOINT实现的PERF_TYPE_TRACEPOINT类型的perf_event。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">static notrace void							\</span><br><span class="line">perf_trace_##call(void *__data, proto)					\</span><br><span class="line">&#123;									\</span><br><span class="line">	struct trace_event_call *event_call = __data;			\</span><br><span class="line">	struct trace_event_data_offsets_##call __maybe_unused __data_offsets;\</span><br><span class="line">	struct trace_event_raw_##call *entry;				\</span><br><span class="line">	struct bpf_prog *prog = event_call-&gt;prog;			\</span><br><span class="line">	struct pt_regs *__regs;						\</span><br><span class="line">	u64 __count = 1;						\</span><br><span class="line">	struct task_struct *__task = NULL;				\</span><br><span class="line">	struct hlist_head *head;					\</span><br><span class="line">	int __entry_size;						\</span><br><span class="line">	int __data_size;						\</span><br><span class="line">	int rctx;							\</span><br><span class="line">									\</span><br><span class="line">	__data_size = trace_event_get_offsets_##call(&amp;__data_offsets, args); \</span><br><span class="line">									\</span><br><span class="line">	head = this_cpu_ptr(event_call-&gt;perf_events);			\</span><br><span class="line">	if (!prog &amp;&amp; __builtin_constant_p(!__task) &amp;&amp; !__task &amp;&amp;	\</span><br><span class="line">				hlist_empty(head))			\</span><br><span class="line">		return;							\</span><br><span class="line">									\</span><br><span class="line">	__entry_size = ALIGN(__data_size + sizeof(*entry) + sizeof(u32),\</span><br><span class="line">			     sizeof(u64));				\</span><br><span class="line">	__entry_size -= sizeof(u32);					\</span><br><span class="line">									\</span><br><span class="line">	entry = perf_trace_buf_alloc(__entry_size, &amp;__regs, &amp;rctx);	\</span><br><span class="line">	if (!entry)							\</span><br><span class="line">		return;							\</span><br><span class="line">									\</span><br><span class="line">	perf_fetch_caller_regs(__regs);					\</span><br><span class="line">									\</span><br><span class="line">	tstruct								\</span><br><span class="line">									\</span><br><span class="line">	&#123; assign; &#125;							\</span><br><span class="line">									\</span><br><span class="line">	perf_trace_run_bpf_submit(entry, __entry_size, rctx,		\</span><br><span class="line">				  event_call, __count, __regs,		\</span><br><span class="line">				  head, __task);			\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">void perf_trace_run_bpf_submit(void *raw_data, int size, int rctx,</span><br><span class="line">			       struct trace_event_call *call, u64 count,</span><br><span class="line">			       struct pt_regs *regs, struct hlist_head *head,</span><br><span class="line">			       struct task_struct *task)</span><br><span class="line">&#123;</span><br><span class="line">	struct bpf_prog *prog = call-&gt;prog;</span><br><span class="line"></span><br><span class="line">    /* (1) 调用bpf_prog处理 */</span><br><span class="line">	if (prog) &#123;</span><br><span class="line">		*(struct pt_regs **)raw_data = regs;</span><br><span class="line">		if (!trace_call_bpf(prog, raw_data) || hlist_empty(head)) &#123;</span><br><span class="line">			perf_swevent_put_recursion_context(rctx);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	/* (2) perf_event的数据处理 */</span><br><span class="line">	perf_tp_event(call-&gt;event.type, count, raw_data, size, regs, head,</span><br><span class="line">		      rctx, task);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">unsigned int trace_call_bpf(struct bpf_prog *prog, void *ctx)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned int ret;</span><br><span class="line"></span><br><span class="line">	if (in_nmi()) /* not supported yet */</span><br><span class="line">		return 1;</span><br><span class="line"></span><br><span class="line">	preempt_disable();</span><br><span class="line"></span><br><span class="line">	if (unlikely(__this_cpu_inc_return(bpf_prog_active) != 1)) &#123;</span><br><span class="line">		/*</span><br><span class="line">		 * since some bpf program is already running on this cpu,</span><br><span class="line">		 * don&apos;t call into another bpf program (same or different)</span><br><span class="line">		 * and don&apos;t send kprobe event into ring-buffer,</span><br><span class="line">		 * so return zero here</span><br><span class="line">		 */</span><br><span class="line">		ret = 0;</span><br><span class="line">		goto out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	</span><br><span class="line">	/* (1.1) 对bpf_prog的调用 */</span><br><span class="line">	ret = BPF_PROG_RUN(prog, ctx);</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line"></span><br><span class="line"> out:</span><br><span class="line">	__this_cpu_dec(bpf_prog_active);</span><br><span class="line">	preempt_enable();</span><br><span class="line"></span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>3、TRACE_EVENT_FL_UKPROBE实现的PERF_TYPE_TRACEPOINT类型的perf_event。</li>
</ul>
<p>kprobe类型的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">static void</span><br><span class="line">kprobe_perf_func(struct trace_kprobe *tk, struct pt_regs *regs)</span><br><span class="line">&#123;</span><br><span class="line">	struct trace_event_call *call = &amp;tk-&gt;tp.call;</span><br><span class="line">	struct bpf_prog *prog = call-&gt;prog;</span><br><span class="line">	struct kprobe_trace_entry_head *entry;</span><br><span class="line">	struct hlist_head *head;</span><br><span class="line">	int size, __size, dsize;</span><br><span class="line">	int rctx;</span><br><span class="line"></span><br><span class="line">    /* (1) 调用bpf_prog处理 */</span><br><span class="line">	if (prog &amp;&amp; !trace_call_bpf(prog, regs))</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	head = this_cpu_ptr(call-&gt;perf_events);</span><br><span class="line">	if (hlist_empty(head))</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	dsize = __get_data_size(&amp;tk-&gt;tp, regs);</span><br><span class="line">	__size = sizeof(*entry) + tk-&gt;tp.size + dsize;</span><br><span class="line">	size = ALIGN(__size + sizeof(u32), sizeof(u64));</span><br><span class="line">	size -= sizeof(u32);</span><br><span class="line"></span><br><span class="line">	entry = perf_trace_buf_alloc(size, NULL, &amp;rctx);</span><br><span class="line">	if (!entry)</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	entry-&gt;ip = (unsigned long)tk-&gt;rp.kp.addr;</span><br><span class="line">	memset(&amp;entry[1], 0, dsize);</span><br><span class="line">	store_trace_args(sizeof(*entry), &amp;tk-&gt;tp, regs, (u8 *)&amp;entry[1], dsize);</span><br><span class="line">	/* (2) perf_event的数据处理 */</span><br><span class="line">	perf_trace_buf_submit(entry, size, rctx, call-&gt;event.type, 1, regs,</span><br><span class="line">			      head, NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>kretprobe类型的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">static void</span><br><span class="line">kretprobe_perf_func(struct trace_kprobe *tk, struct kretprobe_instance *ri,</span><br><span class="line">		    struct pt_regs *regs)</span><br><span class="line">&#123;</span><br><span class="line">	struct trace_event_call *call = &amp;tk-&gt;tp.call;</span><br><span class="line">	struct bpf_prog *prog = call-&gt;prog;</span><br><span class="line">	struct kretprobe_trace_entry_head *entry;</span><br><span class="line">	struct hlist_head *head;</span><br><span class="line">	int size, __size, dsize;</span><br><span class="line">	int rctx;</span><br><span class="line"></span><br><span class="line">    /* (1) 调用bpf_prog处理 */</span><br><span class="line">	if (prog &amp;&amp; !trace_call_bpf(prog, regs))</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	head = this_cpu_ptr(call-&gt;perf_events);</span><br><span class="line">	if (hlist_empty(head))</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	dsize = __get_data_size(&amp;tk-&gt;tp, regs);</span><br><span class="line">	__size = sizeof(*entry) + tk-&gt;tp.size + dsize;</span><br><span class="line">	size = ALIGN(__size + sizeof(u32), sizeof(u64));</span><br><span class="line">	size -= sizeof(u32);</span><br><span class="line"></span><br><span class="line">	entry = perf_trace_buf_alloc(size, NULL, &amp;rctx);</span><br><span class="line">	if (!entry)</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	entry-&gt;func = (unsigned long)tk-&gt;rp.kp.addr;</span><br><span class="line">	entry-&gt;ret_ip = (unsigned long)ri-&gt;ret_addr;</span><br><span class="line">	store_trace_args(sizeof(*entry), &amp;tk-&gt;tp, regs, (u8 *)&amp;entry[1], dsize);</span><br><span class="line">	</span><br><span class="line">	/* (2) perf_event的数据处理 */</span><br><span class="line">	perf_trace_buf_submit(entry, size, rctx, call-&gt;event.type, 1, regs,</span><br><span class="line">			      head, NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3、Filter类型的BPF程序"><a href="#3、Filter类型的BPF程序" class="headerlink" title="3、Filter类型的BPF程序"></a>3、Filter类型的BPF程序</h1><p>暂不分析</p>
<h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p><a href="http://www.csie.ntnu.edu.tw/~u91029/Graph.html#5" target="_blank" rel="noopener">1、Graph</a></p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/BPF/" rel="tag"># BPF</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/12/21/ftrace_trace_event/" rel="next" title="Linux Ftrace 1.2、trace event">
                <i class="fa fa-chevron-left"></i> Linux Ftrace 1.2、trace event
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/12/21/bpf_reference_guide/" rel="prev" title="Linux BPF 3.2、BPF and XDP Reference Guide">
                Linux BPF 3.2、BPF and XDP Reference Guide <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/touxiang/ycqs.jpg" alt="pwl999">
            
              <p class="site-author-name" itemprop="name">pwl999</p>
              <p class="site-description motion-element" itemprop="description">RTFSC(Read The Fucking Source Code)</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives">
                
                    <span class="site-state-item-count">30</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">3</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">22</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1、bpf-系统调用"><span class="nav-number">1.</span> <span class="nav-text">1、bpf()系统调用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1、bpf加载"><span class="nav-number">1.1.</span> <span class="nav-text">1.1、bpf加载</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-1、bpf内存空间分配"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1.1、bpf内存空间分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-2、bpf-verifier"><span class="nav-number">1.1.2.</span> <span class="nav-text">1.1.2、bpf verifier</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-3、bpf-JIT-kernel-interpreter"><span class="nav-number">1.1.3.</span> <span class="nav-text">1.1.3、bpf JIT/kernel interpreter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-4、fd分配"><span class="nav-number">1.1.4.</span> <span class="nav-text">1.1.4、fd分配</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2、bpf-map操作"><span class="nav-number">1.2.</span> <span class="nav-text">1.2、bpf map操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-1、map的创建"><span class="nav-number">1.2.1.</span> <span class="nav-text">1.2.1、map的创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-2、map的查找"><span class="nav-number">1.2.2.</span> <span class="nav-text">1.2.2、map的查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-3、BPF-FUNC-map-lookup-elem"><span class="nav-number">1.2.3.</span> <span class="nav-text">1.2.3、BPF_FUNC_map_lookup_elem</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3、obj-pin"><span class="nav-number">1.3.</span> <span class="nav-text">1.3、obj pin</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-1、bpf-obj-pin"><span class="nav-number">1.3.1.</span> <span class="nav-text">1.3.1、bpf_obj_pin()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-2、bpf-obj-get"><span class="nav-number">1.3.2.</span> <span class="nav-text">1.3.2、bpf_obj_get()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2、Tracing类型的BPF程序"><span class="nav-number">2.</span> <span class="nav-text">2、Tracing类型的BPF程序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1、bpf程序的绑定"><span class="nav-number">2.1.</span> <span class="nav-text">2.1、bpf程序的绑定</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2、bpf程序的执行"><span class="nav-number">2.2.</span> <span class="nav-text">2.2、bpf程序的执行</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3、Filter类型的BPF程序"><span class="nav-number">3.</span> <span class="nav-text">3、Filter类型的BPF程序</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考资料："><span class="nav-number">4.</span> <span class="nav-text">参考资料：</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">pwl999</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v6.6.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script src="/js/src/utils.js?v=6.6.0"></script>

  <script src="/js/src/motion.js?v=6.6.0"></script>



  
  


  <script src="/js/src/affix.js?v=6.6.0"></script>

  <script src="/js/src/schemes/pisces.js?v=6.6.0"></script>



  
  <script src="/js/src/scrollspy.js?v=6.6.0"></script>
<script src="/js/src/post-details.js?v=6.6.0"></script>



  


  <script src="/js/src/bootstrap.js?v=6.6.0"></script>



  

  
    <script id="dsq-count-scr" src="https://.disqus.com/count.js" async></script>
  

  





  











  





  

  

  

  

  

  
  

  

  

  

  

  

  

</body>
</html>
