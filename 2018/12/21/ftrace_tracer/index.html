<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
































<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.6.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.6.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.6.0" color="#222">









<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.6.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="如trace event一章的描述，任何一种trace都离不开以下流程：  函数插桩。使用各种插桩方式把自己的trace函数插入到需要跟踪的probe point上； input trace数据。在trace的probe函数被命中时，会存储数据到ringbuffer当中；这里还包括filter和trigger功能； ouput trace数据。用户或者程序需要读出trace数据，根据需要输出ram">
<meta name="keywords" content="function tracer">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux Ftrace 1.3、tracer (function、function_graph、irq_off)">
<meta property="og:url" content="http://yoursite.com/2018/12/21/ftrace_tracer/index.html">
<meta property="og:site_name" content="pwl999&#39;s blog">
<meta property="og:description" content="如trace event一章的描述，任何一种trace都离不开以下流程：  函数插桩。使用各种插桩方式把自己的trace函数插入到需要跟踪的probe point上； input trace数据。在trace的probe函数被命中时，会存储数据到ringbuffer当中；这里还包括filter和trigger功能； ouput trace数据。用户或者程序需要读出trace数据，根据需要输出ram">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/images/ftrace_tracer/static_ftrace_probe.png">
<meta property="og:image" content="http://yoursite.com/images/ftrace_tracer/dynamic_ftrace_nop.png">
<meta property="og:image" content="http://yoursite.com/images/ftrace_tracer/dynamic_ftrace_probe.png">
<meta property="og:image" content="http://yoursite.com/images/ftrace_tracer/dynamic_ftrace_stub_manag.png">
<meta property="og:image" content="http://yoursite.com/images/ftrace_tracer/entry_function_tracer_format.png">
<meta property="og:image" content="http://yoursite.com/images/ftrace_tracer/function_graph_flow.png">
<meta property="og:image" content="http://yoursite.com/images/ftrace_tracer/dynamic_ftrace_stub_manag_graph.png">
<meta property="og:image" content="http://yoursite.com/images/ftrace_tracer/entry_trace_graph_entry.png">
<meta property="og:image" content="http://yoursite.com/images/ftrace_tracer/entry_trace_graph_return.png">
<meta property="og:image" content="http://yoursite.com/images/ftrace_tracer/irqoff_trace_flow.png">
<meta property="og:updated_time" content="2018-12-21T03:23:06.275Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Linux Ftrace 1.3、tracer (function、function_graph、irq_off)">
<meta name="twitter:description" content="如trace event一章的描述，任何一种trace都离不开以下流程：  函数插桩。使用各种插桩方式把自己的trace函数插入到需要跟踪的probe point上； input trace数据。在trace的probe函数被命中时，会存储数据到ringbuffer当中；这里还包括filter和trigger功能； ouput trace数据。用户或者程序需要读出trace数据，根据需要输出ram">
<meta name="twitter:image" content="http://yoursite.com/images/ftrace_tracer/static_ftrace_probe.png">






  <link rel="canonical" href="http://yoursite.com/2018/12/21/ftrace_tracer/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Linux Ftrace 1.3、tracer (function、function_graph、irq_off) | pwl999's blog</title>
  












  <noscript>
  <style>
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion .logo-line-before i { left: initial; }
    .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">pwl999's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/21/ftrace_tracer/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="pwl999">
      <meta itemprop="description" content="RTFSC(Read The Fucking Source Code)">
      <meta itemprop="image" content="/images/touxiang/ycqs.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="pwl999's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Linux Ftrace 1.3、tracer (function、function_graph、irq_off)

              
            
          </h1>
        

        <div class="post-meta">

          

        <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-21 10:18:21 / 修改时间：11:23:06" itemprop="dateCreated datePublished" datetime="2018-12-21T10:18:21+08:00">2018-12-21</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/Trace/" itemprop="url" rel="index"><span itemprop="name">Trace</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>如trace event一章的描述，任何一种trace都离不开以下流程：</p>
<ul>
<li>函数插桩。使用各种插桩方式把自己的trace函数插入到需要跟踪的probe point上；</li>
<li>input trace数据。在trace的probe函数被命中时，会存储数据到ringbuffer当中；这里还包括filter和trigger功能；</li>
<li>ouput trace数据。用户或者程序需要读出trace数据，根据需要输出ram数据或者是方面用户阅读的数据；对数据的解析，遵循谁存储谁提供解析规则的原则；</li>
</ul>
<p>以function tracer为首的tracer也遵循同样的流程。</p>
<h1 id="1、fucntion-tracer"><a href="#1、fucntion-tracer" class="headerlink" title="1、fucntion tracer"></a>1、fucntion tracer</h1><p>function tracer最大的难点在于：dynamic ftrace时(如不做说明本文默认dynamic)对大量插桩点的管理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root:/d/tracing # cat available_filter_functions | wc -l</span><br><span class="line">49099</span><br><span class="line">root:/d/tracing #</span><br><span class="line">root:/d/tracing # cat available_events | wc -l</span><br><span class="line">987</span><br></pre></td></tr></table></figure>
<p>可以看到上述一个普通的系统，function tracer的插桩点为49099个，trace event的插桩点为987个。function tracer的插桩点几乎大于trace event插桩点两个数量级，而且trace event的插桩点是每一个插桩点都是独立控制的，而function tracer的插桩点默认是一起控制的(也可以通过set_ftrace_filter、set_ftrace_notrace来分开控制)。</p>
<p>这么庞大的数量的插桩点。如果独立控制会消耗大量的内存，如果集中控制又怎么能实现部分的filter和command控制？一旦桩函数的实现不简洁，开销会迅速放大。对这部分感兴趣可以直接跳转到<a href="#dynamic_stub_manag">1.2.2、插桩点的动态管理</a>。</p>
<h2 id="1-1、插桩原理"><a href="#1-1、插桩原理" class="headerlink" title="1.1、插桩原理"></a>1.1、插桩原理</h2><h3 id="1-1-1、-mcount"><a href="#1-1-1、-mcount" class="headerlink" title="1.1.1、_mcount()"></a>1.1.1、_mcount()</h3><p>众所周知function trace是利用_mcount()函数进行插桩的。在gcc使用了“-pg”选项以后，会在每个函数的入口插入以下语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function:</span><br><span class="line">    ...</span><br><span class="line">    mov x0, x30</span><br><span class="line">    bl _mcount</span><br><span class="line">    [function&apos;s body ...]</span><br></pre></td></tr></table></figure>
<p>默认的_mcount函数是空操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(_mcount)</span><br><span class="line">	ret</span><br><span class="line">ENDPROC(_mcount)</span><br></pre></td></tr></table></figure>
<p>每个函数入口插入对_mcount()函数的调用，就是gcc提供的插桩机制。我们可以重新定义_mcount()函数中的内容，调用想要执行的内容。</p>
<h3 id="1-1-2、static-ftrace插桩"><a href="#1-1-2、static-ftrace插桩" class="headerlink" title="1.1.2、static ftrace插桩"></a>1.1.2、static ftrace插桩</h3><p>static ftrace就是使用重定义_mcount()函数的方法来实现插桩的:</p>
<p><img src="/images/ftrace_tracer/static_ftrace_probe.png" alt="image"></p>
<p>arch/arm64/kernel/entry-ftrace.S：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#ifndef CONFIG_DYNAMIC_FTRACE</span><br><span class="line">/*</span><br><span class="line"> * void _mcount(unsigned long return_address)</span><br><span class="line"> * @return_address: return address to instrumented function</span><br><span class="line"> *</span><br><span class="line"> * This function makes calls, if enabled, to:</span><br><span class="line"> *     - tracer function to probe instrumented function&apos;s entry,</span><br><span class="line"> *     - ftrace_graph_caller to set up an exit hook</span><br><span class="line"> */</span><br><span class="line">ENTRY(_mcount)</span><br><span class="line">	mcount_enter</span><br><span class="line"></span><br><span class="line">	adrp	x0, ftrace_trace_function</span><br><span class="line">	ldr	x2, [x0, #:lo12:ftrace_trace_function]</span><br><span class="line">	adr	x0, ftrace_stub</span><br><span class="line">	cmp	x0, x2			// if (ftrace_trace_function</span><br><span class="line">	b.eq	skip_ftrace_call	//     != ftrace_stub) &#123;</span><br><span class="line"></span><br><span class="line">	mcount_get_pc	x0		//       function&apos;s pc</span><br><span class="line">	mcount_get_lr	x1		//       function&apos;s lr (= parent&apos;s pc)</span><br><span class="line">	blr	x2			//   (*ftrace_trace_function)(pc, lr);</span><br><span class="line"></span><br><span class="line">#ifndef CONFIG_FUNCTION_GRAPH_TRACER</span><br><span class="line">skip_ftrace_call:			//   return;</span><br><span class="line">	mcount_exit			// &#125;</span><br><span class="line">#else</span><br><span class="line">	mcount_exit			//   return;</span><br><span class="line">					// &#125;</span><br><span class="line">skip_ftrace_call:</span><br><span class="line">	adrp	x1, ftrace_graph_return</span><br><span class="line">	ldr	x2, [x1, #:lo12:ftrace_graph_return]</span><br><span class="line">	cmp	x0, x2			//   if ((ftrace_graph_return</span><br><span class="line">	b.ne	ftrace_graph_caller	//        != ftrace_stub)</span><br><span class="line"></span><br><span class="line">	adrp	x1, ftrace_graph_entry	//     || (ftrace_graph_entry</span><br><span class="line">	adrp	x0, ftrace_graph_entry_stub //     != ftrace_graph_entry_stub))</span><br><span class="line">	ldr	x2, [x1, #:lo12:ftrace_graph_entry]</span><br><span class="line">	add	x0, x0, #:lo12:ftrace_graph_entry_stub</span><br><span class="line">	cmp	x0, x2</span><br><span class="line">	b.ne	ftrace_graph_caller	//     ftrace_graph_caller();</span><br><span class="line"></span><br><span class="line">	mcount_exit</span><br><span class="line">#endif /* CONFIG_FUNCTION_GRAPH_TRACER */</span><br><span class="line">ENDPROC(_mcount)</span><br><span class="line"></span><br><span class="line">#else /* CONFIG_DYNAMIC_FTRACE */</span><br></pre></td></tr></table></figure>
<p>对应的伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">void _mcount(void)</span><br><span class="line">&#123;</span><br><span class="line">        /* save any bare state needed in order to do initial checking */</span><br><span class="line"></span><br><span class="line">        /* (1) 如果函数指针ftrace_trace_function不等于默认的桩函数ftrace_stub， </span><br><span class="line">            调用function tracer的回调函数：ftrace_trace_function()</span><br><span class="line">         */</span><br><span class="line">        extern void (*ftrace_trace_function)(unsigned long, unsigned long);</span><br><span class="line">        if (ftrace_trace_function != ftrace_stub)</span><br><span class="line">                goto do_trace;</span><br><span class="line"></span><br><span class="line">        /* (2) 如果 (ftrace_trace_function = = ftrace_stub) &amp;&amp; </span><br><span class="line">            (ftrace_graph_return != ftrace_stub ||</span><br><span class="line">            ftrace_graph_entry != ftrace_graph_entry_stub)</span><br><span class="line">            调用function_graph tracer的回调函数：ftrace_graph_caller()</span><br><span class="line">         */</span><br><span class="line">+#ifdef CONFIG_FUNCTION_GRAPH_TRACER</span><br><span class="line">        extern void (*ftrace_graph_return)(...);</span><br><span class="line">        extern void (*ftrace_graph_entry)(...);</span><br><span class="line">        if (ftrace_graph_return != ftrace_stub ||</span><br><span class="line">            ftrace_graph_entry != ftrace_graph_entry_stub)</span><br><span class="line">                ftrace_graph_caller();</span><br><span class="line">+#endif</span><br><span class="line"></span><br><span class="line">        /* restore any bare state */</span><br><span class="line"></span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">do_trace:</span><br><span class="line"></span><br><span class="line">        /* save all state needed by the ABI (see paragraph above) */</span><br><span class="line"></span><br><span class="line">        unsigned long frompc = ...;</span><br><span class="line">        unsigned long selfpc = &lt;return address&gt; - MCOUNT_INSN_SIZE;</span><br><span class="line">        </span><br><span class="line">        /* (1.1) 调用function tracer的回调函数：ftrace_trace_function() */</span><br><span class="line">        ftrace_trace_function(frompc, selfpc);</span><br><span class="line"></span><br><span class="line">        /* restore all state needed by the ABI */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>问：static ftrace下，怎么保准notrace的函数不被跟踪？</p>
</blockquote>
<h3 id="1-1-3、dynamic-ftrace插桩"><a href="#1-1-3、dynamic-ftrace插桩" class="headerlink" title="1.1.3、dynamic ftrace插桩"></a>1.1.3、dynamic ftrace插桩</h3><p>static ftrace一旦使能，对kernel中所有的函数(除开notrace、online、其他特殊函数)进行插桩，这带来的性能开销是惊人的，有可能导致人们弃用ftrace功能。</p>
<p>为了解决这个问题，内核开发者推出了dynamic ftrace。因为实际上调试者一般不需要对所有函数进行追踪，只会对感兴趣的一部分函数进行追踪。dynamic ftrace把不需要追踪的函数入口处指令“bl _mcount”替换成“nop”，这样基本对性能无影响；对需要追踪的函替换入口处“bl _mcount”为需要调用的函数。</p>
<p>1、ftrace在初始化时，根据编译时“scripts/recordmcount.pl”脚本记录的所有函数入口处插桩位置的“bl _mcount”，将其替换成“nop”指令：</p>
<p><img src="/images/ftrace_tracer/dynamic_ftrace_nop.png" alt="image"></p>
<p>2、在tracer enable的时候，把需要跟踪的函数的插桩位置“nop”替换成“bl ftrace_caller”。</p>
<p>为什么不使用“bl _mcount”？主要原因是开发者不喜欢在_mcount()中使用宏来区分两种情况，索性重新创建一个新函数ftrace_caller()。</p>
<p><img src="/images/ftrace_tracer/dynamic_ftrace_probe.png" alt="image"></p>
<p>arch/arm64/kernel/entry-ftrace.S：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#ifndef CONFIG_DYNAMIC_FTRACE</span><br><span class="line">#else /* CONFIG_DYNAMIC_FTRACE */</span><br><span class="line">/*</span><br><span class="line"> * _mcount() is used to build the kernel with -pg option, but all the branch</span><br><span class="line"> * instructions to _mcount() are replaced to NOP initially at kernel start up,</span><br><span class="line"> * and later on, NOP to branch to ftrace_caller() when enabled or branch to</span><br><span class="line"> * NOP when disabled per-function base.</span><br><span class="line"> */</span><br><span class="line">ENTRY(_mcount)</span><br><span class="line">	ret</span><br><span class="line">ENDPROC(_mcount)</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * void ftrace_caller(unsigned long return_address)</span><br><span class="line"> * @return_address: return address to instrumented function</span><br><span class="line"> *</span><br><span class="line"> * This function is a counterpart of _mcount() in &apos;static&apos; ftrace, and</span><br><span class="line"> * makes calls to:</span><br><span class="line"> *     - tracer function to probe instrumented function&apos;s entry,</span><br><span class="line"> *     - ftrace_graph_caller to set up an exit hook</span><br><span class="line"> */</span><br><span class="line">ENTRY(ftrace_caller)</span><br><span class="line">	mcount_enter</span><br><span class="line"></span><br><span class="line">	mcount_get_pc0	x0		//     function&apos;s pc</span><br><span class="line">	mcount_get_lr	x1		//     function&apos;s lr</span><br><span class="line"></span><br><span class="line">	.global ftrace_call</span><br><span class="line">ftrace_call:				// tracer(pc, lr);</span><br><span class="line">	nop				// This will be replaced with &quot;bl xxx&quot;</span><br><span class="line">					// where xxx can be any kind of tracer.</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_FUNCTION_GRAPH_TRACER</span><br><span class="line">	.global ftrace_graph_call</span><br><span class="line">ftrace_graph_call:			// ftrace_graph_caller();</span><br><span class="line">	nop				// If enabled, this will be replaced</span><br><span class="line">					// &quot;b ftrace_graph_caller&quot;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	mcount_exit</span><br><span class="line">ENDPROC(ftrace_caller)</span><br><span class="line">#endif /* CONFIG_DYNAMIC_FTRACE */</span><br></pre></td></tr></table></figure>
<p>对应的伪代码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">void ftrace_caller(void)</span><br><span class="line">&#123;</span><br><span class="line">        /* save all state needed by the ABI (see paragraph above) */</span><br><span class="line"></span><br><span class="line">        unsigned long frompc = ...;</span><br><span class="line">        unsigned long selfpc = &lt;return address&gt; - MCOUNT_INSN_SIZE;</span><br><span class="line"></span><br><span class="line">        /* This will be replaced with &quot;bl xxx&quot; where xxx can be any kind of tracer. */</span><br><span class="line">        /* (1) function tracer的桩位置</span><br><span class="line">            放弃了函数指针，使用nop指令占位，在运行时动态修改指令到&quot;bl xxx&quot;</span><br><span class="line">         */</span><br><span class="line">ftrace_call:</span><br><span class="line">        nop     </span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_FUNCTION_GRAPH_TRACER</span><br><span class="line">        /* If enabled, this will be replaced &quot;b ftrace_graph_caller&quot; */</span><br><span class="line">        /* (2) function_graph tracer的桩位置</span><br><span class="line">            放弃了函数指针，使用nop指令占位，在运行时动态修改指令到&quot;b ftrace_graph_caller&quot;</span><br><span class="line">         */</span><br><span class="line">ftrace_graph_call:</span><br><span class="line">        nop    </span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">        /* restore all state needed by the ABI */</span><br><span class="line"></span><br><span class="line">        return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-2、插桩点管理"><a href="#1-2、插桩点管理" class="headerlink" title="1.2、插桩点管理"></a>1.2、插桩点管理</h2><h3 id="1-2-1、插桩点的初始化"><a href="#1-2-1、插桩点的初始化" class="headerlink" title="1.2.1、插桩点的初始化"></a>1.2.1、插桩点的初始化</h3><p>1、在编译的时候调用recordmcount.pl搜集所有_mcount()函数的调用点，并且所有的调用点地址保存到section __mcount_loc。</p>
<p>include/asm-generic/vmlinux.lds.h:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#ifdef CONFIG_FTRACE_MCOUNT_RECORD</span><br><span class="line">#define MCOUNT_REC()	. = ALIGN(8);				\</span><br><span class="line">			VMLINUX_SYMBOL(__start_mcount_loc) = .; \</span><br><span class="line">			*(__mcount_loc)				\</span><br><span class="line">			VMLINUX_SYMBOL(__stop_mcount_loc) = .;</span><br><span class="line">#else</span><br><span class="line">#define MCOUNT_REC()</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>并没有详细去研究其原理，感兴趣可以具体研究一下“scripts/recordmcount.pl、scripts/recordmcount.c”。</p>
<p>2、在初始化时，遍历section __mcount_loc的调用点地址，默认给所有“bl _mcount”替换成“nop”。</p>
<p>kernel/trace/ftrace.c：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br></pre></td><td class="code"><pre><span class="line">void __init ftrace_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	extern unsigned long __start_mcount_loc[];</span><br><span class="line">	extern unsigned long __stop_mcount_loc[];</span><br><span class="line">	unsigned long count, flags;</span><br><span class="line">	int ret;</span><br><span class="line"></span><br><span class="line">	local_irq_save(flags);</span><br><span class="line">	ret = ftrace_dyn_arch_init();</span><br><span class="line">	local_irq_restore(flags);</span><br><span class="line">	if (ret)</span><br><span class="line">		goto failed;</span><br><span class="line"></span><br><span class="line">	count = __stop_mcount_loc - __start_mcount_loc;</span><br><span class="line">	if (!count) &#123;</span><br><span class="line">		pr_info(&quot;ftrace: No functions to be traced?\n&quot;);</span><br><span class="line">		goto failed;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pr_info(&quot;ftrace: allocating %ld entries in %ld pages\n&quot;,</span><br><span class="line">		count, count / ENTRIES_PER_PAGE + 1);</span><br><span class="line"></span><br><span class="line">	last_ftrace_enabled = ftrace_enabled = 1;</span><br><span class="line"></span><br><span class="line">    /* 遍历section __mcount_loc，处理其中保存的调用地址 */</span><br><span class="line">	ret = ftrace_process_locs(NULL,</span><br><span class="line">				  __start_mcount_loc,</span><br><span class="line">				  __stop_mcount_loc);</span><br><span class="line"></span><br><span class="line">	ret = register_module_notifier(&amp;ftrace_module_exit_nb);</span><br><span class="line">	if (ret)</span><br><span class="line">		pr_warning(&quot;Failed to register trace ftrace module exit notifier\n&quot;);</span><br><span class="line"></span><br><span class="line">	set_ftrace_early_filters();</span><br><span class="line"></span><br><span class="line">	return;</span><br><span class="line"> failed:</span><br><span class="line">	ftrace_disabled = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">static int ftrace_process_locs(struct module *mod,</span><br><span class="line">			       unsigned long *start,</span><br><span class="line">			       unsigned long *end)</span><br><span class="line">&#123;</span><br><span class="line">	struct ftrace_page *start_pg;</span><br><span class="line">	struct ftrace_page *pg;</span><br><span class="line">	struct dyn_ftrace *rec;</span><br><span class="line">	unsigned long count;</span><br><span class="line">	unsigned long *p;</span><br><span class="line">	unsigned long addr;</span><br><span class="line">	unsigned long flags = 0; /* Shut up gcc */</span><br><span class="line">	int ret = -ENOMEM;</span><br><span class="line"></span><br><span class="line">	count = end - start;</span><br><span class="line"></span><br><span class="line">	if (!count)</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">    /* (1) 对地址进行排序 */</span><br><span class="line">	sort(start, count, sizeof(*start),</span><br><span class="line">	     ftrace_cmp_ips, NULL);</span><br><span class="line"></span><br><span class="line">    /* (2) 对每个地址分配新的dyn_ftrace结构来存储 </span><br><span class="line">        在section __mcount_loc中，只是简单的存储了unsigned long类型的调用地址</span><br><span class="line">        dyn_ftrace结构除了使用-&gt;ip来存储地址，还使用-&gt;flags来存储当前的状态和被引用计数</span><br><span class="line">     */</span><br><span class="line">	start_pg = ftrace_allocate_pages(count);</span><br><span class="line">	if (!start_pg)</span><br><span class="line">		return -ENOMEM;</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;ftrace_lock);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Core and each module needs their own pages, as</span><br><span class="line">	 * modules will free them when they are removed.</span><br><span class="line">	 * Force a new page to be allocated for modules.</span><br><span class="line">	 */</span><br><span class="line">	if (!mod) &#123;</span><br><span class="line">		WARN_ON(ftrace_pages || ftrace_pages_start);</span><br><span class="line">		/* First initialization */</span><br><span class="line">		ftrace_pages = ftrace_pages_start = start_pg;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		if (!ftrace_pages)</span><br><span class="line">			goto out;</span><br><span class="line"></span><br><span class="line">		if (WARN_ON(ftrace_pages-&gt;next)) &#123;</span><br><span class="line">			/* Hmm, we have free pages? */</span><br><span class="line">			while (ftrace_pages-&gt;next)</span><br><span class="line">				ftrace_pages = ftrace_pages-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ftrace_pages-&gt;next = start_pg;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (3) 更新dyn_ftrace新结构中的-&gt;ip字段 */</span><br><span class="line">	p = start;</span><br><span class="line">	pg = start_pg;</span><br><span class="line">	while (p &lt; end) &#123;</span><br><span class="line">		addr = ftrace_call_adjust(*p++);</span><br><span class="line">		/*</span><br><span class="line">		 * Some architecture linkers will pad between</span><br><span class="line">		 * the different mcount_loc sections of different</span><br><span class="line">		 * object files to satisfy alignments.</span><br><span class="line">		 * Skip any NULL pointers.</span><br><span class="line">		 */</span><br><span class="line">		if (!addr)</span><br><span class="line">			continue;</span><br><span class="line"></span><br><span class="line">		if (pg-&gt;index == pg-&gt;size) &#123;</span><br><span class="line">			/* We should have allocated enough */</span><br><span class="line">			if (WARN_ON(!pg-&gt;next))</span><br><span class="line">				break;</span><br><span class="line">			pg = pg-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		rec = &amp;pg-&gt;records[pg-&gt;index++];</span><br><span class="line">		rec-&gt;ip = addr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* We should have used all pages */</span><br><span class="line">	WARN_ON(pg-&gt;next);</span><br><span class="line"></span><br><span class="line">	/* Assign the last page to ftrace_pages */</span><br><span class="line">	ftrace_pages = pg;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * We only need to disable interrupts on start up</span><br><span class="line">	 * because we are modifying code that an interrupt</span><br><span class="line">	 * may execute, and the modification is not atomic.</span><br><span class="line">	 * But for modules, nothing runs the code we modify</span><br><span class="line">	 * until we are finished with it, and there&apos;s no</span><br><span class="line">	 * reason to cause large interrupt latencies while we do it.</span><br><span class="line">	 */</span><br><span class="line">	if (!mod)</span><br><span class="line">		local_irq_save(flags);</span><br><span class="line">	/* (4) 更新dyn_ftrace新结构中的-&gt;flags字段 </span><br><span class="line">	    默认给所有调用点替换成“nop”指令</span><br><span class="line">	 */</span><br><span class="line">	ftrace_update_code(mod, start_pg);</span><br><span class="line">	if (!mod)</span><br><span class="line">		local_irq_restore(flags);</span><br><span class="line">	ret = 0;</span><br><span class="line"> out:</span><br><span class="line">	mutex_unlock(&amp;ftrace_lock);</span><br><span class="line"></span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">||→</span><br><span class="line"></span><br><span class="line">static int ftrace_update_code(struct module *mod, struct ftrace_page *new_pgs)</span><br><span class="line">&#123;</span><br><span class="line">	struct ftrace_page *pg;</span><br><span class="line">	struct dyn_ftrace *p;</span><br><span class="line">	cycle_t start, stop;</span><br><span class="line">	unsigned long update_cnt = 0;</span><br><span class="line">	unsigned long ref = 0;</span><br><span class="line">	bool test = false;</span><br><span class="line">	int i;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * When adding a module, we need to check if tracers are</span><br><span class="line">	 * currently enabled and if they are set to trace all functions.</span><br><span class="line">	 * If they are, we need to enable the module functions as well</span><br><span class="line">	 * as update the reference counts for those function records.</span><br><span class="line">	 */</span><br><span class="line">	if (mod) &#123;</span><br><span class="line">		struct ftrace_ops *ops;</span><br><span class="line"></span><br><span class="line">		for (ops = ftrace_ops_list;</span><br><span class="line">		     ops != &amp;ftrace_list_end; ops = ops-&gt;next) &#123;</span><br><span class="line">			if (ops-&gt;flags &amp; FTRACE_OPS_FL_ENABLED) &#123;</span><br><span class="line">				if (ops_traces_mod(ops))</span><br><span class="line">					ref++;</span><br><span class="line">				else</span><br><span class="line">					test = true;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	start = ftrace_now(raw_smp_processor_id());</span><br><span class="line"></span><br><span class="line">    /* (4.1) 逐个遍历dyn_ftrace结构 */</span><br><span class="line">	for (pg = new_pgs; pg; pg = pg-&gt;next) &#123;</span><br><span class="line"></span><br><span class="line">		for (i = 0; i &lt; pg-&gt;index; i++) &#123;</span><br><span class="line">			int cnt = ref;</span><br><span class="line"></span><br><span class="line">			/* If something went wrong, bail without enabling anything */</span><br><span class="line">			if (unlikely(ftrace_disabled))</span><br><span class="line">				return -1;</span><br><span class="line"></span><br><span class="line">			p = &amp;pg-&gt;records[i];</span><br><span class="line">			/* (4.2) 根据有多少个filter操作对调用点地址的引用， </span><br><span class="line">			    给dyn_ftrace-&gt;flags字段中的引用count部分赋值</span><br><span class="line">			 */</span><br><span class="line">			if (test)</span><br><span class="line">				cnt += referenced_filters(p);</span><br><span class="line">			p-&gt;flags = cnt;</span><br><span class="line"></span><br><span class="line">			/*</span><br><span class="line">			 * Do the initial record conversion from mcount jump</span><br><span class="line">			 * to the NOP instructions.</span><br><span class="line">			 */</span><br><span class="line">			/* (4.3) 默认把所有的调用点修改成“nop” */</span><br><span class="line">			if (!ftrace_code_disable(mod, p))</span><br><span class="line">				break;</span><br><span class="line"></span><br><span class="line">			update_cnt++;</span><br><span class="line"></span><br><span class="line">			/*</span><br><span class="line">			 * If the tracing is enabled, go ahead and enable the record.</span><br><span class="line">			 *</span><br><span class="line">			 * The reason not to enable the record immediatelly is the</span><br><span class="line">			 * inherent check of ftrace_make_nop/ftrace_make_call for</span><br><span class="line">			 * correct previous instructions.  Making first the NOP</span><br><span class="line">			 * conversion puts the module to the correct state, thus</span><br><span class="line">			 * passing the ftrace_make_call check.</span><br><span class="line">			 */</span><br><span class="line">			if (ftrace_start_up &amp;&amp; cnt) &#123;</span><br><span class="line">			    /* (4.4) 如果tracing已经使能，且引用计数不为0 </span><br><span class="line">			        使能这个调用点</span><br><span class="line">			     */</span><br><span class="line">				int failed = __ftrace_replace_code(p, 1);</span><br><span class="line">				if (failed)</span><br><span class="line">					ftrace_bug(failed, p);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	stop = ftrace_now(raw_smp_processor_id());</span><br><span class="line">	ftrace_update_time = stop - start;</span><br><span class="line">	ftrace_update_tot_cnt += update_cnt;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-2、插桩点的动态管理"><a href="#1-2-2、插桩点的动态管理" class="headerlink" title="1.2.2、插桩点的动态管理 "></a>1.2.2、插桩点的动态管理<a id="dynamic_stub_manag"> </a></h3><p>为了应对本文最开始处提出的难题，内核使用了插桩点控制链表+命令hash表的形式。</p>
<p><img src="/images/ftrace_tracer/dynamic_ftrace_stub_manag.png" alt="image"></p>
<p>function tracer插桩点动态管理的原理：</p>
<ul>
<li>1、每个“bl _mcount”的插桩点ip对应一个每个插桩点对应一个dyn_ftrace结构。dyn_ftrace-&gt;flags的低26bit用来表示引用计数，如果有ftrcae_ops会操作到该ip，引用计数会加1。如果ref_cnt大于0，插桩点就需要使能了，把其替换为“bl ftrace_caller”；</li>
<li>2、ftrcae_ops采用hash表来表达对ip的引用，一个ftrcae_ops有两张hash表filter_hash和notrace_hash，综合的结果就是对ip的引用。function tracer模式时，有两个可能的ftrcae_ops：global_ops、trace_probe_ops。两个中任意一个引用到ip，都会造成ip的1级插桩点被替换为“bl ftrace_caller”；</li>
<li>3、通过设置“set_ftrace_filter/set_ftrace_notrace”会造成对global_ops的filter_hash/notrace_hash的配置，它的作用是配置function tracer的filter；</li>
<li>4、通过设置“set_ftrace_filter”会造成对trace_probe_ops的filter_hash的配置，它的作用是配置filter command，并且会把command和对应的ip加入到另外一张另外一张hash表ftrace_func_hash表中；</li>
<li>5、ftrace_caller()有两个2级插桩点：ftrace_call、ftrace_graph_call。在function tracer模式时，只有ftrace_call被设置成“bl  ftrace_ops_list_func”；</li>
<li>6、ftrace_ops_list_func()的工作就是遍历ftrace_ops_list链表，逐个执行其中的ftrace_ops-&gt;func()。</li>
<li>7、global_ops的-&gt;func()函数为function_trace_call()，记录trace数据：ip + parent_ip；</li>
<li>8、trace_probe_ops的-&gt;func()函数为function_trace_probe_call()，逐个执行ftrace_func_hash表中，ip为本ip的filter command。</li>
</ul>
<p>有以下几种场景，涉及到插桩点的动态管理：</p>
<ul>
<li>tracer的使能。当使用“echo xxx_tracer &gt; current_tracer”时，会关闭旧的current tracer并使能新的tracer。典型的包括function tracer合入function_graph tracer；</li>
<li>filter的配置。使用“echo function_name &gt; set_ftrace_filter/set_ftrace_notrace”，可以配置部分function被trace，而不是所有function被trace；</li>
<li>filter command的配置。使用“echo ‘!__schedule_bug:traceoff’ &gt; set_ftrace_filter”，类似命令可以配置条件触发的command，当条件满足后command会被执行；</li>
</ul>
<p>下面我们看看具体场景下的代码实现细节：</p>
<h3 id="1-2-3、tracer注册"><a href="#1-2-3、tracer注册" class="headerlink" title="1.2.3、tracer注册"></a>1.2.3、tracer注册</h3><p>1、tracer注册。tracer可以通过register_tracer()进行注册。</p>
<p>以function tracer为例，kernel/trace/trace_functions.c：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static struct tracer function_trace __tracer_data =</span><br><span class="line">&#123;</span><br><span class="line">	.name		= &quot;function&quot;,</span><br><span class="line">	.init		= function_trace_init,</span><br><span class="line">	.reset		= function_trace_reset,</span><br><span class="line">	.start		= function_trace_start,</span><br><span class="line">	.flags		= &amp;func_flags,</span><br><span class="line">	.set_flag	= func_set_flag,</span><br><span class="line">	.allow_instances = true,</span><br><span class="line">#ifdef CONFIG_FTRACE_SELFTEST</span><br><span class="line">	.selftest	= trace_selftest_startup_function,</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static __init int init_function_trace(void)</span><br><span class="line">&#123;</span><br><span class="line">	init_func_cmd_traceon();</span><br><span class="line">	return register_tracer(&amp;function_trace);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>register_tracer()的实现，kernel/trace/trace.c：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">int __init register_tracer(struct tracer *type)</span><br><span class="line">&#123;</span><br><span class="line">	struct tracer *t;</span><br><span class="line">	int ret = 0;</span><br><span class="line"></span><br><span class="line">	if (!type-&gt;name) &#123;</span><br><span class="line">		pr_info(&quot;Tracer must have a name\n&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (strlen(type-&gt;name) &gt;= MAX_TRACER_SIZE) &#123;</span><br><span class="line">		pr_info(&quot;Tracer has a name longer than %d\n&quot;, MAX_TRACER_SIZE);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;trace_types_lock);</span><br><span class="line"></span><br><span class="line">	tracing_selftest_running = true;</span><br><span class="line"></span><br><span class="line">    /* (1) 如果tracer已经注册，直接返回 */</span><br><span class="line">	for (t = trace_types; t; t = t-&gt;next) &#123;</span><br><span class="line">		if (strcmp(type-&gt;name, t-&gt;name) == 0) &#123;</span><br><span class="line">			/* already found */</span><br><span class="line">			pr_info(&quot;Tracer %s already registered\n&quot;,</span><br><span class="line">				type-&gt;name);</span><br><span class="line">			ret = -1;</span><br><span class="line">			goto out;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (2) tracer对应的相关trace_option */</span><br><span class="line">	if (!type-&gt;set_flag)</span><br><span class="line">		type-&gt;set_flag = &amp;dummy_set_flag;</span><br><span class="line">	if (!type-&gt;flags)</span><br><span class="line">		type-&gt;flags = &amp;dummy_tracer_flags;</span><br><span class="line">	else</span><br><span class="line">		if (!type-&gt;flags-&gt;opts)</span><br><span class="line">			type-&gt;flags-&gt;opts = dummy_tracer_opt;</span><br><span class="line"></span><br><span class="line">	ret = run_tracer_selftest(type);</span><br><span class="line">	if (ret &lt; 0)</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">    /* (3) 将新的tracer加入到trace_types链表中 */</span><br><span class="line">	type-&gt;next = trace_types;</span><br><span class="line">	trace_types = type;</span><br><span class="line">	add_tracer_options(&amp;global_trace, type);</span><br><span class="line"></span><br><span class="line"> out:</span><br><span class="line">	tracing_selftest_running = false;</span><br><span class="line">	mutex_unlock(&amp;trace_types_lock);</span><br><span class="line"></span><br><span class="line">	if (ret || !default_bootup_tracer)</span><br><span class="line">		goto out_unlock;</span><br><span class="line"></span><br><span class="line">	if (strncmp(default_bootup_tracer, type-&gt;name, MAX_TRACER_SIZE))</span><br><span class="line">		goto out_unlock;</span><br><span class="line"></span><br><span class="line">	printk(KERN_INFO &quot;Starting tracer &apos;%s&apos;\n&quot;, type-&gt;name);</span><br><span class="line">	/* Do we want this tracer to start on bootup? */</span><br><span class="line">	/* (4) 设置boot默认的tracer */</span><br><span class="line">	tracing_set_tracer(&amp;global_trace, type-&gt;name);</span><br><span class="line">	default_bootup_tracer = NULL;</span><br><span class="line"></span><br><span class="line">	apply_trace_boot_options();</span><br><span class="line"></span><br><span class="line">	/* disable other selftests, since this will break it. */</span><br><span class="line">	tracing_selftest_disabled = true;</span><br><span class="line">#ifdef CONFIG_FTRACE_STARTUP_TEST</span><br><span class="line">	printk(KERN_INFO &quot;Disabling FTRACE selftests due to running tracer &apos;%s&apos;\n&quot;,</span><br><span class="line">	       type-&gt;name);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"> out_unlock:</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-4、tracer使能"><a href="#1-2-4、tracer使能" class="headerlink" title="1.2.4、tracer使能"></a>1.2.4、tracer使能</h3><p>2、tracer使能。我们可以使用“echo function &gt; current_tracer”命令来使能或者切换tracer。</p>
<p>来具体看看其代码实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line">trace_create_file(&quot;current_tracer&quot;, 0644, d_tracer,</span><br><span class="line">		tr, &amp;set_tracer_fops);</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static const struct file_operations set_tracer_fops = &#123;</span><br><span class="line">	.open		= tracing_open_generic,</span><br><span class="line">	.read		= tracing_set_trace_read,</span><br><span class="line">	.write		= tracing_set_trace_write,</span><br><span class="line">	.llseek		= generic_file_llseek,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static ssize_t</span><br><span class="line">tracing_set_trace_write(struct file *filp, const char __user *ubuf,</span><br><span class="line">			size_t cnt, loff_t *ppos)</span><br><span class="line">&#123;</span><br><span class="line">    /* (1) 当前文件所在trace buffer，默认是global_trace </span><br><span class="line">        初始化时：</span><br><span class="line">        init_tracer_tracefs(&amp;global_trace, d_tracer); -&gt; </span><br><span class="line">        trace_create_file(&quot;current_tracer&quot;, 0644, d_tracer,	tr, &amp;set_tracer_fops);</span><br><span class="line">     */</span><br><span class="line">	struct trace_array *tr = filp-&gt;private_data;</span><br><span class="line">	char buf[MAX_TRACER_SIZE+1];</span><br><span class="line">	int i;</span><br><span class="line">	size_t ret;</span><br><span class="line">	int err;</span><br><span class="line"></span><br><span class="line">	ret = cnt;</span><br><span class="line"></span><br><span class="line">	if (cnt &gt; MAX_TRACER_SIZE)</span><br><span class="line">		cnt = MAX_TRACER_SIZE;</span><br><span class="line"></span><br><span class="line">	if (copy_from_user(&amp;buf, ubuf, cnt))</span><br><span class="line">		return -EFAULT;</span><br><span class="line"></span><br><span class="line">	buf[cnt] = 0;</span><br><span class="line"></span><br><span class="line">	/* strip ending whitespace. */</span><br><span class="line">	for (i = cnt - 1; i &gt; 0 &amp;&amp; isspace(buf[i]); i--)</span><br><span class="line">		buf[i] = 0;</span><br><span class="line"></span><br><span class="line">    /* (2) 使能新的tracer */</span><br><span class="line">	err = tracing_set_tracer(tr, buf);</span><br><span class="line">	if (err)</span><br><span class="line">		return err;</span><br><span class="line"></span><br><span class="line">	*ppos += ret;</span><br><span class="line"></span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">static int tracing_set_tracer(struct trace_array *tr, const char *buf)</span><br><span class="line">&#123;</span><br><span class="line">	struct tracer *t;</span><br><span class="line">#ifdef CONFIG_TRACER_MAX_TRACE</span><br><span class="line">	bool had_max_tr;</span><br><span class="line">#endif</span><br><span class="line">	int ret = 0;</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;trace_types_lock);</span><br><span class="line"></span><br><span class="line">	if (!ring_buffer_expanded) &#123;</span><br><span class="line">		ret = __tracing_resize_ring_buffer(tr, trace_buf_size,</span><br><span class="line">						RING_BUFFER_ALL_CPUS);</span><br><span class="line">		if (ret &lt; 0)</span><br><span class="line">			goto out;</span><br><span class="line">		ret = 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (2.1) 根据名字，在trace_types链表中找到对应的tracer */</span><br><span class="line">	for (t = trace_types; t; t = t-&gt;next) &#123;</span><br><span class="line">		if (strcmp(t-&gt;name, buf) == 0)</span><br><span class="line">			break;</span><br><span class="line">	&#125;</span><br><span class="line">	if (!t) &#123;</span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">		goto out;</span><br><span class="line">	&#125;</span><br><span class="line">	if (t == tr-&gt;current_trace)</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">	/* Some tracers are only allowed for the top level buffer */</span><br><span class="line">	if (!trace_ok_for_array(t, tr)) &#123;</span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">		goto out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* If trace pipe files are being read, we can&apos;t change the tracer */</span><br><span class="line">	if (tr-&gt;current_trace-&gt;ref) &#123;</span><br><span class="line">		ret = -EBUSY;</span><br><span class="line">		goto out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	trace_branch_disable();</span><br><span class="line"></span><br><span class="line">    /* (2.2) 去使能旧的当前tracer */</span><br><span class="line">	tr-&gt;current_trace-&gt;enabled--;</span><br><span class="line"></span><br><span class="line">	if (tr-&gt;current_trace-&gt;reset)</span><br><span class="line">		tr-&gt;current_trace-&gt;reset(tr);</span><br><span class="line"></span><br><span class="line">	/* Current trace needs to be nop_trace before synchronize_sched */</span><br><span class="line">	tr-&gt;current_trace = &amp;nop_trace;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_TRACER_MAX_TRACE</span><br><span class="line">	had_max_tr = tr-&gt;allocated_snapshot;</span><br><span class="line"></span><br><span class="line">	if (had_max_tr &amp;&amp; !t-&gt;use_max_tr) &#123;</span><br><span class="line">		/*</span><br><span class="line">		 * We need to make sure that the update_max_tr sees that</span><br><span class="line">		 * current_trace changed to nop_trace to keep it from</span><br><span class="line">		 * swapping the buffers after we resize it.</span><br><span class="line">		 * The update_max_tr is called from interrupts disabled</span><br><span class="line">		 * so a synchronized_sched() is sufficient.</span><br><span class="line">		 */</span><br><span class="line">		synchronize_sched();</span><br><span class="line">		free_snapshot(tr);</span><br><span class="line">	&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_TRACER_MAX_TRACE</span><br><span class="line">	if (t-&gt;use_max_tr &amp;&amp; !had_max_tr) &#123;</span><br><span class="line">		ret = alloc_snapshot(tr);</span><br><span class="line">		if (ret &lt; 0)</span><br><span class="line">			goto out;</span><br><span class="line">	&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    /* (2.3) 调用新tracer的init函数 */</span><br><span class="line">	if (t-&gt;init) &#123;</span><br><span class="line">		ret = tracer_init(t, tr);</span><br><span class="line">		if (ret)</span><br><span class="line">			goto out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (2.4) 把新的tracer设置为当前tracer */</span><br><span class="line">	tr-&gt;current_trace = t;</span><br><span class="line">	tr-&gt;current_trace-&gt;enabled++;</span><br><span class="line">	trace_branch_enable(tr);</span><br><span class="line"> out:</span><br><span class="line">	mutex_unlock(&amp;trace_types_lock);</span><br><span class="line"></span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">||→</span><br><span class="line"></span><br><span class="line">int tracer_init(struct tracer *t, struct trace_array *tr)</span><br><span class="line">&#123;</span><br><span class="line">	tracing_reset_online_cpus(&amp;tr-&gt;trace_buffer);</span><br><span class="line">	return t-&gt;init(tr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-5、function-tracer使能"><a href="#1-2-5、function-tracer使能" class="headerlink" title="1.2.5、function tracer使能  "></a>1.2.5、function tracer使能 <a id="function_tracer_enable"> </a></h3><p>3、function tracer的使能。本质上是global_ops的注册后使能。</p>
<p>在初始化的时候，把global_trace的-&gt;ops初始化成了global_ops。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">start_kernel() -&gt; trace_init() -&gt; tracer_alloc_buffers:</span><br><span class="line"></span><br><span class="line">tracer_alloc_buffers</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    ftrace_init_global_array_ops(&amp;global_trace);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">__init void ftrace_init_global_array_ops(struct trace_array *tr)</span><br><span class="line">&#123;</span><br><span class="line">	tr-&gt;ops = &amp;global_ops;</span><br><span class="line">	tr-&gt;ops-&gt;private = tr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static struct ftrace_ops global_ops = &#123;</span><br><span class="line">	.func				= ftrace_stub,</span><br><span class="line">	.local_hash.notrace_hash	= EMPTY_HASH,</span><br><span class="line">	.local_hash.filter_hash		= EMPTY_HASH,</span><br><span class="line">	INIT_OPS_HASH(global_ops)</span><br><span class="line">	.flags				= FTRACE_OPS_FL_RECURSION_SAFE |</span><br><span class="line">					  FTRACE_OPS_FL_INITIALIZED |</span><br><span class="line">					  FTRACE_OPS_FL_PID,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>继续分析t-&gt;init()，以function tracer为例，调用到function_trace_init()：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br></pre></td><td class="code"><pre><span class="line">static int function_trace_init(struct trace_array *tr)</span><br><span class="line">&#123;</span><br><span class="line">	ftrace_func_t func;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Instance trace_arrays get their ops allocated</span><br><span class="line">	 * at instance creation. Unless it failed</span><br><span class="line">	 * the allocation.</span><br><span class="line">	 */</span><br><span class="line">	/* (2.4.1) 这里的tr默认就是global_trace </span><br><span class="line">	    这里的tr-&gt;ops默认是global_ops</span><br><span class="line">	 */</span><br><span class="line">	if (!tr-&gt;ops)</span><br><span class="line">		return -ENOMEM;</span><br><span class="line"></span><br><span class="line">    /* (2.4.2) func为保存trace信息到ringbuffer的函数 */</span><br><span class="line">	/* Currently only the global instance can do stack tracing */</span><br><span class="line">	if (tr-&gt;flags &amp; TRACE_ARRAY_FL_GLOBAL &amp;&amp;</span><br><span class="line">	    func_flags.val &amp; TRACE_FUNC_OPT_STACK)</span><br><span class="line">		func = function_stack_trace_call;</span><br><span class="line">	else</span><br><span class="line">		func = function_trace_call;</span><br><span class="line"></span><br><span class="line">    /* (2.4.3) tr-&gt;ops-&gt;func = func */</span><br><span class="line">	ftrace_init_array_ops(tr, func);</span><br><span class="line"></span><br><span class="line">	tr-&gt;trace_buffer.cpu = get_cpu();</span><br><span class="line">	put_cpu();</span><br><span class="line"></span><br><span class="line">	tracing_start_cmdline_record();</span><br><span class="line">	</span><br><span class="line">	/* (2.4.4) 启动function tracer </span><br><span class="line">	    将tr-&gt;ops也加入到ftrace_ops_list当中</span><br><span class="line">	 */</span><br><span class="line">	tracing_start_function_trace(tr);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static void tracing_start_function_trace(struct trace_array *tr)</span><br><span class="line">&#123;</span><br><span class="line">	tr-&gt;function_enabled = 0;</span><br><span class="line">	register_ftrace_function(tr-&gt;ops);</span><br><span class="line">	tr-&gt;function_enabled = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">int register_ftrace_function(struct ftrace_ops *ops)</span><br><span class="line">&#123;</span><br><span class="line">	int ret = -1;</span><br><span class="line"></span><br><span class="line">    /* (2.4.4.1) 初始化hash表 </span><br><span class="line">        ops-&gt;func_hash = &amp;ops-&gt;local_hash;</span><br><span class="line">     */</span><br><span class="line">	ftrace_ops_init(ops);</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;ftrace_lock);</span><br><span class="line"></span><br><span class="line">    /* (2.4.4.2) 将global_ops加入ftrace_ops_list </span><br><span class="line">        并且根据情况，修改各个桩位置的指令</span><br><span class="line">     */</span><br><span class="line">	ret = ftrace_startup(ops, 0);</span><br><span class="line"></span><br><span class="line">	mutex_unlock(&amp;ftrace_lock);</span><br><span class="line"></span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">||→</span><br><span class="line"></span><br><span class="line">static int ftrace_startup(struct ftrace_ops *ops, int command)</span><br><span class="line">&#123;</span><br><span class="line">	int ret;</span><br><span class="line"></span><br><span class="line">	if (unlikely(ftrace_disabled))</span><br><span class="line">		return -ENODEV;</span><br><span class="line"></span><br><span class="line">    /* (2.4.4.2.1) 1、把global_ops加入ftrace_ops_list </span><br><span class="line">        2、根据ftrace_ops_list链表中成员的情况给ftrace_trace_function指针赋值：</span><br><span class="line">            ftrace_ops_list链表为空，= ftrace_stub</span><br><span class="line">            ftrace_ops_list链表有1个成员，= ftrace_ops_get_list_func(ftrace_ops_list)</span><br><span class="line">            ftrace_ops_list链表有多个成员，= ftrace_ops_list_func</span><br><span class="line">        3、更新ftrace_graph_entry</span><br><span class="line">    */</span><br><span class="line">	ret = __register_ftrace_function(ops);</span><br><span class="line">	if (ret)</span><br><span class="line">		return ret;</span><br><span class="line"></span><br><span class="line">	ftrace_start_up++;</span><br><span class="line">	command |= FTRACE_UPDATE_CALLS;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Note that ftrace probes uses this to start up</span><br><span class="line">	 * and modify functions it will probe. But we still</span><br><span class="line">	 * set the ADDING flag for modification, as probes</span><br><span class="line">	 * do not have trampolines. If they add them in the</span><br><span class="line">	 * future, then the probes will need to distinguish</span><br><span class="line">	 * between adding and updating probes.</span><br><span class="line">	 */</span><br><span class="line">	ops-&gt;flags |= FTRACE_OPS_FL_ENABLED | FTRACE_OPS_FL_ADDING;</span><br><span class="line"></span><br><span class="line">    /* (2.4.4.2.2) 遍历全部_mcount插桩点ftrace_rec </span><br><span class="line">        根据ip在新、旧hash表中的变化，设置对应rec-&gt;flags中的FTRACE_FL_IPMODIFY</span><br><span class="line">     */</span><br><span class="line">	ret = ftrace_hash_ipmodify_enable(ops);</span><br><span class="line">	if (ret &lt; 0) &#123;</span><br><span class="line">		/* Rollback registration process */</span><br><span class="line">		__unregister_ftrace_function(ops);</span><br><span class="line">		ftrace_start_up--;</span><br><span class="line">		ops-&gt;flags &amp;= ~FTRACE_OPS_FL_ENABLED;</span><br><span class="line">		return ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (2.4.4.2.3) 遍历全部_mcount插桩点ftrace_rec </span><br><span class="line">        根据filter_hash、notrace_hash是否match ip，给对应rec-&gt;flags中ref_cnt进行加1/减1操作</span><br><span class="line">     */</span><br><span class="line">	ftrace_hash_rec_enable(ops, 1);</span><br><span class="line"></span><br><span class="line">    /* (2.4.4.2.4) 更新插桩点： </span><br><span class="line">        FTRACE_UPDATE_CALLS被设置，更新_mcount插桩点：ref_cnt大于0的插桩点，更新成ftrace_caller()</span><br><span class="line">        FTRACE_UPDATE_TRACE_FUNC被设置，更新ftrace_call插桩点：更新成ftrace_trace_function指向的函数</span><br><span class="line">        FTRACE_START_FUNC_RET被设置，更新ftrace_graph_call插桩点：更新成ftrace_graph_caller()</span><br><span class="line">     */</span><br><span class="line">	ftrace_startup_enable(command);</span><br><span class="line"></span><br><span class="line">	ops-&gt;flags &amp;= ~FTRACE_OPS_FL_ADDING;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">ftrace_startup_enable() -&gt; ftrace_run_update_code() -&gt; arch_ftrace_update_code() -&gt; ftrace_modify_all_code() -&gt; </span><br><span class="line"></span><br><span class="line">void ftrace_modify_all_code(int command)</span><br><span class="line">&#123;</span><br><span class="line">	int update = command &amp; FTRACE_UPDATE_TRACE_FUNC;</span><br><span class="line">	int err = 0;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * If the ftrace_caller calls a ftrace_ops func directly,</span><br><span class="line">	 * we need to make sure that it only traces functions it</span><br><span class="line">	 * expects to trace. When doing the switch of functions,</span><br><span class="line">	 * we need to update to the ftrace_ops_list_func first</span><br><span class="line">	 * before the transition between old and new calls are set,</span><br><span class="line">	 * as the ftrace_ops_list_func will check the ops hashes</span><br><span class="line">	 * to make sure the ops are having the right functions</span><br><span class="line">	 * traced.</span><br><span class="line">	 */</span><br><span class="line">	/* (2.4.4.2.4.1) 如果FTRACE_UPDATE_TRACE_FUNC被设置，对于ftrace_call插桩点，</span><br><span class="line">	    直接调用ftrace_ops_list链表中某个ftrace_ops的操作需要谨慎 </span><br><span class="line">	    保险起见，默认还是使用ftrace_ops_list_func()，它会轮询ftrace_ops_list链表中所有ftrace_ops</span><br><span class="line">	 */</span><br><span class="line">	if (update) &#123;</span><br><span class="line">		err = ftrace_update_ftrace_func(ftrace_ops_list_func);</span><br><span class="line">		if (FTRACE_WARN_ON(err))</span><br><span class="line">			return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (2.4.4.2.4.2) 如果FTRACE_UPDATE_CALLS被设置，对于_mcount插桩点，</span><br><span class="line">        遍历全部ftrace_rec，ref_cnt大于0的插桩点，更新成ftrace_caller()</span><br><span class="line">     */</span><br><span class="line">	if (command &amp; FTRACE_UPDATE_CALLS)</span><br><span class="line">		ftrace_replace_code(1);</span><br><span class="line">	else if (command &amp; FTRACE_DISABLE_CALLS)</span><br><span class="line">		ftrace_replace_code(0);</span><br><span class="line"></span><br><span class="line">    /* (2.4.4.2.4.3) 如果FTRACE_UPDATE_TRACE_FUNC被设置，对于ftrace_call插桩点，</span><br><span class="line">        如果ftrace_trace_function确实不等于ftrace_ops_list_func()</span><br><span class="line">        更新成ftrace_trace_function指向的函数</span><br><span class="line">     */</span><br><span class="line">	if (update &amp;&amp; ftrace_trace_function != ftrace_ops_list_func) &#123;</span><br><span class="line">		function_trace_op = set_function_trace_op;</span><br><span class="line">		smp_wmb();</span><br><span class="line">		/* If irqs are disabled, we are in stop machine */</span><br><span class="line">		if (!irqs_disabled())</span><br><span class="line">			smp_call_function(ftrace_sync_ipi, NULL, 1);</span><br><span class="line">		err = ftrace_update_ftrace_func(ftrace_trace_function);</span><br><span class="line">		if (FTRACE_WARN_ON(err))</span><br><span class="line">			return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (2.4.4.2.4.4) 如果FTRACE_START_FUNC_RET被设置，对于ftrace_graph_call插桩点，</span><br><span class="line">        更新成ftrace_graph_caller()</span><br><span class="line">     */</span><br><span class="line">	if (command &amp; FTRACE_START_FUNC_RET)</span><br><span class="line">		err = ftrace_enable_ftrace_graph_caller();</span><br><span class="line">	else if (command &amp; FTRACE_STOP_FUNC_RET)</span><br><span class="line">		err = ftrace_disable_ftrace_graph_caller();</span><br><span class="line">	FTRACE_WARN_ON(err);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">void __weak ftrace_replace_code(int enable)</span><br><span class="line">&#123;</span><br><span class="line">	struct dyn_ftrace *rec;</span><br><span class="line">	struct ftrace_page *pg;</span><br><span class="line">	int failed;</span><br><span class="line"></span><br><span class="line">	if (unlikely(ftrace_disabled))</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">    /* 遍历ftrace_rec */</span><br><span class="line">	do_for_each_ftrace_rec(pg, rec) &#123;</span><br><span class="line">		failed = __ftrace_replace_code(rec, enable);</span><br><span class="line">		if (failed) &#123;</span><br><span class="line">			ftrace_bug(failed, rec);</span><br><span class="line">			/* Stop processing */</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; while_for_each_ftrace_rec();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static int</span><br><span class="line">__ftrace_replace_code(struct dyn_ftrace *rec, int enable)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned long ftrace_old_addr;</span><br><span class="line">	unsigned long ftrace_addr;</span><br><span class="line">	int ret;</span><br><span class="line"></span><br><span class="line">    /* (2.4.4.2.4.2.1) _mcount插桩点使能后的地址为： </span><br><span class="line">        ops-&gt;trampoline or ftrace_caller</span><br><span class="line">     */</span><br><span class="line">	ftrace_addr = ftrace_get_addr_new(rec);</span><br><span class="line"></span><br><span class="line">	/* This needs to be done before we call ftrace_update_record */</span><br><span class="line">	ftrace_old_addr = ftrace_get_addr_curr(rec);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    /* (2.4.4.2.4.2.2) 根据rec-&gt;flags中的flag和refcnt，以及enable </span><br><span class="line">        得出操作是：FTRACE_UPDATE_IGNORE/FTRACE_UPDATE_MAKE_CALL/FTRACE_UPDATE_MAKE_NOP</span><br><span class="line">     */</span><br><span class="line">	ret = ftrace_update_record(rec, enable);</span><br><span class="line"></span><br><span class="line">    /* (2.4.4.2.4.2.3) 修改_mcount插桩点处的指令为新的桩函数跳转指令 */</span><br><span class="line">	switch (ret) &#123;</span><br><span class="line">	case FTRACE_UPDATE_IGNORE:</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">	case FTRACE_UPDATE_MAKE_CALL:</span><br><span class="line">		return ftrace_make_call(rec, ftrace_addr);</span><br><span class="line"></span><br><span class="line">	case FTRACE_UPDATE_MAKE_NOP:</span><br><span class="line">		return ftrace_make_nop(NULL, rec, ftrace_old_addr);</span><br><span class="line"></span><br><span class="line">	case FTRACE_UPDATE_MODIFY_CALL:</span><br><span class="line">		return ftrace_modify_call(rec, ftrace_old_addr, ftrace_addr);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return -1; /* unknow ftrace bug */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-6、配置function-tracer的filter"><a href="#1-2-6、配置function-tracer的filter" class="headerlink" title="1.2.6、配置function tracer的filter  "></a>1.2.6、配置function tracer的filter <a id="set_ftrace_filter"> </a></h3><p>4、通过“set_ftrace_filter”、“set_ftrace_notrace”设置function trcer的filter。本质上是操作global_ops的filter_hash、notrace_hash。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/* global_ops注册成inode-&gt;i_private */</span><br><span class="line">ftrace_create_filter_files(&amp;global_ops, d_tracer);</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">void ftrace_create_filter_files(struct ftrace_ops *ops,</span><br><span class="line">				struct dentry *parent)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	trace_create_file(&quot;set_ftrace_filter&quot;, 0644, parent,</span><br><span class="line">			  ops, &amp;ftrace_filter_fops);</span><br><span class="line"></span><br><span class="line">	trace_create_file(&quot;set_ftrace_notrace&quot;, 0644, parent,</span><br><span class="line">			  ops, &amp;ftrace_notrace_fops);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static const struct file_operations ftrace_filter_fops = &#123;</span><br><span class="line">	.open = ftrace_filter_open,</span><br><span class="line">	.read = seq_read,</span><br><span class="line">	.write = ftrace_filter_write,</span><br><span class="line">	.llseek = tracing_lseek,</span><br><span class="line">	.release = ftrace_regex_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>“set_ftrace_filter”、“set_ftrace_notrace”的文件操作有个技巧，就是在open的时候分配一个临时hash表iter-&gt;hash来拷贝global_ops的filter_hash/notrace_hash的内容，在write操作实际设置filter时对iter-&gt;hash操作，在close的时候使用新的hash表iter-&gt;hash来更新global_ops。</p>
<p>open文件操作中对global_ops hash表的备份操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">static int</span><br><span class="line">ftrace_filter_open(struct inode *inode, struct file *file)</span><br><span class="line">&#123;</span><br><span class="line">    /* (1) 得到global_ops结构 */</span><br><span class="line">	struct ftrace_ops *ops = inode-&gt;i_private;</span><br><span class="line"></span><br><span class="line">    /* (2) */</span><br><span class="line">	return ftrace_regex_open(ops,</span><br><span class="line">			FTRACE_ITER_FILTER | FTRACE_ITER_DO_HASH,</span><br><span class="line">			inode, file);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">int</span><br><span class="line">ftrace_regex_open(struct ftrace_ops *ops, int flag,</span><br><span class="line">		  struct inode *inode, struct file *file)</span><br><span class="line">&#123;</span><br><span class="line">	struct ftrace_iterator *iter;</span><br><span class="line">	struct ftrace_hash *hash;</span><br><span class="line">	int ret = 0;</span><br><span class="line"></span><br><span class="line">	ftrace_ops_init(ops);</span><br><span class="line"></span><br><span class="line">	if (unlikely(ftrace_disabled))</span><br><span class="line">		return -ENODEV;</span><br><span class="line"></span><br><span class="line">	iter = kzalloc(sizeof(*iter), GFP_KERNEL);</span><br><span class="line">	if (!iter)</span><br><span class="line">		return -ENOMEM;</span><br><span class="line"></span><br><span class="line">	if (trace_parser_get_init(&amp;iter-&gt;parser, FTRACE_BUFF_MAX)) &#123;</span><br><span class="line">		kfree(iter);</span><br><span class="line">		return -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	iter-&gt;ops = ops;</span><br><span class="line">	iter-&gt;flags = flag;</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;ops-&gt;func_hash-&gt;regex_lock);</span><br><span class="line"></span><br><span class="line">	if (flag &amp; FTRACE_ITER_NOTRACE)</span><br><span class="line">		hash = ops-&gt;func_hash-&gt;notrace_hash;</span><br><span class="line">	else</span><br><span class="line">		hash = ops-&gt;func_hash-&gt;filter_hash;</span><br><span class="line"></span><br><span class="line">	if (file-&gt;f_mode &amp; FMODE_WRITE) &#123;</span><br><span class="line">		const int size_bits = FTRACE_HASH_DEFAULT_BITS;</span><br><span class="line"></span><br><span class="line">        /* (2.1) 使用iter-&gt;hash备份global_ops中的filter_hash/notrace_hash */</span><br><span class="line">		if (file-&gt;f_flags &amp; O_TRUNC)</span><br><span class="line">			iter-&gt;hash = alloc_ftrace_hash(size_bits);</span><br><span class="line">		else</span><br><span class="line">			iter-&gt;hash = alloc_and_copy_ftrace_hash(size_bits, hash);</span><br><span class="line"></span><br><span class="line">		if (!iter-&gt;hash) &#123;</span><br><span class="line">			trace_parser_put(&amp;iter-&gt;parser);</span><br><span class="line">			kfree(iter);</span><br><span class="line">			ret = -ENOMEM;</span><br><span class="line">			goto out_unlock;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (file-&gt;f_mode &amp; FMODE_READ) &#123;</span><br><span class="line">		iter-&gt;pg = ftrace_pages_start;</span><br><span class="line"></span><br><span class="line">		ret = seq_open(file, &amp;show_ftrace_seq_ops);</span><br><span class="line">		if (!ret) &#123;</span><br><span class="line">			struct seq_file *m = file-&gt;private_data;</span><br><span class="line">			m-&gt;private = iter;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			/* Failed */</span><br><span class="line">			free_ftrace_hash(iter-&gt;hash);</span><br><span class="line">			trace_parser_put(&amp;iter-&gt;parser);</span><br><span class="line">			kfree(iter);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; else</span><br><span class="line">		file-&gt;private_data = iter;</span><br><span class="line"></span><br><span class="line"> out_unlock:</span><br><span class="line">	mutex_unlock(&amp;ops-&gt;func_hash-&gt;regex_lock);</span><br><span class="line"></span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>write文件操作中对iter-&gt;hash表的更新操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line">ftrace_filter_write() -&gt; ftrace_regex_write() </span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static ssize_t</span><br><span class="line">ftrace_regex_write(struct file *file, const char __user *ubuf,</span><br><span class="line">		   size_t cnt, loff_t *ppos, int enable)</span><br><span class="line">&#123;</span><br><span class="line">	struct ftrace_iterator *iter;</span><br><span class="line">	struct trace_parser *parser;</span><br><span class="line">	ssize_t ret, read;</span><br><span class="line"></span><br><span class="line">	if (!cnt)</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">	if (file-&gt;f_mode &amp; FMODE_READ) &#123;</span><br><span class="line">		struct seq_file *m = file-&gt;private_data;</span><br><span class="line">		iter = m-&gt;private;</span><br><span class="line">	&#125; else</span><br><span class="line">		iter = file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">	if (unlikely(ftrace_disabled))</span><br><span class="line">		return -ENODEV;</span><br><span class="line"></span><br><span class="line">	/* iter-&gt;hash is a local copy, so we don&apos;t need regex_lock */</span><br><span class="line"></span><br><span class="line">	parser = &amp;iter-&gt;parser;</span><br><span class="line">	read = trace_get_user(parser, ubuf, cnt, ppos);</span><br><span class="line"></span><br><span class="line">	if (read &gt;= 0 &amp;&amp; trace_parser_loaded(parser) &amp;&amp;</span><br><span class="line">	    !trace_parser_cont(parser)) &#123;</span><br><span class="line">	    /* (1) 解析filter配置命令，配置到iter-&gt;hash中 */</span><br><span class="line">		ret = ftrace_process_regex(iter-&gt;hash, parser-&gt;buffer,</span><br><span class="line">					   parser-&gt;idx, enable);</span><br><span class="line">		trace_parser_clear(parser);</span><br><span class="line">		if (ret &lt; 0)</span><br><span class="line">			goto out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = read;</span><br><span class="line"> out:</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static int ftrace_process_regex(struct ftrace_hash *hash,</span><br><span class="line">				char *buff, int len, int enable)</span><br><span class="line">&#123;</span><br><span class="line">	char *func, *command, *next = buff;</span><br><span class="line">	struct ftrace_func_command *p;</span><br><span class="line">	int ret = -EINVAL;</span><br><span class="line"></span><br><span class="line">	func = strsep(&amp;next, &quot;:&quot;);</span><br><span class="line"></span><br><span class="line">    /* (1.1) filter配置，更新iter-&gt;hash */</span><br><span class="line">	if (!next) &#123;</span><br><span class="line">		ret = ftrace_match_records(hash, func, len);</span><br><span class="line">		if (!ret)</span><br><span class="line">			ret = -EINVAL;</span><br><span class="line">		if (ret &lt; 0)</span><br><span class="line">			return ret;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* command found */</span><br><span class="line"></span><br><span class="line">	command = strsep(&amp;next, &quot;:&quot;);</span><br><span class="line"></span><br><span class="line">    /* (1.2) filter command配置，最后实际会操作到trace_probe_ops </span><br><span class="line">        和iter-&gt;hash、global_ops无关，下一小节中详述</span><br><span class="line">    */</span><br><span class="line">	mutex_lock(&amp;ftrace_cmd_mutex);</span><br><span class="line">	list_for_each_entry(p, &amp;ftrace_commands, list) &#123;</span><br><span class="line">		if (strcmp(p-&gt;name, command) == 0) &#123;</span><br><span class="line">			ret = p-&gt;func(hash, func, command, next, enable);</span><br><span class="line">			goto out_unlock;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> out_unlock:</span><br><span class="line">	mutex_unlock(&amp;ftrace_cmd_mutex);</span><br><span class="line"></span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">ftrace_match_records() -&gt; match_records()</span><br><span class="line"></span><br><span class="line">static int</span><br><span class="line">match_records(struct ftrace_hash *hash, char *func, int len, char *mod)</span><br><span class="line">&#123;</span><br><span class="line">	struct ftrace_page *pg;</span><br><span class="line">	struct dyn_ftrace *rec;</span><br><span class="line">	struct ftrace_glob func_g = &#123; .type = MATCH_FULL &#125;;</span><br><span class="line">	struct ftrace_glob mod_g = &#123; .type = MATCH_FULL &#125;;</span><br><span class="line">	struct ftrace_glob *mod_match = (mod) ? &amp;mod_g : NULL;</span><br><span class="line">	int exclude_mod = 0;</span><br><span class="line">	int found = 0;</span><br><span class="line">	int ret;</span><br><span class="line">	int clear_filter;</span><br><span class="line"></span><br><span class="line">    /* (1.1.1) 解析filter命令字符串 </span><br><span class="line">        clear_filter = 命令中的“!”</span><br><span class="line">     */</span><br><span class="line">	if (func) &#123;</span><br><span class="line">		func_g.type = filter_parse_regex(func, len, &amp;func_g.search,</span><br><span class="line">						 &amp;clear_filter);</span><br><span class="line">		func_g.len = strlen(func_g.search);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (mod) &#123;</span><br><span class="line">		mod_g.type = filter_parse_regex(mod, strlen(mod),</span><br><span class="line">				&amp;mod_g.search, &amp;exclude_mod);</span><br><span class="line">		mod_g.len = strlen(mod_g.search);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;ftrace_lock);</span><br><span class="line"></span><br><span class="line">	if (unlikely(ftrace_disabled))</span><br><span class="line">		goto out_unlock;</span><br><span class="line"></span><br><span class="line">    /* (1.1.2) 遍历ftrcae_rec */</span><br><span class="line">	do_for_each_ftrace_rec(pg, rec) &#123;</span><br><span class="line">	    /* 如果ip在filter中存在，将其加入/删除到iter-&gt;hash中 */</span><br><span class="line">		if (ftrace_match_record(rec, &amp;func_g, mod_match, exclude_mod)) &#123;</span><br><span class="line">			ret = enter_record(hash, rec, clear_filter);</span><br><span class="line">			if (ret &lt; 0) &#123;</span><br><span class="line">				found = ret;</span><br><span class="line">				goto out_unlock;</span><br><span class="line">			&#125;</span><br><span class="line">			found = 1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; while_for_each_ftrace_rec();</span><br><span class="line"> out_unlock:</span><br><span class="line">	mutex_unlock(&amp;ftrace_lock);</span><br><span class="line"></span><br><span class="line">	return found;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static int</span><br><span class="line">enter_record(struct ftrace_hash *hash, struct dyn_ftrace *rec, int clear_filter)</span><br><span class="line">&#123;</span><br><span class="line">	struct ftrace_func_entry *entry;</span><br><span class="line">	int ret = 0;</span><br><span class="line"></span><br><span class="line">	entry = ftrace_lookup_ip(hash, rec-&gt;ip);</span><br><span class="line">	if (clear_filter) &#123;</span><br><span class="line">		/* Do nothing if it doesn&apos;t exist */</span><br><span class="line">		if (!entry)</span><br><span class="line">			return 0;</span><br><span class="line"></span><br><span class="line">		free_hash_entry(hash, entry);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		/* Do nothing if it exists */</span><br><span class="line">		if (entry)</span><br><span class="line">			return 0;</span><br><span class="line"></span><br><span class="line">		ret = add_hash_entry(hash, rec-&gt;ip);</span><br><span class="line">	&#125;</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>close文件操作中对global_ops hash表的更新操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">int ftrace_regex_release(struct inode *inode, struct file *file)</span><br><span class="line">&#123;</span><br><span class="line">	struct seq_file *m = (struct seq_file *)file-&gt;private_data;</span><br><span class="line">	struct ftrace_ops_hash old_hash_ops;</span><br><span class="line">	struct ftrace_iterator *iter;</span><br><span class="line">	struct ftrace_hash **orig_hash;</span><br><span class="line">	struct ftrace_hash *old_hash;</span><br><span class="line">	struct trace_parser *parser;</span><br><span class="line">	int filter_hash;</span><br><span class="line">	int ret;</span><br><span class="line"></span><br><span class="line">	if (file-&gt;f_mode &amp; FMODE_READ) &#123;</span><br><span class="line">		iter = m-&gt;private;</span><br><span class="line">		seq_release(inode, file);</span><br><span class="line">	&#125; else</span><br><span class="line">		iter = file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">	parser = &amp;iter-&gt;parser;</span><br><span class="line">	if (trace_parser_loaded(parser)) &#123;</span><br><span class="line">		parser-&gt;buffer[parser-&gt;idx] = 0;</span><br><span class="line">		ftrace_match_records(iter-&gt;hash, parser-&gt;buffer, parser-&gt;idx);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	trace_parser_put(parser);</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;iter-&gt;ops-&gt;func_hash-&gt;regex_lock);</span><br><span class="line"></span><br><span class="line">	if (file-&gt;f_mode &amp; FMODE_WRITE) &#123;</span><br><span class="line">		filter_hash = !!(iter-&gt;flags &amp; FTRACE_ITER_FILTER);</span><br><span class="line"></span><br><span class="line">		if (filter_hash)</span><br><span class="line">			orig_hash = &amp;iter-&gt;ops-&gt;func_hash-&gt;filter_hash;</span><br><span class="line">		else</span><br><span class="line">			orig_hash = &amp;iter-&gt;ops-&gt;func_hash-&gt;notrace_hash;</span><br><span class="line"></span><br><span class="line">		mutex_lock(&amp;ftrace_lock);</span><br><span class="line">		old_hash = *orig_hash;</span><br><span class="line">		old_hash_ops.filter_hash = iter-&gt;ops-&gt;func_hash-&gt;filter_hash;</span><br><span class="line">		old_hash_ops.notrace_hash = iter-&gt;ops-&gt;func_hash-&gt;notrace_hash;</span><br><span class="line">		/* (1) 使用iter-&gt;hash来更新global_ops的filter_hash/notrace_hash */</span><br><span class="line">		ret = ftrace_hash_move(iter-&gt;ops, filter_hash,</span><br><span class="line">				       orig_hash, iter-&gt;hash);</span><br><span class="line">		/* (2) 根据最新hash表的内容，更新_mcount插桩点 </span><br><span class="line">		    遍历全部ftrace_rec：</span><br><span class="line">		        ref_cnt大于0的插桩点，更新成ftrace_caller()</span><br><span class="line">		        ref_cnt等于0的插桩点，更新成nop</span><br><span class="line">		 */</span><br><span class="line">		if (!ret) &#123;</span><br><span class="line">			ftrace_ops_update_code(iter-&gt;ops, &amp;old_hash_ops);</span><br><span class="line">			free_ftrace_hash_rcu(old_hash);</span><br><span class="line">		&#125;</span><br><span class="line">		mutex_unlock(&amp;ftrace_lock);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mutex_unlock(&amp;iter-&gt;ops-&gt;func_hash-&gt;regex_lock);</span><br><span class="line">	free_ftrace_hash(iter-&gt;hash);</span><br><span class="line">	kfree(iter);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static void ftrace_ops_update_code(struct ftrace_ops *ops,</span><br><span class="line">				   struct ftrace_ops_hash *old_hash)</span><br><span class="line">&#123;</span><br><span class="line">	struct ftrace_ops *op;</span><br><span class="line"></span><br><span class="line">	if (!ftrace_enabled)</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	if (ops-&gt;flags &amp; FTRACE_OPS_FL_ENABLED) &#123;</span><br><span class="line">		ftrace_run_modify_code(ops, FTRACE_UPDATE_CALLS, old_hash);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * If this is the shared global_ops filter, then we need to</span><br><span class="line">	 * check if there is another ops that shares it, is enabled.</span><br><span class="line">	 * If so, we still need to run the modify code.</span><br><span class="line">	 */</span><br><span class="line">	if (ops-&gt;func_hash != &amp;global_ops.local_hash)</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	do_for_each_ftrace_op(op, ftrace_ops_list) &#123;</span><br><span class="line">		if (op-&gt;func_hash == &amp;global_ops.local_hash &amp;&amp;</span><br><span class="line">		    op-&gt;flags &amp; FTRACE_OPS_FL_ENABLED) &#123;</span><br><span class="line">			ftrace_run_modify_code(op, FTRACE_UPDATE_CALLS, old_hash);</span><br><span class="line">			/* Only need to do this once */</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; while_for_each_ftrace_op(op);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-7、配置function-tracer的filter-command"><a href="#1-2-7、配置function-tracer的filter-command" class="headerlink" title="1.2.7、配置function tracer的filter command"></a>1.2.7、配置function tracer的filter command</h3><p>5、通过“set_ftrace_filter”设置function trcer的filter command。本质上向trace_probe_ops注册cmd，以及操作trace_probe_ops的filter_hash、notrace_hash。</p>
<p>虽然同样是操作set_ftrace_filter，但是配置filter和配置filter command是操作到不同的实体：</p>
<ul>
<li>配置filter。操作的是global_ops的filter_hash/notrace_hash的内容；</li>
<li>配置filter command。是把command向trace_probe_ops注册，并且操作trace_probe_ops的filter_hash/notrace_hash的内容；</li>
</ul>
<p>在配置filter command之前首先得注册command：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">init_function_trace() -&gt; init_func_cmd_traceon()</span><br><span class="line"></span><br><span class="line">static int __init init_func_cmd_traceon(void)</span><br><span class="line">&#123;</span><br><span class="line">	int ret;</span><br><span class="line"></span><br><span class="line">    /* 注册：把command加入到ftrace_commands链表 */</span><br><span class="line">	ret = register_ftrace_command(&amp;ftrace_traceoff_cmd);</span><br><span class="line">	if (ret)</span><br><span class="line">		return ret;</span><br><span class="line"></span><br><span class="line">	ret = register_ftrace_command(&amp;ftrace_traceon_cmd);</span><br><span class="line">	if (ret)</span><br><span class="line">		goto out_free_traceoff;</span><br><span class="line"></span><br><span class="line">	ret = register_ftrace_command(&amp;ftrace_stacktrace_cmd);</span><br><span class="line">	if (ret)</span><br><span class="line">		goto out_free_traceon;</span><br><span class="line"></span><br><span class="line">	ret = register_ftrace_command(&amp;ftrace_dump_cmd);</span><br><span class="line">	if (ret)</span><br><span class="line">		goto out_free_stacktrace;</span><br><span class="line"></span><br><span class="line">	ret = register_ftrace_command(&amp;ftrace_cpudump_cmd);</span><br><span class="line">	if (ret)</span><br><span class="line">		goto out_free_dump;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static struct ftrace_func_command ftrace_traceon_cmd = &#123;</span><br><span class="line">	.name			= &quot;traceon&quot;,</span><br><span class="line">	.func			= ftrace_trace_onoff_callback,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们以”traceon”command为例，继续分析上一节对“set_ftrace_filter”的文件操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br></pre></td><td class="code"><pre><span class="line">static int ftrace_process_regex(struct ftrace_hash *hash,</span><br><span class="line">				char *buff, int len, int enable)</span><br><span class="line">&#123;</span><br><span class="line">	char *func, *command, *next = buff;</span><br><span class="line">	struct ftrace_func_command *p;</span><br><span class="line">	int ret = -EINVAL;</span><br><span class="line"></span><br><span class="line">	func = strsep(&amp;next, &quot;:&quot;);</span><br><span class="line"></span><br><span class="line">    /* (1.1) filter配置，更新iter-&gt;hash */</span><br><span class="line">	if (!next) &#123;</span><br><span class="line">		ret = ftrace_match_records(hash, func, len);</span><br><span class="line">		if (!ret)</span><br><span class="line">			ret = -EINVAL;</span><br><span class="line">		if (ret &lt; 0)</span><br><span class="line">			return ret;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* command found */</span><br><span class="line"></span><br><span class="line">	command = strsep(&amp;next, &quot;:&quot;);</span><br><span class="line"></span><br><span class="line">    /* (1.2) filter command配置，最后实际会操作到trace_probe_ops </span><br><span class="line">        和iter-&gt;hash、global_ops无关，下一小节中详述</span><br><span class="line">    */</span><br><span class="line">	mutex_lock(&amp;ftrace_cmd_mutex);</span><br><span class="line">	list_for_each_entry(p, &amp;ftrace_commands, list) &#123;</span><br><span class="line">		if (strcmp(p-&gt;name, command) == 0) &#123;</span><br><span class="line">			ret = p-&gt;func(hash, func, command, next, enable);</span><br><span class="line">			goto out_unlock;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> out_unlock:</span><br><span class="line">	mutex_unlock(&amp;ftrace_cmd_mutex);</span><br><span class="line"></span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static int</span><br><span class="line">ftrace_trace_onoff_callback(struct ftrace_hash *hash,</span><br><span class="line">			    char *glob, char *cmd, char *param, int enable)</span><br><span class="line">&#123;</span><br><span class="line">	struct ftrace_probe_ops *ops;</span><br><span class="line"></span><br><span class="line">	/* we register both traceon and traceoff to this callback */</span><br><span class="line">	/* (1.2.1) 配置command的执行ops */</span><br><span class="line">	if (strcmp(cmd, &quot;traceon&quot;) == 0)</span><br><span class="line">		ops = param ? &amp;traceon_count_probe_ops : &amp;traceon_probe_ops;</span><br><span class="line">	else</span><br><span class="line">		ops = param ? &amp;traceoff_count_probe_ops : &amp;traceoff_probe_ops;</span><br><span class="line"></span><br><span class="line">    /* (1.2.2) 注册command到trace_probe_ops */</span><br><span class="line">	return ftrace_trace_probe_callback(ops, hash, glob, cmd,</span><br><span class="line">					   param, enable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static int</span><br><span class="line">ftrace_trace_probe_callback(struct ftrace_probe_ops *ops,</span><br><span class="line">			    struct ftrace_hash *hash, char *glob,</span><br><span class="line">			    char *cmd, char *param, int enable)</span><br><span class="line">&#123;</span><br><span class="line">	void *count = (void *)-1;</span><br><span class="line">	char *number;</span><br><span class="line">	int ret;</span><br><span class="line"></span><br><span class="line">	/* hash funcs only work with set_ftrace_filter */</span><br><span class="line">	if (!enable)</span><br><span class="line">		return -EINVAL;</span><br><span class="line"></span><br><span class="line">    /* (1.2.2.1) 如果命令是“!”，注销filter command */</span><br><span class="line">	if (glob[0] == &apos;!&apos;) &#123;</span><br><span class="line">		unregister_ftrace_function_probe_func(glob+1, ops);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (!param)</span><br><span class="line">		goto out_reg;</span><br><span class="line"></span><br><span class="line">	number = strsep(&amp;param, &quot;:&quot;);</span><br><span class="line"></span><br><span class="line">	if (!strlen(number))</span><br><span class="line">		goto out_reg;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * We use the callback data field (which is a pointer)</span><br><span class="line">	 * as our counter.</span><br><span class="line">	 */</span><br><span class="line">	/* (1.2.2.2) 解析到filter command中的“count”字段 */</span><br><span class="line">	ret = kstrtoul(number, 0, (unsigned long *)&amp;count);</span><br><span class="line">	if (ret)</span><br><span class="line">		return ret;</span><br><span class="line"></span><br><span class="line"> out_reg:</span><br><span class="line">    /* (1.2.2.3) 继续注册filter command */</span><br><span class="line">	ret = register_ftrace_function_probe(glob, ops, count);</span><br><span class="line"></span><br><span class="line">	return ret &lt; 0 ? ret : 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">int</span><br><span class="line">register_ftrace_function_probe(char *glob, struct ftrace_probe_ops *ops,</span><br><span class="line">			      void *data)</span><br><span class="line">&#123;</span><br><span class="line">	struct ftrace_ops_hash old_hash_ops;</span><br><span class="line">	struct ftrace_func_probe *entry;</span><br><span class="line">	struct ftrace_glob func_g;</span><br><span class="line">	struct ftrace_hash **orig_hash = &amp;trace_probe_ops.func_hash-&gt;filter_hash;</span><br><span class="line">	struct ftrace_hash *old_hash = *orig_hash;</span><br><span class="line">	struct ftrace_hash *hash;</span><br><span class="line">	struct ftrace_page *pg;</span><br><span class="line">	struct dyn_ftrace *rec;</span><br><span class="line">	int not;</span><br><span class="line">	unsigned long key;</span><br><span class="line">	int count = 0;</span><br><span class="line">	int ret;</span><br><span class="line"></span><br><span class="line">    /* (1.2.2.3.1) filter command中函数名部分的解析 */</span><br><span class="line">	func_g.type = filter_parse_regex(glob, strlen(glob),</span><br><span class="line">			&amp;func_g.search, &amp;not);</span><br><span class="line">	func_g.len = strlen(func_g.search);</span><br><span class="line"></span><br><span class="line">	/* we do not support &apos;!&apos; for function probes */</span><br><span class="line">	if (WARN_ON(not))</span><br><span class="line">		return -EINVAL;</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;trace_probe_ops.func_hash-&gt;regex_lock);</span><br><span class="line"></span><br><span class="line">	old_hash_ops.filter_hash = old_hash;</span><br><span class="line">	/* Probes only have filters */</span><br><span class="line">	old_hash_ops.notrace_hash = NULL;</span><br><span class="line"></span><br><span class="line">    /* (1.2.2.3.1) 将trace_probe_ops的filter_hash拷贝到临时hash表 */</span><br><span class="line">	hash = alloc_and_copy_ftrace_hash(FTRACE_HASH_DEFAULT_BITS, old_hash);</span><br><span class="line">	if (!hash) &#123;</span><br><span class="line">		count = -ENOMEM;</span><br><span class="line">		goto out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (unlikely(ftrace_disabled)) &#123;</span><br><span class="line">		count = -ENODEV;</span><br><span class="line">		goto out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;ftrace_lock);</span><br><span class="line"></span><br><span class="line">    /* 遍历ftrace_rec */</span><br><span class="line">	do_for_each_ftrace_rec(pg, rec) &#123;</span><br><span class="line"></span><br><span class="line">		if (!ftrace_match_record(rec, &amp;func_g, NULL, 0))</span><br><span class="line">			continue;</span><br><span class="line"></span><br><span class="line">		entry = kmalloc(sizeof(*entry), GFP_KERNEL);</span><br><span class="line">		if (!entry) &#123;</span><br><span class="line">			/* If we did not process any, then return error */</span><br><span class="line">			if (!count)</span><br><span class="line">				count = -ENOMEM;</span><br><span class="line">			goto out_unlock;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		count++;</span><br><span class="line"></span><br><span class="line">		entry-&gt;data = data;</span><br><span class="line"></span><br><span class="line">		/*</span><br><span class="line">		 * The caller might want to do something special</span><br><span class="line">		 * for each function we find. We call the callback</span><br><span class="line">		 * to give the caller an opportunity to do so.</span><br><span class="line">		 */</span><br><span class="line">		if (ops-&gt;init) &#123;</span><br><span class="line">			if (ops-&gt;init(ops, rec-&gt;ip, &amp;entry-&gt;data) &lt; 0) &#123;</span><br><span class="line">				/* caller does not like this func */</span><br><span class="line">				kfree(entry);</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        /* (1.2.2.3.3) 如果当前ip符合当前函数filter规则，加入到临时hash表 */</span><br><span class="line">		ret = enter_record(hash, rec, 0);</span><br><span class="line">		if (ret &lt; 0) &#123;</span><br><span class="line">			kfree(entry);</span><br><span class="line">			count = ret;</span><br><span class="line">			goto out_unlock;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        /* (1.2.2.3.4) 把command的操作和对应ip组合成entry，加入到另外一张hash表ftrace_func_hash */</span><br><span class="line">		entry-&gt;ops = ops;</span><br><span class="line">		entry-&gt;ip = rec-&gt;ip;</span><br><span class="line"></span><br><span class="line">		key = hash_long(entry-&gt;ip, FTRACE_HASH_BITS);</span><br><span class="line">		hlist_add_head_rcu(&amp;entry-&gt;node, &amp;ftrace_func_hash[key]);</span><br><span class="line"></span><br><span class="line">	&#125; while_for_each_ftrace_rec();</span><br><span class="line"></span><br><span class="line">    /* (1.2.2.3.5) 把临时hash表更新到trace_probe_ops的filter_hash中 */</span><br><span class="line">	ret = ftrace_hash_move(&amp;trace_probe_ops, 1, orig_hash, hash);</span><br><span class="line"></span><br><span class="line">    /* (1.2.2.3.6) 如果trace_probe_ops已经注册，根据hash表的更新来更新_mcount插桩点 </span><br><span class="line">        如果trace_probe_ops没有注册，注册并更新_mcount插桩点</span><br><span class="line">     */</span><br><span class="line">	__enable_ftrace_function_probe(&amp;old_hash_ops);</span><br><span class="line"></span><br><span class="line">	if (!ret)</span><br><span class="line">		free_ftrace_hash_rcu(old_hash);</span><br><span class="line">	else</span><br><span class="line">		count = ret;</span><br><span class="line"></span><br><span class="line"> out_unlock:</span><br><span class="line">	mutex_unlock(&amp;ftrace_lock);</span><br><span class="line"> out:</span><br><span class="line">	mutex_unlock(&amp;trace_probe_ops.func_hash-&gt;regex_lock);</span><br><span class="line">	free_ftrace_hash(hash);</span><br><span class="line"></span><br><span class="line">	return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>trace_probe_ops在被调用的时候，执行ftrace_func_hash中的filter command：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">ftrace_caller() -&gt; ftrace_ops_list_func() -&gt; __ftrace_ops_list_func() </span><br><span class="line"></span><br><span class="line">static inline void</span><br><span class="line">__ftrace_ops_list_func(unsigned long ip, unsigned long parent_ip,</span><br><span class="line">		       struct ftrace_ops *ignored, struct pt_regs *regs)</span><br><span class="line">&#123;</span><br><span class="line">	struct ftrace_ops *op;</span><br><span class="line">	int bit;</span><br><span class="line"></span><br><span class="line">	bit = trace_test_and_set_recursion(TRACE_LIST_START, TRACE_LIST_MAX);</span><br><span class="line">	if (bit &lt; 0)</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Some of the ops may be dynamically allocated,</span><br><span class="line">	 * they must be freed after a synchronize_sched().</span><br><span class="line">	 */</span><br><span class="line">	preempt_disable_notrace();</span><br><span class="line">	/* 遍历ftrace_ops_list链表，</span><br><span class="line">	    在当前ip满足hash的情况下，逐个执行ftrace_ops-&gt;func()</span><br><span class="line">	 */</span><br><span class="line">	do_for_each_ftrace_op(op, ftrace_ops_list) &#123;</span><br><span class="line">		if (ftrace_ops_test(op, ip, regs)) &#123;</span><br><span class="line">			if (FTRACE_WARN_ON(!op-&gt;func)) &#123;</span><br><span class="line">				pr_warn(&quot;op=%p %pS\n&quot;, op, op);</span><br><span class="line">				goto out;</span><br><span class="line">			&#125;</span><br><span class="line">			op-&gt;func(ip, parent_ip, op, regs);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; while_for_each_ftrace_op(op);</span><br><span class="line">out:</span><br><span class="line">	preempt_enable_notrace();</span><br><span class="line">	trace_clear_recursion(bit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static struct ftrace_ops trace_probe_ops __read_mostly =</span><br><span class="line">&#123;</span><br><span class="line">	.func		= function_trace_probe_call,</span><br><span class="line">	.flags		= FTRACE_OPS_FL_INITIALIZED,</span><br><span class="line">	INIT_OPS_HASH(trace_probe_ops)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static void function_trace_probe_call(unsigned long ip, unsigned long parent_ip,</span><br><span class="line">				      struct ftrace_ops *op, struct pt_regs *pt_regs)</span><br><span class="line">&#123;</span><br><span class="line">	struct ftrace_func_probe *entry;</span><br><span class="line">	struct hlist_head *hhd;</span><br><span class="line">	unsigned long key;</span><br><span class="line"></span><br><span class="line">	key = hash_long(ip, FTRACE_HASH_BITS);</span><br><span class="line"></span><br><span class="line">	hhd = &amp;ftrace_func_hash[key];</span><br><span class="line"></span><br><span class="line">	if (hlist_empty(hhd))</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Disable preemption for these calls to prevent a RCU grace</span><br><span class="line">	 * period. This syncs the hash iteration and freeing of items</span><br><span class="line">	 * on the hash. rcu_read_lock is too dangerous here.</span><br><span class="line">	 */</span><br><span class="line">	preempt_disable_notrace();</span><br><span class="line">	/* 逐个执行ftrace_func_hash表中，ip为本ip的filter command */</span><br><span class="line">	hlist_for_each_entry_rcu_notrace(entry, hhd, node) &#123;</span><br><span class="line">		if (entry-&gt;ip == ip)</span><br><span class="line">			entry-&gt;ops-&gt;func(ip, parent_ip, &amp;entry-&gt;data);</span><br><span class="line">	&#125;</span><br><span class="line">	preempt_enable_notrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-3、数据存入"><a href="#1-3、数据存入" class="headerlink" title="1.3、数据存入"></a>1.3、数据存入</h2><p>function tracer的数据存入的路径为：</p>
<p>ftrace_caller() -&gt; ftrace_ops_list_func() -&gt; __ftrace_ops_list_func() -&gt; global_ops-&gt;func() -&gt; function_trace_call()：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">static void</span><br><span class="line">function_trace_call(unsigned long ip, unsigned long parent_ip,</span><br><span class="line">		    struct ftrace_ops *op, struct pt_regs *pt_regs)</span><br><span class="line">&#123;</span><br><span class="line">	struct trace_array *tr = op-&gt;private;</span><br><span class="line">	struct trace_array_cpu *data;</span><br><span class="line">	unsigned long flags;</span><br><span class="line">	int bit;</span><br><span class="line">	int cpu;</span><br><span class="line">	int pc;</span><br><span class="line"></span><br><span class="line">	if (unlikely(!tr-&gt;function_enabled))</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	pc = preempt_count();</span><br><span class="line">	preempt_disable_notrace();</span><br><span class="line"></span><br><span class="line">	bit = trace_test_and_set_recursion(TRACE_FTRACE_START, TRACE_FTRACE_MAX);</span><br><span class="line">	if (bit &lt; 0)</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">	cpu = smp_processor_id();</span><br><span class="line">	data = per_cpu_ptr(tr-&gt;trace_buffer.data, cpu);</span><br><span class="line">	if (!atomic_read(&amp;data-&gt;disabled)) &#123;</span><br><span class="line">		local_save_flags(flags);</span><br><span class="line">		trace_function(tr, ip, parent_ip, flags, pc);</span><br><span class="line">	&#125;</span><br><span class="line">	trace_clear_recursion(bit);</span><br><span class="line"></span><br><span class="line"> out:</span><br><span class="line">	preempt_enable_notrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">trace_function(struct trace_array *tr,</span><br><span class="line">	       unsigned long ip, unsigned long parent_ip, unsigned long flags,</span><br><span class="line">	       int pc)</span><br><span class="line">&#123;</span><br><span class="line">	struct trace_event_call *call = &amp;event_function;</span><br><span class="line">	struct ring_buffer *buffer = tr-&gt;trace_buffer.buffer;</span><br><span class="line">	struct ring_buffer_event *event;</span><br><span class="line">	struct ftrace_entry *entry;</span><br><span class="line"></span><br><span class="line">    /* (1) 从ringbuffer中分配空间 </span><br><span class="line">        type = TRACE_FN</span><br><span class="line">     */</span><br><span class="line">	event = trace_buffer_lock_reserve(buffer, TRACE_FN, sizeof(*entry),</span><br><span class="line">					  flags, pc);</span><br><span class="line">	if (!event)</span><br><span class="line">		return;</span><br><span class="line">	entry	= ring_buffer_event_data(event);</span><br><span class="line">	/* (2) 存入function tracer自定义的trace数据：ip、parent_ip */</span><br><span class="line">	entry-&gt;ip			= ip;</span><br><span class="line">	entry-&gt;parent_ip		= parent_ip;</span><br><span class="line"></span><br><span class="line">	if (!call_filter_check_discard(call, entry, buffer, event))</span><br><span class="line">		__buffer_unlock_commit(buffer, event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-1、数据格式"><a href="#1-3-1、数据格式" class="headerlink" title="1.3.1、数据格式"></a>1.3.1、数据格式</h3><p>function tracer自定义的trace数据非常简单：ip、parent_ip</p>
<p><img src="/images/ftrace_tracer/entry_function_tracer_format.png" alt="image"></p>
<h3 id="1-3-2、filter"><a href="#1-3-2、filter" class="headerlink" title="1.3.2、filter"></a>1.3.2、filter</h3><p>关于filter和filter command的配置在<a href="#dynamic_stub_manag">1.2.2、插桩点的动态管理</a>一节已经讲得非常详细了，这里就不再重复。</p>
<h2 id="1-4、数据读出"><a href="#1-4、数据读出" class="headerlink" title="1.4、数据读出"></a>1.4、数据读出</h2><p>从trace文件读出的function tracer默认数据格式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"># cat trace</span><br><span class="line"># tracer: function</span><br><span class="line">#</span><br><span class="line"># entries-in-buffer/entries-written: 36/36   #P:8</span><br><span class="line">#</span><br><span class="line">#                              _-----=&gt; irqs-off</span><br><span class="line">#                             / _----=&gt; need-resched</span><br><span class="line">#                            | / _---=&gt; hardirq/softirq</span><br><span class="line">#                            || / _--=&gt; preempt-depth</span><br><span class="line">#                            ||| /     delay</span><br><span class="line">#           TASK-PID   CPU#  ||||    TIMESTAMP  FUNCTION</span><br><span class="line">#              | |       |   ||||       |         |</span><br><span class="line">              sh-18361 [001] ...1 663922.156238: schedule_hrtimeout_range &lt;-poll_schedule_timeout</span><br><span class="line">              sh-18361 [001] ...1 663922.156251: schedule_hrtimeout_range_clock &lt;-schedule_hrtimeout_range</span><br><span class="line">          &lt;idle&gt;-0     [003] .n.2 663922.156660: schedule_preempt_disabled &lt;-cpu_startup_entry</span><br><span class="line">     -&gt;transport-5191  [002] ...1 663922.157592: schedule_timeout &lt;-wait_for_common</span><br><span class="line">            adbd-5189  [002] ...1 663922.158219: schedule_hrtimeout_range &lt;-poll_schedule_timeout</span><br><span class="line">            adbd-5189  [002] ...1 663922.158222: schedule_hrtimeout_range_clock &lt;-schedule_hrtimeout_range</span><br><span class="line">          &lt;idle&gt;-0     [001] .n.2 663922.158342: schedule_preempt_disabled &lt;-cpu_startup_entry</span><br><span class="line">     -&gt;transport-5191  [001] ...1 663922.159407: schedule_timeout &lt;-unix_stream_read_generic</span><br><span class="line">     &lt;-transport-5192  [001] ...1 663922.159904: schedule_timeout &lt;-wait_for_common</span><br><span class="line">     -&gt;transport-5191  [001] ...1 663922.160413: schedule_timeout &lt;-unix_stream_read_generic</span><br><span class="line">            adbd-5189  [001] ...1 663922.160895: schedule_hrtimeout_range &lt;-poll_schedule_timeout</span><br><span class="line">            adbd-5189  [001] ...1 663922.160898: schedule_hrtimeout_range_clock &lt;-schedule_hrtimeout_range</span><br><span class="line">          &lt;idle&gt;-0     [002] .n.2 663922.163694: schedule_preempt_disabled &lt;-cpu_startup_entry</span><br><span class="line">          &lt;idle&gt;-0     [003] .n.2 663922.175958: schedule_preempt_disabled &lt;-cpu_startup_entry</span><br><span class="line">  ndroid.systemu-2200  [003] ...1 663922.179945: schedule_hrtimeout_range &lt;-SyS_epoll_wait</span><br><span class="line">  ndroid.systemu-2200  [003] ...1 663922.179950: schedule_hrtimeout_range_clock &lt;-schedule_hrtimeout_range</span><br><span class="line">          &lt;idle&gt;-0     [003] .n.2 663922.181418: schedule_preempt_disabled &lt;-cpu_startup_entry</span><br><span class="line">          &lt;idle&gt;-0     [002] .n.2 663922.181584: schedule_preempt_disabled &lt;-cpu_startup_entry</span><br><span class="line">          &lt;idle&gt;-0     [002] .n.2 663922.200878: schedule_preempt_disabled &lt;-cpu_startup_entry</span><br><span class="line">          &lt;idle&gt;-0     [001] .n.2 663922.203506: schedule_preempt_disabled &lt;-cpu_startup_entry</span><br><span class="line">     rcu_preempt-7     [002] ...1 663922.203519: schedule_timeout &lt;-rcu_gp_kthread</span><br><span class="line">  ndroid.systemu-2200  [002] ...1 663922.205619: schedule_hrtimeout_range &lt;-SyS_epoll_wait</span><br><span class="line">  ndroid.systemu-2200  [002] ...1 663922.205624: schedule_hrtimeout_range_clock &lt;-schedule_hrtimeout_range</span><br><span class="line">          &lt;idle&gt;-0     [003] .n.2 663922.208538: schedule_preempt_disabled &lt;-cpu_startup_entry</span><br><span class="line">          &lt;idle&gt;-0     [002] .n.2 663922.213243: schedule_preempt_disabled &lt;-cpu_startup_entry</span><br><span class="line">          &lt;idle&gt;-0     [003] .n.2 663922.217986: schedule_preempt_disabled &lt;-cpu_startup_entry</span><br><span class="line">          &lt;idle&gt;-0     [003] .n.2 663922.227857: schedule_preempt_disabled &lt;-cpu_startup_entry</span><br><span class="line">  ndroid.systemu-2200  [003] ...1 663922.231819: schedule_hrtimeout_range &lt;-SyS_epoll_wait</span><br><span class="line">  ndroid.systemu-2200  [003] ...1 663922.231824: schedule_hrtimeout_range_clock &lt;-schedule_hrtimeout_range</span><br><span class="line">          &lt;idle&gt;-0     [002] .n.2 663922.234282: schedule_preempt_disabled &lt;-cpu_startup_entry</span><br><span class="line">          &lt;idle&gt;-0     [001] .n.2 663922.246355: schedule_preempt_disabled &lt;-cpu_startup_entry</span><br><span class="line">          &lt;idle&gt;-0     [002] .n.2 663922.251360: schedule_preempt_disabled &lt;-cpu_startup_entry</span><br><span class="line">  ndroid.systemu-2200  [002] ...1 663922.255168: schedule_hrtimeout_range &lt;-SyS_epoll_wait</span><br><span class="line">  ndroid.systemu-2200  [002] ...1 663922.255172: schedule_hrtimeout_range_clock &lt;-schedule_hrtimeout_range</span><br><span class="line">          &lt;idle&gt;-0     [003] .n.2 663922.256775: schedule_preempt_disabled &lt;-cpu_startup_entry</span><br><span class="line">          &lt;idle&gt;-0     [001] .n.2 663922.257253: schedule_preempt_disabled &lt;-cpu_startup_entry</span><br></pre></td></tr></table></figure>
<p>在kernel/trace/trace_ouput.c文件中，注册了系统默认的几种trace_event。function tracer使用TRACE_FN类型的trace_fn_event：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">static struct trace_event *events[] __initdata = &#123;</span><br><span class="line">	&amp;trace_fn_event,</span><br><span class="line">	&amp;trace_graph_ent_event,</span><br><span class="line">	&amp;trace_graph_ret_event,</span><br><span class="line">	&amp;trace_ctx_event,</span><br><span class="line">	&amp;trace_wake_event,</span><br><span class="line">	&amp;trace_stack_event,</span><br><span class="line">	&amp;trace_user_stack_event,</span><br><span class="line">	&amp;trace_bputs_event,</span><br><span class="line">	&amp;trace_bprint_event,</span><br><span class="line">	&amp;trace_print_event,</span><br><span class="line">	NULL</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">__init static int init_events(void)</span><br><span class="line">&#123;</span><br><span class="line">	struct trace_event *event;</span><br><span class="line">	int i, ret;</span><br><span class="line"></span><br><span class="line">	for (i = 0; events[i]; i++) &#123;</span><br><span class="line">		event = events[i];</span><br><span class="line"></span><br><span class="line">		ret = register_trace_event(event);</span><br><span class="line">		if (!ret) &#123;</span><br><span class="line">			printk(KERN_WARNING &quot;event %d failed to register\n&quot;,</span><br><span class="line">			       event-&gt;type);</span><br><span class="line">			WARN_ON_ONCE(1);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|→</span><br><span class="line"></span><br><span class="line">static struct trace_event_functions trace_fn_funcs = &#123;</span><br><span class="line">	.trace		= trace_fn_trace,</span><br><span class="line">	.raw		= trace_fn_raw,</span><br><span class="line">	.hex		= trace_fn_hex,</span><br><span class="line">	.binary		= trace_fn_bin,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct trace_event trace_fn_event = &#123;</span><br><span class="line">	.type		= TRACE_FN,</span><br><span class="line">	.funcs		= &amp;trace_fn_funcs,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在数据读出时，会调用到event对应的event-&gt;funcs-&gt;trace()函数，seq_read() -&gt; s_show() -&gt; print_trace_line() -&gt; print_trace_fmt() -&gt; event-&gt;funcs-&gt;trace()：</p>
<p>TRACE_FN，event-&gt;funcs-&gt;trace()对应trace_fn_trace()：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/* TRACE_FN */</span><br><span class="line">static enum print_line_t trace_fn_trace(struct trace_iterator *iter, int flags,</span><br><span class="line">					struct trace_event *event)</span><br><span class="line">&#123;</span><br><span class="line">	struct ftrace_entry *field;</span><br><span class="line">	struct trace_seq *s = &amp;iter-&gt;seq;</span><br><span class="line"></span><br><span class="line">	trace_assign_type(field, iter-&gt;ent);</span><br><span class="line"></span><br><span class="line">    /* (1) 打印出本ip对应的符号 */</span><br><span class="line">	seq_print_ip_sym(s, field-&gt;ip, flags);</span><br><span class="line"></span><br><span class="line">    /* (2) 如果trace option运行，打印出父ip对应的符号 */</span><br><span class="line">	if ((flags &amp; TRACE_ITER_PRINT_PARENT) &amp;&amp; field-&gt;parent_ip) &#123;</span><br><span class="line">		trace_seq_puts(s, &quot; &lt;-&quot;);</span><br><span class="line">		seq_print_ip_sym(s, field-&gt;parent_ip, flags);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	trace_seq_putc(s, &apos;\n&apos;);</span><br><span class="line"></span><br><span class="line">	return trace_handle_return(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2、function-graph-tracer"><a href="#2、function-graph-tracer" class="headerlink" title="2、function_graph tracer"></a>2、function_graph tracer</h1><p>function_graph tracer从function tracer发展而来，function tracer使用“_mcount”插桩可以跟踪到每个函数的调用入口，而function_graph tracer即可以跟踪到函数的入口还可以跟踪到函数的返回。</p>
<h2 id="2-1、插桩原理"><a href="#2-1、插桩原理" class="headerlink" title="2.1、插桩原理"></a>2.1、插桩原理</h2><p><img src="/images/ftrace_tracer/function_graph_flow.png" alt="image"></p>
<p>如上图：一切的关键是在入口桩函数被调用时，修改了func()的返回地址，不是返回到func’s parent()函数继续去执行，而是返回到reurn桩函数return_to_handler()中。return_to_handler()中执行完自己的return处理函数以后，再把返回地址恢复成func’s parent中的地址，返回继续执行原有的路径。</p>
<p>原本的入口处插桩，只能追踪到函数的切换。现在入口、出口同时插桩，还能获得函数的执行时长，做更多的分析。</p>
<h2 id="2-2、插桩点管理"><a href="#2-2、插桩点管理" class="headerlink" title="2.2、插桩点管理"></a>2.2、插桩点管理</h2><p><img src="/images/ftrace_tracer/dynamic_ftrace_stub_manag_graph.png" alt="image"></p>
<p>function_graph tracer插桩点动态管理的原理：</p>
<ul>
<li>1、每个“bl _mcount”的插桩点ip对应一个每个插桩点对应一个dyn_ftrace结构。dyn_ftrace-&gt;flags的低26bit用来表示引用计数，如果有ftrcae_ops会操作到该ip，引用计数会加1。如果ref_cnt大于0，插桩点就需要使能了，把其替换为“bl ftrace_caller”；</li>
<li>2、ftrcae_ops采用hash表来表达对ip的引用，一个ftrcae_ops有两张hash表filter_hash和notrace_hash，综合的结果就是对ip的引用。function_graph tracer模式时，有一个的ftrcae_ops：graph_ops。并且graph_ops的hash表是直接引用global_ops的hash表，这样做的目的是可以保留function tracer模式时的filter配置。如果引用到ip，都会造成ip的1级插桩点被替换为“bl ftrace_caller”；</li>
<li>3、通过设置“set_ftrace_filter/set_ftrace_notrace”会造成对global_ops的filter_hash/notrace_hash的配置，它的作用相当于1级过滤。在function_graph tracer模式时，通过2级过滤的函数才能记录trace信息：1级过滤(函数必须是“set_ftrace_filter/set_ftrace_notrace”配置中允许的函数)，2级过滤(函数必须是“set_graph_function/set_graph_notrace”配置中允许的函数或者是被它们调用的子函数)；</li>
<li>4、通过设置“set_graph_function/set_graph_notrace”可以配置2级过滤，实际上是配置到ftrace_graph_funcs[]/ftrace_graph_notrace_funcs[]表中。</li>
<li>5、ftrace_caller()有两个2级插桩点：ftrace_call、ftrace_graph_call。在function tracer模式时，只有ftrace_graph_call被设置成“bl ftrace_graph_caller”；</li>
<li>6、ftrace_graph_caller()的工作就是设置环境，让函数在入口处调用trace_graph_entry()，在返回处调用trace_graph_return()；</li>
<li>7、在trace_graph_entry()中会进行2级过滤的合法性判断，函数必须是“set_graph_function/set_graph_notrace”配置中允许的函数或者是被它们调用的子函数才能继续执行，否则出错返回后面的trace_graph_return()都不会被执行。</li>
<li>8、trace_graph_entry()、trace_graph_return()的工作都是记录trace信息：ip+时间戳；</li>
</ul>
<p>在以下场景时，function_graph会涉及到对各个插桩点的动态修改：</p>
<ul>
<li>tracer的使能。当使用“echo xxx_tracer &gt; current_tracer”时，会关闭旧的current tracer并使能新的tracer。典型的包括function tracer合入function_graph tracer；</li>
<li>function_graph filter的配置。使用“echo function_name &gt; set_ftrace_filter/set_ftrace_notrace”，可以配置部分function被trace，而不是所有function被trace；</li>
<li>function filter的配置。使用“echo function_name &gt; set_graph_function/set_graph_notrace”，可以配置部分function被trace，而不是所有function被trace；</li>
</ul>
<p>下面我们看看具体场景下的代码实现细节：</p>
<h3 id="2-2-1、function-graph-tracer使能"><a href="#2-2-1、function-graph-tracer使能" class="headerlink" title="2.2.1、function_graph tracer使能"></a>2.2.1、function_graph tracer使能</h3><p>参考<a href="#function_tracer_enable">“1.2.5、function tracer使能”</a>这一节，tracer的使能最后调用的是tracer-&gt;init()函数。</p>
<p>对function_graph tracer来说，调用的是graph_trace_init()：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">static struct tracer graph_trace __tracer_data = &#123;</span><br><span class="line">	.name		= &quot;function_graph&quot;,</span><br><span class="line">	.update_thresh	= graph_trace_update_thresh,</span><br><span class="line">	.open		= graph_trace_open,</span><br><span class="line">	.pipe_open	= graph_trace_open,</span><br><span class="line">	.close		= graph_trace_close,</span><br><span class="line">	.pipe_close	= graph_trace_close,</span><br><span class="line">	.init		= graph_trace_init,</span><br><span class="line">	.reset		= graph_trace_reset,</span><br><span class="line">	.print_line	= print_graph_function,</span><br><span class="line">	.print_header	= print_graph_headers,</span><br><span class="line">	.flags		= &amp;tracer_flags,</span><br><span class="line">	.set_flag	= func_graph_set_flag,</span><br><span class="line">#ifdef CONFIG_FTRACE_SELFTEST</span><br><span class="line">	.selftest	= trace_selftest_startup_function_graph,</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static int graph_trace_init(struct trace_array *tr)</span><br><span class="line">&#123;</span><br><span class="line">	int ret;</span><br><span class="line"></span><br><span class="line">	set_graph_array(tr);</span><br><span class="line">	if (tracing_thresh)</span><br><span class="line">		ret = register_ftrace_graph(&amp;trace_graph_thresh_return,</span><br><span class="line">					    &amp;trace_graph_thresh_entry);</span><br><span class="line">	else</span><br><span class="line">		ret = register_ftrace_graph(&amp;trace_graph_return,</span><br><span class="line">					    &amp;trace_graph_entry);</span><br><span class="line">	if (ret)</span><br><span class="line">		return ret;</span><br><span class="line">	tracing_start_cmdline_record();</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">/* function_graph tracer的专用ftrace_ops：graph_ops */</span><br><span class="line">static struct ftrace_ops graph_ops = &#123;</span><br><span class="line">	.func			= ftrace_stub,</span><br><span class="line">	.flags			= FTRACE_OPS_FL_RECURSION_SAFE |</span><br><span class="line">				   FTRACE_OPS_FL_INITIALIZED |</span><br><span class="line">				   FTRACE_OPS_FL_PID |</span><br><span class="line">				   FTRACE_OPS_FL_STUB,</span><br><span class="line">#ifdef FTRACE_GRAPH_TRAMP_ADDR</span><br><span class="line">	.trampoline		= FTRACE_GRAPH_TRAMP_ADDR,</span><br><span class="line">	/* trampoline_size is only needed for dynamically allocated tramps */</span><br><span class="line">#endif</span><br><span class="line">	ASSIGN_OPS_HASH(graph_ops, &amp;global_ops.local_hash)  /* graph_ops共用global_ops的hash表，这样可以支持&quot;set_ftrace_filter&quot;的配置 */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int register_ftrace_graph(trace_func_graph_ret_t retfunc,</span><br><span class="line">			trace_func_graph_ent_t entryfunc)</span><br><span class="line">&#123;</span><br><span class="line">	int ret = 0;</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;ftrace_lock);</span><br><span class="line"></span><br><span class="line">	/* we currently allow only one tracer registered at a time */</span><br><span class="line">	if (ftrace_graph_active) &#123;</span><br><span class="line">		ret = -EBUSY;</span><br><span class="line">		goto out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	register_pm_notifier(&amp;ftrace_suspend_notifier);</span><br><span class="line"></span><br><span class="line">	ftrace_graph_active++;</span><br><span class="line">	ret = start_graph_tracing();</span><br><span class="line">	if (ret) &#123;</span><br><span class="line">		ftrace_graph_active--;</span><br><span class="line">		goto out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* (1) 给ftrace_graph_entry、ftrace_graph_return指针赋值 */</span><br><span class="line">	ftrace_graph_return = retfunc;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Update the indirect function to the entryfunc, and the</span><br><span class="line">	 * function that gets called to the entry_test first. Then</span><br><span class="line">	 * call the update fgraph entry function to determine if</span><br><span class="line">	 * the entryfunc should be called directly or not.</span><br><span class="line">	 */</span><br><span class="line">	__ftrace_graph_entry = entryfunc;</span><br><span class="line">	ftrace_graph_entry = ftrace_graph_entry_test;</span><br><span class="line">	update_function_graph_func();</span><br><span class="line"></span><br><span class="line">    /* (2) 注册graph_ops:</span><br><span class="line">        1、将graph_ops加入到ftrace_ops_list链表；</span><br><span class="line">        2、根据graph_ops的hash表，更新_mcount插桩点；</span><br><span class="line">        3、更新ftrace_graph_call插桩点为ftrace_graph_caller()</span><br><span class="line">     */</span><br><span class="line">	ret = ftrace_startup(&amp;graph_ops, FTRACE_START_FUNC_RET);</span><br><span class="line">out:</span><br><span class="line">	mutex_unlock(&amp;ftrace_lock);</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-2、配置function-filter-1级过滤"><a href="#2-2-2、配置function-filter-1级过滤" class="headerlink" title="2.2.2、配置function filter(1级过滤)"></a>2.2.2、配置function filter(1级过滤)</h3><p>因为function_graph tracer的graph_ops继续共用global_ops的hash表，使用“set_ftrace_filter/set_ftrace_notrace”接口可以配置global_ops的filter_hash/notrace_hash表。所以可以继续使用“set_ftrace_filter/set_ftrace_notrace”来配置function_graph tracer的filter。</p>
<p>function_graph tracer还可以使用“set_graph_function/set_graph_notrace”接口来配置过滤，需要两种过滤条件都满足的函数才能被trace。所以我们命名当前过滤为1级过滤。</p>
<p>具体的代码解析参考：<a href="#set_ftrace_filter"> 1.2.6、配置function tracer的filter </a></p>
<h3 id="2-2-3、配置function-graph-filter-2级过滤"><a href="#2-2-3、配置function-graph-filter-2级过滤" class="headerlink" title="2.2.3、配置function_graph filter(2级过滤)"></a>2.2.3、配置function_graph filter(2级过滤)</h3><p>通过设置“set_graph_function/set_graph_notrace”可以配置2级过滤，实际上是配置到ftrace_graph_funcs[]/ftrace_graph_notrace_funcs[]表中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">trace_create_file(&quot;set_graph_function&quot;, 0444, d_tracer,</span><br><span class="line">			    NULL,</span><br><span class="line">			    &amp;ftrace_graph_fops);</span><br><span class="line">trace_create_file(&quot;set_graph_notrace&quot;, 0444, d_tracer,</span><br><span class="line">			    NULL,</span><br><span class="line">			    &amp;ftrace_graph_notrace_fops);</span><br><span class="line"></span><br><span class="line">static const struct file_operations ftrace_graph_fops = &#123;</span><br><span class="line">	.open		= ftrace_graph_open,</span><br><span class="line">	.read		= seq_read,</span><br><span class="line">	.write		= ftrace_graph_write,</span><br><span class="line">	.llseek		= tracing_lseek,</span><br><span class="line">	.release	= ftrace_graph_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static int</span><br><span class="line">ftrace_graph_open(struct inode *inode, struct file *file)</span><br><span class="line">&#123;</span><br><span class="line">	struct ftrace_graph_data *fgd;</span><br><span class="line"></span><br><span class="line">	if (unlikely(ftrace_disabled))</span><br><span class="line">		return -ENODEV;</span><br><span class="line"></span><br><span class="line">	fgd = kmalloc(sizeof(*fgd), GFP_KERNEL);</span><br><span class="line">	if (fgd == NULL)</span><br><span class="line">		return -ENOMEM;</span><br><span class="line"></span><br><span class="line">	fgd-&gt;table = ftrace_graph_funcs;</span><br><span class="line">	fgd-&gt;size = FTRACE_GRAPH_MAX_FUNCS;</span><br><span class="line">	fgd-&gt;count = &amp;ftrace_graph_count;</span><br><span class="line">	fgd-&gt;seq_ops = &amp;ftrace_graph_seq_ops;</span><br><span class="line"></span><br><span class="line">	return __ftrace_graph_open(inode, file, fgd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static ssize_t</span><br><span class="line">ftrace_graph_write(struct file *file, const char __user *ubuf,</span><br><span class="line">		   size_t cnt, loff_t *ppos)</span><br><span class="line">&#123;</span><br><span class="line">	struct trace_parser parser;</span><br><span class="line">	ssize_t read, ret = 0;</span><br><span class="line">	struct ftrace_graph_data *fgd = file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">	if (!cnt)</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">	if (trace_parser_get_init(&amp;parser, FTRACE_BUFF_MAX))</span><br><span class="line">		return -ENOMEM;</span><br><span class="line"></span><br><span class="line">	read = trace_get_user(&amp;parser, ubuf, cnt, ppos);</span><br><span class="line"></span><br><span class="line">	if (read &gt;= 0 &amp;&amp; trace_parser_loaded((&amp;parser))) &#123;</span><br><span class="line">		parser.buffer[parser.idx] = 0;</span><br><span class="line"></span><br><span class="line">		mutex_lock(&amp;graph_lock);</span><br><span class="line"></span><br><span class="line">		/* we allow only one expression at a time */</span><br><span class="line">		/* 根据filter设置条件，设置ftrace_graph_funcs[]表 */</span><br><span class="line">		ret = ftrace_set_func(fgd-&gt;table, fgd-&gt;count, fgd-&gt;size,</span><br><span class="line">				      parser.buffer);</span><br><span class="line"></span><br><span class="line">		mutex_unlock(&amp;graph_lock);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (!ret)</span><br><span class="line">		ret = read;</span><br><span class="line"></span><br><span class="line">	trace_parser_put(&amp;parser);</span><br><span class="line"></span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在trace_graph_entry()中会进行2级过滤的合法性判断，函数必须是“set_graph_function/set_graph_notrace”配置中允许的函数或者是被它们调用的子函数才能继续执行，否则出错返回后面的trace_graph_return()都不会被执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">int trace_graph_entry(struct ftrace_graph_ent *trace)</span><br><span class="line">&#123;</span><br><span class="line">	struct trace_array *tr = graph_array;</span><br><span class="line">	struct trace_array_cpu *data;</span><br><span class="line">	unsigned long flags;</span><br><span class="line">	long disabled;</span><br><span class="line">	int ret;</span><br><span class="line">	int cpu;</span><br><span class="line">	int pc;</span><br><span class="line"></span><br><span class="line">	if (!ftrace_trace_task(current))</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">	/* trace it when it is-nested-in or is a function enabled. */</span><br><span class="line">	/*  ftrace_graph_addr(trace-&gt;func) // 函数必须是“set_graph_function/set_graph_notrace”配置中允许的函数</span><br><span class="line">	    trace-&gt;depth // 或者是被它们调用的子函数</span><br><span class="line">	 */</span><br><span class="line">	if ((!(trace-&gt;depth || ftrace_graph_addr(trace-&gt;func)) ||</span><br><span class="line">	     ftrace_graph_ignore_irqs()) || (trace-&gt;depth &lt; 0) ||</span><br><span class="line">	    (max_depth &amp;&amp; trace-&gt;depth &gt;= max_depth))</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Do not trace a function if it&apos;s filtered by set_graph_notrace.</span><br><span class="line">	 * Make the index of ret stack negative to indicate that it should</span><br><span class="line">	 * ignore further functions.  But it needs its own ret stack entry</span><br><span class="line">	 * to recover the original index in order to continue tracing after</span><br><span class="line">	 * returning from the function.</span><br><span class="line">	 */</span><br><span class="line">	if (ftrace_graph_notrace_addr(trace-&gt;func))</span><br><span class="line">		return 1;</span><br><span class="line"></span><br><span class="line">	local_irq_save(flags);</span><br><span class="line">	cpu = raw_smp_processor_id();</span><br><span class="line">	data = per_cpu_ptr(tr-&gt;trace_buffer.data, cpu);</span><br><span class="line">	disabled = atomic_inc_return(&amp;data-&gt;disabled);</span><br><span class="line">	if (likely(disabled == 1)) &#123;</span><br><span class="line">		pc = preempt_count();</span><br><span class="line">		ret = __trace_graph_entry(tr, trace, flags, pc);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		ret = 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	atomic_dec(&amp;data-&gt;disabled);</span><br><span class="line">	local_irq_restore(flags);</span><br><span class="line"></span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static inline int ftrace_graph_addr(unsigned long addr)</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line"></span><br><span class="line">	if (!ftrace_graph_count)</span><br><span class="line">		return 1;</span><br><span class="line"></span><br><span class="line">    /* 查找地址是否在ftrace_graph_funcs[]表中 */</span><br><span class="line">	for (i = 0; i &lt; ftrace_graph_count; i++) &#123;</span><br><span class="line">		if (addr == ftrace_graph_funcs[i]) &#123;</span><br><span class="line">			/*</span><br><span class="line">			 * If no irqs are to be traced, but a set_graph_function</span><br><span class="line">			 * is set, and called by an interrupt handler, we still</span><br><span class="line">			 * want to trace it.</span><br><span class="line">			 */</span><br><span class="line">			if (in_irq())</span><br><span class="line">				trace_recursion_set(TRACE_IRQ_BIT);</span><br><span class="line">			else</span><br><span class="line">				trace_recursion_clear(TRACE_IRQ_BIT);</span><br><span class="line">			return 1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-3、数据存入"><a href="#2-3、数据存入" class="headerlink" title="2.3、数据存入"></a>2.3、数据存入</h2><p>和function tracer不一样的是，function_graph在进入函数和返回函数时都有trace数据存入。</p>
<h3 id="2-3-1、trace-graph-entry"><a href="#2-3-1、trace-graph-entry" class="headerlink" title="2.3.1、trace_graph_entry()"></a>2.3.1、trace_graph_entry()</h3><p><img src="/images/ftrace_tracer/entry_trace_graph_entry.png" alt="image"></p>
<p>函数入口的存入：trace_graph_entry() -&gt; __trace_graph_entry()：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int __trace_graph_entry(struct trace_array *tr,</span><br><span class="line">				struct ftrace_graph_ent *trace,</span><br><span class="line">				unsigned long flags,</span><br><span class="line">				int pc)</span><br><span class="line">&#123;</span><br><span class="line">	struct trace_event_call *call = &amp;event_funcgraph_entry;</span><br><span class="line">	struct ring_buffer_event *event;</span><br><span class="line">	struct ring_buffer *buffer = tr-&gt;trace_buffer.buffer;</span><br><span class="line">	struct ftrace_graph_ent_entry *entry;</span><br><span class="line"></span><br><span class="line">	event = trace_buffer_lock_reserve(buffer, TRACE_GRAPH_ENT,</span><br><span class="line">					  sizeof(*entry), flags, pc);</span><br><span class="line">	if (!event)</span><br><span class="line">		return 0;</span><br><span class="line">	entry	= ring_buffer_event_data(event);</span><br><span class="line">	entry-&gt;graph_ent			= *trace;</span><br><span class="line">	if (!call_filter_check_discard(call, entry, buffer, event))</span><br><span class="line">		__buffer_unlock_commit(buffer, event);</span><br><span class="line"></span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-2、trace-graph-return"><a href="#2-3-2、trace-graph-return" class="headerlink" title="2.3.2、trace_graph_return()"></a>2.3.2、trace_graph_return()</h3><p><img src="/images/ftrace_tracer/entry_trace_graph_return.png" alt="image"></p>
<p>函数返回的存入：trace_graph_return() -&gt; __trace_graph_return()：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void __trace_graph_return(struct trace_array *tr,</span><br><span class="line">				struct ftrace_graph_ret *trace,</span><br><span class="line">				unsigned long flags,</span><br><span class="line">				int pc)</span><br><span class="line">&#123;</span><br><span class="line">	struct trace_event_call *call = &amp;event_funcgraph_exit;</span><br><span class="line">	struct ring_buffer_event *event;</span><br><span class="line">	struct ring_buffer *buffer = tr-&gt;trace_buffer.buffer;</span><br><span class="line">	struct ftrace_graph_ret_entry *entry;</span><br><span class="line"></span><br><span class="line">	event = trace_buffer_lock_reserve(buffer, TRACE_GRAPH_RET,</span><br><span class="line">					  sizeof(*entry), flags, pc);</span><br><span class="line">	if (!event)</span><br><span class="line">		return;</span><br><span class="line">	entry	= ring_buffer_event_data(event);</span><br><span class="line">	entry-&gt;ret				= *trace;</span><br><span class="line">	if (!call_filter_check_discard(call, entry, buffer, event))</span><br><span class="line">		__buffer_unlock_commit(buffer, event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-3、filter"><a href="#2-3-3、filter" class="headerlink" title="2.3.3、filter"></a>2.3.3、filter</h3><p>参见“2.2.2、配置function filter(1级过滤)”和“2.2.3、配置function_graph filter(2级过滤)”。</p>
<h2 id="2-4、数据读出"><a href="#2-4、数据读出" class="headerlink" title="2.4、数据读出"></a>2.4、数据读出</h2><p>从trace文件读出的function_graph tracer默认数据格式为：(显示function_graph中设置的函数或者是被它们调用的子函数)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"># cat trace</span><br><span class="line"># tracer: function_graph</span><br><span class="line">#</span><br><span class="line"># CPU  DURATION                  FUNCTION CALLS</span><br><span class="line"># |     |   |                     |   |   |   |</span><br><span class="line"> 0)               |  tty_open() &#123;</span><br><span class="line"> 0)   1.563 us    |    nonseekable_open();</span><br><span class="line"> 0)               |    tty_alloc_file() &#123;</span><br><span class="line"> 0)               |      kmem_cache_alloc_trace() &#123;</span><br><span class="line"> 0)               |        __might_sleep() &#123;</span><br><span class="line"> 0)   0.417 us    |          ___might_sleep();</span><br><span class="line"> 0)   4.791 us    |        &#125;</span><br><span class="line"> 0)   1.302 us    |        preempt_count_add();</span><br><span class="line"> 0)   1.250 us    |        preempt_count_sub();</span><br><span class="line"> 0)               |        __slab_alloc.isra.60.constprop.62() &#123;</span><br><span class="line"> 0)               |          ___slab_alloc.constprop.63() &#123;</span><br><span class="line"> 0)               |            _raw_spin_lock() &#123;</span><br><span class="line"> 0)   1.250 us    |              preempt_count_add();</span><br><span class="line"> 0)   0.520 us    |              do_raw_spin_trylock();</span><br><span class="line"> 0)   9.531 us    |            &#125;</span><br><span class="line"> 0)   0.781 us    |            preempt_count_add();</span><br><span class="line"> 0)   0.469 us    |            preempt_count_sub();</span><br><span class="line"> 0)               |            _raw_spin_unlock() &#123;</span><br><span class="line"> 0)   0.521 us    |              do_raw_spin_unlock();</span><br><span class="line"> 0)   1.614 us    |              preempt_count_sub();</span><br><span class="line"> 0)   9.584 us    |            &#125;</span><br><span class="line"> 0)               |            alloc_debug_processing() &#123;</span><br><span class="line"> 0)               |              check_slab() &#123;</span><br><span class="line"> 0)   1.198 us    |                slab_pad_check.part.52();</span><br><span class="line"> 0)   5.990 us    |              &#125;</span><br><span class="line"> 0)               |              check_object() &#123;</span><br><span class="line"> 0)   1.719 us    |                check_bytes_and_report();</span><br><span class="line"> 0)   0.521 us    |                check_bytes_and_report();</span><br><span class="line"> 0)   2.448 us    |                check_bytes_and_report();</span><br><span class="line"> 0)   0.469 us    |                check_bytes_and_report();</span><br><span class="line"> 0)   1.927 us    |                check_bytes_and_report();</span><br><span class="line"> 0) + 29.843 us   |              &#125;</span><br><span class="line"> 0)               |              set_track() &#123;</span><br></pre></td></tr></table></figure>
<p>在通过trace文件读出数据时，如果tracer的print_line()函数有定义，则会调用print_line()函数进行解析。而不再去使用event-&gt;funcs-&gt;trace()函数。</p>
<p>1、读操作时，seq_read() -&gt; s_show() -&gt; print_trace_line() -&gt; tracer-&gt;print_line()：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">static struct tracer graph_trace __tracer_data = &#123;</span><br><span class="line">	.name		= &quot;function_graph&quot;,</span><br><span class="line">	.update_thresh	= graph_trace_update_thresh,</span><br><span class="line">	.open		= graph_trace_open,</span><br><span class="line">	.pipe_open	= graph_trace_open,</span><br><span class="line">	.close		= graph_trace_close,</span><br><span class="line">	.pipe_close	= graph_trace_close,</span><br><span class="line">	.init		= graph_trace_init,</span><br><span class="line">	.reset		= graph_trace_reset,</span><br><span class="line">	.print_line	= print_graph_function,</span><br><span class="line">	.print_header	= print_graph_headers,</span><br><span class="line">	.flags		= &amp;tracer_flags,</span><br><span class="line">	.set_flag	= func_graph_set_flag,</span><br><span class="line">#ifdef CONFIG_FTRACE_SELFTEST</span><br><span class="line">	.selftest	= trace_selftest_startup_function_graph,</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static enum print_line_t</span><br><span class="line">print_graph_function(struct trace_iterator *iter)</span><br><span class="line">&#123;</span><br><span class="line">	return print_graph_function_flags(iter, tracer_flags.val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">enum print_line_t</span><br><span class="line">print_graph_function_flags(struct trace_iterator *iter, u32 flags)</span><br><span class="line">&#123;</span><br><span class="line">	struct ftrace_graph_ent_entry *field;</span><br><span class="line">	struct fgraph_data *data = iter-&gt;private;</span><br><span class="line">	struct trace_entry *entry = iter-&gt;ent;</span><br><span class="line">	struct trace_seq *s = &amp;iter-&gt;seq;</span><br><span class="line">	int cpu = iter-&gt;cpu;</span><br><span class="line">	int ret;</span><br><span class="line"></span><br><span class="line">	if (flags &amp; TRACE_GRAPH_PRINT_FLAT)</span><br><span class="line">		return TRACE_TYPE_UNHANDLED;</span><br><span class="line"></span><br><span class="line">	if (data &amp;&amp; per_cpu_ptr(data-&gt;cpu_data, cpu)-&gt;ignore) &#123;</span><br><span class="line">		per_cpu_ptr(data-&gt;cpu_data, cpu)-&gt;ignore = 0;</span><br><span class="line">		return TRACE_TYPE_HANDLED;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * If the last output failed, there&apos;s a possibility we need</span><br><span class="line">	 * to print out the missing entry which would never go out.</span><br><span class="line">	 */</span><br><span class="line">	if (data &amp;&amp; data-&gt;failed) &#123;</span><br><span class="line">		field = &amp;data-&gt;ent;</span><br><span class="line">		iter-&gt;cpu = data-&gt;cpu;</span><br><span class="line">		ret = print_graph_entry(field, s, iter, flags);</span><br><span class="line">		if (ret == TRACE_TYPE_HANDLED &amp;&amp; iter-&gt;cpu != cpu) &#123;</span><br><span class="line">			per_cpu_ptr(data-&gt;cpu_data, iter-&gt;cpu)-&gt;ignore = 1;</span><br><span class="line">			ret = TRACE_TYPE_NO_CONSUME;</span><br><span class="line">		&#125;</span><br><span class="line">		iter-&gt;cpu = cpu;</span><br><span class="line">		return ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	switch (entry-&gt;type) &#123;</span><br><span class="line">	/* (1) 打印TRACE_GRAPH_ENT类型的entry */</span><br><span class="line">	case TRACE_GRAPH_ENT: &#123;</span><br><span class="line">		/*</span><br><span class="line">		 * print_graph_entry() may consume the current event,</span><br><span class="line">		 * thus @field may become invalid, so we need to save it.</span><br><span class="line">		 * sizeof(struct ftrace_graph_ent_entry) is very small,</span><br><span class="line">		 * it can be safely saved at the stack.</span><br><span class="line">		 */</span><br><span class="line">		struct ftrace_graph_ent_entry saved;</span><br><span class="line">		trace_assign_type(field, entry);</span><br><span class="line">		saved = *field;</span><br><span class="line">		return print_graph_entry(&amp;saved, s, iter, flags);</span><br><span class="line">	&#125;</span><br><span class="line">	/* (2) 打印TRACE_GRAPH_RET类型的entry */</span><br><span class="line">	case TRACE_GRAPH_RET: &#123;</span><br><span class="line">		struct ftrace_graph_ret_entry *field;</span><br><span class="line">		trace_assign_type(field, entry);</span><br><span class="line">		return print_graph_return(&amp;field-&gt;ret, s, entry, iter, flags);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	/* (3) TRACE_STACK、TRACE_FN这两种类型的entry，graph无法处理，返回交由系统打印 */</span><br><span class="line">	case TRACE_STACK:</span><br><span class="line">	case TRACE_FN:</span><br><span class="line">		/* dont trace stack and functions as comments */</span><br><span class="line">		return TRACE_TYPE_UNHANDLED;</span><br><span class="line"></span><br><span class="line">    /* (4) 打印其他类型的entry */</span><br><span class="line">	default:</span><br><span class="line">		return print_graph_comment(s, entry, iter, flags);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return TRACE_TYPE_HANDLED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、在第一次读操作时，会打印header。seq_read() -&gt; s_show() -&gt; print_trace_line() -&gt; tracer-&gt;print_header()：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">static void print_graph_headers(struct seq_file *s)</span><br><span class="line">&#123;</span><br><span class="line">	print_graph_headers_flags(s, tracer_flags.val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">void print_graph_headers_flags(struct seq_file *s, u32 flags)</span><br><span class="line">&#123;</span><br><span class="line">	struct trace_iterator *iter = s-&gt;private;</span><br><span class="line">	struct trace_array *tr = iter-&gt;tr;</span><br><span class="line"></span><br><span class="line">	if (flags &amp; TRACE_GRAPH_PRINT_FLAT) &#123;</span><br><span class="line">		trace_default_header(s);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (!(tr-&gt;trace_flags &amp; TRACE_ITER_CONTEXT_INFO))</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	if (tr-&gt;trace_flags &amp; TRACE_ITER_LATENCY_FMT) &#123;</span><br><span class="line">		/* print nothing if the buffers are empty */</span><br><span class="line">		if (trace_empty(iter))</span><br><span class="line">			return;</span><br><span class="line"></span><br><span class="line">		print_trace_header(s, iter);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	__print_graph_headers_flags(tr, s, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、在open的时候，也会调用到tracer的open函数。tracing_open() -&gt; __tracing_open() -&gt; tracer-&gt;open()：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">void graph_trace_open(struct trace_iterator *iter)</span><br><span class="line">&#123;</span><br><span class="line">	/* pid and depth on the last trace processed */</span><br><span class="line">	struct fgraph_data *data;</span><br><span class="line">	gfp_t gfpflags;</span><br><span class="line">	int cpu;</span><br><span class="line"></span><br><span class="line">	iter-&gt;private = NULL;</span><br><span class="line"></span><br><span class="line">	/* We can be called in atomic context via ftrace_dump() */</span><br><span class="line">	gfpflags = (in_atomic() || irqs_disabled()) ? GFP_ATOMIC : GFP_KERNEL;</span><br><span class="line"></span><br><span class="line">	data = kzalloc(sizeof(*data), gfpflags);</span><br><span class="line">	if (!data)</span><br><span class="line">		goto out_err;</span><br><span class="line"></span><br><span class="line">	data-&gt;cpu_data = alloc_percpu_gfp(struct fgraph_cpu_data, gfpflags);</span><br><span class="line">	if (!data-&gt;cpu_data)</span><br><span class="line">		goto out_err_free;</span><br><span class="line"></span><br><span class="line">	for_each_possible_cpu(cpu) &#123;</span><br><span class="line">		pid_t *pid = &amp;(per_cpu_ptr(data-&gt;cpu_data, cpu)-&gt;last_pid);</span><br><span class="line">		int *depth = &amp;(per_cpu_ptr(data-&gt;cpu_data, cpu)-&gt;depth);</span><br><span class="line">		int *ignore = &amp;(per_cpu_ptr(data-&gt;cpu_data, cpu)-&gt;ignore);</span><br><span class="line">		int *depth_irq = &amp;(per_cpu_ptr(data-&gt;cpu_data, cpu)-&gt;depth_irq);</span><br><span class="line"></span><br><span class="line">		*pid = -1;</span><br><span class="line">		*depth = 0;</span><br><span class="line">		*ignore = 0;</span><br><span class="line">		*depth_irq = -1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	iter-&gt;private = data;</span><br><span class="line"></span><br><span class="line">	return;</span><br><span class="line"></span><br><span class="line"> out_err_free:</span><br><span class="line">	kfree(data);</span><br><span class="line"> out_err:</span><br><span class="line">	pr_warning(&quot;function graph tracer: not enough memory\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3、irqsoff-tracer"><a href="#3、irqsoff-tracer" class="headerlink" title="3、irqsoff tracer"></a>3、irqsoff tracer</h1><p>irqsoff tracer用来追踪最大关中断时间。它的trace会提供几部分信息：</p>
<ul>
<li>1、irqoff的最大时长:latency；</li>
<li>2、在最大irqoff这期间所有的function trace信息；</li>
<li>3、最后的irqon的函数回调信息；</li>
</ul>
<h2 id="3-1、插桩"><a href="#3-1、插桩" class="headerlink" title="3.1、插桩"></a>3.1、插桩</h2><p><img src="/images/ftrace_tracer/irqoff_trace_flow.png" alt="image"></p>
<p>irqsoff tracer的插桩方法，是直接在local_irq_enable()、local_irq_disable()中直接插入钩子函数trace_hardirqs_on()、trace_hardirqs_off()。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#ifdef CONFIG_TRACE_IRQFLAGS</span><br><span class="line">#define local_irq_enable() \</span><br><span class="line">	do &#123; trace_hardirqs_on(); raw_local_irq_enable(); &#125; while (0)</span><br><span class="line">#define local_irq_disable() \</span><br><span class="line">	do &#123; raw_local_irq_disable(); trace_hardirqs_off(); &#125; while (0)</span><br><span class="line">#define local_irq_save(flags)				\</span><br><span class="line">	do &#123;						\</span><br><span class="line">		raw_local_irq_save(flags);		\</span><br><span class="line">		trace_hardirqs_off();			\</span><br><span class="line">	&#125; while (0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define local_irq_restore(flags)			\</span><br><span class="line">	do &#123;						\</span><br><span class="line">		if (raw_irqs_disabled_flags(flags)) &#123;	\</span><br><span class="line">			raw_local_irq_restore(flags);	\</span><br><span class="line">			trace_hardirqs_off();		\</span><br><span class="line">		&#125; else &#123;				\</span><br><span class="line">			trace_hardirqs_on();		\</span><br><span class="line">			raw_local_irq_restore(flags);	\</span><br><span class="line">		&#125;					\</span><br><span class="line">	&#125; while (0)</span><br><span class="line"></span><br><span class="line">#define safe_halt()				\</span><br><span class="line">	do &#123;					\</span><br><span class="line">		trace_hardirqs_on();		\</span><br><span class="line">		raw_safe_halt();		\</span><br><span class="line">	&#125; while (0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#else /* !CONFIG_TRACE_IRQFLAGS */</span><br></pre></td></tr></table></figure>
<h3 id="3-1-1、trace-hardirqs-on-off"><a href="#3-1-1、trace-hardirqs-on-off" class="headerlink" title="3.1.1、trace_hardirqs_on/off()"></a>3.1.1、trace_hardirqs_on/off()</h3><p>local_irq_disable() -&gt; trace_hardirqs_off()：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">void trace_hardirqs_off(void)</span><br><span class="line">&#123;</span><br><span class="line">	if (!preempt_trace() &amp;&amp; irq_trace())</span><br><span class="line">		start_critical_timing(CALLER_ADDR0, CALLER_ADDR1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static inline void</span><br><span class="line">start_critical_timing(unsigned long ip, unsigned long parent_ip)</span><br><span class="line">&#123;</span><br><span class="line">	int cpu;</span><br><span class="line">	struct trace_array *tr = irqsoff_trace;</span><br><span class="line">	struct trace_array_cpu *data;</span><br><span class="line">	unsigned long flags;</span><br><span class="line"></span><br><span class="line">	if (!tracer_enabled || !tracing_is_enabled())</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	cpu = raw_smp_processor_id();</span><br><span class="line"></span><br><span class="line">    /* (1) 如果已经开始tracing，中间的重复关中断操作被忽略 */</span><br><span class="line">	if (per_cpu(tracing_cpu, cpu))</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	data = per_cpu_ptr(tr-&gt;trace_buffer.data, cpu);</span><br><span class="line"></span><br><span class="line">	if (unlikely(!data) || atomic_read(&amp;data-&gt;disabled))</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	atomic_inc(&amp;data-&gt;disabled);</span><br><span class="line"></span><br><span class="line">    /* (2) 记录trace的开始时间 */</span><br><span class="line">	data-&gt;critical_sequence = max_sequence;</span><br><span class="line">	data-&gt;preempt_timestamp = ftrace_now(cpu);</span><br><span class="line">	data-&gt;critical_start = parent_ip ? : ip;</span><br><span class="line"></span><br><span class="line">	local_save_flags(flags);</span><br><span class="line"></span><br><span class="line">    /* (3) 记录一下当前的function trace信息 */</span><br><span class="line">	__trace_function(tr, ip, parent_ip, flags, preempt_count());</span><br><span class="line"></span><br><span class="line">    /* (4) 设置开始tracing标志 </span><br><span class="line">        这是一个非常重要的标准，打开所有function trace的记录</span><br><span class="line">     */</span><br><span class="line">	per_cpu(tracing_cpu, cpu) = 1;</span><br><span class="line"></span><br><span class="line">	atomic_dec(&amp;data-&gt;disabled);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>local_irq_enable() -&gt; trace_hardirqs_on()：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line">void trace_hardirqs_on(void)</span><br><span class="line">&#123;</span><br><span class="line">	if (!preempt_trace() &amp;&amp; irq_trace())</span><br><span class="line">		stop_critical_timing(CALLER_ADDR0, CALLER_ADDR1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static inline void</span><br><span class="line">stop_critical_timing(unsigned long ip, unsigned long parent_ip)</span><br><span class="line">&#123;</span><br><span class="line">	int cpu;</span><br><span class="line">	struct trace_array *tr = irqsoff_trace;</span><br><span class="line">	struct trace_array_cpu *data;</span><br><span class="line">	unsigned long flags;</span><br><span class="line"></span><br><span class="line">	cpu = raw_smp_processor_id();</span><br><span class="line">	/* Always clear the tracing cpu on stopping the trace */</span><br><span class="line">	/* (1) 清除开始tracing标志 </span><br><span class="line">        这是一个非常重要的标准，停止所有function trace的记录</span><br><span class="line">     */</span><br><span class="line">	if (unlikely(per_cpu(tracing_cpu, cpu)))</span><br><span class="line">		per_cpu(tracing_cpu, cpu) = 0;</span><br><span class="line">	else</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	if (!tracer_enabled || !tracing_is_enabled())</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	data = per_cpu_ptr(tr-&gt;trace_buffer.data, cpu);</span><br><span class="line"></span><br><span class="line">	if (unlikely(!data) ||</span><br><span class="line">	    !data-&gt;critical_start || atomic_read(&amp;data-&gt;disabled))</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	atomic_inc(&amp;data-&gt;disabled);</span><br><span class="line"></span><br><span class="line">    /* (2) 记录一下当前的function trace信息 */</span><br><span class="line">	local_save_flags(flags);</span><br><span class="line">	__trace_function(tr, ip, parent_ip, flags, preempt_count());</span><br><span class="line">	</span><br><span class="line">	/* (3) check当前的irqoff持续时长是不是最大的latency */</span><br><span class="line">	check_critical_timing(tr, data, parent_ip ? : ip, cpu);</span><br><span class="line">	data-&gt;critical_start = 0;</span><br><span class="line">	atomic_dec(&amp;data-&gt;disabled);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">check_critical_timing(struct trace_array *tr,</span><br><span class="line">		      struct trace_array_cpu *data,</span><br><span class="line">		      unsigned long parent_ip,</span><br><span class="line">		      int cpu)</span><br><span class="line">&#123;</span><br><span class="line">	cycle_t T0, T1, delta;</span><br><span class="line">	unsigned long flags;</span><br><span class="line">	int pc;</span><br><span class="line"></span><br><span class="line">    /* (3.1) 当前irqoff的持续时长 */</span><br><span class="line">	T0 = data-&gt;preempt_timestamp;</span><br><span class="line">	T1 = ftrace_now(cpu);</span><br><span class="line">	delta = T1-T0;</span><br><span class="line"></span><br><span class="line">	local_save_flags(flags);</span><br><span class="line"></span><br><span class="line">	pc = preempt_count();</span><br><span class="line"></span><br><span class="line">    /* (3.2) 判断是否是新的最大latency */</span><br><span class="line">	if (!report_latency(tr, delta))</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">	raw_spin_lock_irqsave(&amp;max_trace_lock, flags);</span><br><span class="line"></span><br><span class="line">	/* check if we are still the max latency */</span><br><span class="line">	if (!report_latency(tr, delta))</span><br><span class="line">		goto out_unlock;</span><br><span class="line"></span><br><span class="line">    /* (3.3) 如果是最大latency： </span><br><span class="line">        记录一下当前的function trace信息</span><br><span class="line">        记录当前的stack信息</span><br><span class="line">     */</span><br><span class="line">	__trace_function(tr, CALLER_ADDR0, parent_ip, flags, pc);</span><br><span class="line">	/* Skip 5 functions to get to the irq/preempt enable function */</span><br><span class="line">	__trace_stack(tr, flags, 5, pc);</span><br><span class="line"></span><br><span class="line">	if (data-&gt;critical_sequence != max_sequence)</span><br><span class="line">		goto out_unlock;</span><br><span class="line"></span><br><span class="line">	data-&gt;critical_end = parent_ip;</span><br><span class="line"></span><br><span class="line">    /* (3.4) ---------重要----------------- </span><br><span class="line">        这一步非常重要，主要做了以下工作：</span><br><span class="line">        1、把当前的trace buffer备份到max_buffer中</span><br><span class="line">        2、更新max_buffer中max_buf-&gt;time_start时间戳，这个记录了最大latency trace信息的起始位置</span><br><span class="line">     */</span><br><span class="line">	if (likely(!is_tracing_stopped())) &#123;</span><br><span class="line">		tr-&gt;max_latency = delta;</span><br><span class="line">		update_max_tr_single(tr, current, cpu);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	max_sequence++;</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">	raw_spin_unlock_irqrestore(&amp;max_trace_lock, flags);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	data-&gt;critical_sequence = max_sequence;</span><br><span class="line">	data-&gt;preempt_timestamp = ftrace_now(cpu);</span><br><span class="line">	__trace_function(tr, CALLER_ADDR0, parent_ip, flags, pc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">update_max_tr_single(struct trace_array *tr, struct task_struct *tsk, int cpu)</span><br><span class="line">&#123;</span><br><span class="line">	int ret;</span><br><span class="line"></span><br><span class="line">	if (tr-&gt;stop_count)</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	WARN_ON_ONCE(!irqs_disabled());</span><br><span class="line">	if (!tr-&gt;allocated_snapshot) &#123;</span><br><span class="line">		/* Only the nop tracer should hit this when disabling */</span><br><span class="line">		WARN_ON_ONCE(tr-&gt;current_trace != &amp;nop_trace);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	arch_spin_lock(&amp;tr-&gt;max_lock);</span><br><span class="line"></span><br><span class="line">    /* (3.4.1) swap trace_buffer和max_buffer，把包含最大latency过程的trace信息备份到max_buffer中 */</span><br><span class="line">	ret = ring_buffer_swap_cpu(tr-&gt;max_buffer.buffer, tr-&gt;trace_buffer.buffer, cpu);</span><br><span class="line"></span><br><span class="line">	if (ret == -EBUSY) &#123;</span><br><span class="line">		/*</span><br><span class="line">		 * We failed to swap the buffer due to a commit taking</span><br><span class="line">		 * place on this CPU. We fail to record, but we reset</span><br><span class="line">		 * the max trace buffer (no one writes directly to it)</span><br><span class="line">		 * and flag that it failed.</span><br><span class="line">		 */</span><br><span class="line">		trace_array_printk_buf(tr-&gt;max_buffer.buffer, _THIS_IP_,</span><br><span class="line">			&quot;Failed to swap buffers due to commit in progress\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	WARN_ON_ONCE(ret &amp;&amp; ret != -EAGAIN &amp;&amp; ret != -EBUSY);</span><br><span class="line"></span><br><span class="line">    /* (3.4.2) 已经把包含最大latency过程的trace信息备份到max_buffer中了， </span><br><span class="line">        但是这个信息中包含了多次irqoff的trace信息，哪一次才是最大latency的信息呢？</span><br><span class="line">        使用max_buf-&gt;time_start来记录最大latency的起始时间</span><br><span class="line">        max_buf-&gt;time_start = data-&gt;preempt_timestamp;</span><br><span class="line">     */</span><br><span class="line">	__update_max_tr(tr, tsk, cpu);</span><br><span class="line">	arch_spin_unlock(&amp;tr-&gt;max_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-1-2、irqoff-trace信息的读取"><a href="#3-1-2、irqoff-trace信息的读取" class="headerlink" title="3.1.2、irqoff trace信息的读取"></a>3.1.2、irqoff trace信息的读取</h3><p>参考上一节，最大latency的trace信息被备份到了max_buffer中了，且max_buf-&gt;time_start来记录最大latency的起始时间。</p>
<p>所以在trace读取irqoff trace信息时，需要从max_buffer读取。tracing_open() -&gt; __tracing_open()：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">static struct trace_iterator *</span><br><span class="line">__tracing_open(struct inode *inode, struct file *file, bool snapshot)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_TRACER_MAX_TRACE</span><br><span class="line">	/* Currently only the top directory has a snapshot */</span><br><span class="line">	/* (1) 如果tracer的print_max被定义，从max_buffer从读取数据 */</span><br><span class="line">	if (tr-&gt;current_trace-&gt;print_max || snapshot)</span><br><span class="line">		iter-&gt;trace_buffer = &amp;tr-&gt;max_buffer;</span><br><span class="line">	else</span><br><span class="line">#endif</span><br><span class="line">		iter-&gt;trace_buffer = &amp;tr-&gt;trace_buffer;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static struct tracer irqsoff_tracer __read_mostly =</span><br><span class="line">&#123;</span><br><span class="line">	.name		= &quot;irqsoff&quot;,</span><br><span class="line">	.init		= irqsoff_tracer_init,</span><br><span class="line">	.reset		= irqsoff_tracer_reset,</span><br><span class="line">	.start		= irqsoff_tracer_start,</span><br><span class="line">	.stop		= irqsoff_tracer_stop,</span><br><span class="line">	.print_max	= true,     /* irqoff tracer的print_max为true */</span><br><span class="line">	.print_header   = irqsoff_print_header,</span><br><span class="line">	.print_line     = irqsoff_print_line,</span><br><span class="line">	.flag_changed	= irqsoff_flag_changed,</span><br><span class="line">#ifdef CONFIG_FTRACE_SELFTEST</span><br><span class="line">	.selftest    = trace_selftest_startup_irqsoff,</span><br><span class="line">#endif</span><br><span class="line">	.open           = irqsoff_trace_open,</span><br><span class="line">	.close          = irqsoff_trace_close,</span><br><span class="line">	.allow_instances = true,</span><br><span class="line">	.use_max_tr	= true,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在读取时，还需要做时间同步只读取max_buf-&gt;time_start时间戳以后的数据。tracing_open() -&gt; __tracing_open() -&gt; tracing_iter_reset()：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">void tracing_iter_reset(struct trace_iterator *iter, int cpu)</span><br><span class="line">&#123;</span><br><span class="line">	struct ring_buffer_event *event;</span><br><span class="line">	struct ring_buffer_iter *buf_iter;</span><br><span class="line">	unsigned long entries = 0;</span><br><span class="line">	u64 ts;</span><br><span class="line"></span><br><span class="line">	per_cpu_ptr(iter-&gt;trace_buffer-&gt;data, cpu)-&gt;skipped_entries = 0;</span><br><span class="line"></span><br><span class="line">	buf_iter = trace_buffer_iter(iter, cpu);</span><br><span class="line">	if (!buf_iter)</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	ring_buffer_iter_reset(buf_iter);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * We could have the case with the max latency tracers</span><br><span class="line">	 * that a reset never took place on a cpu. This is evident</span><br><span class="line">	 * by the timestamp being before the start of the buffer.</span><br><span class="line">	 */</span><br><span class="line">	/* (1) 对于时间戳小于time_start的trace数据全部丢弃掉， </span><br><span class="line">	    只读取time_start时间戳以后的数据</span><br><span class="line">	 */</span><br><span class="line">	while ((event = ring_buffer_iter_peek(buf_iter, &amp;ts))) &#123;</span><br><span class="line">		if (ts &gt;= iter-&gt;trace_buffer-&gt;time_start)</span><br><span class="line">			break;</span><br><span class="line">		entries++;</span><br><span class="line">		ring_buffer_read(buf_iter, NULL);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	per_cpu_ptr(iter-&gt;trace_buffer-&gt;data, cpu)-&gt;skipped_entries = entries;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-1-3、irqsoff-tracer的使能"><a href="#3-1-3、irqsoff-tracer的使能" class="headerlink" title="3.1.3、irqsoff tracer的使能"></a>3.1.3、irqsoff tracer的使能</h3><ul>
<li>irqsoff tracer需要使用function trace或者function_graph trace来记录最大latency的中间函数调用过程。所以它会注册一个global_ops-&gt;func，或者使用graph_ops注册。</li>
<li>trace数据的写入受trace_hardirqs_off()、trace_hardirqs_on()中配置的开关per_cpu(tracing_cpu, cpu)控制。在trace_hardirqs_off()时打开开关，在trace_hardirqs_on()时关闭开关，这样就记录下了irqoff过程中的具体函数调用过程。</li>
</ul>
<p>参考<a href="#function_tracer_enable">“1.2.5、function tracer使能”</a>这一节，tracer的使能最后调用的是tracer-&gt;init()函数。</p>
<p>对irqsoff tracer来说，调用的是irqsoff_tracer_init()：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">static struct tracer irqsoff_tracer __read_mostly =</span><br><span class="line">&#123;</span><br><span class="line">	.name		= &quot;irqsoff&quot;,</span><br><span class="line">	.init		= irqsoff_tracer_init,</span><br><span class="line">	.reset		= irqsoff_tracer_reset,</span><br><span class="line">	.start		= irqsoff_tracer_start,</span><br><span class="line">	.stop		= irqsoff_tracer_stop,</span><br><span class="line">	.print_max	= true,</span><br><span class="line">	.print_header   = irqsoff_print_header,</span><br><span class="line">	.print_line     = irqsoff_print_line,</span><br><span class="line">	.flag_changed	= irqsoff_flag_changed,</span><br><span class="line">#ifdef CONFIG_FTRACE_SELFTEST</span><br><span class="line">	.selftest    = trace_selftest_startup_irqsoff,</span><br><span class="line">#endif</span><br><span class="line">	.open           = irqsoff_trace_open,</span><br><span class="line">	.close          = irqsoff_trace_close,</span><br><span class="line">	.allow_instances = true,</span><br><span class="line">	.use_max_tr	= true,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static int irqsoff_tracer_init(struct trace_array *tr)</span><br><span class="line">&#123;</span><br><span class="line">	trace_type = TRACER_IRQS_OFF;</span><br><span class="line"></span><br><span class="line">	return __irqsoff_tracer_init(tr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static int __irqsoff_tracer_init(struct trace_array *tr)</span><br><span class="line">&#123;</span><br><span class="line">	if (irqsoff_busy)</span><br><span class="line">		return -EBUSY;</span><br><span class="line"></span><br><span class="line">	save_flags = tr-&gt;trace_flags;</span><br><span class="line"></span><br><span class="line">	/* non overwrite screws up the latency tracers */</span><br><span class="line">	set_tracer_flag(tr, TRACE_ITER_OVERWRITE, 1);</span><br><span class="line">	set_tracer_flag(tr, TRACE_ITER_LATENCY_FMT, 1);</span><br><span class="line"></span><br><span class="line">	tr-&gt;max_latency = 0;</span><br><span class="line">	irqsoff_trace = tr;</span><br><span class="line">	/* make sure that the tracer is visible */</span><br><span class="line">	smp_wmb();</span><br><span class="line">	tracing_reset_online_cpus(&amp;tr-&gt;trace_buffer);</span><br><span class="line"></span><br><span class="line">    /* (1) 如果采用function trace模式来记录最大latency过程中的trace信息 </span><br><span class="line">        global_ops-&gt;func = irqsoff_tracer_call()</span><br><span class="line">     */</span><br><span class="line">	ftrace_init_array_ops(tr, irqsoff_tracer_call);</span><br><span class="line"></span><br><span class="line">	/* Only toplevel instance supports graph tracing */</span><br><span class="line">	/* (2) 选择使用 function trace模式 or function_graph trace模式 注册</span><br><span class="line">	    默认是function trace模式</span><br><span class="line">	 */</span><br><span class="line">	if (start_irqsoff_tracer(tr, (tr-&gt;flags &amp; TRACE_ARRAY_FL_GLOBAL &amp;&amp;</span><br><span class="line">				      is_graph(tr))))</span><br><span class="line">		printk(KERN_ERR &quot;failed to start irqsoff tracer\n&quot;);</span><br><span class="line"></span><br><span class="line">	irqsoff_busy = true;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">start_irqsoff_tracer() -&gt; register_irqsoff_function()</span><br><span class="line"></span><br><span class="line">static int register_irqsoff_function(struct trace_array *tr, int graph, int set)</span><br><span class="line">&#123;</span><br><span class="line">	int ret;</span><br><span class="line"></span><br><span class="line">	/* &apos;set&apos; is set if TRACE_ITER_FUNCTION is about to be set */</span><br><span class="line">	if (function_enabled || (!set &amp;&amp; !(tr-&gt;trace_flags &amp; TRACE_ITER_FUNCTION)))</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">	if (graph)</span><br><span class="line">	    /* (2.1) function_graph trace模式注册 */</span><br><span class="line">		ret = register_ftrace_graph(&amp;irqsoff_graph_return,</span><br><span class="line">					    &amp;irqsoff_graph_entry);</span><br><span class="line">	else</span><br><span class="line">	    /* (2.2) function trace模式注册 */</span><br><span class="line">		ret = register_ftrace_function(tr-&gt;ops);</span><br><span class="line"></span><br><span class="line">	if (!ret)</span><br><span class="line">		function_enabled = true;</span><br><span class="line"></span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在记录trace数据时，需要判断per_cpu(tracing_cpu, cpu)开关。以function trace模式为例，我们来看看其irqsoff_tracer_call()函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">static void</span><br><span class="line">irqsoff_tracer_call(unsigned long ip, unsigned long parent_ip,</span><br><span class="line">		    struct ftrace_ops *op, struct pt_regs *pt_regs)</span><br><span class="line">&#123;</span><br><span class="line">	struct trace_array *tr = irqsoff_trace;</span><br><span class="line">	struct trace_array_cpu *data;</span><br><span class="line">	unsigned long flags;</span><br><span class="line"></span><br><span class="line">	if (!func_prolog_dec(tr, &amp;data, &amp;flags))</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	trace_function(tr, ip, parent_ip, flags, preempt_count());</span><br><span class="line"></span><br><span class="line">	atomic_dec(&amp;data-&gt;disabled);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static int func_prolog_dec(struct trace_array *tr,</span><br><span class="line">			   struct trace_array_cpu **data,</span><br><span class="line">			   unsigned long *flags)</span><br><span class="line">&#123;</span><br><span class="line">	long disabled;</span><br><span class="line">	int cpu;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Does not matter if we preempt. We test the flags</span><br><span class="line">	 * afterward, to see if irqs are disabled or not.</span><br><span class="line">	 * If we preempt and get a false positive, the flags</span><br><span class="line">	 * test will fail.</span><br><span class="line">	 */</span><br><span class="line">	cpu = raw_smp_processor_id();</span><br><span class="line">	/* 对tracing_cpu开关的判断，由trace_hardirqs_off()、trace_hardirqs_on()函数控制 */</span><br><span class="line">	if (likely(!per_cpu(tracing_cpu, cpu)))</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">	local_save_flags(*flags);</span><br><span class="line">	/*</span><br><span class="line">	 * Slight chance to get a false positive on tracing_cpu,</span><br><span class="line">	 * although I&apos;m starting to think there isn&apos;t a chance.</span><br><span class="line">	 * Leave this for now just to be paranoid.</span><br><span class="line">	 */</span><br><span class="line">	if (!irqs_disabled_flags(*flags) &amp;&amp; !preempt_count())</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">	*data = per_cpu_ptr(tr-&gt;trace_buffer.data, cpu);</span><br><span class="line">	disabled = atomic_inc_return(&amp;(*data)-&gt;disabled);</span><br><span class="line"></span><br><span class="line">	if (likely(disabled == 1))</span><br><span class="line">		return 1;</span><br><span class="line"></span><br><span class="line">	atomic_dec(&amp;(*data)-&gt;disabled);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-2、数据存入"><a href="#3-2、数据存入" class="headerlink" title="3.2、数据存入"></a>3.2、数据存入</h2><p>它的trace会提供几部分信息：</p>
<ul>
<li>1、irqoff的最大时长:latency；</li>
<li>2、在最大irqoff这期间所有的function trace信息；</li>
<li>3、最后的irqon的函数回调信息；</li>
</ul>
<p>具体的存入方法参考“3.1、插桩”这一节的描述。</p>
<h2 id="3-3、数据读出"><a href="#3-3、数据读出" class="headerlink" title="3.3、数据读出"></a>3.3、数据读出</h2><p>从trace文件读出的irqoff tracer默认数据格式为：(显示最大latency以及过程中的详细函数调用)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br></pre></td><td class="code"><pre><span class="line"># cat trace</span><br><span class="line"># tracer: irqsoff</span><br><span class="line">#</span><br><span class="line"># irqsoff latency trace v1.1.5 on 4.4.21-g6678ed0-01979-g8d8eeb5-cIcd1f2d8-dirty</span><br><span class="line"># --------------------------------------------------------------------</span><br><span class="line"># latency: 1703 us, #184/184, CPU#3 | (M:preempt VP:0, KP:0, SP:0 HP:0 #P:8)</span><br><span class="line">#    -----------------</span><br><span class="line">#    | task: swapper/3-0 (uid:0 nice:0 policy:0 rt_prio:0)</span><br><span class="line">#    -----------------</span><br><span class="line">#  =&gt; started at: lpm_cpuidle_enter</span><br><span class="line">#  =&gt; ended at:   cpuidle_enter_state</span><br><span class="line">#</span><br><span class="line">#</span><br><span class="line">#                  _------=&gt; CPU#</span><br><span class="line">#                 / _-----=&gt; irqs-off</span><br><span class="line">#                | / _----=&gt; need-resched</span><br><span class="line">#                || / _---=&gt; hardirq/softirq</span><br><span class="line">#                ||| / _--=&gt; preempt-depth</span><br><span class="line">#                |||| /     delay</span><br><span class="line">#  cmd     pid   ||||| time  |   caller</span><br><span class="line">#     \   /      |||||  \    |   /</span><br><span class="line">  &lt;idle&gt;-0       3dn.1    3us : psci_enter_sleep &lt;-lpm_cpuidle_enter</span><br><span class="line">  &lt;idle&gt;-0       3dn.2    9us : update_debug_pc_event &lt;-psci_enter_sleep</span><br><span class="line">  &lt;idle&gt;-0       3dn.2   11us : _raw_spin_lock &lt;-update_debug_pc_event</span><br><span class="line">  &lt;idle&gt;-0       3dn.2   13us : preempt_count_add &lt;-_raw_spin_lock</span><br><span class="line">  &lt;idle&gt;-0       3dn.3   17us : do_raw_spin_trylock &lt;-_raw_spin_lock</span><br><span class="line">  &lt;idle&gt;-0       3dn.3   20us : _raw_spin_unlock &lt;-update_debug_pc_event</span><br><span class="line">  &lt;idle&gt;-0       3dn.3   23us : do_raw_spin_unlock &lt;-_raw_spin_unlock</span><br><span class="line">  &lt;idle&gt;-0       3dn.3   25us : preempt_count_sub &lt;-_raw_spin_unlock</span><br><span class="line">  &lt;idle&gt;-0       3dn.2   28us : ktime_get &lt;-lpm_cpuidle_enter</span><br><span class="line">  &lt;idle&gt;-0       3dn.2   33us : arch_counter_read &lt;-ktime_get</span><br><span class="line">  &lt;idle&gt;-0       3dn.2   35us : lpm_stats_cpu_exit &lt;-lpm_cpuidle_enter</span><br><span class="line">  &lt;idle&gt;-0       3dn.2   37us : update_level_stats.part.1 &lt;-lpm_stats_cpu_exit</span><br><span class="line">  &lt;idle&gt;-0       3dn.2   41us : cluster_unprepare &lt;-lpm_cpuidle_enter</span><br><span class="line">  &lt;idle&gt;-0       3dn.2   43us : _raw_spin_lock &lt;-cluster_unprepare</span><br><span class="line">  &lt;idle&gt;-0       3dn.2   44us : preempt_count_add &lt;-_raw_spin_lock</span><br><span class="line">  &lt;idle&gt;-0       3dn.3   46us : do_raw_spin_trylock &lt;-_raw_spin_lock</span><br><span class="line">  &lt;idle&gt;-0       3dn.3   50us : lpm_stats_cluster_exit &lt;-cluster_unprepare</span><br><span class="line">  &lt;idle&gt;-0       3dn.3   52us : update_level_stats.part.1 &lt;-lpm_stats_cluster_exit</span><br><span class="line">  &lt;idle&gt;-0       3dn.3   57us : update_debug_pc_event &lt;-cluster_unprepare</span><br><span class="line">  &lt;idle&gt;-0       3dn.3   59us : _raw_spin_lock &lt;-update_debug_pc_event</span><br><span class="line">  &lt;idle&gt;-0       3dn.3   60us : preempt_count_add &lt;-_raw_spin_lock</span><br><span class="line">  &lt;idle&gt;-0       3dn.4   62us : do_raw_spin_trylock &lt;-_raw_spin_lock</span><br><span class="line">  &lt;idle&gt;-0       3dn.4   65us : _raw_spin_unlock &lt;-update_debug_pc_event</span><br><span class="line">  &lt;idle&gt;-0       3dn.4   66us : do_raw_spin_unlock &lt;-_raw_spin_unlock</span><br><span class="line">  &lt;idle&gt;-0       3dn.4   69us : preempt_count_sub &lt;-_raw_spin_unlock</span><br><span class="line">  &lt;idle&gt;-0       3dn.3   71us : sched_set_cluster_dstate &lt;-cluster_unprepare</span><br><span class="line">  &lt;idle&gt;-0       3dn.3   74us : cpu_cluster_pm_exit &lt;-cluster_unprepare</span><br><span class="line">  &lt;idle&gt;-0       3dn.3   76us : _raw_read_lock &lt;-cpu_cluster_pm_exit</span><br><span class="line">  &lt;idle&gt;-0       3dn.3   78us : preempt_count_add &lt;-_raw_read_lock</span><br><span class="line">  &lt;idle&gt;-0       3dn.4   80us : do_raw_read_trylock &lt;-_raw_read_lock</span><br><span class="line">  &lt;idle&gt;-0       3dn.4   82us : cpu_pm_notify &lt;-cpu_cluster_pm_exit</span><br><span class="line">  &lt;idle&gt;-0       3dn.4   84us : __raw_notifier_call_chain &lt;-cpu_pm_notify</span><br><span class="line">  &lt;idle&gt;-0       3dn.4   86us : notifier_call_chain &lt;-__raw_notifier_call_chain</span><br><span class="line">  &lt;idle&gt;-0       3dn.4   88us : gic_cpu_pm_notifier &lt;-notifier_call_chain</span><br><span class="line">  &lt;idle&gt;-0       3dn.4   90us : arch_timer_cpu_pm_notify &lt;-notifier_call_chain</span><br><span class="line">  &lt;idle&gt;-0       3dn.4   92us : jtag_cpu_pm_callback &lt;-notifier_call_chain</span><br><span class="line">  &lt;idle&gt;-0       3dn.4   95us : gladiator_erp_pm_callback &lt;-notifier_call_chain</span><br><span class="line">  &lt;idle&gt;-0       3dn.4   97us : cpu_pm_pmu_notify &lt;-notifier_call_chain</span><br><span class="line">  &lt;idle&gt;-0       3dn.4   99us : cpu_pm_pmu_common &lt;-cpu_pm_pmu_notify</span><br><span class="line">  &lt;idle&gt;-0       3dn.4  102us : cti_cpu_pm_callback &lt;-notifier_call_chain</span><br><span class="line">  &lt;idle&gt;-0       3dn.4  104us : coresight_cti_ctx_restore &lt;-cti_cpu_pm_callback</span><br><span class="line">  &lt;idle&gt;-0       3dn.4  109us : _raw_spin_lock_irqsave &lt;-coresight_cti_ctx_restore</span><br><span class="line">  &lt;idle&gt;-0       3dn.4  111us : preempt_count_add &lt;-_raw_spin_lock_irqsave</span><br><span class="line">  &lt;idle&gt;-0       3dn.5  113us!: do_raw_spin_trylock &lt;-_raw_spin_lock_irqsave</span><br><span class="line">  &lt;idle&gt;-0       3dn.5  222us : _raw_spin_unlock_irqrestore &lt;-coresight_cti_ctx_restore</span><br><span class="line">  &lt;idle&gt;-0       3dn.5  224us : do_raw_spin_unlock &lt;-_raw_spin_unlock_irqrestore</span><br><span class="line">  &lt;idle&gt;-0       3dn.5  226us : preempt_count_sub &lt;-_raw_spin_unlock_irqrestore</span><br><span class="line">  &lt;idle&gt;-0       3dn.4  228us : _raw_spin_lock_irqsave &lt;-coresight_cti_ctx_restore</span><br><span class="line">  &lt;idle&gt;-0       3dn.4  230us : preempt_count_add &lt;-_raw_spin_lock_irqsave</span><br><span class="line">  &lt;idle&gt;-0       3dn.5  232us!: do_raw_spin_trylock &lt;-_raw_spin_lock_irqsave</span><br><span class="line">  &lt;idle&gt;-0       3dn.5  337us : _raw_spin_unlock_irqrestore &lt;-coresight_cti_ctx_restore</span><br><span class="line">  &lt;idle&gt;-0       3dn.5  339us : do_raw_spin_unlock &lt;-_raw_spin_unlock_irqrestore</span><br><span class="line">  &lt;idle&gt;-0       3dn.5  341us : preempt_count_sub &lt;-_raw_spin_unlock_irqrestore</span><br><span class="line">  &lt;idle&gt;-0       3dn.4  343us : _raw_spin_lock_irqsave &lt;-coresight_cti_ctx_restore</span><br><span class="line">  &lt;idle&gt;-0       3dn.4  346us : preempt_count_add &lt;-_raw_spin_lock_irqsave</span><br><span class="line">  &lt;idle&gt;-0       3dn.5  348us!: do_raw_spin_trylock &lt;-_raw_spin_lock_irqsave</span><br><span class="line">  &lt;idle&gt;-0       3dn.5  492us : _raw_spin_unlock_irqrestore &lt;-coresight_cti_ctx_restore</span><br><span class="line">  &lt;idle&gt;-0       3dn.5  494us : do_raw_spin_unlock &lt;-_raw_spin_unlock_irqrestore</span><br><span class="line">  &lt;idle&gt;-0       3dn.5  497us : preempt_count_sub &lt;-_raw_spin_unlock_irqrestore</span><br><span class="line">  &lt;idle&gt;-0       3dn.4  499us : _raw_spin_lock_irqsave &lt;-coresight_cti_ctx_restore</span><br><span class="line">  &lt;idle&gt;-0       3dn.4  501us : preempt_count_add &lt;-_raw_spin_lock_irqsave</span><br><span class="line">  &lt;idle&gt;-0       3dn.5  503us+: do_raw_spin_trylock &lt;-_raw_spin_lock_irqsave</span><br><span class="line">  &lt;idle&gt;-0       3dn.5  603us : _raw_spin_unlock_irqrestore &lt;-coresight_cti_ctx_restore</span><br><span class="line">  &lt;idle&gt;-0       3dn.5  605us : do_raw_spin_unlock &lt;-_raw_spin_unlock_irqrestore</span><br><span class="line">  &lt;idle&gt;-0       3dn.5  607us : preempt_count_sub &lt;-_raw_spin_unlock_irqrestore</span><br><span class="line">  &lt;idle&gt;-0       3dn.4  613us : fpsimd_cpu_pm_notifier &lt;-notifier_call_chain</span><br><span class="line">  &lt;idle&gt;-0       3dn.4  615us : _raw_read_unlock &lt;-cpu_cluster_pm_exit</span><br><span class="line">  &lt;idle&gt;-0       3dn.4  617us : do_raw_read_unlock &lt;-_raw_read_unlock</span><br><span class="line">  &lt;idle&gt;-0       3dn.4  619us : preempt_count_sub &lt;-_raw_read_unlock</span><br><span class="line">  &lt;idle&gt;-0       3dn.3  621us : update_cluster_history &lt;-cluster_unprepare</span><br><span class="line">  &lt;idle&gt;-0       3dn.3  623us : ktime_get &lt;-update_cluster_history</span><br><span class="line">  &lt;idle&gt;-0       3dn.3  626us : arch_counter_read &lt;-ktime_get</span><br><span class="line">  &lt;idle&gt;-0       3dn.3  629us : cluster_unprepare &lt;-cluster_unprepare</span><br><span class="line">  &lt;idle&gt;-0       3dn.3  631us : _raw_spin_lock &lt;-cluster_unprepare</span><br><span class="line">  &lt;idle&gt;-0       3dn.3  633us : preempt_count_add &lt;-_raw_spin_lock</span><br><span class="line">  &lt;idle&gt;-0       3dn.4  635us : do_raw_spin_trylock &lt;-_raw_spin_lock</span><br><span class="line">  &lt;idle&gt;-0       3dn.4  638us : _raw_spin_unlock &lt;-cluster_unprepare</span><br><span class="line">  &lt;idle&gt;-0       3dn.4  640us : do_raw_spin_unlock &lt;-_raw_spin_unlock</span><br><span class="line">  &lt;idle&gt;-0       3dn.4  642us : preempt_count_sub &lt;-_raw_spin_unlock</span><br><span class="line">  &lt;idle&gt;-0       3dn.3  644us : _raw_spin_unlock &lt;-cluster_unprepare</span><br><span class="line">  &lt;idle&gt;-0       3dn.3  645us : do_raw_spin_unlock &lt;-_raw_spin_unlock</span><br><span class="line">  &lt;idle&gt;-0       3dn.3  647us : preempt_count_sub &lt;-_raw_spin_unlock</span><br><span class="line">  &lt;idle&gt;-0       3dn.2  649us : tick_broadcast_oneshot_control &lt;-lpm_cpuidle_enter</span><br><span class="line">  &lt;idle&gt;-0       3dn.2  651us : __tick_broadcast_oneshot_control &lt;-tick_broadcast_oneshot_control</span><br><span class="line">  &lt;idle&gt;-0       3dn.2  653us : _raw_spin_lock &lt;-__tick_broadcast_oneshot_control</span><br><span class="line">  &lt;idle&gt;-0       3dn.2  654us : preempt_count_add &lt;-_raw_spin_lock</span><br><span class="line">  &lt;idle&gt;-0       3dn.3  657us : do_raw_spin_trylock &lt;-_raw_spin_lock</span><br><span class="line">  &lt;idle&gt;-0       3dn.3  660us : clockevents_switch_state &lt;-__tick_broadcast_oneshot_control</span><br><span class="line">  &lt;idle&gt;-0       3dn.3  663us : ktime_get &lt;-__tick_broadcast_oneshot_control</span><br><span class="line">  &lt;idle&gt;-0       3dn.3  667us : arch_counter_read &lt;-ktime_get</span><br><span class="line">  &lt;idle&gt;-0       3dn.3  668us : tick_program_event &lt;-__tick_broadcast_oneshot_control</span><br><span class="line">  &lt;idle&gt;-0       3dn.3  670us : clockevents_program_event &lt;-tick_program_event</span><br><span class="line">  &lt;idle&gt;-0       3dn.3  672us : ktime_get &lt;-clockevents_program_event</span><br><span class="line">  &lt;idle&gt;-0       3dn.3  676us : arch_counter_read &lt;-ktime_get</span><br><span class="line">  &lt;idle&gt;-0       3dn.3  678us : arch_timer_set_next_event_virt &lt;-clockevents_program_event</span><br><span class="line">  &lt;idle&gt;-0       3dn.3  679us : _raw_spin_unlock &lt;-__tick_broadcast_oneshot_control</span><br><span class="line">  &lt;idle&gt;-0       3dn.3  681us : do_raw_spin_unlock &lt;-_raw_spin_unlock</span><br><span class="line">  &lt;idle&gt;-0       3dn.3  683us : preempt_count_sub &lt;-_raw_spin_unlock</span><br><span class="line">  &lt;idle&gt;-0       3dn.2  685us : cpu_pm_exit &lt;-lpm_cpuidle_enter</span><br><span class="line">  &lt;idle&gt;-0       3dn.2  686us : _raw_read_lock &lt;-cpu_pm_exit</span><br><span class="line">  &lt;idle&gt;-0       3dn.2  688us : preempt_count_add &lt;-_raw_read_lock</span><br><span class="line">  &lt;idle&gt;-0       3dn.3  689us : do_raw_read_trylock &lt;-_raw_read_lock</span><br><span class="line">  &lt;idle&gt;-0       3dn.3  691us : cpu_pm_notify &lt;-cpu_pm_exit</span><br><span class="line">  &lt;idle&gt;-0       3dn.3  693us : __raw_notifier_call_chain &lt;-cpu_pm_notify</span><br><span class="line">  &lt;idle&gt;-0       3dn.3  694us : notifier_call_chain &lt;-__raw_notifier_call_chain</span><br><span class="line">  &lt;idle&gt;-0       3dn.3  696us : gic_cpu_pm_notifier &lt;-notifier_call_chain</span><br><span class="line">  &lt;idle&gt;-0       3dn.3  698us : gic_cpu_sys_reg_init &lt;-gic_cpu_pm_notifier</span><br><span class="line">  &lt;idle&gt;-0       3dn.3  700us : arch_timer_cpu_pm_notify &lt;-notifier_call_chain</span><br><span class="line">  &lt;idle&gt;-0       3dn.3  702us : jtag_cpu_pm_callback &lt;-notifier_call_chain</span><br><span class="line">  &lt;idle&gt;-0       3dn.3  704us : msm_jtag_restore_state &lt;-jtag_cpu_pm_callback</span><br><span class="line">  &lt;idle&gt;-0       3dn.3  708us : msm_jtag_etm_restore_state &lt;-msm_jtag_restore_state</span><br><span class="line">  &lt;idle&gt;-0       3dn.3  716us : raw_notifier_call_chain &lt;-msm_jtag_etm_restore_state</span><br><span class="line">  &lt;idle&gt;-0       3dn.3  717us!: notifier_call_chain &lt;-raw_notifier_call_chain</span><br><span class="line">  &lt;idle&gt;-0       3dn.3 1524us : gladiator_erp_pm_callback &lt;-notifier_call_chain</span><br><span class="line">  &lt;idle&gt;-0       3dn.3 1526us : cpu_pm_pmu_notify &lt;-notifier_call_chain</span><br><span class="line">  &lt;idle&gt;-0       3dn.3 1529us : armv8pmu_reset &lt;-cpu_pm_pmu_notify</span><br><span class="line">  &lt;idle&gt;-0       3dn.3 1531us : cpu_pm_pmu_common &lt;-cpu_pm_pmu_notify</span><br><span class="line">  &lt;idle&gt;-0       3dn.3 1533us : cpu_pm_pmu_setup &lt;-cpu_pm_pmu_common</span><br><span class="line">  &lt;idle&gt;-0       3dn.3 1538us : rcu_irq_enter &lt;-cpu_pm_pmu_setup</span><br><span class="line">  &lt;idle&gt;-0       3dn.3 1542us : rcu_eqs_exit_common.isra.48 &lt;-rcu_irq_enter</span><br><span class="line">  &lt;idle&gt;-0       3dn.3 1545us : rcu_try_advance_all_cbs &lt;-rcu_eqs_exit_common.isra.48</span><br><span class="line">  &lt;idle&gt;-0       3dn.3 1553us : armpmu_start &lt;-cpu_pm_pmu_setup</span><br><span class="line">  &lt;idle&gt;-0       3dn.3 1558us : armpmu_event_set_period &lt;-armpmu_start</span><br><span class="line">  &lt;idle&gt;-0       3dn.3 1562us : __rcu_read_lock &lt;-perf_event_update_userpage</span><br><span class="line">  &lt;idle&gt;-0       3dn.3 1566us : __rcu_read_unlock &lt;-perf_event_update_userpage</span><br><span class="line">  &lt;idle&gt;-0       3dn.3 1568us : armv8pmu_enable_event &lt;-armpmu_start</span><br><span class="line">  &lt;idle&gt;-0       3dn.3 1570us : _raw_spin_lock_irqsave &lt;-armv8pmu_enable_event</span><br><span class="line">  &lt;idle&gt;-0       3dn.3 1572us : preempt_count_add &lt;-_raw_spin_lock_irqsave</span><br><span class="line">  &lt;idle&gt;-0       3dn.4 1574us : do_raw_spin_trylock &lt;-_raw_spin_lock_irqsave</span><br><span class="line">  &lt;idle&gt;-0       3dn.4 1576us : _raw_spin_unlock_irqrestore &lt;-armv8pmu_enable_event</span><br><span class="line">  &lt;idle&gt;-0       3dn.4 1578us : do_raw_spin_unlock &lt;-_raw_spin_unlock_irqrestore</span><br><span class="line">  &lt;idle&gt;-0       3dn.4 1581us : preempt_count_sub &lt;-_raw_spin_unlock_irqrestore</span><br><span class="line">  &lt;idle&gt;-0       3dn.3 1584us : rcu_irq_exit &lt;-cpu_pm_pmu_setup</span><br><span class="line">  &lt;idle&gt;-0       3dn.3 1586us : rcu_eqs_enter_common.isra.46 &lt;-rcu_irq_exit</span><br><span class="line">  &lt;idle&gt;-0       3dn.3 1591us : rcu_irq_enter &lt;-cpu_pm_pmu_setup</span><br><span class="line">  &lt;idle&gt;-0       3dn.3 1593us : rcu_eqs_exit_common.isra.48 &lt;-rcu_irq_enter</span><br><span class="line">  &lt;idle&gt;-0       3dn.3 1596us : rcu_try_advance_all_cbs &lt;-rcu_eqs_exit_common.isra.48</span><br><span class="line">  &lt;idle&gt;-0       3dn.3 1598us : armpmu_start &lt;-cpu_pm_pmu_setup</span><br><span class="line">  &lt;idle&gt;-0       3dn.3 1601us : armpmu_event_set_period &lt;-armpmu_start</span><br><span class="line">  &lt;idle&gt;-0       3dn.3 1603us : __rcu_read_lock &lt;-perf_event_update_userpage</span><br><span class="line">  &lt;idle&gt;-0       3dn.3 1605us : __rcu_read_unlock &lt;-perf_event_update_userpage</span><br><span class="line">  &lt;idle&gt;-0       3dn.3 1606us : armv8pmu_enable_event &lt;-armpmu_start</span><br><span class="line">  &lt;idle&gt;-0       3dn.3 1608us : _raw_spin_lock_irqsave &lt;-armv8pmu_enable_event</span><br><span class="line">  &lt;idle&gt;-0       3dn.3 1611us : preempt_count_add &lt;-_raw_spin_lock_irqsave</span><br><span class="line">  &lt;idle&gt;-0       3dn.4 1615us : do_raw_spin_trylock &lt;-_raw_spin_lock_irqsave</span><br><span class="line">  &lt;idle&gt;-0       3dn.4 1617us : _raw_spin_unlock_irqrestore &lt;-armv8pmu_enable_event</span><br><span class="line">  &lt;idle&gt;-0       3dn.4 1619us : do_raw_spin_unlock &lt;-_raw_spin_unlock_irqrestore</span><br><span class="line">  &lt;idle&gt;-0       3dn.4 1622us : preempt_count_sub &lt;-_raw_spin_unlock_irqrestore</span><br><span class="line">  &lt;idle&gt;-0       3dn.3 1623us : rcu_irq_exit &lt;-cpu_pm_pmu_setup</span><br><span class="line">  &lt;idle&gt;-0       3dn.3 1627us : rcu_eqs_enter_common.isra.46 &lt;-rcu_irq_exit</span><br><span class="line">  &lt;idle&gt;-0       3dn.3 1629us : rcu_irq_enter &lt;-cpu_pm_pmu_setup</span><br><span class="line">  &lt;idle&gt;-0       3dn.3 1632us : rcu_eqs_exit_common.isra.48 &lt;-rcu_irq_enter</span><br><span class="line">  &lt;idle&gt;-0       3dn.3 1634us : rcu_try_advance_all_cbs &lt;-rcu_eqs_exit_common.isra.48</span><br><span class="line">  &lt;idle&gt;-0       3dn.3 1637us : armpmu_start &lt;-cpu_pm_pmu_setup</span><br><span class="line">  &lt;idle&gt;-0       3dn.3 1639us : armpmu_event_set_period &lt;-armpmu_start</span><br><span class="line">  &lt;idle&gt;-0       3dn.3 1642us : __rcu_read_lock &lt;-perf_event_update_userpage</span><br><span class="line">  &lt;idle&gt;-0       3dn.3 1644us : __rcu_read_unlock &lt;-perf_event_update_userpage</span><br><span class="line">  &lt;idle&gt;-0       3dn.3 1646us : armv8pmu_enable_event &lt;-armpmu_start</span><br><span class="line">  &lt;idle&gt;-0       3dn.3 1647us : _raw_spin_lock_irqsave &lt;-armv8pmu_enable_event</span><br><span class="line">  &lt;idle&gt;-0       3dn.3 1649us : preempt_count_add &lt;-_raw_spin_lock_irqsave</span><br><span class="line">  &lt;idle&gt;-0       3dn.4 1651us : do_raw_spin_trylock &lt;-_raw_spin_lock_irqsave</span><br><span class="line">  &lt;idle&gt;-0       3dn.4 1653us : _raw_spin_unlock_irqrestore &lt;-armv8pmu_enable_event</span><br><span class="line">  &lt;idle&gt;-0       3dn.4 1655us : do_raw_spin_unlock &lt;-_raw_spin_unlock_irqrestore</span><br><span class="line">  &lt;idle&gt;-0       3dn.4 1657us : preempt_count_sub &lt;-_raw_spin_unlock_irqrestore</span><br><span class="line">  &lt;idle&gt;-0       3dn.3 1659us : rcu_irq_exit &lt;-cpu_pm_pmu_setup</span><br><span class="line">  &lt;idle&gt;-0       3dn.3 1662us : rcu_eqs_enter_common.isra.46 &lt;-rcu_irq_exit</span><br><span class="line">  &lt;idle&gt;-0       3dn.3 1665us : armv8pmu_start &lt;-cpu_pm_pmu_common</span><br><span class="line">  &lt;idle&gt;-0       3dn.3 1667us : _raw_spin_lock_irqsave &lt;-armv8pmu_start</span><br><span class="line">  &lt;idle&gt;-0       3dn.3 1670us : preempt_count_add &lt;-_raw_spin_lock_irqsave</span><br><span class="line">  &lt;idle&gt;-0       3dn.4 1672us : do_raw_spin_trylock &lt;-_raw_spin_lock_irqsave</span><br><span class="line">  &lt;idle&gt;-0       3dn.4 1674us : _raw_spin_unlock_irqrestore &lt;-armv8pmu_start</span><br><span class="line">  &lt;idle&gt;-0       3dn.4 1676us : do_raw_spin_unlock &lt;-_raw_spin_unlock_irqrestore</span><br><span class="line">  &lt;idle&gt;-0       3dn.4 1679us : preempt_count_sub &lt;-_raw_spin_unlock_irqrestore</span><br><span class="line">  &lt;idle&gt;-0       3dn.3 1680us : cti_cpu_pm_callback &lt;-notifier_call_chain</span><br><span class="line">  &lt;idle&gt;-0       3dn.3 1683us : fpsimd_cpu_pm_notifier &lt;-notifier_call_chain</span><br><span class="line">  &lt;idle&gt;-0       3dn.3 1684us : _raw_read_unlock &lt;-cpu_pm_exit</span><br><span class="line">  &lt;idle&gt;-0       3dn.3 1686us : do_raw_read_unlock &lt;-_raw_read_unlock</span><br><span class="line">  &lt;idle&gt;-0       3dn.3 1688us : preempt_count_sub &lt;-_raw_read_unlock</span><br><span class="line">  &lt;idle&gt;-0       3dn.2 1691us : sched_set_cpu_cstate &lt;-lpm_cpuidle_enter</span><br><span class="line">  &lt;idle&gt;-0       3dn.2 1693us : ktime_get &lt;-lpm_cpuidle_enter</span><br><span class="line">  &lt;idle&gt;-0       3dn.2 1697us : arch_counter_read &lt;-ktime_get</span><br><span class="line">  &lt;idle&gt;-0       3dn.1 1702us : lpm_cpuidle_enter &lt;-cpuidle_enter_state</span><br><span class="line">  &lt;idle&gt;-0       3dn.1 1708us+: trace_hardirqs_on &lt;-cpuidle_enter_state</span><br><span class="line">  &lt;idle&gt;-0       3dn.1 1720us : &lt;stack trace&gt;</span><br><span class="line"> =&gt; trace_hardirqs_on</span><br><span class="line"> =&gt; lpm_cpuidle_enter</span><br><span class="line"> =&gt; cpuidle_enter_state</span><br><span class="line"> =&gt; cpuidle_enter</span><br><span class="line"> =&gt; cpu_startup_entry</span><br><span class="line"> =&gt; secondary_start_kernel</span><br><span class="line"> =&gt;</span><br></pre></td></tr></table></figure>
<p>在通过trace文件读出数据时：</p>
<ul>
<li>具体函数调用信息是使用trace_function()或者trace_graph_function()函数进行记录的，调用相应的方法解析即可；</li>
<li>最后的irqon的函数回调信息是使用__trace_stack()函数进行记录的，调用相应的方法解析即可；</li>
<li>最大latency信息的解析，使用tracer-&gt;print_header()；</li>
</ul>
<p>在第一次读操作时，会打印header。seq_read() -&gt; s_show() -&gt; print_trace_line() -&gt; tracer-&gt;print_header()：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static void irqsoff_print_header(struct seq_file *s)</span><br><span class="line">&#123;</span><br><span class="line">	trace_default_header(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p><a href="https://www.kernel.org/doc/html/latest/trace/ftrace-design.html" target="_blank" rel="noopener">1、Function Tracer Design</a><br><a href="http://blog.chinaunix.net/xmlrpc.php?r=blog/article&amp;uid=23141914&amp;id=5603238" target="_blank" rel="noopener">2、ftrace function_graph分析</a>  </p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/function-tracer/" rel="tag"># function tracer</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/12/21/ftrace_trace_event/" rel="next" title="Linux Ftrace 1.2、trace event">
                <i class="fa fa-chevron-left"></i> Linux Ftrace 1.2、trace event
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/12/21/perf_event_architecture/" rel="prev" title="Linux Perf 1.1、perf_event内核框架">
                Linux Perf 1.1、perf_event内核框架 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/touxiang/ycqs.jpg" alt="pwl999">
            
              <p class="site-author-name" itemprop="name">pwl999</p>
              <p class="site-description motion-element" itemprop="description">RTFSC(Read The Fucking Source Code)</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives">
                
                    <span class="site-state-item-count">30</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">3</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">22</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1、fucntion-tracer"><span class="nav-number">1.</span> <span class="nav-text">1、fucntion tracer</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1、插桩原理"><span class="nav-number">1.1.</span> <span class="nav-text">1.1、插桩原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-1、-mcount"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1.1、_mcount()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-2、static-ftrace插桩"><span class="nav-number">1.1.2.</span> <span class="nav-text">1.1.2、static ftrace插桩</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-3、dynamic-ftrace插桩"><span class="nav-number">1.1.3.</span> <span class="nav-text">1.1.3、dynamic ftrace插桩</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2、插桩点管理"><span class="nav-number">1.2.</span> <span class="nav-text">1.2、插桩点管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-1、插桩点的初始化"><span class="nav-number">1.2.1.</span> <span class="nav-text">1.2.1、插桩点的初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-2、插桩点的动态管理"><span class="nav-number">1.2.2.</span> <span class="nav-text">1.2.2、插桩点的动态管理 </span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-3、tracer注册"><span class="nav-number">1.2.3.</span> <span class="nav-text">1.2.3、tracer注册</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-4、tracer使能"><span class="nav-number">1.2.4.</span> <span class="nav-text">1.2.4、tracer使能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-5、function-tracer使能"><span class="nav-number">1.2.5.</span> <span class="nav-text">1.2.5、function tracer使能  </span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-6、配置function-tracer的filter"><span class="nav-number">1.2.6.</span> <span class="nav-text">1.2.6、配置function tracer的filter  </span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-7、配置function-tracer的filter-command"><span class="nav-number">1.2.7.</span> <span class="nav-text">1.2.7、配置function tracer的filter command</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3、数据存入"><span class="nav-number">1.3.</span> <span class="nav-text">1.3、数据存入</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-1、数据格式"><span class="nav-number">1.3.1.</span> <span class="nav-text">1.3.1、数据格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-2、filter"><span class="nav-number">1.3.2.</span> <span class="nav-text">1.3.2、filter</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4、数据读出"><span class="nav-number">1.4.</span> <span class="nav-text">1.4、数据读出</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2、function-graph-tracer"><span class="nav-number">2.</span> <span class="nav-text">2、function_graph tracer</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1、插桩原理"><span class="nav-number">2.1.</span> <span class="nav-text">2.1、插桩原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2、插桩点管理"><span class="nav-number">2.2.</span> <span class="nav-text">2.2、插桩点管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-1、function-graph-tracer使能"><span class="nav-number">2.2.1.</span> <span class="nav-text">2.2.1、function_graph tracer使能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-2、配置function-filter-1级过滤"><span class="nav-number">2.2.2.</span> <span class="nav-text">2.2.2、配置function filter(1级过滤)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-3、配置function-graph-filter-2级过滤"><span class="nav-number">2.2.3.</span> <span class="nav-text">2.2.3、配置function_graph filter(2级过滤)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3、数据存入"><span class="nav-number">2.3.</span> <span class="nav-text">2.3、数据存入</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-1、trace-graph-entry"><span class="nav-number">2.3.1.</span> <span class="nav-text">2.3.1、trace_graph_entry()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-2、trace-graph-return"><span class="nav-number">2.3.2.</span> <span class="nav-text">2.3.2、trace_graph_return()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-3、filter"><span class="nav-number">2.3.3.</span> <span class="nav-text">2.3.3、filter</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4、数据读出"><span class="nav-number">2.4.</span> <span class="nav-text">2.4、数据读出</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3、irqsoff-tracer"><span class="nav-number">3.</span> <span class="nav-text">3、irqsoff tracer</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1、插桩"><span class="nav-number">3.1.</span> <span class="nav-text">3.1、插桩</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-1、trace-hardirqs-on-off"><span class="nav-number">3.1.1.</span> <span class="nav-text">3.1.1、trace_hardirqs_on/off()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-2、irqoff-trace信息的读取"><span class="nav-number">3.1.2.</span> <span class="nav-text">3.1.2、irqoff trace信息的读取</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-3、irqsoff-tracer的使能"><span class="nav-number">3.1.3.</span> <span class="nav-text">3.1.3、irqsoff tracer的使能</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2、数据存入"><span class="nav-number">3.2.</span> <span class="nav-text">3.2、数据存入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3、数据读出"><span class="nav-number">3.3.</span> <span class="nav-text">3.3、数据读出</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考资料："><span class="nav-number">4.</span> <span class="nav-text">参考资料：</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">pwl999</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v6.6.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script src="/js/src/utils.js?v=6.6.0"></script>

  <script src="/js/src/motion.js?v=6.6.0"></script>



  
  


  <script src="/js/src/affix.js?v=6.6.0"></script>

  <script src="/js/src/schemes/pisces.js?v=6.6.0"></script>



  
  <script src="/js/src/scrollspy.js?v=6.6.0"></script>
<script src="/js/src/post-details.js?v=6.6.0"></script>



  


  <script src="/js/src/bootstrap.js?v=6.6.0"></script>



  

  
    <script id="dsq-count-scr" src="https://.disqus.com/count.js" async></script>
  

  





  











  





  

  

  

  

  

  
  

  

  

  

  

  

  

</body>
</html>
