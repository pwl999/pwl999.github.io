<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
































<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.6.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.6.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.6.0" color="#222">









<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.6.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="workqueue是内核里面很重要的一个机制，特别是内核驱动，一般的小型任务(work)都不会自己起一个线程来处理，而是扔到workqueu中处理。workqueue的主要工作就是用进程上下文来处理内核中大量的小任务。   所以workqueue的主要设计思想：一个是并行，多个work不要相互阻塞；另外一个是节省资源，多个work尽量共享资源(进程、调度、内存)，不要造成系统过多的资源浪费。">
<meta name="keywords" content="workqueue">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux Workqueue">
<meta property="og:url" content="http://yoursite.com/2018/12/21/linux_workqueue/index.html">
<meta property="og:site_name" content="pwl999&#39;s blog">
<meta property="og:description" content="workqueue是内核里面很重要的一个机制，特别是内核驱动，一般的小型任务(work)都不会自己起一个线程来处理，而是扔到workqueu中处理。workqueue的主要工作就是用进程上下文来处理内核中大量的小任务。   所以workqueue的主要设计思想：一个是并行，多个work不要相互阻塞；另外一个是节省资源，多个work尽量共享资源(进程、调度、内存)，不要造成系统过多的资源浪费。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/images/workqueue/wq_topology.png">
<meta property="og:image" content="http://yoursite.com/images/workqueue/wq_worker_pool.png">
<meta property="og:image" content="http://yoursite.com/images/workqueue/wq_normal_wq_topology.png">
<meta property="og:image" content="http://yoursite.com/images/workqueue/wq_unbound_std_wq.png">
<meta property="og:image" content="http://yoursite.com/images/workqueue/wq_unboundstd_wq_topology.png">
<meta property="og:image" content="http://yoursite.com/images/workqueue/wq_ordered_wq.png">
<meta property="og:image" content="http://yoursite.com/images/workqueue/wq_ordered_wq_topology.png">
<meta property="og:image" content="http://yoursite.com/images/workqueue/wq_worker_statusmachine.png">
<meta property="og:updated_time" content="2018-12-21T03:08:17.973Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Linux Workqueue">
<meta name="twitter:description" content="workqueue是内核里面很重要的一个机制，特别是内核驱动，一般的小型任务(work)都不会自己起一个线程来处理，而是扔到workqueu中处理。workqueue的主要工作就是用进程上下文来处理内核中大量的小任务。   所以workqueue的主要设计思想：一个是并行，多个work不要相互阻塞；另外一个是节省资源，多个work尽量共享资源(进程、调度、内存)，不要造成系统过多的资源浪费。">
<meta name="twitter:image" content="http://yoursite.com/images/workqueue/wq_topology.png">






  <link rel="canonical" href="http://yoursite.com/2018/12/21/linux_workqueue/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Linux Workqueue | pwl999's blog</title>
  












  <noscript>
  <style>
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion .logo-line-before i { left: initial; }
    .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">pwl999's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/21/linux_workqueue/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="pwl999">
      <meta itemprop="description" content="RTFSC(Read The Fucking Source Code)">
      <meta itemprop="image" content="/images/touxiang/ycqs.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="pwl999's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Linux Workqueue

              
            
          </h1>
        

        <div class="post-meta">

          
            <i class="fa fa-thumb-tack"></i>
            <font color="7D26CD">置顶</font>
            <span class="post-meta-divider">|</span>
          

        <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-21 10:18:21 / 修改时间：11:08:17" itemprop="dateCreated datePublished" datetime="2018-12-21T10:18:21+08:00">2018-12-21</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/12/21/linux_workqueue/#comments" itemprop="discussionUrl">
                
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/12/21/linux_workqueue/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>workqueue是内核里面很重要的一个机制，特别是内核驱动，一般的小型任务(work)都不会自己起一个线程来处理，而是扔到workqueu中处理。workqueue的主要工作就是用进程上下文来处理内核中大量的小任务。  </p>
<p>所以workqueue的主要设计思想：一个是并行，多个work不要相互阻塞；另外一个是节省资源，多个work尽量共享资源(进程、调度、内存)，不要造成系统过多的资源浪费。  </p>
<p>为了实现的设计思想，workqueue的设计实现也更新了很多版本。最新的workqueue实现叫做CMWQ(Concurrency Managed Workqueue)，也就是用更加智能的算法来实现“并行和节省”。新版本的workque创建函数改成alloc_workqueue()，旧版本的函数create_*workqueue()逐渐会被被废弃。</p>
<blockquote>
<p>本文的代码分析基于linux kernel 3.18.22，最好的学习方法还是”read the fucking source code”</p>
</blockquote>
<h1 id="1-CMWQ的几个基本概念"><a href="#1-CMWQ的几个基本概念" class="headerlink" title="1.CMWQ的几个基本概念"></a>1.CMWQ的几个基本概念</h1><p>关于workqueue中几个概念都是work相关的数据结构非常容易混淆，大概可以这样来理解：</p>
<ul>
<li>work        ：工作。</li>
<li>workqueue    ：工作的集合。workqueue和work是一对多的关系。</li>
<li>worker    ：工人。在代码中worker对应一个work_thread()内核线程。</li>
<li>worker_pool：工人的集合。worker_pool和worker是一对多的关系。</li>
<li>pwq(pool_workqueue)：中间人/中介，负责建立起workqueue和worker_pool之间的关系。workqueue和pwq是一对多的关系，pwq和worker_pool是一对一的关系。</li>
</ul>
<p><img src="/images/workqueue/wq_topology.png" alt="wq_topology"></p>
<p>最终的目的还是把work(工作)传递给worker(工人)去执行，中间的数据结构和各种关系目的是把这件事组织的更加清晰高效。</p>
<h2 id="1-1-worker-pool"><a href="#1-1-worker-pool" class="headerlink" title="1.1 worker_pool"></a>1.1 worker_pool</h2><p>每个执行work的线程叫做worker，一组worker的集合叫做worker_pool。CMWQ的精髓就在worker_pool里面worker的动态增减管理上manage_workers()。</p>
<p>CMWQ对worker_pool分成两类：  </p>
<ul>
<li>normal worker_pool，给通用的workqueue使用；</li>
<li>unbound worker_pool，给WQ_UNBOUND类型的的workqueue使用；</li>
</ul>
<h3 id="1-1-1-normal-worker-pool"><a href="#1-1-1-normal-worker-pool" class="headerlink" title="1.1.1 normal worker_pool"></a>1.1.1 normal worker_pool</h3><p>默认work是在normal worker_pool中处理的。系统的规划是每个cpu创建两个normal worker_pool：一个normal优先级(nice=0)、一个高优先级(nice=HIGHPRI_NICE_LEVEL)，对应创建出来的worker的进程nice不一样。</p>
<p>每个worker对应一个worker_thread()内核线程，一个worker_pool包含一个或者多个worker，worker_pool中worker的数量是根据worker_pool中work的负载来动态增减的。</p>
<p>我们可以通过“ps|grep kworker”命令来查看所有worker对应的内核线程，normal worker_pool对应内核线程(worker_thread())的命名规则是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">snprintf</span>(id_buf, <span class="keyword">sizeof</span>(id_buf), <span class="string">"%d:%d%s"</span>, pool-&gt;cpu, id,</span><br><span class="line">	 pool-&gt;attrs-&gt;nice &lt; <span class="number">0</span>  ? <span class="string">"H"</span> : <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">worker-&gt;task = kthread_create_on_node(worker_thread, worker, pool-&gt;node,</span><br><span class="line">				      <span class="string">"kworker/%s"</span>, id_buf);</span><br></pre></td></tr></table></figure>
<p>so类似名字是normal worker_pool：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shell@PRO5:/ $ ps | grep &quot;kworker&quot;</span><br><span class="line">root      14    2     0      0     worker_thr 0000000000 S kworker/1:0H		// cpu1 高优先级worker_pool的第0个worker进程</span><br><span class="line">root      17    2     0      0     worker_thr 0000000000 S kworker/2:0		// cpu2 低优先级worker_pool的第0个worker进程</span><br><span class="line">root      18    2     0      0     worker_thr 0000000000 S kworker/2:0H		// cpu2 高优先级worker_pool的第0个worker进程</span><br><span class="line">root      23699 2     0      0     worker_thr 0000000000 S kworker/0:1		// cpu0 低优先级worker_pool的第1个worker进程</span><br></pre></td></tr></table></figure>
<p><img src="/images/workqueue/wq_worker_pool.png" alt="wq_worker_pool"> </p>
<p>对应的拓扑图如下：</p>
<p><img src="/images/workqueue/wq_normal_wq_topology.png" alt="wq_normal_wq_topology"></p>
<p>以下是normal worker_pool详细的创建过程代码分析：</p>
<ul>
<li>kernel/workqueue.c:  </li>
<li>init_workqueues() -&gt; init_worker_pool()/create_worker()</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">init_workqueues</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> std_nice[NR_STD_WORKER_POOLS] = &#123; <span class="number">0</span>, HIGHPRI_NICE_LEVEL &#125;;</span><br><span class="line">	<span class="keyword">int</span> i, cpu;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (1)给每个cpu创建对应的worker_pool</span></span><br><span class="line">	<span class="comment">/* initialize CPU pools */</span></span><br><span class="line">	for_each_possible_cpu(cpu) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span>;</span></span><br><span class="line"></span><br><span class="line">		i = <span class="number">0</span>;</span><br><span class="line">		for_each_cpu_worker_pool(pool, cpu) &#123;</span><br><span class="line">			BUG_ON(init_worker_pool(pool));</span><br><span class="line">			<span class="comment">// 指定cpu</span></span><br><span class="line">			pool-&gt;cpu = cpu;</span><br><span class="line">			cpumask_copy(pool-&gt;attrs-&gt;cpumask, cpumask_of(cpu));</span><br><span class="line">			<span class="comment">// 指定进程优先级nice</span></span><br><span class="line">			pool-&gt;attrs-&gt;nice = std_nice[i++];</span><br><span class="line">			pool-&gt;node = cpu_to_node(cpu);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* alloc pool ID */</span></span><br><span class="line">			mutex_lock(&amp;wq_pool_mutex);</span><br><span class="line">			BUG_ON(worker_pool_assign_id(pool));</span><br><span class="line">			mutex_unlock(&amp;wq_pool_mutex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (2)给每个worker_pool创建第一个worker</span></span><br><span class="line">	<span class="comment">/* create the initial worker */</span></span><br><span class="line">	for_each_online_cpu(cpu) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span>;</span></span><br><span class="line"></span><br><span class="line">		for_each_cpu_worker_pool(pool, cpu) &#123;</span><br><span class="line">			pool-&gt;flags &amp;= ~POOL_DISASSOCIATED;</span><br><span class="line">			BUG_ON(!create_worker(pool));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">init_worker_pool</span><span class="params">(struct worker_pool *pool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	spin_lock_init(&amp;pool-&gt;lock);</span><br><span class="line">	pool-&gt;id = <span class="number">-1</span>;</span><br><span class="line">	pool-&gt;cpu = <span class="number">-1</span>;</span><br><span class="line">	pool-&gt;node = NUMA_NO_NODE;</span><br><span class="line">	pool-&gt;flags |= POOL_DISASSOCIATED;</span><br><span class="line">	<span class="comment">// (1.1) worker_pool的work list，各个workqueue把work挂载到这个链表上，</span></span><br><span class="line">	<span class="comment">// 让worker_pool对应的多个worker来执行</span></span><br><span class="line">	INIT_LIST_HEAD(&amp;pool-&gt;worklist);</span><br><span class="line">	<span class="comment">// (1.2) worker_pool的idle worker list，</span></span><br><span class="line">	<span class="comment">// worker没有活干时，不会马上销毁，先进入idle状态备选</span></span><br><span class="line">	INIT_LIST_HEAD(&amp;pool-&gt;idle_list);</span><br><span class="line">	<span class="comment">// (1.3) worker_pool的busy worker list，</span></span><br><span class="line">	<span class="comment">// worker正在干活，在执行work</span></span><br><span class="line">	hash_init(pool-&gt;busy_hash);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (1.4) 检查idle状态worker是否需要destroy的timer</span></span><br><span class="line">	init_timer_deferrable(&amp;pool-&gt;idle_timer);</span><br><span class="line">	pool-&gt;idle_timer.function = idle_worker_timeout;</span><br><span class="line">	pool-&gt;idle_timer.data = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)pool;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (1.5) 在worker_pool创建新的worker时，检查是否超时的timer</span></span><br><span class="line">	setup_timer(&amp;pool-&gt;mayday_timer, pool_mayday_timeout,</span><br><span class="line">		    (<span class="keyword">unsigned</span> <span class="keyword">long</span>)pool);</span><br><span class="line"></span><br><span class="line">	mutex_init(&amp;pool-&gt;manager_arb);</span><br><span class="line">	mutex_init(&amp;pool-&gt;attach_mutex);</span><br><span class="line">	INIT_LIST_HEAD(&amp;pool-&gt;workers);</span><br><span class="line"></span><br><span class="line">	ida_init(&amp;pool-&gt;worker_ida);</span><br><span class="line">	INIT_HLIST_NODE(&amp;pool-&gt;hash_node);</span><br><span class="line">	pool-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* shouldn't fail above this point */</span></span><br><span class="line">	pool-&gt;attrs = alloc_workqueue_attrs(GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!pool-&gt;attrs)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> struct worker *<span class="title">create_worker</span><span class="params">(struct worker_pool *pool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">worker</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	<span class="keyword">int</span> id = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">char</span> id_buf[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* ID is needed to determine kthread name */</span></span><br><span class="line">	id = ida_simple_get(&amp;pool-&gt;worker_ida, <span class="number">0</span>, <span class="number">0</span>, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (id &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">	worker = alloc_worker(pool-&gt;node);</span><br><span class="line">	<span class="keyword">if</span> (!worker)</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">	worker-&gt;pool = pool;</span><br><span class="line">	worker-&gt;id = id;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pool-&gt;cpu &gt;= <span class="number">0</span>)</span><br><span class="line">		<span class="comment">// (2.1) 给normal worker_pool的worker构造进程名</span></span><br><span class="line">		<span class="built_in">snprintf</span>(id_buf, <span class="keyword">sizeof</span>(id_buf), <span class="string">"%d:%d%s"</span>, pool-&gt;cpu, id,</span><br><span class="line">			 pool-&gt;attrs-&gt;nice &lt; <span class="number">0</span>  ? <span class="string">"H"</span> : <span class="string">""</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="comment">// (2.2) 给unbound worker_pool的worker构造进程名</span></span><br><span class="line">		<span class="built_in">snprintf</span>(id_buf, <span class="keyword">sizeof</span>(id_buf), <span class="string">"u%d:%d"</span>, pool-&gt;id, id);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (2.3) 创建worker对应的内核进程</span></span><br><span class="line">	worker-&gt;task = kthread_create_on_node(worker_thread, worker, pool-&gt;node,</span><br><span class="line">					      <span class="string">"kworker/%s"</span>, id_buf);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(worker-&gt;task))</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (2.4) 设置内核进程对应的优先级nice</span></span><br><span class="line">	set_user_nice(worker-&gt;task, pool-&gt;attrs-&gt;nice);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* prevent userland from meddling with cpumask of workqueue workers */</span></span><br><span class="line">	worker-&gt;task-&gt;flags |= PF_NO_SETAFFINITY;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (2.5) 将worker和worker_pool绑定</span></span><br><span class="line">	<span class="comment">/* successful, attach the worker to the pool */</span></span><br><span class="line">	worker_attach_to_pool(worker, pool);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (2.6) 将worker初始状态设置成idle，</span></span><br><span class="line">	<span class="comment">// wake_up_process以后，worker自动leave idle状态</span></span><br><span class="line">	<span class="comment">/* start the newly created worker */</span></span><br><span class="line">	spin_lock_irq(&amp;pool-&gt;lock);</span><br><span class="line">	worker-&gt;pool-&gt;nr_workers++;</span><br><span class="line">	worker_enter_idle(worker);</span><br><span class="line">	wake_up_process(worker-&gt;task);</span><br><span class="line">	spin_unlock_irq(&amp;pool-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> worker;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">	<span class="keyword">if</span> (id &gt;= <span class="number">0</span>)</span><br><span class="line">		ida_simple_remove(&amp;pool-&gt;worker_ida, id);</span><br><span class="line">	kfree(worker);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">|| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">worker_attach_to_pool</span><span class="params">(struct worker *worker,</span></span></span><br><span class="line"><span class="function"><span class="params">				   struct worker_pool *pool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	mutex_lock(&amp;pool-&gt;attach_mutex);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (2.5.1) 将worker线程和cpu绑定</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * set_cpus_allowed_ptr() will fail if the cpumask doesn't have any</span></span><br><span class="line"><span class="comment">	 * online CPUs.  It'll be re-applied when any of the CPUs come up.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	set_cpus_allowed_ptr(worker-&gt;task, pool-&gt;attrs-&gt;cpumask);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The pool-&gt;attach_mutex ensures %POOL_DISASSOCIATED remains</span></span><br><span class="line"><span class="comment">	 * stable across this function.  See the comments above the</span></span><br><span class="line"><span class="comment">	 * flag definition for details.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (pool-&gt;flags &amp; POOL_DISASSOCIATED)</span><br><span class="line">		worker-&gt;flags |= WORKER_UNBOUND;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (2.5.2) 将worker加入worker_pool链表</span></span><br><span class="line">	list_add_tail(&amp;worker-&gt;node, &amp;pool-&gt;workers);</span><br><span class="line"></span><br><span class="line">	mutex_unlock(&amp;pool-&gt;attach_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-1-2-unbound-worker-pool"><a href="#1-1-2-unbound-worker-pool" class="headerlink" title="1.1.2 unbound worker_pool"></a>1.1.2 unbound worker_pool</h3><p>大部分的work都是通过normal worker_pool来执行的(例如通过schedule_work()、schedule_work_on()压入到系统workqueue(system_wq)中的work)，最后都是通过normal worker_pool中的worker来执行的。这些worker是和某个cpu绑定的，work一旦被worker开始执行，都是一直运行到某个cpu上的不会切换cpu。</p>
<p>unbound worker_pool相对应的意思，就是worker可以在多个cpu上调度的。但是他其实也是绑定的，只不过它绑定的单位不是cpu而是node。所谓的node是对NUMA(Non Uniform Memory Access Architecture)系统来说的，NUMA可能存在多个node，每个node可能包含一个或者多个cpu。</p>
<p>unbound worker_pool对应内核线程(worker_thread())的命名规则是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">snprintf</span>(id_buf, <span class="keyword">sizeof</span>(id_buf), <span class="string">"u%d:%d"</span>, pool-&gt;id, id);</span><br><span class="line"></span><br><span class="line">worker-&gt;task = kthread_create_on_node(worker_thread, worker, pool-&gt;node,</span><br><span class="line">				      <span class="string">"kworker/%s"</span>, id_buf);</span><br></pre></td></tr></table></figure>
<p>so类似名字是unbound worker_pool：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shell@PRO5:/ $ ps | grep &quot;kworker&quot;</span><br><span class="line">root      23906 2     0      0     worker_thr 0000000000 S kworker/u20:2	// unbound pool 20的第2个worker进程</span><br><span class="line">root      24564 2     0      0     worker_thr 0000000000 S kworker/u20:0	// unbound pool 20的第0个worker进程</span><br><span class="line">root      24622 2     0      0     worker_thr 0000000000 S kworker/u21:1	// unbound pool 21的第1个worker进程</span><br></pre></td></tr></table></figure>
<p>unbound worker_pool也分成两类：</p>
<ul>
<li>unbound_std_wq。每个node对应一个worker_pool，多个node就对应多个worker_pool;</li>
</ul>
<p><img src="/images/workqueue/wq_unbound_std_wq.png" alt="wq_unbound_std_wq">  </p>
<p>对应的拓扑图如下：</p>
<p><img src="/images/workqueue/wq_unboundstd_wq_topology.png" alt="wq_unboundstd_wq_topology"></p>
<ul>
<li>ordered_wq。所有node对应一个default worker_pool；</li>
</ul>
<p><img src="/images/workqueue/wq_ordered_wq.png" alt="wq_ordered_wq">  </p>
<p>对应的拓扑图如下：</p>
<p><img src="/images/workqueue/wq_ordered_wq_topology.png" alt="wq_ordered_wq_topology"></p>
<p>以下是unbound worker_pool详细的创建过程代码分析：</p>
<ul>
<li>kernel/workqueue.c:  </li>
<li>init_workqueues() -&gt; unbound_std_wq_attrs/ordered_wq_attrs</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">init_workqueues</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (1) 初始化normal和high nice对应的unbound attrs</span></span><br><span class="line">	<span class="comment">/* create default unbound and ordered wq attrs */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NR_STD_WORKER_POOLS; i++) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">workqueue_attrs</span> *<span class="title">attrs</span>;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// (2) unbound_std_wq_attrs</span></span><br><span class="line">		BUG_ON(!(attrs = alloc_workqueue_attrs(GFP_KERNEL)));</span><br><span class="line">		attrs-&gt;nice = std_nice[i];</span><br><span class="line">		unbound_std_wq_attrs[i] = attrs;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * An ordered wq should have only one pwq as ordering is</span></span><br><span class="line"><span class="comment">		 * guaranteed by max_active which is enforced by pwqs.</span></span><br><span class="line"><span class="comment">		 * Turn off NUMA so that dfl_pwq is used for all nodes.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">// (3) ordered_wq_attrs，no_numa = true;</span></span><br><span class="line">		BUG_ON(!(attrs = alloc_workqueue_attrs(GFP_KERNEL)));</span><br><span class="line">		attrs-&gt;nice = std_nice[i];</span><br><span class="line">		attrs-&gt;no_numa = <span class="literal">true</span>;</span><br><span class="line">		ordered_wq_attrs[i] = attrs;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>kernel/workqueue.c:  </li>
<li>__alloc_workqueue_key() -&gt; alloc_and_link_pwqs() -&gt; apply_workqueue_attrs() -&gt; alloc_unbound_pwq()/numa_pwq_tbl_install()</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *__<span class="title">alloc_workqueue_key</span>(<span class="title">const</span> <span class="title">char</span> *<span class="title">fmt</span>,</span></span><br><span class="line"><span class="class">					       <span class="title">unsigned</span> <span class="title">int</span> <span class="title">flags</span>,</span></span><br><span class="line"><span class="class">					       <span class="title">int</span> <span class="title">max_active</span>,</span></span><br><span class="line"><span class="class">					       <span class="title">struct</span> <span class="title">lock_class_key</span> *<span class="title">key</span>,</span></span><br><span class="line"><span class="class">					       <span class="title">const</span> <span class="title">char</span> *<span class="title">lock_name</span>, ...)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">size_t</span> tbl_size = <span class="number">0</span>;</span><br><span class="line">	va_list args;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">wq</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> *<span class="title">pwq</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* see the comment above the definition of WQ_POWER_EFFICIENT */</span></span><br><span class="line">	<span class="keyword">if</span> ((flags &amp; WQ_POWER_EFFICIENT) &amp;&amp; wq_power_efficient)</span><br><span class="line">		flags |= WQ_UNBOUND;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* allocate wq and format name */</span></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; WQ_UNBOUND)</span><br><span class="line">		tbl_size = nr_node_ids * <span class="keyword">sizeof</span>(wq-&gt;numa_pwq_tbl[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (1) 分配workqueue_struct数据结构</span></span><br><span class="line">	wq = kzalloc(<span class="keyword">sizeof</span>(*wq) + tbl_size, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!wq)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; WQ_UNBOUND) &#123;</span><br><span class="line">		wq-&gt;unbound_attrs = alloc_workqueue_attrs(GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (!wq-&gt;unbound_attrs)</span><br><span class="line">			<span class="keyword">goto</span> err_free_wq;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	va_start(args, lock_name);</span><br><span class="line">	vsnprintf(wq-&gt;name, <span class="keyword">sizeof</span>(wq-&gt;name), fmt, args);</span><br><span class="line">	va_end(args);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (2) pwq最多放到worker_pool中的work数</span></span><br><span class="line">	max_active = max_active ?: WQ_DFL_ACTIVE;</span><br><span class="line">	max_active = wq_clamp_max_active(max_active, flags, wq-&gt;name);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* init wq */</span></span><br><span class="line">	wq-&gt;flags = flags;</span><br><span class="line">	wq-&gt;saved_max_active = max_active;</span><br><span class="line">	mutex_init(&amp;wq-&gt;mutex);</span><br><span class="line">	atomic_set(&amp;wq-&gt;nr_pwqs_to_flush, <span class="number">0</span>);</span><br><span class="line">	INIT_LIST_HEAD(&amp;wq-&gt;pwqs);</span><br><span class="line">	INIT_LIST_HEAD(&amp;wq-&gt;flusher_queue);</span><br><span class="line">	INIT_LIST_HEAD(&amp;wq-&gt;flusher_overflow);</span><br><span class="line">	INIT_LIST_HEAD(&amp;wq-&gt;maydays);</span><br><span class="line"></span><br><span class="line">	lockdep_init_map(&amp;wq-&gt;lockdep_map, lock_name, key, <span class="number">0</span>);</span><br><span class="line">	INIT_LIST_HEAD(&amp;wq-&gt;<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (3) 给workqueue分配对应的pool_workqueue</span></span><br><span class="line">	<span class="comment">// pool_workqueue将workqueue和worker_pool链接起来</span></span><br><span class="line">	<span class="keyword">if</span> (alloc_and_link_pwqs(wq) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> err_free_wq;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (4) 如果是WQ_MEM_RECLAIM类型的workqueue</span></span><br><span class="line">	<span class="comment">// 创建对应的rescuer_thread()内核进程</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Workqueues which may be used during memory reclaim should</span></span><br><span class="line"><span class="comment">	 * have a rescuer to guarantee forward progress.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; WQ_MEM_RECLAIM) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">rescuer</span>;</span></span><br><span class="line"></span><br><span class="line">		rescuer = alloc_worker(NUMA_NO_NODE);</span><br><span class="line">		<span class="keyword">if</span> (!rescuer)</span><br><span class="line">			<span class="keyword">goto</span> err_destroy;</span><br><span class="line"></span><br><span class="line">		rescuer-&gt;rescue_wq = wq;</span><br><span class="line">		rescuer-&gt;task = kthread_create(rescuer_thread, rescuer, <span class="string">"%s"</span>,</span><br><span class="line">					       wq-&gt;name);</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(rescuer-&gt;task)) &#123;</span><br><span class="line">			kfree(rescuer);</span><br><span class="line">			<span class="keyword">goto</span> err_destroy;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		wq-&gt;rescuer = rescuer;</span><br><span class="line">		rescuer-&gt;task-&gt;flags |= PF_NO_SETAFFINITY;</span><br><span class="line">		wake_up_process(rescuer-&gt;task);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (5) 如果是需要，创建workqueue对应的sysfs文件</span></span><br><span class="line">	<span class="keyword">if</span> ((wq-&gt;flags &amp; WQ_SYSFS) &amp;&amp; workqueue_sysfs_register(wq))</span><br><span class="line">		<span class="keyword">goto</span> err_destroy;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * wq_pool_mutex protects global freeze state and workqueues list.</span></span><br><span class="line"><span class="comment">	 * Grab it, adjust max_active and add the new @wq to workqueues</span></span><br><span class="line"><span class="comment">	 * list.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	mutex_lock(&amp;wq_pool_mutex);</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;wq-&gt;mutex);</span><br><span class="line">	for_each_pwq(pwq, wq)</span><br><span class="line">		pwq_adjust_max_active(pwq);</span><br><span class="line">	mutex_unlock(&amp;wq-&gt;mutex);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (6) 将新的workqueue加入到全局链表workqueues中</span></span><br><span class="line">	list_add(&amp;wq-&gt;<span class="built_in">list</span>, &amp;workqueues);</span><br><span class="line"></span><br><span class="line">	mutex_unlock(&amp;wq_pool_mutex);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> wq;</span><br><span class="line"></span><br><span class="line">err_free_wq:</span><br><span class="line">	free_workqueue_attrs(wq-&gt;unbound_attrs);</span><br><span class="line">	kfree(wq);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">err_destroy:</span><br><span class="line">	destroy_workqueue(wq);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">alloc_and_link_pwqs</span><span class="params">(struct workqueue_struct *wq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> highpri = wq-&gt;flags &amp; WQ_HIGHPRI;</span><br><span class="line">	<span class="keyword">int</span> cpu, ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (3.1) normal workqueue</span></span><br><span class="line">	<span class="comment">// pool_workqueue链接workqueue和worker_pool的过程</span></span><br><span class="line">	<span class="keyword">if</span> (!(wq-&gt;flags &amp; WQ_UNBOUND)) &#123;</span><br><span class="line">		<span class="comment">// 给workqueue的每个cpu分配对应的pool_workqueue，赋值给wq-&gt;cpu_pwqs</span></span><br><span class="line">		wq-&gt;cpu_pwqs = alloc_percpu(struct pool_workqueue);</span><br><span class="line">		<span class="keyword">if</span> (!wq-&gt;cpu_pwqs)</span><br><span class="line">			<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">		for_each_possible_cpu(cpu) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> *<span class="title">pwq</span> =</span></span><br><span class="line"><span class="class">				<span class="title">per_cpu_ptr</span>(<span class="title">wq</span>-&gt;<span class="title">cpu_pwqs</span>, <span class="title">cpu</span>);</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">cpu_pools</span> =</span></span><br><span class="line"><span class="class">				<span class="title">per_cpu</span>(<span class="title">cpu_worker_pools</span>, <span class="title">cpu</span>);</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">// 将初始化时已经创建好的normal worker_pool，赋值给pool_workqueue</span></span><br><span class="line">			init_pwq(pwq, wq, &amp;cpu_pools[highpri]);</span><br><span class="line"></span><br><span class="line">			mutex_lock(&amp;wq-&gt;mutex);</span><br><span class="line">			<span class="comment">// 将pool_workqueue和workqueue链接起来</span></span><br><span class="line">			link_pwq(pwq);</span><br><span class="line">			mutex_unlock(&amp;wq-&gt;mutex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (wq-&gt;flags &amp; __WQ_ORDERED) &#123;</span><br><span class="line">	<span class="comment">// (3.2) unbound ordered_wq workqueue</span></span><br><span class="line">	<span class="comment">// pool_workqueue链接workqueue和worker_pool的过程</span></span><br><span class="line">		ret = apply_workqueue_attrs(wq, ordered_wq_attrs[highpri]);</span><br><span class="line">		<span class="comment">/* there should only be single pwq for ordering guarantee */</span></span><br><span class="line">		WARN(!ret &amp;&amp; (wq-&gt;pwqs.next != &amp;wq-&gt;dfl_pwq-&gt;pwqs_node ||</span><br><span class="line">			      wq-&gt;pwqs.prev != &amp;wq-&gt;dfl_pwq-&gt;pwqs_node),</span><br><span class="line">		     <span class="string">"ordering guarantee broken for workqueue %s\n"</span>, wq-&gt;name);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// (3.3) unbound unbound_std_wq workqueue</span></span><br><span class="line">	<span class="comment">// pool_workqueue链接workqueue和worker_pool的过程</span></span><br><span class="line">		<span class="keyword">return</span> apply_workqueue_attrs(wq, unbound_std_wq_attrs[highpri]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">|| →</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">apply_workqueue_attrs</span><span class="params">(struct workqueue_struct *wq,</span></span></span><br><span class="line"><span class="function"><span class="params">			  <span class="keyword">const</span> struct workqueue_attrs *attrs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (3.2.1) 根据的ubound的ordered_wq_attrs/unbound_std_wq_attrs</span></span><br><span class="line">	<span class="comment">// 创建对应的pool_workqueue和worker_pool</span></span><br><span class="line">	<span class="comment">// 其中worker_pool不是默认创建好的，是需要动态创建的，对应的worker内核进程也要重新创建</span></span><br><span class="line">	<span class="comment">// 创建好的pool_workqueue赋值给pwq_tbl[node]</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If something goes wrong during CPU up/down, we'll fall back to</span></span><br><span class="line"><span class="comment">	 * the default pwq covering whole @att- kernel/workqueue.c:  </span></span><br><span class="line"><span class="comment">- __alloc_workqueue_key() -&gt; alloc_and_link_pwqs() -&gt; apply_workqueue_attrs() -&gt; alloc_unbound_pwq()/numa_pwq_tbl_install()rs-&gt;cpumask.  Always create</span></span><br><span class="line"><span class="comment">	 * it even if we don't use it immediately.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	dfl_pwq = alloc_unbound_pwq(wq, new_attrs);</span><br><span class="line">	<span class="keyword">if</span> (!dfl_pwq)</span><br><span class="line">		<span class="keyword">goto</span> enomem_pwq;</span><br><span class="line"></span><br><span class="line">	for_each_node(node) &#123;</span><br><span class="line">		<span class="keyword">if</span> (wq_calc_node_cpumask(attrs, node, <span class="number">-1</span>, tmp_attrs-&gt;cpumask)) &#123;</span><br><span class="line">			pwq_tbl[node] = alloc_unbound_pwq(wq, tmp_attrs);</span><br><span class="line">			<span class="keyword">if</span> (!pwq_tbl[node])</span><br><span class="line">				<span class="keyword">goto</span> enomem_pwq;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			dfl_pwq-&gt;refcnt++;</span><br><span class="line">			pwq_tbl[node] = dfl_pwq;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* save the previous pwq and install the new one */</span></span><br><span class="line">	<span class="comment">// (3.2.2) 将临时pwq_tbl[node]赋值给wq-&gt;numa_pwq_tbl[node]</span></span><br><span class="line">	for_each_node(node)</span><br><span class="line">		pwq_tbl[node] = numa_pwq_tbl_install(wq, node, pwq_tbl[node]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">||| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> struct pool_workqueue *<span class="title">alloc_unbound_pwq</span><span class="params">(struct workqueue_struct *wq,</span></span></span><br><span class="line"><span class="function"><span class="params">					<span class="keyword">const</span> struct workqueue_attrs *attrs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> *<span class="title">pwq</span>;</span></span><br><span class="line"></span><br><span class="line">	lockdep_assert_held(&amp;wq_pool_mutex);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (3.2.1.1) 如果对应attrs已经创建多对应的unbound_pool，则使用已有的unbound_pool</span></span><br><span class="line">	<span class="comment">// 否则根据attrs创建新的unbound_pool</span></span><br><span class="line">	pool = get_unbound_pool(attrs);</span><br><span class="line">	<span class="keyword">if</span> (!pool)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	pwq = kmem_cache_alloc_node(pwq_cache, GFP_KERNEL, pool-&gt;node);</span><br><span class="line">	<span class="keyword">if</span> (!pwq) &#123;</span><br><span class="line">		put_unbound_pool(pool);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	init_pwq(pwq, wq, pool);</span><br><span class="line">	<span class="keyword">return</span> pwq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-2-worker"><a href="#1-2-worker" class="headerlink" title="1.2 worker"></a>1.2 worker</h2><p>每个worker对应一个worker_thread()内核线程，一个worker_pool对应一个或者多个worker。多个worker从同一个链表中worker_pool-&gt;worklist获取work进行处理。</p>
<p>所以这其中有几个重点：</p>
<ul>
<li>worker怎么处理work；</li>
<li>worker_pool怎么动态管理worker的数量；</li>
</ul>
<h3 id="1-2-1-worker处理work"><a href="#1-2-1-worker处理work" class="headerlink" title="1.2.1 worker处理work"></a>1.2.1 worker处理work</h3><p>处理work的过程主要在worker_thread() -&gt; process_one_work()中处理，我们具体看看代码的实现过程。</p>
<ul>
<li>kernel/workqueue.c:  </li>
<li>worker_thread() -&gt; process_one_work()</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">worker_thread</span><span class="params">(<span class="keyword">void</span> *__worker)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">worker</span> = __<span class="title">worker</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span> = <span class="title">worker</span>-&gt;<span class="title">pool</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* tell the scheduler that this is a workqueue worker */</span></span><br><span class="line">	worker-&gt;task-&gt;flags |= PF_WQ_WORKER;</span><br><span class="line">woke_up:</span><br><span class="line">	spin_lock_irq(&amp;pool-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (1) 是否die</span></span><br><span class="line">	<span class="comment">/* am I supposed to die? */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(worker-&gt;flags &amp; WORKER_DIE)) &#123;</span><br><span class="line">		spin_unlock_irq(&amp;pool-&gt;lock);</span><br><span class="line">		WARN_ON_ONCE(!list_empty(&amp;worker-&gt;entry));</span><br><span class="line">		worker-&gt;task-&gt;flags &amp;= ~PF_WQ_WORKER;</span><br><span class="line"></span><br><span class="line">		set_task_comm(worker-&gt;task, <span class="string">"kworker/dying"</span>);</span><br><span class="line">		ida_simple_remove(&amp;pool-&gt;worker_ida, worker-&gt;id);</span><br><span class="line">		worker_detach_from_pool(worker, pool);</span><br><span class="line">		kfree(worker);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (2) 脱离idle状态</span></span><br><span class="line">	<span class="comment">// 被唤醒之前worker都是idle状态</span></span><br><span class="line">	worker_leave_idle(worker);</span><br><span class="line">recheck:</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// (3) 如果需要本worker继续执行则继续，否则进入idle状态</span></span><br><span class="line">	<span class="comment">// need more worker的条件： (pool-&gt;worklist != 0) &amp;&amp; (pool-&gt;nr_running == 0)</span></span><br><span class="line">	<span class="comment">// worklist上有work需要执行，并且现在没有处于running的work</span></span><br><span class="line">	<span class="comment">/* no more worker necessary? */</span></span><br><span class="line">	<span class="keyword">if</span> (!need_more_worker(pool))</span><br><span class="line">		<span class="keyword">goto</span> sleep;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (4) 如果(pool-&gt;nr_idle == 0)，则启动创建更多的worker</span></span><br><span class="line">	<span class="comment">// 说明idle队列中已经没有备用worker了，先创建 一些worker备用</span></span><br><span class="line">	<span class="comment">/* do we need to manage? */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!may_start_working(pool)) &amp;&amp; manage_workers(worker))</span><br><span class="line">		<span class="keyword">goto</span> recheck;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * -&gt;scheduled list can only be filled while a worker is</span></span><br><span class="line"><span class="comment">	 * preparing to process a work or actually processing it.</span></span><br><span class="line"><span class="comment">	 * Make sure nobody diddled with it while I was sleeping.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	WARN_ON_ONCE(!list_empty(&amp;worker-&gt;scheduled));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Finish PREP stage.  We're guaranteed to have at least one idle</span></span><br><span class="line"><span class="comment">	 * worker or that someone else has already assumed the manager</span></span><br><span class="line"><span class="comment">	 * role.  This is where @worker starts participating in concurrency</span></span><br><span class="line"><span class="comment">	 * management if applicable and concurrency management is restored</span></span><br><span class="line"><span class="comment">	 * after being rebound.  See rebind_workers() for details.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	worker_clr_flags(worker, WORKER_PREP | WORKER_REBOUND);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="comment">// (5) 如果pool-&gt;worklist不为空，从其中取出一个work进行处理</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> *<span class="title">work</span> =</span></span><br><span class="line"><span class="class">			<span class="title">list_first_entry</span>(&amp;<span class="title">pool</span>-&gt;<span class="title">worklist</span>,</span></span><br><span class="line"><span class="class">					 <span class="title">struct</span> <span class="title">work_struct</span>, <span class="title">entry</span>);</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (likely(!(*work_data_bits(work) &amp; WORK_STRUCT_LINKED))) &#123;</span><br><span class="line">			<span class="comment">/* optimization path, not strictly necessary */</span></span><br><span class="line">			<span class="comment">// (6) 执行正常的work</span></span><br><span class="line">			process_one_work(worker, work);</span><br><span class="line">			<span class="keyword">if</span> (unlikely(!list_empty(&amp;worker-&gt;scheduled)))</span><br><span class="line">				process_scheduled_works(worker);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// (7) 执行系统特意scheduled给某个worker的work</span></span><br><span class="line">			<span class="comment">// 普通的work是放在池子的公共list中的pool-&gt;worklist</span></span><br><span class="line">			<span class="comment">// 只有一些特殊的work被特意派送给某个worker的worker-&gt;scheduled</span></span><br><span class="line">			<span class="comment">// 包括：1、执行flush_work时插入的barrier work；</span></span><br><span class="line">			<span class="comment">// 2、collision时从其他worker推送到本worker的work</span></span><br><span class="line">			move_linked_works(work, &amp;worker-&gt;scheduled, <span class="literal">NULL</span>);</span><br><span class="line">			process_scheduled_works(worker);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="comment">// (8) worker keep_working的条件：</span></span><br><span class="line">	<span class="comment">// pool-&gt;worklist不为空 &amp;&amp; (pool-&gt;nr_running &lt;= 1)</span></span><br><span class="line">	&#125; <span class="keyword">while</span> (keep_working(pool));</span><br><span class="line"></span><br><span class="line">	worker_set_flags(worker, WORKER_PREP);supposed</span><br><span class="line">sleep:</span><br><span class="line">	<span class="comment">// (9) worker进入idle状态</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * pool-&gt;lock is held and there's no work to process and no need to</span></span><br><span class="line"><span class="comment">	 * manage, sleep.  Workers are woken up only while holding</span></span><br><span class="line"><span class="comment">	 * pool-&gt;lock or from local cpu, so setting the current state</span></span><br><span class="line"><span class="comment">	 * before releasing pool-&gt;lock is enough to prevent losing any</span></span><br><span class="line"><span class="comment">	 * event.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	worker_enter_idle(worker);</span><br><span class="line">	__set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">	spin_unlock_irq(&amp;pool-&gt;lock);</span><br><span class="line">	schedule();</span><br><span class="line">	<span class="keyword">goto</span> woke_up;</span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process_one_work</span><span class="params">(struct worker *worker, struct work_struct *work)</span></span></span><br><span class="line"><span class="function">__<span class="title">releases</span><span class="params">(&amp;pool-&gt;lock)</span></span></span><br><span class="line"><span class="function">__<span class="title">acquires</span><span class="params">(&amp;pool-&gt;lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> *<span class="title">pwq</span> = <span class="title">get_work_pwq</span>(<span class="title">work</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span> = <span class="title">worker</span>-&gt;<span class="title">pool</span>;</span></span><br><span class="line">	<span class="keyword">bool</span> cpu_intensive = pwq-&gt;wq-&gt;flags &amp; WQ_CPU_INTENSIVE;</span><br><span class="line">	<span class="keyword">int</span> work_color;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">collision</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * It is permissible to free the struct work_struct from</span></span><br><span class="line"><span class="comment">	 * inside the function that is called from it, this we need to</span></span><br><span class="line"><span class="comment">	 * take into account for lockdep too.  To avoid bogus "held</span></span><br><span class="line"><span class="comment">	 * lock freed" warnings as well as problems when looking into</span></span><br><span class="line"><span class="comment">	 * work-&gt;lockdep_map, make a copy and use that here.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">lockdep_map</span>;</span></span><br><span class="line"></span><br><span class="line">	lockdep_copy_map(&amp;lockdep_map, &amp;work-&gt;lockdep_map);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* ensure we're on the correct CPU */</span></span><br><span class="line">	WARN_ON_ONCE(!(pool-&gt;flags &amp; POOL_DISASSOCIATED) &amp;&amp;</span><br><span class="line">		     raw_smp_processor_id() != pool-&gt;cpu);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (8.1) 如果work已经在worker_pool的其他worker上执行，</span></span><br><span class="line">	<span class="comment">// 将work放入对应worker的scheduled队列中延后执行</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * A single work shouldn't be executed concurrently by</span></span><br><span class="line"><span class="comment">	 * multiple workers on a single cpu.  Check whether anyone is</span></span><br><span class="line"><span class="comment">	 * already processing the work.  If so, defer the work to the</span></span><br><span class="line"><span class="comment">	 * currently executing one.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	collision = find_worker_executing_work(pool, work);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(collision)) &#123;</span><br><span class="line">		move_linked_works(work, &amp;collision-&gt;scheduled, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (8.2) 将worker加入busy队列pool-&gt;busy_hash</span></span><br><span class="line">	<span class="comment">/* claim and dequeue */</span></span><br><span class="line">	debug_work_deactivate(work);</span><br><span class="line">	hash_add(pool-&gt;busy_hash, &amp;worker-&gt;hentry, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)work);</span><br><span class="line">	worker-&gt;current_work = work;</span><br><span class="line">	worker-&gt;current_func = work-&gt;func;</span><br><span class="line">	worker-&gt;current_pwq = pwq;</span><br><span class="line">	work_color = get_work_color(work);</span><br><span class="line"></span><br><span class="line">	list_del_init(&amp;work-&gt;entry);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (8.3) 如果work所在的wq是cpu密集型的WQ_CPU_INTENSIVE</span></span><br><span class="line">	<span class="comment">// 则当前work的执行脱离worker_pool的动态调度，成为一个独立的线程</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * CPU intensive works don't participate in concurrency management.</span></span><br><span class="line"><span class="comment">	 * They're the scheduler's responsibility.  This takes @worker out</span></span><br><span class="line"><span class="comment">	 * of concurrency management and the next code block will chain</span></span><br><span class="line"><span class="comment">	 * execution of the pending work items.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(cpu_intensive))</span><br><span class="line">		worker_set_flags(worker, WORKER_CPU_INTENSIVE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (8.4) 在UNBOUND或者CPU_INTENSIVE work中判断是否需要唤醒idle worker</span></span><br><span class="line">	<span class="comment">// 普通work不会执行这个操作</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Wake up another worker if necessary.  The condition is always</span></span><br><span class="line"><span class="comment">	 * false for normal per-cpu workers since nr_running would always</span></span><br><span class="line"><span class="comment">	 * be &gt;= 1 at this point.  This is used to chain execution of the</span></span><br><span class="line"><span class="comment">	 * pending work items for WORKER_NOT_RUNNING workers such as the</span></span><br><span class="line"><span class="comment">	 * UNBOUND and CPU_INTENSIVE ones.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (need_more_worker(pool))</span><br><span class="line">		wake_up_worker(pool);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Record the last pool and clear PENDING which should be the last</span></span><br><span class="line"><span class="comment">	 * update to @work.  Also, do this inside @pool-&gt;lock so that</span></span><br><span class="line"><span class="comment">	 * PENDING and queued state changes happen together while IRQ is</span></span><br><span class="line"><span class="comment">	 * disabled.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	set_work_pool_and_clear_pending(work, pool-&gt;id);</span><br><span class="line"></span><br><span class="line">	spin_unlock_irq(&amp;pool-&gt;lock);</span><br><span class="line"></span><br><span class="line">	lock_map_acquire_read(&amp;pwq-&gt;wq-&gt;lockdep_map);</span><br><span class="line">	lock_map_acquire(&amp;lockdep_map);</span><br><span class="line">	trace_workqueue_execute_start(work);</span><br><span class="line">	<span class="comment">// (8.5) 执行work函数</span></span><br><span class="line">	worker-&gt;current_func(work);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * While we must be careful to not use "work" after this, the trace</span></span><br><span class="line"><span class="comment">	 * point will only record its address.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	trace_workqueue_execute_end(work);</span><br><span class="line">	lock_map_release(&amp;lockdep_map);</span><br><span class="line">	lock_map_release(&amp;pwq-&gt;wq-&gt;lockdep_map);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(in_atomic() || lockdep_depth(current) &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">		pr_err(<span class="string">"BUG: workqueue leaked lock or atomic: %s/0x%08x/%d\n"</span></span><br><span class="line">		       <span class="string">"     last function: %pf\n"</span>,</span><br><span class="line">		       current-&gt;comm, preempt_count(), task_pid_nr(current),</span><br><span class="line">		       worker-&gt;current_func);</span><br><span class="line">		debug_show_held_locks(current);</span><br><span class="line">		dump_stack();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The following prevents a kworker from hogging CPU on !PREEMPT</span></span><br><span class="line"><span class="comment">	 * kernels, where a requeueing work item waiting for something to</span></span><br><span class="line"><span class="comment">	 * happen could deadlock with stop_machine as such work item could</span></span><br><span class="line"><span class="comment">	 * indefinitely requeue itself while all other CPUs are trapped in</span></span><br><span class="line"><span class="comment">	 * stop_machine. At the same time, report a quiescent RCU state so</span></span><br><span class="line"><span class="comment">	 * the same condition doesn't freeze RCU.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	cond_resched_rcu_qs();</span><br><span class="line"></span><br><span class="line">	spin_lock_irq(&amp;pool-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* clear cpu intensive status */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(cpu_intensive))</span><br><span class="line">		worker_clr_flags(worker, WORKER_CPU_INTENSIVE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* we're done with it, release */</span></span><br><span class="line">	hash_del(&amp;worker-&gt;hentry);</span><br><span class="line">	worker-&gt;current_work = <span class="literal">NULL</span>;</span><br><span class="line">	worker-&gt;current_func = <span class="literal">NULL</span>;</span><br><span class="line">	worker-&gt;current_pwq = <span class="literal">NULL</span>;</span><br><span class="line">	worker-&gt;desc_valid = <span class="literal">false</span>;</span><br><span class="line">	pwq_dec_nr_in_flight(pwq, work_color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-2-worker-pool动态管理worker"><a href="#1-2-2-worker-pool动态管理worker" class="headerlink" title="1.2.2 worker_pool动态管理worker"></a>1.2.2 worker_pool动态管理worker</h3><p>worker_pool怎么来动态增减worker，这部分的算法是CMWQ的核心。其思想如下：</p>
<ul>
<li>worker_pool中的worker有3种状态：idle、running、suspend；</li>
<li>如果worker_pool中有work需要处理，保持至少一个runn- kernel/workqueue.c:  </li>
<li>worker_thread() -&gt; process_one_work()<br>ing worker来处理；</li>
<li>running worker在处理work的过程中进入了阻塞suspend状态，为了保持其他work的执行，需要唤醒新的idle worker来处理work；</li>
<li>如果有work需要执行且running worker大于1个，会让多余的running worker进入idle状态；</li>
<li>如果没有work需要执行，会让所有worker进入idle状态；</li>
<li>如果创建的worker过多，destroy_worker在300s(IDLE_WORKER_TIMEOUT)时间内没有再次运行的idle worker。</li>
</ul>
<p><img src="/images/workqueue/wq_worker_statusmachine.png" alt="wq_worker_statusmachine"></p>
<p>详细代码可以参考上节worker_thread() -&gt; process_one_work()的分析。</p>
<p>为了追踪worker的running和suspend状态，用来动态调整worker的数量。wq使用在进程调度中加钩子函数的技巧：</p>
<ul>
<li>追踪worker从suspend进入running状态：ttwu_activate() -&gt; wq_worker_waking_up()</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wq_worker_waking_up</span><span class="params">(struct task_struct *task, <span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">worker</span> = <span class="title">kthread_data</span>(<span class="title">task</span>);</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(worker-&gt;flags &amp; WORKER_NOT_RUNNING)) &#123;</span><br><span class="line">		WARN_ON_ONCE(worker-&gt;pool-&gt;cpu != cpu);</span><br><span class="line">		<span class="comment">// 增加worker_pool中running的worker数量</span></span><br><span class="line">		atomic_inc(&amp;worker-&gt;pool-&gt;nr_running);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>追踪worker从running进入suspend状态：__schedule() -&gt; wq_worker_sleeping()</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct task_struct *<span class="title">wq_worker_sleeping</span><span class="params">(struct task_struct *task, <span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">worker</span> = <span class="title">kthread_data</span>(<span class="title">task</span>), *<span class="title">to_wakeup</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Rescuers, which may not have all the fields set up like normal</span></span><br><span class="line"><span class="comment">	 * workers, also reach here, let's not access anything before</span></span><br><span class="line"><span class="comment">	 * checking NOT_RUNNING.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (worker-&gt;flags &amp; WORKER_NOT_RUNNING)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	pool = worker-&gt;pool;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* this can only happen on the local cpu */</span></span><br><span class="line">	<span class="keyword">if</span> (WARN_ON_ONCE(cpu != raw_smp_processor_id() || pool-&gt;cpu != cpu))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The counterpart of the following dec_and_test, implied mb,</span></span><br><span class="line"><span class="comment">	 * worklist not empty test sequence is in insert_work().</span></span><br><span class="line"><span class="comment">	 * Please read comment there.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * NOT_RUNNING is clear.  This means that we're bound to and</span></span><br><span class="line"><span class="comment">	 * running on the local cpu w/ rq lock held and preemption</span></span><br><span class="line"><span class="comment">	 * disabled, which in turn means that none else could be</span></span><br><span class="line"><span class="comment">	 * manipulating idle_list, so dereferencing idle_list without pool</span></span><br><span class="line"><span class="comment">	 * lock is safe.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">// 减少worker_pool中running的worker数量</span></span><br><span class="line">	<span class="comment">// 如果worklist还有work需要处理，唤醒第一个idle worker进行处理</span></span><br><span class="line">	<span class="keyword">if</span> (atomic_dec_and_test(&amp;pool-&gt;nr_running) &amp;&amp;</span><br><span class="line">	    !list_empty(&amp;pool-&gt;worklist))</span><br><span class="line">		to_wakeup = first_idle_worker(pool);</span><br><span class="line">	<span class="keyword">return</span> to_wakeup ? to_wakeup-&gt;task : <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里worker_pool的调度思想是：如果有work需要处理，保持一个running状态的worker处理，不多也不少。</p>
<p>但是这里有一个问题如果work是cpu密集型的，它虽然也没有进入suspend状态，但是会长时间的占用cpu，让后续的work阻塞太长时间。</p>
<p>为了解决这个问题，CMWQ设计了WQ_CPU_INTENSIVE，如果一个wq声明自己是CPU_INTENSIVE，则让当前worker脱离动态调度，像是进入了suspend状态，那么CMWQ会创建新的worker，后续的work会得到执行。</p>
<ul>
<li>kernel/workqueue.c:  </li>
<li>worker_thread() -&gt; process_one_work()</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process_one_work</span><span class="params">(struct worker *worker, struct work_struct *work)</span></span></span><br><span class="line"><span class="function">__<span class="title">releases</span><span class="params">(&amp;pool-&gt;lock)</span></span></span><br><span class="line"><span class="function">__<span class="title">acquires</span><span class="params">(&amp;pool-&gt;lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> cpu_intensive = pwq-&gt;wq-&gt;flags &amp; WQ_CPU_INTENSIVE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// (1) 设置当前worker的WORKER_CPU_INTENSIVE标志</span></span><br><span class="line">	<span class="comment">// nr_running会被减1</span></span><br><span class="line">	<span class="comment">// 对worker_pool来说，当前worker相当于进入了suspend状态</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * CPU intensive works don't participate in concurrency management.</span></span><br><span class="line"><span class="comment">	 * They're the scheduler's responsibility.  This takes @worker out</span></span><br><span class="line"><span class="comment">	 * of concurrency management and the next code block will chain</span></span><br><span class="line"><span class="comment">	 * execution of the pending work items.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(cpu_intensive))</span><br><span class="line">		worker_set_flags(worker, WORKER_CPU_INTENSIVE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (2) 接上一步，判断是否需要唤醒新的worker来处理work</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Wake up another worker if necessary.  The condition is always</span></span><br><span class="line"><span class="comment">	 * false for normal per-cpu workers since nr_running would always</span></span><br><span class="line"><span class="comment">	 * be &gt;= 1 at this point.  This is used to chain execution of the</span></span><br><span class="line"><span class="comment">	 * pending work items for WORKER_NOT_RUNNING workers such as the</span></span><br><span class="line"><span class="comment">	 * UNBOUND and CPU_INTENSIVE ones.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (need_more_worker(pool))</span><br><span class="line">		wake_up_worker(pool);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (3) 执行work</span></span><br><span class="line">	worker-&gt;current_func(work);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// (4) 执行完，清理当前worker的WORKER_CPU_INTENSIVE标志</span></span><br><span class="line">	<span class="comment">// 当前worker重新进入running状态</span></span><br><span class="line">	<span class="comment">/* clear cpu intensive status */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(cpu_intensive))</span><br><span class="line">		worker_clr_flags(worker, WORKER_CPU_INTENSIVE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	WORKER_NOT_RUNNING	= WORKER_PREP | WORKER_CPU_INTENSIVE |</span><br><span class="line">				  WORKER_UNBOUND | WORKER_REBOUND,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> worker_set_flags(struct worker *worker, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">	struct worker_pool *pool = worker-&gt;pool;</span><br><span class="line"></span><br><span class="line">	WARN_ON_ONCE(worker-&gt;task != current);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If transitioning into NOT_RUNNING, adjust nr_running. */</span></span><br><span class="line">	<span class="keyword">if</span> ((flags &amp; WORKER_NOT_RUNNING) &amp;&amp;</span><br><span class="line">	    !(worker-&gt;flags &amp; WORKER_NOT_RUNNING)) &#123;</span><br><span class="line">		atomic_dec(&amp;pool-&gt;nr_running);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	worker-&gt;flags |= flags;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">worker_clr_flags</span><span class="params">(struct worker *worker, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span> = <span class="title">worker</span>-&gt;<span class="title">pool</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> oflags = worker-&gt;flags;</span><br><span class="line"></span><br><span class="line">	WARN_ON_ONCE(worker-&gt;task != current);</span><br><span class="line"></span><br><span class="line">	worker-&gt;flags &amp;= ~flags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If transitioning out of NOT_RUNNING, increment nr_running.  Note</span></span><br><span class="line"><span class="comment">	 * that the nested NOT_RUNNING is not a noop.  NOT_RUNNING is mask</span></span><br><span class="line"><span class="comment">	 * of multiple flags, not a single flag.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> ((flags &amp; WORKER_NOT_RUNNING) &amp;&amp; (oflags &amp; WORKER_NOT_RUNNING))</span><br><span class="line">		<span class="keyword">if</span> (!(worker-&gt;flags &amp; WORKER_NOT_RUNNING))</span><br><span class="line">			atomic_inc(&amp;pool-&gt;nr_running);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-3-cpu-hotplug处理"><a href="#1-2-3-cpu-hotplug处理" class="headerlink" title="1.2.3 cpu hotplug处理"></a>1.2.3 cpu hotplug处理</h3><p>从上几节可以看到，系统会创建和cpu绑定的normal worker_pool和不绑定cpu的unbound worker_pool，worker_pool又会动态的创建worker。</p>
<p>那么在cpu hotplug的时候，会怎么样动态的处理worker_pool和worker呢？来看具体的代码分析：</p>
<ul>
<li>kernel/workqueue.c:  </li>
<li>workqueue_cpu_up_callback()/workqueue_cpu_down_callback()</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">init_workqueues</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	cpu_notifier(workqueue_cpu_up_callback, CPU_PRI_WORKQUEUE_UP);</span><br><span class="line">	hotcpu_notifier(workqueue_cpu_down_callback, CPU_PRI_WORKQUEUE_DOWN);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workqueue_cpu_down_callback</span><span class="params">(struct notifier_block *nfb,</span></span></span><br><span class="line"><span class="function"><span class="params">						 <span class="keyword">unsigned</span> <span class="keyword">long</span> action,</span></span></span><br><span class="line"><span class="function"><span class="params">						 <span class="keyword">void</span> *hcpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cpu = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)hcpu;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">unbind_work</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">wq</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (action &amp; ~CPU_TASKS_FROZEN) &#123;</span><br><span class="line">	<span class="keyword">case</span> CPU_DOWN_PREPARE:</span><br><span class="line">		<span class="comment">/* unbinding per-cpu workers should happen on the local CPU */</span></span><br><span class="line">		INIT_WORK_ONSTACK(&amp;unbind_work, wq_unbind_fn);</span><br><span class="line">		<span class="comment">// (1) cpu down_prepare</span></span><br><span class="line">		<span class="comment">// 把和当前cpu绑定的normal worker_pool上的worker停工</span></span><br><span class="line">		<span class="comment">// 随着当前cpu被down掉，这些worker会迁移到其他cpu上</span></span><br><span class="line">		queue_work_on(cpu, system_highpri_wq, &amp;unbind_work);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// (2) unbound wq对cpu变化的更新</span></span><br><span class="line">		<span class="comment">/* update NUMA affinity of unbound workqueues */</span></span><br><span class="line">		mutex_lock(&amp;wq_pool_mutex);</span><br><span class="line">		list_for_each_entry(wq, &amp;workqueues, <span class="built_in">list</span>)</span><br><span class="line">			wq_update_unbound_numa(wq, cpu, <span class="literal">false</span>);</span><br><span class="line">		mutex_unlock(&amp;wq_pool_mutex);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* wait for per-cpu unbinding to finish */</span></span><br><span class="line">		flush_work(&amp;unbind_work);</span><br><span class="line">		destroy_work_on_stack(&amp;unbind_work);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> NOTIFY_OK;</span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workqueue_cpu_up_callback</span><span class="params">(struct notifier_block *nfb,</span></span></span><br><span class="line"><span class="function"><span class="params">					       <span class="keyword">unsigned</span> <span class="keyword">long</span> action,</span></span></span><br><span class="line"><span class="function"><span class="params">					       <span class="keyword">void</span> *hcpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cpu = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)hcpu;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">wq</span>;</span></span><br><span class="line">	<span class="keyword">int</span> pi;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (action &amp; ~CPU_TASKS_FROZEN) &#123;</span><br><span class="line">	<span class="keyword">case</span> CPU_UP_PREPARE:</span><br><span class="line">		for_each_cpu_worker_pool(pool, cpu) &#123;</span><br><span class="line">			<span class="keyword">if</span> (pool-&gt;nr_workers)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span> (!create_worker(pool))</span><br><span class="line">				<span class="keyword">return</span> NOTIFY_BAD;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> CPU_DOWN_FAILED:</span><br><span class="line">	<span class="keyword">case</span> CPU_ONLINE:</span><br><span class="line">		mutex_lock(&amp;wq_pool_mutex);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// (3) cpu up</span></span><br><span class="line">		for_each_pool(pool, pi) &#123;</span><br><span class="line">			mutex_lock(&amp;pool-&gt;attach_mutex);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 如果和当前cpu绑定的normal worker_pool上，有WORKER_UNBOUND停工的worker</span></span><br><span class="line">			<span class="comment">// 重新绑定worker到worker_pool</span></span><br><span class="line">			<span class="comment">// 让这些worker开工，并绑定到当前cpu</span></span><br><span class="line">			<span class="keyword">if</span> (pool-&gt;cpu == cpu)</span><br><span class="line">				rebind_workers(pool);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (pool-&gt;cpu &lt; <span class="number">0</span>)</span><br><span class="line">				restore_unbound_workers_cpumask(pool, cpu);</span><br><span class="line"></span><br><span class="line">			mutex_unlock(&amp;pool-&gt;attach_mutex);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* update NUMA affinity of unbound workqueues */</span></span><br><span class="line">		list_for_each_entry(wq, &amp;workqueues, <span class="built_in">list</span>)</span><br><span class="line">			wq_update_unbound_numa(wq, cpu, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">		mutex_unlock(&amp;wq_pool_mutex);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> NOTIFY_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-3-workqueue"><a href="#1-3-workqueue" class="headerlink" title="1.3 workqueue"></a>1.3 workqueue</h2><p>workqueue就是存放一组work的集合，基本可以分为两类：一类系统创建的workqueue，一类是用户自己创建的workqueue。</p>
<p>不论是系统还是用户workqueue，如果没有指定WQ_UNBOUND，默认都是和normal worker_pool绑定。</p>
<h3 id="1-3-1-系统workqueue"><a href="#1-3-1-系统workqueue" class="headerlink" title="1.3.1 系统workqueue"></a>1.3.1 系统workqueue</h3><p>系统在初始化时创建了一批默认的workqueue：system_wq、system_highpri_wq、system_long_wq、system_unbound_wq、system_freezable_wq、system_power_efficient_wq、system_freezable_power_efficient_wq。</p>
<p>像system_wq，就是schedule_work()默认使用的。</p>
<ul>
<li>kernel/workqueue.c:  </li>
<li>init_workqueues()</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">init_workqueues</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	system_wq = alloc_workqueue(<span class="string">"events"</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	system_highpri_wq = alloc_workqueue(<span class="string">"events_highpri"</span>, WQ_HIGHPRI, <span class="number">0</span>);</span><br><span class="line">	system_long_wq = alloc_workqueue(<span class="string">"events_long"</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	system_unbound_wq = alloc_workqueue(<span class="string">"events_unbound"</span>, WQ_UNBOUND,</span><br><span class="line">					    WQ_UNBOUND_MAX_ACTIVE);</span><br><span class="line">	system_freezable_wq = alloc_workqueue(<span class="string">"events_freezable"</span>,</span><br><span class="line">					      WQ_FREEZABLE, <span class="number">0</span>);</span><br><span class="line">	system_power_efficient_wq = alloc_workqueue(<span class="string">"events_power_efficient"</span>,</span><br><span class="line">					      WQ_POWER_EFFICIENT, <span class="number">0</span>);</span><br><span class="line">	system_freezable_power_efficient_wq = alloc_workqueue(<span class="string">"events_freezable_power_efficient"</span>,</span><br><span class="line">					      WQ_FREEZABLE | WQ_POWER_EFFICIENT,</span><br><span class="line">					      <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-2-workqueue创建"><a href="#1-3-2-workqueue创建" class="headerlink" title="1.3.2 workqueue创建"></a>1.3.2 workqueue创建</h3><p>详细过程见上几节的代码分析：alloc_workqueue() -&gt; __alloc_workqueue_key() -&gt; alloc_and_link_pwqs()。</p>
<h3 id="1-3-3-flush-workqueue"><a href="#1-3-3-flush-workqueue" class="headerlink" title="1.3.3 flush_workqueue()"></a>1.3.3 flush_workqueue()</h3><p>这一部分的逻辑，wq-&gt;work_color、wq-&gt;flush_color换来换去的逻辑实在看的头晕。看不懂暂时不想看，放着以后看吧，或者有谁看懂了教我一下。：）</p>
<h2 id="1-4-pool-workqueue"><a href="#1-4-pool-workqueue" class="headerlink" title="1.4 pool_workqueue"></a>1.4 pool_workqueue</h2><p>pool_workqueue只是一个中介角色。</p>
<p>详细过程见上几节的代码分析：alloc_workqueue() -&gt; __alloc_workqueue_key() -&gt; alloc_and_link_pwqs()。</p>
<h2 id="1-5-work"><a href="#1-5-work" class="headerlink" title="1.5 work"></a>1.5 work</h2><p>描述一份待执行的工作。</p>
<h3 id="1-5-1-queue-work"><a href="#1-5-1-queue-work" class="headerlink" title="1.5.1 queue_work()"></a>1.5.1 queue_work()</h3><p>将work压入到workqueue当中。</p>
<ul>
<li>kernel/workqueue.c:  </li>
<li>queue_work() -&gt; queue_work_on() -&gt; __queue_work()</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __queue_work(<span class="keyword">int</span> cpu, struct workqueue_struct *wq,</span><br><span class="line">			 struct work_struct *work)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> *<span class="title">pwq</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">last_pool</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">worklist</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> work_flags;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> req_cpu = cpu;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * While a work item is PENDING &amp;&amp; off queue, a task trying to</span></span><br><span class="line"><span class="comment">	 * steal the PENDING will busy-loop waiting for it to either get</span></span><br><span class="line"><span class="comment">	 * queued or lose PENDING.  Grabbing PENDING and queueing should</span></span><br><span class="line"><span class="comment">	 * happen with IRQ disabled.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	WARN_ON_ONCE(!irqs_disabled());</span><br><span class="line"></span><br><span class="line">	debug_work_activate(work);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* if draining, only works from the same workqueue are allowed */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(wq-&gt;flags &amp; __WQ_DRAINING) &amp;&amp;</span><br><span class="line">	    WARN_ON_ONCE(!is_chained_work(wq)))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">retry:</span><br><span class="line">	<span class="comment">// (1) 如果没有指定cpu，则使用当前cpu</span></span><br><span class="line">	<span class="keyword">if</span> (req_cpu == WORK_CPU_UNBOUND)</span><br><span class="line">		cpu = raw_smp_processor_id();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* pwq which will be used unless @work is executing elsewhere */</span></span><br><span class="line">	<span class="keyword">if</span> (!(wq-&gt;flags &amp; WQ_UNBOUND))</span><br><span class="line">		<span class="comment">// (2) 对于normal wq，使用当前cpu对应的normal worker_pool</span></span><br><span class="line">		pwq = per_cpu_ptr(wq-&gt;cpu_pwqs, cpu);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="comment">// (3) 对于unbound wq，使用当前cpu对应node的worker_pool</span></span><br><span class="line">		pwq = unbound_pwq_by_node(wq, cpu_to_node(cpu));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (4) 如果work在其他worker上正在被执行，把work压到对应的worker上去</span></span><br><span class="line">	<span class="comment">// 避免work出现重入的问题</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If @work was previously on a different pool, it might still be</span></span><br><span class="line"><span class="comment">	 * running there, in which case the work needs to be queued on that</span></span><br><span class="line"><span class="comment">	 * pool to guarantee non-reentrancy.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	last_pool = get_work_pool(work);</span><br><span class="line">	<span class="keyword">if</span> (last_pool &amp;&amp; last_pool != pwq-&gt;pool) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">worker</span>;</span></span><br><span class="line"></span><br><span class="line">		spin_lock(&amp;last_pool-&gt;lock);</span><br><span class="line"></span><br><span class="line">		worker = find_worker_executing_work(last_pool, work);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (worker &amp;&amp; worker-&gt;current_pwq-&gt;wq == wq) &#123;</span><br><span class="line">			pwq = worker-&gt;current_pwq;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/* meh... not running there, queue here */</span></span><br><span class="line">			spin_unlock(&amp;last_pool-&gt;lock);</span><br><span class="line">			spin_lock(&amp;pwq-&gt;pool-&gt;lock);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		spin_lock(&amp;pwq-&gt;pool-&gt;lock);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * pwq is determined and locked.  For unbound pools, we could have</span></span><br><span class="line"><span class="comment">	 * raced with pwq release and it could already be dead.  If its</span></span><br><span class="line"><span class="comment">	 * refcnt is zero, repeat pwq selection.  Note that pwqs never die</span></span><br><span class="line"><span class="comment">	 * without another pwq replacing it in the numa_pwq_tbl or while</span></span><br><span class="line"><span class="comment">	 * work items are executing on it, so the retrying is guaranteed to</span></span><br><span class="line"><span class="comment">	 * make forward-progress.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!pwq-&gt;refcnt)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (wq-&gt;flags &amp; WQ_UNBOUND) &#123;</span><br><span class="line">			spin_unlock(&amp;pwq-&gt;pool-&gt;lock);</span><br><span class="line">			cpu_relax();</span><br><span class="line">			<span class="keyword">goto</span> retry;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* oops */</span></span><br><span class="line">		WARN_ONCE(<span class="literal">true</span>, <span class="string">"workqueue: per-cpu pwq for %s on cpu%d has 0 refcnt"</span>,</span><br><span class="line">			  wq-&gt;name, cpu);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* pwq determined, queue */</span></span><br><span class="line">	trace_workqueue_queue_work(req_cpu, pwq, work);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (WARN_ON(!list_empty(&amp;work-&gt;entry))) &#123;</span><br><span class="line">		spin_unlock(&amp;pwq-&gt;pool-&gt;lock);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pwq-&gt;nr_in_flight[pwq-&gt;work_color]++;</span><br><span class="line">	work_flags = work_color_to_flags(pwq-&gt;work_color);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (5) 如果还没有达到max_active，将work挂载到pool-&gt;worklist</span></span><br><span class="line">	<span class="keyword">if</span> (likely(pwq-&gt;nr_active &lt; pwq-&gt;max_active)) &#123;</span><br><span class="line">		trace_workqueue_activate_work(work);</span><br><span class="line">		pwq-&gt;nr_active++;</span><br><span class="line">		worklist = &amp;pwq-&gt;pool-&gt;worklist;</span><br><span class="line">	<span class="comment">// 否则，将work挂载到临时队列pwq-&gt;delayed_works</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		work_flags |= WORK_STRUCT_DELAYED;</span><br><span class="line">		worklist = &amp;pwq-&gt;delayed_works;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (6) 将work压入worklist当中</span></span><br><span class="line">	insert_work(pwq, work, worklist, work_flags);</span><br><span class="line"></span><br><span class="line">	spin_unlock(&amp;pwq-&gt;pool-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-5-2-flush-work"><a href="#1-5-2-flush-work" class="headerlink" title="1.5.2 flush_work()"></a>1.5.2 flush_work()</h3><p>flush某个work，确保work执行完成。</p>
<p>怎么判断异步的work已经执行完成？这里面使用了一个技巧：在目标work的后面插入一个新的work wq_barrier，如果wq_barrier执行完成，那么目标work肯定已经执行完成。</p>
<ul>
<li>kernel/workqueue.c:  </li>
<li>queue_work() -&gt; queue_work_on() -&gt; __queue_work()</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * flush_work - wait for a work to finish executing the last queueing instance</span></span><br><span class="line"><span class="comment"> * @work: the work to flush</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Wait until @work has finished execution.  @work is guaranteed to be idle</span></span><br><span class="line"><span class="comment"> * on return if it hasn't been requeued since flush started.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return:</span></span><br><span class="line"><span class="comment"> * %true if flush_work() waited for the work to finish execution,</span></span><br><span class="line"><span class="comment"> * %false if it was already idle.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">flush_work</span><span class="params">(struct work_struct *work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wq_barrier</span> <span class="title">barr</span>;</span></span><br><span class="line"></span><br><span class="line">	lock_map_acquire(&amp;work-&gt;lockdep_map);</span><br><span class="line">	lock_map_release(&amp;work-&gt;lockdep_map);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (start_flush_work(work, &amp;barr)) &#123;</span><br><span class="line">		<span class="comment">// 等待barr work执行完成的信号</span></span><br><span class="line">		wait_for_completion(&amp;barr.done);</span><br><span class="line">		destroy_work_on_stack(&amp;barr.work);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">start_flush_work</span><span class="params">(struct work_struct *work, struct wq_barrier *barr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">worker</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> *<span class="title">pwq</span>;</span></span><br><span class="line"></span><br><span class="line">	might_sleep();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (1) 如果work所在worker_pool为NULL，说明work已经执行完</span></span><br><span class="line">	local_irq_disable();</span><br><span class="line">	pool = get_work_pool(work);</span><br><span class="line">	<span class="keyword">if</span> (!pool) &#123;</span><br><span class="line">		local_irq_enable();</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	spin_lock(&amp;pool-&gt;lock);</span><br><span class="line">	<span class="comment">/* see the comment in try_to_grab_pending() with the same code */</span></span><br><span class="line">	pwq = get_work_pwq(work);</span><br><span class="line">	<span class="keyword">if</span> (pwq) &#123;</span><br><span class="line">		<span class="comment">// (2) 如果work所在pwq指向的worker_pool不等于上一步得到的worker_pool，说明work已经执行完</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(pwq-&gt;pool != pool))</span><br><span class="line">			<span class="keyword">goto</span> already_gone;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// (3) 如果work所在pwq为NULL，并且也没有在当前执行的work中，说明work已经执行完</span></span><br><span class="line">		worker = find_worker_executing_work(pool, work);</span><br><span class="line">		<span class="keyword">if</span> (!worker)</span><br><span class="line">			<span class="keyword">goto</span> already_gone;</span><br><span class="line">		pwq = worker-&gt;current_pwq;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (4) 如果work没有执行完，向work的后面插入barr work</span></span><br><span class="line">	insert_wq_barrier(pwq, barr, work, worker);</span><br><span class="line">	spin_unlock_irq(&amp;pool-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If @max_active is 1 or rescuer is in use, flushing another work</span></span><br><span class="line"><span class="comment">	 * item on the same workqueue may lead to deadlock.  Make sure the</span></span><br><span class="line"><span class="comment">	 * flusher is not running on the same workqueue by verifying write</span></span><br><span class="line"><span class="comment">	 * access.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (pwq-&gt;wq-&gt;saved_max_active == <span class="number">1</span> || pwq-&gt;wq-&gt;rescuer)</span><br><span class="line">		lock_map_acquire(&amp;pwq-&gt;wq-&gt;lockdep_map);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		lock_map_acquire_read(&amp;pwq-&gt;wq-&gt;lockdep_map);</span><br><span class="line">	lock_map_release(&amp;pwq-&gt;wq-&gt;lockdep_map);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">already_gone:</span><br><span class="line">	spin_unlock_irq(&amp;pool-&gt;lock);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">|| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert_wq_barrier</span><span class="params">(struct pool_workqueue *pwq,</span></span></span><br><span class="line"><span class="function"><span class="params">			      struct wq_barrier *barr,</span></span></span><br><span class="line"><span class="function"><span class="params">			      struct work_struct *target, struct worker *worker)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">head</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> linked = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * debugobject calls are safe here even with pool-&gt;lock locked</span></span><br><span class="line"><span class="comment">	 * as we know for sure that this will not trigger any of the</span></span><br><span class="line"><span class="comment">	 * checks and call back into the fixup functions where we</span></span><br><span class="line"><span class="comment">	 * might deadlock.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">// (4.1) barr work的执行函数wq_barrier_func()</span></span><br><span class="line">	INIT_WORK_ONSTACK(&amp;barr-&gt;work, wq_barrier_func);</span><br><span class="line">	__set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(&amp;barr-&gt;work));</span><br><span class="line">	init_completion(&amp;barr-&gt;done);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If @target is currently being executed, schedule the</span></span><br><span class="line"><span class="comment">	 * barrier to the worker; otherwise, put it after @target.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">// (4.2) 如果work当前在worker中执行，则barr work插入scheduled队列</span></span><br><span class="line">	<span class="keyword">if</span> (worker)</span><br><span class="line">		head = worker-&gt;scheduled.next;</span><br><span class="line">	<span class="comment">// 否则，则barr work插入正常的worklist队列中，插入位置在目标work后面</span></span><br><span class="line">	<span class="comment">// 并且置上WORK_STRUCT_LINKED标志</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> *bits = work_data_bits(target);</span><br><span class="line"></span><br><span class="line">		head = target-&gt;entry.next;</span><br><span class="line">		<span class="comment">/* there can already be other linked works, inherit and set */</span></span><br><span class="line">		linked = *bits &amp; WORK_STRUCT_LINKED;</span><br><span class="line">		__set_bit(WORK_STRUCT_LINKED_BIT, bits);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	debug_work_activate(&amp;barr-&gt;work);</span><br><span class="line">	insert_work(pwq, &amp;barr-&gt;work, head,</span><br><span class="line">		    work_color_to_flags(WORK_NO_COLOR) | linked);</span><br><span class="line">&#125;</span><br><span class="line">||| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">wq_barrier_func</span><span class="params">(struct work_struct *work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wq_barrier</span> *<span class="title">barr</span> = <span class="title">container_of</span>(<span class="title">work</span>, <span class="title">struct</span> <span class="title">wq_barrier</span>, <span class="title">work</span>);</span></span><br><span class="line">	<span class="comment">// (4.1.1) barr work执行完成，发出complete信号。</span></span><br><span class="line">	complete(&amp;barr-&gt;done);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-Workqueue对外接口函数"><a href="#2-Workqueue对外接口函数" class="headerlink" title="2.Workqueue对外接口函数"></a>2.Workqueue对外接口函数</h1><p>CMWQ实现的workqueue机制，被包装成相应的对外接口函数。</p>
<h2 id="2-1-schedule-work"><a href="#2-1-schedule-work" class="headerlink" title="2.1 schedule_work()"></a>2.1 schedule_work()</h2><p>把work压入系统默认wq system_wq，WORK_CPU_UNBOUND指定worker为当前cpu绑定的normal worker_pool创建的worker。</p>
<ul>
<li>kernel/workqueue.c:  </li>
<li>schedule_work() -&gt; queue_work_on() -&gt; __queue_work()</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">schedule_work</span><span class="params">(struct work_struct *work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> queue_work(system_wq, work);</span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">queue_work</span><span class="params">(struct workqueue_struct *wq,</span></span></span><br><span class="line"><span class="function"><span class="params">			      struct work_struct *work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> queue_work_on(WORK_CPU_UNBOUND, wq, work);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-sschedule-work-on"><a href="#2-2-sschedule-work-on" class="headerlink" title="2.2 sschedule_work_on()"></a>2.2 sschedule_work_on()</h2><p>在schedule_work()基础上，可以指定work运行的cpu。</p>
<ul>
<li>kernel/workqueue.c:  </li>
<li>schedule_work_on() -&gt; queue_work_on() -&gt; __queue_work()</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">schedule_work_on</span><span class="params">(<span class="keyword">int</span> cpu, struct work_struct *work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> queue_work_on(cpu, system_wq, work);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-3-schedule-delayed-work"><a href="#2-3-schedule-delayed-work" class="headerlink" title="2.3 schedule_delayed_work()"></a>2.3 schedule_delayed_work()</h2><p>启动一个timer，在timer定时到了以后调用delayed_work_timer_fn()把work压入系统默认wq system_wq。</p>
<ul>
<li>kernel/workqueue.c:  </li>
<li>schedule_work_on() -&gt; queue_work_on() -&gt; __queue_work()</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">schedule_delayed_work</span><span class="params">(struct delayed_work *dwork,</span></span></span><br><span class="line"><span class="function"><span class="params">					 <span class="keyword">unsigned</span> <span class="keyword">long</span> delay)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> queue_delayed_work(system_wq, dwork, delay);</span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">queue_delayed_work</span><span class="params">(struct workqueue_struct *wq,</span></span></span><br><span class="line"><span class="function"><span class="params">				      struct delayed_work *dwork,</span></span></span><br><span class="line"><span class="function"><span class="params">				      <span class="keyword">unsigned</span> <span class="keyword">long</span> delay)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> queue_delayed_work_on(WORK_CPU_UNBOUND, wq, dwork, delay);</span><br><span class="line">&#125;</span><br><span class="line">|| →</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">queue_delayed_work_on</span><span class="params">(<span class="keyword">int</span> cpu, struct workqueue_struct *wq,</span></span></span><br><span class="line"><span class="function"><span class="params">			   struct delayed_work *dwork, <span class="keyword">unsigned</span> <span class="keyword">long</span> delay)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> *<span class="title">work</span> = &amp;<span class="title">dwork</span>-&gt;<span class="title">work</span>;</span></span><br><span class="line">	<span class="keyword">bool</span> ret = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* read the comment in __queue_work() */</span></span><br><span class="line">	local_irq_save(flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))) &#123;</span><br><span class="line">		__queue_delayed_work(cpu, wq, dwork, delay);</span><br><span class="line">		ret = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	local_irq_restore(flags);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">||| →</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __queue_delayed_work(<span class="keyword">int</span> cpu, struct workqueue_struct *wq,</span><br><span class="line">				struct delayed_work *dwork, <span class="keyword">unsigned</span> <span class="keyword">long</span> delay)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> *<span class="title">timer</span> = &amp;<span class="title">dwork</span>-&gt;<span class="title">timer</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> *<span class="title">work</span> = &amp;<span class="title">dwork</span>-&gt;<span class="title">work</span>;</span></span><br><span class="line"></span><br><span class="line">	WARN_ON_ONCE(timer-&gt;function != delayed_work_timer_fn ||</span><br><span class="line">		     timer-&gt;data != (<span class="keyword">unsigned</span> <span class="keyword">long</span>)dwork);</span><br><span class="line">	WARN_ON_ONCE(timer_pending(timer));</span><br><span class="line">	WARN_ON_ONCE(!list_empty(&amp;work-&gt;entry));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If @delay is 0, queue @dwork-&gt;work immediately.  This is for</span></span><br><span class="line"><span class="comment">	 * both optimization and correctness.  The earliest @timer can</span></span><br><span class="line"><span class="comment">	 * expire is on the closest next tick and delayed_work users depend</span></span><br><span class="line"><span class="comment">	 * on that there's no such delay when @delay is 0.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!delay) &#123;</span><br><span class="line">		__queue_work(cpu, wq, &amp;dwork-&gt;work);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	timer_stats_timer_set_start_info(&amp;dwork-&gt;timer);</span><br><span class="line"></span><br><span class="line">	dwork-&gt;wq = wq;</span><br><span class="line">	dwork-&gt;cpu = cpu;</span><br><span class="line">	timer-&gt;expires = jiffies + delay;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(cpu != WORK_CPU_UNBOUND))</span><br><span class="line">		add_timer_on(timer, cpu);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		add_timer(timer);</span><br><span class="line">&#125;</span><br><span class="line">|||| →</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delayed_work_timer_fn</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> __data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">delayed_work</span> *<span class="title">dwork</span> = (<span class="title">struct</span> <span class="title">delayed_work</span> *)__<span class="title">data</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* should have been called from irqsafe timer with irq already off */</span></span><br><span class="line">	__queue_work(dwork-&gt;cpu, dwork-&gt;wq, &amp;dwork-&gt;work);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/Documentation/workqueue.txt?id=refs/tags/v4.7-rc5" target="_blank" rel="noopener">Documentation/workqueue.txt</a></li>
</ol>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/workqueue/" rel="tag"># workqueue</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/12/21/perf_simpleperf/" rel="next" title="Linux Perf 2.1、simpleperf">
                <i class="fa fa-chevron-left"></i> Linux Perf 2.1、simpleperf
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/12/21/linux_signal/" rel="prev" title="Linux Signal">
                Linux Signal <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/touxiang/ycqs.jpg" alt="pwl999">
            
              <p class="site-author-name" itemprop="name">pwl999</p>
              <p class="site-description motion-element" itemprop="description">RTFSC(Read The Fucking Source Code)</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives">
                
                    <span class="site-state-item-count">30</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">3</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">22</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-CMWQ的几个基本概念"><span class="nav-number">1.</span> <span class="nav-text">1.CMWQ的几个基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-worker-pool"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 worker_pool</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-1-normal-worker-pool"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1.1 normal worker_pool</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-2-unbound-worker-pool"><span class="nav-number">1.1.2.</span> <span class="nav-text">1.1.2 unbound worker_pool</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-worker"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 worker</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-1-worker处理work"><span class="nav-number">1.2.1.</span> <span class="nav-text">1.2.1 worker处理work</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-2-worker-pool动态管理worker"><span class="nav-number">1.2.2.</span> <span class="nav-text">1.2.2 worker_pool动态管理worker</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-3-cpu-hotplug处理"><span class="nav-number">1.2.3.</span> <span class="nav-text">1.2.3 cpu hotplug处理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-workqueue"><span class="nav-number">1.3.</span> <span class="nav-text">1.3 workqueue</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-1-系统workqueue"><span class="nav-number">1.3.1.</span> <span class="nav-text">1.3.1 系统workqueue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-2-workqueue创建"><span class="nav-number">1.3.2.</span> <span class="nav-text">1.3.2 workqueue创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-3-flush-workqueue"><span class="nav-number">1.3.3.</span> <span class="nav-text">1.3.3 flush_workqueue()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-pool-workqueue"><span class="nav-number">1.4.</span> <span class="nav-text">1.4 pool_workqueue</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-5-work"><span class="nav-number">1.5.</span> <span class="nav-text">1.5 work</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-1-queue-work"><span class="nav-number">1.5.1.</span> <span class="nav-text">1.5.1 queue_work()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-2-flush-work"><span class="nav-number">1.5.2.</span> <span class="nav-text">1.5.2 flush_work()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-Workqueue对外接口函数"><span class="nav-number">2.</span> <span class="nav-text">2.Workqueue对外接口函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-schedule-work"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 schedule_work()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-sschedule-work-on"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 sschedule_work_on()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-schedule-delayed-work"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 schedule_delayed_work()</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考资料"><span class="nav-number">3.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">pwl999</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v6.6.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script src="/js/src/utils.js?v=6.6.0"></script>

  <script src="/js/src/motion.js?v=6.6.0"></script>



  
  


  <script src="/js/src/affix.js?v=6.6.0"></script>

  <script src="/js/src/schemes/pisces.js?v=6.6.0"></script>



  
  <script src="/js/src/scrollspy.js?v=6.6.0"></script>
<script src="/js/src/post-details.js?v=6.6.0"></script>



  


  <script src="/js/src/bootstrap.js?v=6.6.0"></script>



  

  
    <script id="dsq-count-scr" src="https://.disqus.com/count.js" async></script>
  

  
    <script>
      var disqus_config = function () {
        this.page.url = "http://yoursite.com/2018/12/21/linux_workqueue/";
        this.page.identifier = "2018/12/21/linux_workqueue/";
        this.page.title = 'Linux Workqueue';
        };
      function loadComments () {
        var d = document, s = d.createElement('script');
        s.src = 'https://.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      }
      
        loadComments();
      
    </script>
  





  











  





  

  

  

  

  

  
  

  

  

  

  

  

  

</body>
</html>
